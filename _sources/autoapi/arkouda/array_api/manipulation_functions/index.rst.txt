arkouda.array_api.manipulation_functions
========================================

.. py:module:: arkouda.array_api.manipulation_functions


Functions
---------

.. autoapisummary::

   arkouda.array_api.manipulation_functions.broadcast_arrays
   arkouda.array_api.manipulation_functions.broadcast_to
   arkouda.array_api.manipulation_functions.concat
   arkouda.array_api.manipulation_functions.expand_dims
   arkouda.array_api.manipulation_functions.flip
   arkouda.array_api.manipulation_functions.moveaxis
   arkouda.array_api.manipulation_functions.permute_dims
   arkouda.array_api.manipulation_functions.repeat
   arkouda.array_api.manipulation_functions.reshape
   arkouda.array_api.manipulation_functions.roll
   arkouda.array_api.manipulation_functions.squeeze
   arkouda.array_api.manipulation_functions.stack
   arkouda.array_api.manipulation_functions.tile
   arkouda.array_api.manipulation_functions.unstack


Module Contents
---------------

.. py:function:: broadcast_arrays(*arrays: arkouda.array_api.array_object.Array) -> List[arkouda.array_api.array_object.Array]

   Broadcast arrays to a common shape.

   :param arrays: The arrays to broadcast. Must be broadcastable to a common shape.
   :type arrays: Array

   :returns: A list whose elements are the given Arrays broadcasted to the common shape.
   :rtype: List

   :raises ValueError: Raised by broadcast_to if a common shape cannot be determined.

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> import arkouda.array_api as xp
   >>> a = xp.asarray(ak.arange(10).reshape(1,2,5))
   >>> b = xp.asarray(ak.arange(20).reshape(4,1,5))
   >>> c = xp.broadcast_arrays(a,b)
   >>> c[0][0,:,:]
   Arkouda Array ((2, 5), int64)[[0 1 2 3 4] [5 6 7 8 9]]
   >>> c[1][:,0,0]
   Arkouda Array ((4,), int64)[0 5 10 15]


.. py:function:: broadcast_to(x: arkouda.array_api.array_object.Array, /, shape: Tuple[int, Ellipsis]) -> arkouda.array_api.array_object.Array

   Broadcast the array to the specified shape.

   :param x: The array to be broadcast.
   :type x: Array
   :param shape: The shape to which the array is to be broadcast.
   :type shape: Tuple[int, ...]

   :returns: A new array which is x broadcast to the provided shape.
   :rtype: Array

   :raises ValueError: Raised server-side if the broadcast fails.

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> import arkouda.array_api as xp
   >>> a = xp.asarray(ak.arange(5))
   >>> xp.broadcast_to(a,(2,5))
   Arkouda Array ((2, 5), int64)[[0 1 2 3 4] [0 1 2 3 4]]

   See: https://data-apis.org/array-api/latest/API_specification/broadcasting.html for details.


.. py:function:: concat(arrays: Union[Tuple[arkouda.array_api.array_object.Array, Ellipsis], List[arkouda.array_api.array_object.Array]], /, *, axis: Optional[int] = 0) -> arkouda.array_api.array_object.Array

   Concatenate arrays along an axis.

   :param arrays: The arrays to concatenate. Must have the same shape except along the concatenation axis.
   :type arrays: Tuple[Array, ...] or List[Array]
   :param axis: The axis along which to concatenate the arrays. The default is 0. If None, the arrays are
                flattened before concatenation.
   :type axis: int, optional

   :raises IndexError: Raised if axis is not a valid axis for the given arrays.
   :raises ValueError: Raised if array shapes are incompatible with concat.

   :returns: A new Array which is the concatention of the given Arrays along the given axis.
   :rtype: Array


.. py:function:: expand_dims(x: arkouda.array_api.array_object.Array, /, *, axis: int) -> arkouda.array_api.array_object.Array

   Create a new array with an additional dimension inserted at the specified axis.

   :param x: The array to expand
   :type x: Array
   :param axis: The axis at which to insert the new (size one) dimension. Must be in the range
                `[-x.ndim-1, x.ndim]`.
   :type axis: int

   :raises IndexError: Raised if axis is not a valid axis for the given result.

   :returns: A new Array with a new dimension equal to 1, inserted at the given axis.
   :rtype: Array


.. py:function:: flip(x: arkouda.array_api.array_object.Array, /, *, axis: Optional[Union[int, Tuple[int, Ellipsis]]] = None) -> arkouda.array_api.array_object.Array

   Reverse an array's values along a particular axis or axes.

   :param x: The array to flip
   :type x: Array
   :param axis: The axis or axes along which to flip the array. If None, flip the array along all axes.
   :type axis: int or Tuple[int, ...], optional

   :raises IndexError: Raised if the axis/axes is/are invalid for the given array, or if the flip
       fails server-side.

   :returns: A copy of x with the results reversed along the given axis or axes.
   :rtype: Array


.. py:function:: moveaxis(x: arkouda.array_api.array_object.Array, source: Union[int, Tuple[int, Ellipsis]], destination: Union[int, Tuple[int, Ellipsis]], /) -> arkouda.array_api.array_object.Array

   Move axes of an array to new positions.

   :param x: The array whose axes are to be reordered
   :type x: Array
   :param source: Original positions of the axes to move. Values must be unique and fall within the range
                  `[-x.ndim, x.ndim)`.
   :type source: int or Tuple[int, ...]
   :param destination: Destination positions for each of the original axes. Must be the same length as `source`.
                       Values must be unique and fall within the range `[-x.ndim, x.ndim)`.
   :type destination: int or Tuple[int, ...]

   :raises ValueError: Raised if source and destination are not the same type (tuple or int).
   :raises IndexError: Raised if source, destination, or both are not valid for x.ndim.

   :returns: A new Array with the axes shifted per the givern source, destination.
   :rtype: Array


.. py:function:: permute_dims(x: arkouda.array_api.array_object.Array, /, axes: Tuple[int, Ellipsis]) -> arkouda.array_api.array_object.Array

   Permute the dimensions of an array.

   :param x: The array whose dimensions are to be permuted
   :type x: Array
   :param axes: The new order of the dimensions. Must be a permutation of the integers from 0 to `x.ndim-1`.
   :type axes: Tuple[int, ...]

   :raises IndexError: Raised if the given axes are not a valid reordering of the axes of x.

   :returns: A copy of x with the axes permuted as per the axes argument.
   :rtype: Array


.. py:function:: repeat(x: arkouda.array_api.array_object.Array, repeats: Union[int, arkouda.array_api.array_object.Array], /, *, axis: Optional[int] = None) -> arkouda.array_api.array_object.Array

   Repeat elements of an array.

   :param x: The array whose values to repeat
   :type x: Array
   :param repeats:
                   The number of repetitions for each element.
                    * If axis is None, must be an integer, or a 1D array of integers with the same size as `x`.
                    * If axis is not None, must be an integer, or a 1D array of integers whose size matches the
                      number of elements along the specified axis.
   :type repeats: int or Array
   :param axis: The axis along which to repeat elements. If None, the array is flattened before repeating,
                and each element is repeated repeats times.
   :type axis: int, optional

   :raises NotYetImplementedError: Raised if axis arg is used.

   :returns: A new 1D array with each element of x repeated repeats times.
   :rtype: Array


.. py:function:: reshape(x: arkouda.array_api.array_object.Array, /, shape: Tuple[int, Ellipsis], *, copy: Optional[bool] = None) -> arkouda.array_api.array_object.Array

   Reshape an array to a new shape.

   :param x: The array to reshape
   :type x: Array
   :param shape: The new shape for the array. Must have the same number of elements as the original array.
   :type shape: Tuple[int, ...]
   :param copy: Whether to create a copy of the array.
                WARNING: currently always creates a copy, ignoring the value of this parameter.
   :type copy: bool, optional

   :raises ValueError: Raised if the given shape is invalid, or if more than one unknown dimension is specified.

   :returns: A reshaped version of x, as specified in shape.
   :rtype: Array


.. py:function:: roll(x: arkouda.array_api.array_object.Array, /, shift: Union[int, Tuple[int, Ellipsis]], *, axis: Optional[Union[int, Tuple[int, Ellipsis]]] = None) -> arkouda.array_api.array_object.Array

   Roll the values in an array by the specified shift(s) along the specified axis or axes.
   Elements that roll beyond the last position are re-introduced at the first position.

   :param x: The array to roll
   :type x: Array
   :param shift: The number of positions by which to shift each axis. If `axis` and `shift` are both tuples, they
                 must have the same length and the `i`-th element of `shift` is the number of positions to shift
                 `axis[i]`. If axis is a tuple and shift is an integer, the same shift is applied to each axis.
                 If axis is None, must be an integer or a one-tuple.
   :type shift: int or Tuple[int, ...]
   :param axis: The axis or axes along which to roll the array. If None, the array is flattened before
                rolling.
   :type axis: int or Tuple[int, ...], optional

   :raises IndexError: Raised if the axis/axes aren't valid for the given array, or if axis and shift are both
       tuples but not of the same length, or if roll fails server-side.

   :returns: An array with the same shape as x, but with elements shifted as per axis and shift.
   :rtype: Array


.. py:function:: squeeze(x: arkouda.array_api.array_object.Array, /, axis: Union[int, Tuple[int, Ellipsis]]) -> arkouda.array_api.array_object.Array

   Remove degenerate (size one) dimensions from an array.

   :param x: The array to squeeze
   :type x: Array
   :param axis: The axis or axes to squeeze (must have a size of one).
   :type axis: int or Tuple[int, ...]

   :returns: The input array, but with the axes specified in axis (which must be of length 1) removed.
   :rtype: Array


.. py:function:: stack(arrays: Union[Tuple[arkouda.array_api.array_object.Array, Ellipsis], List[arkouda.array_api.array_object.Array]], /, *, axis: int = 0) -> arkouda.array_api.array_object.Array

   Stack arrays along a new axis.

   The resulting array will have one more dimension than the input arrays with a size
   equal to the number of input arrays.

   :param arrays: The arrays to stack. Must have the same shape.
   :type arrays: Tuple[Array, ...] or List[Array]
   :param axis: The axis along which to stack the arrays. Must be in the range `[-N, N)`, where N is the number
                of dimensions in the input arrays. The default is 0.
   :type axis: int, optional

   :raises ValueError: Raised if the arrays aren't all the same shape.
   :raises IndexError: Raised if axis isn't valid for the given arrays.

   :returns: A stacked array with rank 1 greater than the input arrays.
   :rtype: Array


.. py:function:: tile(x: arkouda.array_api.array_object.Array, repetitions: Tuple[int, Ellipsis], /) -> arkouda.array_api.array_object.Array

   Tile an array with the specified number of repetitions along each dimension.

   :param x: The array to tile
   :type x: Array
   :param repetitions: The number of repetitions along each dimension. If there are more repetitions than array
                       dimensions, singleton dimensions are prepended to the array to make it match the number of
                       repetitions. If there are more array dimensions than repetitions, ones are prepended to the
                       repetitions tuple to make its length match the number of array dimensions.
   :type repetitions: Tuple[int, ...]

   :returns: The tiled output array.
   :rtype: Array


.. py:function:: unstack(x: arkouda.array_api.array_object.Array, /, *, axis: int = 0) -> Tuple[arkouda.array_api.array_object.Array, Ellipsis]

   Decompose an array along an axis into multiple arrays of the same shape.

   :param x: The array to unstack
   :type x: Array
   :param axis: The axis along which to unstack the array. The default is 0.
   :type axis: int, optional

   :raises IndexError: Raised if the axis is not valid for the given Array.

   :returns: A Tuple of unstacked Arrays.
   :rtype: Tuple


