arkouda.array_api.utility_functions
===================================

.. py:module:: arkouda.array_api.utility_functions


Functions
---------

.. autoapisummary::

   arkouda.array_api.utility_functions.all
   arkouda.array_api.utility_functions.any
   arkouda.array_api.utility_functions.clip
   arkouda.array_api.utility_functions.diff
   arkouda.array_api.utility_functions.pad
   arkouda.array_api.utility_functions.trapezoid
   arkouda.array_api.utility_functions.trapz


Module Contents
---------------

.. py:function:: all(x: arkouda.array_api.array_object.Array, /, *, axis: Optional[Union[int, Tuple[int, Ellipsis]]] = None, keepdims: bool = False) -> arkouda.array_api.array_object.Array

   Check whether all elements of an array evaluate to True along a given axis.

   :param x: The array to check for all True values
   :type x: Array
   :param axis: The axis or axes along which to check for all True values. If None, check all elements.
   :type axis: int or Tuple[int], optional
   :param keepdims: Whether to keep the singleton dimensions along `axis` in the result.
   :type keepdims: bool, optional


.. py:function:: any(x: arkouda.array_api.array_object.Array, /, *, axis: Optional[Union[int, Tuple[int, Ellipsis]]] = None, keepdims: bool = False) -> arkouda.array_api.array_object.Array

   Check whether any elements of an array evaluate to True along a given axis.

   :param x: The array to check for any True values
   :type x: Array
   :param axis: The axis or axes along which to check for any True values. If None, check all elements.
   :type axis: int or Tuple[int], optional
   :param keepdims: Whether to keep the singleton dimensions along `axis` in the result.
   :type keepdims: bool, optional


.. py:function:: clip(a: arkouda.array_api.array_object.Array, a_min, a_max, /) -> arkouda.array_api.array_object.Array

   Clip (limit) the values in an array to a given range.

   :param a: The array to clip
   :type a: Array
   :param a_min: The minimum value
   :type a_min: scalar
   :param a_max: The maximum value
   :type a_max: scalar


.. py:function:: diff(a: arkouda.array_api.array_object.Array, /, n: int = 1, axis: int = -1, prepend=None, append=None) -> arkouda.array_api.array_object.Array

   Calculate the n-th discrete difference along the given axis.

   :param a: The array to calculate the difference
   :type a: Array
   :param n: The order of the finite difference. Default is 1.
   :type n: int, optional
   :param axis: The axis along which to calculate the difference. Default is the last axis.
   :type axis: int, optional
   :param prepend: Array to prepend to `a` along `axis` before calculating the difference.
   :type prepend: Array, optional
   :param append: Array to append to `a` along `axis` before calculating the difference.
   :type append: Array, optional

   :returns: The n-th differences. The shape of the output is the same as `a`
             except along `axis` where the dimension is smaller by `n`. The
             type of the output is the same as the type of the difference
             between any two elements of `a`. This is the same as the type of
             `a` in most cases. A notable exception is `datetime64`, which
             results in a `timedelta64` output array.
   :rtype: Array

   .. rubric:: Notes

   Type is preserved for boolean arrays, so the result will contain
   `False` when consecutive elements are the same and `True` when they
   differ.

   For unsigned integer arrays, the results will also be unsigned. This
   should not be surprising, as the result is consistent with
   calculating the difference directly.

   If this is not desirable, then the array should be cast to a larger
   integer type first:

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> import arkouda.array_api as xp
   >>> x = xp.asarray(ak.array([1, 2, 4, 7, 0]))
   >>> xp.diff(x)
   Arkouda Array ((4,), int64)[1 2 3 -7]
   >>> xp.diff(x, n=2)
   Arkouda Array ((3,), int64)[1 1 -10]

   >>> x = xp.asarray(ak.array([[1, 3, 6, 10], [0, 5, 6, 8]]))
   >>> xp.diff(x)
   Arkouda Array ((2, 3), int64)[[2 3 4] [5 1 2]]
   >>> xp.diff(x, axis=0)
   Arkouda Array ((1, 4), int64)[[-1 2 0 -2]]


.. py:function:: pad(array: arkouda.array_api.array_object.Array, pad_width, mode='constant', **kwargs) -> arkouda.array_api.array_object.Array

   Pad an array.

   :param array: The array to pad
   :type array: Array
   :param pad_width: Number of values padded to the edges of each axis. If a single int, the same value is used for
                     all axes. If a tuple of two ints, those values are used for all axes. If a tuple of tuples, each
                     inner tuple specifies the number of values padded to the beginning and end of each axis.
   :type pad_width: int or Tuple[int, int] or Tuple[Tuple[int, int], ...]
   :param mode: Padding mode. Only 'constant' is currently supported. Use the `constant_values` keyword argument
                to specify the padding value or values (in the same format as `pad_width`).
   :type mode: str, optional


.. py:function:: trapezoid(y: arkouda.array_api.array_object.Array, x: Optional[arkouda.array_api.array_object.Array] = None, dx: Optional[float] = 1.0, axis: int = -1) -> arkouda.array_api.array_object.Array

.. py:function:: trapz(y: arkouda.array_api.array_object.Array, x: Optional[arkouda.array_api.array_object.Array] = None, dx: Optional[float] = 1.0, axis: int = -1) -> arkouda.array_api.array_object.Array

   Integrate along the given axis using the composite trapezoidal rule.

   If `x` is provided, the integration happens in sequence along its
   elements - they are not sorted.

   Integrate `y` (`x`) along each 1d slice on the given axis, compute
   :math:`\int y(x) dx`.
   When `x` is specified, this integrates along the parametric curve,
   computing :math:`\int_t y(t) dt =
   \int_t y(t) \left.\frac{dx}{dt}\right|_{x=x(t)} dt`.

   See https://numpy.org/doc/1.26/reference/generated/numpy.trapz.html#numpy.trapz

   :param y: Input array to integrate.
   :type y: array_like
   :param x: The sample points corresponding to the `y` values. If `x` is None,
             the sample points are assumed to be evenly spaced `dx` apart. The
             default is None.
   :type x: array_like, optional
   :param dx: The spacing between sample points when `x` is None. The default is 1.
   :type dx: scalar, optional
   :param axis: The axis along which to integrate.
   :type axis: int, optional

   :returns: Definite integral of `y` = n-dimensional array as approximated along
             a single axis by the trapezoidal rule. If `y` is a 1-dimensional array,
             then the result is a float. If `n` is greater than 1, then the result
             is an `n`-1 dimensional array.
   :rtype: Array

   .. rubric:: Notes

   Image [2]_ illustrates trapezoidal rule -- y-axis locations of points
   will be taken from `y` array, by default x-axis distances between
   points will be 1.0, alternatively they can be provided with `x` array
   or with `dx` scalar.  Return value will be equal to combined area under
   the red lines.

   .. rubric:: References

   .. [1] Wikipedia page: https://en.wikipedia.org/wiki/Trapezoidal_rule

   .. [2] Illustration image:
          https://en.wikipedia.org/wiki/File:Composite_trapezoidal_rule_illustration.png

   .. rubric:: Examples

   >>> from arkouda import array_api as xp
   >>> y = xp.asarray(ak.array([1, 2, 3]))

   Use the trapezoidal rule on evenly spaced points:
   >>> xp.trapz(y)
   Arkouda Array ((), float64)4.0

   The spacing between sample points can be selected by either the
   ``x`` or ``dx`` arguments:

   >>> x = xp.asarray(ak.array([4, 6, 8]))
   >>> xp.trapz(y, x)
   Arkouda Array ((), float64)8.0
   >>> xp.trapz(y, dx=2.0)
   Arkouda Array ((), float64)8.0

   Using a decreasing ``x`` corresponds to integrating in reverse:

   >>> x = xp.asarray(ak.array([8, 6, 4]))
   >>> xp.trapz(y, x)
   Arkouda Array ((), float64)-8.0

   More generally ``x`` is used to integrate along a parametric curve. We can
   estimate the integral :math:`\int_0^1 x^2 = 1/3` using:

   >>> x = xp.linspace(0, 1, num=50)
   >>> y = x**2
   >>> xp.trapz(y, x)
   Arkouda Array ((), float64)0.333402748854643...

   Or estimate the area of a circle, noting we repeat the sample which closes
   the curve:

   >>> theta = xp.linspace(0, 2 * xp.pi, num=1000, endpoint=True)
   >>> xp.trapz(xp.cos(theta), x=xp.sin(theta))
   Arkouda Array ((), float64)3.14157194137584...

   ``np.trapezoid`` can be applied along a specified axis to do multiple
   computations in one call:

   >>> a = xp.asarray(ak.arange(6).reshape(2, 3))
   >>> a
   Arkouda Array ((2, 3), int64)[[0 1 2] [3 4 5]]
   >>> xp.trapz(a, axis=0)
   Arkouda Array ((3,), float64)[1.5 2.5 3.5]
   >>> xp.trapz(a, axis=1)
   Arkouda Array ((2,), float64)[2.0 8.0]


