:mod:`arkouda.pdarraycreation`
==============================

.. py:module:: arkouda.pdarraycreation


Module Contents
---------------


Functions
~~~~~~~~~

.. autoapisummary::

   arkouda.pdarraycreation.from_series
   arkouda.pdarraycreation.array
   arkouda.pdarraycreation.zeros
   arkouda.pdarraycreation.ones
   arkouda.pdarraycreation.zeros_like
   arkouda.pdarraycreation.ones_like
   arkouda.pdarraycreation.arange
   arkouda.pdarraycreation.linspace
   arkouda.pdarraycreation.randint
   arkouda.pdarraycreation.uniform
   arkouda.pdarraycreation.standard_normal
   arkouda.pdarraycreation.random_strings_uniform
   arkouda.pdarraycreation.random_strings_lognormal


.. function:: from_series(series: pandas.Series, dtype: Optional[Union[type, str]] = None) -> Union[(pdarray, Strings)]

   Converts a Pandas Series to an Arkouda pdarray or Strings object. If
   dtype is None, the dtype is inferred from the Pandas Series. Otherwise,
   the dtype parameter is set if the dtype of the Pandas Series is to be
   overridden or is  unknown (for example, in situations where the Series
   dtype is object).

   :param series: The Pandas Series with a dtype of bool, float64, int64, or string
   :type series: Pandas Series
   :param dtype: The valid dtype types are np.bool, np.float64, np.int64, and np.str
   :type dtype: Optional[type]

   :returns:
   :rtype: Union[pdarray,Strings]

   :raises TypeError: Raised if series is not a Pandas Series object
   :raises ValueError: Raised if the Series dtype is not bool, float64, int64, string, datetime, or timedelta

   .. rubric:: Examples

   >>> ak.from_series(pd.Series(np.random.randint(0,10,5)))
   array([9, 0, 4, 7, 9])

   >>> ak.from_series(pd.Series(['1', '2', '3', '4', '5']),dtype=np.int64)
   array([1, 2, 3, 4, 5])

   >>> ak.from_series(pd.Series(np.random.uniform(low=0.0,high=1.0,size=3)))
   array([0.57600036956445599, 0.41619265571741659, 0.6615356693784662])

   >>> ak.from_series(pd.Series(['0.57600036956445599', '0.41619265571741659',
                      '0.6615356693784662']), dtype=np.float64)
   array([0.57600036956445599, 0.41619265571741659, 0.6615356693784662])

   >>> ak.from_series(pd.Series(np.random.choice([True, False],size=5)))
   array([True, False, True, True, True])

   >>> ak.from_series(pd.Series(['True', 'False', 'False', 'True', 'True']), dtype=np.bool)
   array([True, True, True, True, True])

   >>> ak.from_series(pd.Series(['a', 'b', 'c', 'd', 'e'], dtype="string"))
   array(['a', 'b', 'c', 'd', 'e'])

   >>> ak.from_series(pd.Series(['a', 'b', 'c', 'd', 'e']),dtype=np.str)
   array(['a', 'b', 'c', 'd', 'e'])

   >>> ak.from_series(pd.Series(pd.to_datetime(['1/1/2018', np.datetime64('2018-01-01')])))
   array([1514764800000000000, 1514764800000000000])

   .. rubric:: Notes

   The supported datatypes are bool, float64, int64, string, and datetime64[ns]. The
   data type is either inferred from the the Series or is set via the dtype parameter.

   Series of datetime or timedelta are converted to Arkouda arrays of dtype int64 (nanoseconds)


.. function:: array(a: Union[(pdarray, np.ndarray, Iterable)]) -> Union[(pdarray, Strings)]

   Convert a Python or Numpy Iterable to a pdarray or Strings object, sending
   the corresponding data to the arkouda server.

   :param a: Rank-1 array of a supported dtype
   :type a: Union[pdarray, np.ndarray]

   :returns: A pdarray instance stored on arkouda server or Strings instance, which
             is composed of two pdarrays stored on arkouda server
   :rtype: pdarray or Strings

   :raises TypeError: Raised if a is not a pdarray, np.ndarray, or Python Iterable such as a
       list, array, tuple, or deque
   :raises RuntimeError: Raised if a is not one-dimensional, nbytes > maxTransferBytes, a.dtype is
       not supported (not in DTypes), or if the product of a size and
       a.itemsize > maxTransferBytes
   :raises ValueError: Raised if the returned message is malformed or does not contain the fields
       required to generate the array.

   .. seealso:: :obj:`pdarray.to_ndarray`

   .. rubric:: Notes

   The number of bytes in the input array cannot exceed `arkouda.maxTransferBytes`,
   otherwise a RuntimeError will be raised. This is to protect the user
   from overwhelming the connection between the Python client and the arkouda
   server, under the assumption that it is a low-bandwidth connection. The user
   may override this limit by setting ak.maxTransferBytes to a larger value,
   but should proceed with caution.

   If the pdrray or ndarray is of type U, this method is called twice recursively
   to create the Strings object and the two corresponding pdarrays for string
   bytes and offsets, respectively.

   .. rubric:: Examples

   >>> ak.array(np.arange(1,10))
   array([1, 2, 3, 4, 5, 6, 7, 8, 9])

   >>> ak.array(range(1,10))
   array([1, 2, 3, 4, 5, 6, 7, 8, 9])

   >>> strings = ak.array(['string {}'.format(i) for i in range(0,5)])
   >>> type(strings)
   <class 'arkouda.strings.Strings'>


.. function:: zeros(size: arkouda.dtypes.int_scalars, dtype: type = np.float64) -> arkouda.pdarrayclass.pdarray

   Create a pdarray filled with zeros.

   :param size: Size of the array (only rank-1 arrays supported)
   :type size: int_scalars
   :param dtype: Type of resulting array, default float64
   :type dtype: all_scalars

   :returns: Zeros of the requested size and dtype
   :rtype: pdarray

   :raises TypeError: Raised if the supplied dtype is not supported or if the size
       parameter is neither an int nor a str that is parseable to an int.

   .. seealso:: :obj:`ones`, :obj:`zeros_like`

   .. rubric:: Examples

   >>> ak.zeros(5, dtype=ak.int64)
   array([0, 0, 0, 0, 0])

   >>> ak.zeros(5, dtype=ak.float64)
   array([0, 0, 0, 0, 0])

   >>> ak.zeros(5, dtype=ak.bool)
   array([False, False, False, False, False])


.. function:: ones(size: arkouda.dtypes.int_scalars, dtype: type = float64) -> arkouda.pdarrayclass.pdarray

   Create a pdarray filled with ones.

   :param size: Size of the array (only rank-1 arrays supported)
   :type size: int_scalars
   :param dtype: Resulting array type, default float64
   :type dtype: Union[float64, int64, bool]

   :returns: Ones of the requested size and dtype
   :rtype: pdarray

   :raises TypeError: Raised if the supplied dtype is not supported or if the size
       parameter is neither an int nor a str that is parseable to an int.

   .. seealso:: :obj:`zeros`, :obj:`ones_like`

   .. rubric:: Examples

   >>> ak.ones(5, dtype=ak.int64)
   array([1, 1, 1, 1, 1])

   >>> ak.ones(5, dtype=ak.float64)
   array([1, 1, 1, 1, 1])

   >>> ak.ones(5, dtype=ak.bool)
   array([True, True, True, True, True])


.. function:: zeros_like(pda: arkouda.pdarrayclass.pdarray) -> arkouda.pdarrayclass.pdarray

   Create a zero-filled pdarray of the same size and dtype as an existing
   pdarray.

   :param pda: Array to use for size and dtype
   :type pda: pdarray

   :returns: Equivalent to ak.zeros(pda.size, pda.dtype)
   :rtype: pdarray

   :raises TypeError: Raised if the pda parameter is not a pdarray.

   .. seealso:: :obj:`zeros`, :obj:`ones_like`

   .. rubric:: Examples

   >>> zeros = ak.zeros(5, dtype=ak.int64)
   >>> ak.zeros_like(zeros)
   array([0, 0, 0, 0, 0])

   >>> zeros = ak.zeros(5, dtype=ak.float64)
   >>> ak.zeros_like(zeros)
   array([0, 0, 0, 0, 0])

   >>> zeros = ak.zeros(5, dtype=ak.bool)
   >>> ak.zeros_like(zeros)
   array([False, False, False, False, False])


.. function:: ones_like(pda: arkouda.pdarrayclass.pdarray) -> arkouda.pdarrayclass.pdarray

   Create a one-filled pdarray of the same size and dtype as an existing
   pdarray.

   :param pda: Array to use for size and dtype
   :type pda: pdarray

   :returns: Equivalent to ak.ones(pda.size, pda.dtype)
   :rtype: pdarray

   :raises TypeError: Raised if the pda parameter is not a pdarray.

   .. seealso:: :obj:`ones`, :obj:`zeros_like`

   .. rubric:: Notes

   Logic for generating the pdarray is delegated to the ak.ones method.
   Accordingly, the supported dtypes match are defined by the ak.ones method.

   .. rubric:: Examples

   >>> ones = ak.ones(5, dtype=ak.int64)
    >>> ak.ones_like(ones)
   array([1, 1, 1, 1, 1])

   >>> ones = ak.ones(5, dtype=ak.float64)
   >>> ak.ones_like(ones)
   array([1, 1, 1, 1, 1])

   >>> ones = ak.ones(5, dtype=ak.bool)
   >>> ak.ones_like(ones)
   array([True, True, True, True, True])


.. function:: arange(*args) -> arkouda.pdarrayclass.pdarray

   arange([start,] stop[, stride])

   Create a pdarray of consecutive integers within the interval [start, stop).
   If only one arg is given then arg is the stop parameter. If two args are
   given, then the first arg is start and second is stop. If three args are
   given, then the first arg is start, second is stop, third is stride.

   :param start: Starting value (inclusive)
   :type start: int_scalars, optional
   :param stop: Stopping value (exclusive)
   :type stop: int_scalars
   :param stride: The difference between consecutive elements, the default stride is 1,
                  if stride is specified then start must also be specified.
   :type stride: int_scalars, optional

   :returns: Integers from start (inclusive) to stop (exclusive) by stride
   :rtype: pdarray, int64

   :raises TypeError: Raised if start, stop, or stride is not an int object
   :raises ZeroDivisionError: Raised if stride == 0

   .. seealso:: :obj:`linspace`, :obj:`zeros`, :obj:`ones`, :obj:`randint`

   .. rubric:: Notes

   Negative strides result in decreasing values. Currently, only int64
   pdarrays can be created with this method. For float64 arrays, use
   the linspace method.

   .. rubric:: Examples

   >>> ak.arange(0, 5, 1)
   array([0, 1, 2, 3, 4])

   >>> ak.arange(5, 0, -1)
   array([5, 4, 3, 2, 1])

   >>> ak.arange(0, 10, 2)
   array([0, 2, 4, 6, 8])

   >>> ak.arange(-5, -10, -1)
   array([-5, -6, -7, -8, -9])


.. function:: linspace(start: arkouda.dtypes.numeric_scalars, stop: arkouda.dtypes.numeric_scalars, length: arkouda.dtypes.int_scalars) -> arkouda.pdarrayclass.pdarray

   Create a pdarray of linearly-spaced floats in a closed interval.

   :param start: Start of interval (inclusive)
   :type start: numeric_scalars
   :param stop: End of interval (inclusive)
   :type stop: numeric_scalars
   :param length: Number of points
   :type length: int_scalars

   :returns: Array of evenly spaced float values along the interval
   :rtype: pdarray, float64

   :raises TypeError: Raised if start or stop is not a float or int or if length is not an int

   .. seealso:: :obj:`arange`

   .. rubric:: Notes

   If that start is greater than stop, the pdarray values are generated
   in descending order.

   .. rubric:: Examples

   >>> ak.linspace(0, 1, 5)
   array([0, 0.25, 0.5, 0.75, 1])

   >>> ak.linspace(start=1, stop=0, length=5)
   array([1, 0.75, 0.5, 0.25, 0])

   >>> ak.linspace(start=-5, stop=0, length=5)
   array([-5, -3.75, -2.5, -1.25, 0])


.. function:: randint(low: arkouda.dtypes.numeric_scalars, high: arkouda.dtypes.numeric_scalars, size: arkouda.dtypes.int_scalars, dtype=int64, seed: arkouda.dtypes.int_scalars = None) -> arkouda.pdarrayclass.pdarray

   Generate a pdarray of randomized int, float, or bool values in a
   specified range bounded by the low and high parameters.

   :param low: The low value (inclusive) of the range
   :type low: numeric_scalars
   :param high: The high value (exclusive for int, inclusive for float) of the range
   :type high: numeric_scalars
   :param size: The length of the returned array
   :type size: int_scalars
   :param dtype: The dtype of the array
   :type dtype: Union[int64, float64, bool]
   :param seed: Index for where to pull the first returned value
   :type seed: int_scalars

   :returns: Values drawn uniformly from the specified range having the desired dtype
   :rtype: pdarray

   :raises TypeError: Raised if dtype.name not in DTypes, size is not an int, low or high is
       not an int or float, or seed is not an int
   :raises ValueError: Raised if size < 0 or if high < low

   .. rubric:: Notes

   Calling randint with dtype=float64 will result in uniform non-integral
   floating point values.

   .. rubric:: Examples

   >>> ak.randint(0, 10, 5)
   array([5, 7, 4, 8, 3])

   >>> ak.randint(0, 1, 3, dtype=ak.float64)
   array([0.92176432277231968, 0.083130710959903542, 0.68894208386667544])

   >>> ak.randint(0, 1, 5, dtype=ak.bool)
   array([True, False, True, True, True])

   >>> ak.randint(1, 5, 10, seed=2)
   array([4, 3, 1, 3, 4, 4, 2, 4, 3, 2])

   >>> ak.randint(1, 5, 3, dtype=ak.float64, seed=2)
   array([2.9160772326374946, 4.353429832157099, 4.5392023718621486])

   >>> ak.randint(1, 5, 10, dtype=ak.bool, seed=2)
   array([False, True, True, True, True, False, True, True, True, True])


.. function:: uniform(size: arkouda.dtypes.int_scalars, low: arkouda.dtypes.numeric_scalars = float(0.0), high: arkouda.dtypes.numeric_scalars = 1.0, seed: Union[(None, int_scalars)] = None) -> arkouda.pdarrayclass.pdarray

   Generate a pdarray with uniformly distributed random float values
   in a specified range.

   :param low: The low value (inclusive) of the range, defaults to 0.0
   :type low: float_scalars
   :param high: The high value (inclusive) of the range, defaults to 1.0
   :type high: float_scalars
   :param size: The length of the returned array
   :type size: int_scalars
   :param seed: Value used to initialize the random number generator
   :type seed: int_scalars, optional

   :returns: Values drawn uniformly from the specified range
   :rtype: pdarray, float64

   :raises TypeError: Raised if dtype.name not in DTypes, size is not an int, or if
       either low or high is not an int or float
   :raises ValueError: Raised if size < 0 or if high < low

   .. rubric:: Notes

   The logic for uniform is delegated to the ak.randint method which
   is invoked with a dtype of float64

   .. rubric:: Examples

   >>> ak.uniform(3)
   array([0.92176432277231968, 0.083130710959903542, 0.68894208386667544])

   >>> ak.uniform(size=3,low=0,high=5,seed=0)
   array([0.30013431967121934, 0.47383036230759112, 1.0441791878997098])


.. function:: standard_normal(size: arkouda.dtypes.int_scalars, seed: Union[(None, int_scalars)] = None) -> arkouda.pdarrayclass.pdarray

   Draw real numbers from the standard normal distribution.

   :param size: The number of samples to draw (size of the returned array)
   :type size: int_scalars
   :param seed: Value used to initialize the random number generator
   :type seed: int_scalars

   :returns: The array of random numbers
   :rtype: pdarray, float64

   :raises TypeError: Raised if size is not an int
   :raises ValueError: Raised if size < 0

   .. seealso:: :obj:`randint`

   .. rubric:: Notes

   For random samples from :math:`N(\mu, \sigma^2)`, use:

   ``(sigma * standard_normal(size)) + mu``

   .. rubric:: Examples

   >>> ak.standard_normal(3,1)
   array([-0.68586185091150265, 1.1723810583573375, 0.567584107142031])


.. function:: random_strings_uniform(minlen: arkouda.dtypes.int_scalars, maxlen: arkouda.dtypes.int_scalars, size: arkouda.dtypes.int_scalars, characters: str = 'uppercase', seed: Union[(None, int_scalars)] = None) -> arkouda.strings.Strings

   Generate random strings with lengths uniformly distributed between
   minlen and maxlen, and with characters drawn from a specified set.

   :param minlen: The minimum allowed length of string
   :type minlen: int_scalars
   :param maxlen: The maximum allowed length of string
   :type maxlen: int_scalars
   :param size: The number of strings to generate
   :type size: int_scalars
   :param characters: The set of characters to draw from
   :type characters: (uppercase, lowercase, numeric, printable, binary)
   :param seed: Value used to initialize the random number generator
   :type seed: Union[None, int_scalars], optional

   :returns: The array of random strings
   :rtype: Strings

   :raises ValueError: Raised if minlen < 0, maxlen < minlen, or size < 0

   .. seealso:: :obj:`random_strings_lognormal`, :obj:`randint`

   .. rubric:: Examples

   >>> ak.random_strings_uniform(minlen=1, maxlen=5, seed=1, size=5)
   array(['TVKJ', 'EWAB', 'CO', 'HFMD', 'U'])

   >>> ak.random_strings_uniform(minlen=1, maxlen=5, seed=1, size=5,
   ... characters='printable')
   array(['+5"f', '-P]3', '4k', '~HFF', 'F'])


.. function:: random_strings_lognormal(logmean: arkouda.dtypes.numeric_scalars, logstd: arkouda.dtypes.numeric_scalars, size: arkouda.dtypes.int_scalars, characters: str = 'uppercase', seed: Optional[int_scalars] = None) -> arkouda.strings.Strings

   Generate random strings with log-normally distributed lengths and
   with characters drawn from a specified set.

   :param logmean: The log-mean of the length distribution
   :type logmean: numeric_scalars
   :param logstd: The log-standard-deviation of the length distribution
   :type logstd: numeric_scalars
   :param size: The number of strings to generate
   :type size: int_scalars
   :param characters: The set of characters to draw from
   :type characters: (uppercase, lowercase, numeric, printable, binary)
   :param seed: Value used to initialize the random number generator
   :type seed: int_scalars, optional

   :returns: The Strings object encapsulating a pdarray of random strings
   :rtype: Strings

   :raises TypeError: Raised if logmean is neither a float nor a int, logstd is not a float,
       size is not an int, or if characters is not a str
   :raises ValueError: Raised if logstd <= 0 or size < 0

   .. seealso:: :obj:`random_strings_lognormal`, :obj:`randint`

   .. rubric:: Notes

   The lengths of the generated strings are distributed $Lognormal(\mu, \sigma^2)$,
   with :math:`\mu = logmean` and :math:`\sigma = logstd`. Thus, the strings will
   have an average length of :math:`exp(\mu + 0.5*\sigma^2)`, a minimum length of
   zero, and a heavy tail towards longer strings.

   .. rubric:: Examples

   >>> ak.random_strings_lognormal(2, 0.25, 5, seed=1)
   array(['TVKJTE', 'ABOCORHFM', 'LUDMMGTB', 'KWOQNPHZ', 'VSXRRL'])

   >>> ak.random_strings_lognormal(2, 0.25, 5, seed=1, characters='printable')
   array(['+5"fp-', ']3Q4kC~HF', '=F=`,IE!', 'DjkBa'9(', '5oZ1)='])


