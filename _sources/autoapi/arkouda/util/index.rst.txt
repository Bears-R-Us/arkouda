:py:mod:`arkouda.util`
======================

.. py:module:: arkouda.util


Module Contents
---------------


Functions
~~~~~~~~~

.. autoapisummary::

   arkouda.util.attach
   arkouda.util.attach_all
   arkouda.util.broadcast_dims
   arkouda.util.concatenate
   arkouda.util.convert_bytes
   arkouda.util.convert_if_categorical
   arkouda.util.enrich_inplace
   arkouda.util.expand
   arkouda.util.generic_concat
   arkouda.util.get_callback
   arkouda.util.identity
   arkouda.util.invert_permutation
   arkouda.util.is_float
   arkouda.util.is_int
   arkouda.util.is_numeric
   arkouda.util.is_registered
   arkouda.util.map
   arkouda.util.most_common
   arkouda.util.register
   arkouda.util.register_all
   arkouda.util.report_mem
   arkouda.util.sparse_sum_help
   arkouda.util.unregister
   arkouda.util.unregister_all



.. py:function:: attach(name: str)


.. py:function:: attach_all(names: list)

   Attach to all objects registered with the names provide

   :param names: List of names to attach to
   :type names: list

   :rtype: dict


.. py:function:: broadcast_dims(sa: Sequence[int], sb: Sequence[int]) -> Tuple[int, Ellipsis]

   Algorithm to determine shape of broadcasted PD array given two array shapes

   see: https://data-apis.org/array-api/latest/API_specification/broadcasting.html#algorithm


.. py:function:: concatenate(items, ordered=True)


.. py:function:: convert_bytes(nbytes, unit='B')

   Convert the number of bytes to KB, MB, or GB.

   :param unit: Unit to return. One of {'B', 'KB', 'MB', 'GB'}.
   :type unit: str, default = "B"

   :rtype: int


.. py:function:: convert_if_categorical(values)

   Convert a Categorical array to Strings for display


.. py:function:: enrich_inplace(data, keynames, aggregations, **kwargs)


.. py:function:: expand(size, segs, vals)

   Expand an array with values placed into the indicated segments.

   :param size: The size of the array to be expanded
   :type size: ak.pdarray
   :param segs: The indices where the values should be placed
   :type segs: ak.pdarray
   :param vals: The values to be placed in each segment
   :type vals: ak.pdarray

   :returns: The expanded array.
   :rtype: pdarray

   .. rubric:: Notes

   This function (with different order of arguments) is now in arkouda
   proper as ak.broadcast. It is retained here for backwards compatibility.


.. py:function:: generic_concat(items, ordered=True)


.. py:function:: get_callback(x)


.. py:function:: identity(x)


.. py:function:: invert_permutation(perm)

   Find the inverse of a permutation array.

   :param perm: The permutation array.
   :type perm: ak.pdarray

   :returns: The inverse of the permutation array.
   :rtype: ak.array


.. py:function:: is_float(arry: Union[arkouda.pdarrayclass.pdarray, arkouda.strings.Strings, arkouda.categorical.Categorical, arkouda.series.Series, arkouda.index.Index])

   Check if the dtype of the given array is float.

   :param arry: The input pdarray, Strings, or Categorical object.
   :type arry: (pdarray, Strings, Categorical)

   :returns: * *bool* -- True if the dtype of pda is of type float, False otherwise.
             * *Example* -- >>> import arkouda as ak
               >>> ak.connect()
               >>> data = ak.array([1.0, 2, 3, 4, np.nan])
               >>> is_float(data)
               True

               >>> data2 = ak.arange(5)
               >>> is_float(data2)
               False


.. py:function:: is_int(arry: Union[arkouda.pdarrayclass.pdarray, arkouda.strings.Strings, arkouda.categorical.Categorical, arkouda.series.Series, arkouda.index.Index])

   Check if the dtype of the given array is int.

   :param arry ((pdarray: The input pdarray, Strings, or Categorical object.
   :param Strings: The input pdarray, Strings, or Categorical object.
   :param Categorical)): The input pdarray, Strings, or Categorical object.

   :returns: * *bool* -- True if the dtype of pda is of type int, False otherwise.
             * *Example*
             * *>>> import arkouda as ak*
             * *>>> ak.connect()*
             * *>>> data = ak.array([1.0, 2, 3, 4, np.nan])*
             * *>>> is_int(data)*
             * *False*
             * *>>> data2 = ak.arange(5)*
             * *>>> is_int(data2)*
             * *True*


.. py:function:: is_numeric(arry: Union[arkouda.pdarrayclass.pdarray, arkouda.strings.Strings, arkouda.categorical.Categorical, arkouda.series.Series, arkouda.index.Index]) -> bool

   Check if the dtype of the given array is numeric.

   :param arry: The input pdarray, Strings, or Categorical object.
   :type arry: (pdarray, Strings, Categorical)

   :returns: * *bool* -- True if the dtype of pda is numeric, False otherwise.
             * *Example* -- >>> import arkouda as ak
               >>> ak.connect()
               >>> data = ak.array([1, 2, 3, 4, 5])
               >>> is_numeric(data)
               True

               >>> strings = ak.array(["a", "b", "c"])
               >>> is_numeric(strings)
               False


.. py:function:: is_registered(name: str, as_component: bool = False) -> bool

   Determine if the name provided is associated with a registered Object

   :param name: The name to check for in the registry
   :type name: str
   :param as_component: Default: False
                        When True, the name will be checked to determine if it is registered as a component of
                        a registered object
   :type as_component: bool

   :rtype: bool


.. py:function:: map(values: Union[arkouda.pdarrayclass.pdarray, arkouda.strings.Strings, arkouda.categorical.Categorical], mapping: Union[dict, arkouda.Series]) -> Union[arkouda.pdarrayclass.pdarray, arkouda.strings.Strings]

   Map values of an array according to an input mapping.

   :param values: The values to be mapped.
   :type values: pdarray, Strings, or Categorical
   :param mapping: The mapping correspondence.
   :type mapping: dict or arkouda.Series

   :returns: A new array with the values mapped by the mapping correspondence.
             When the input Series has Categorical values,
             the return Series will have Strings values.
             Otherwise, the return type will match the input type.
   :rtype: arkouda.pdarrayclass.pdarray or arkouda.strings.Strings

   :raises TypeError: Raised if arg is not of type dict or arkouda.Series.
       Raised if values not of type pdarray, Categorical, or Strings.

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.connect()
   >>> from arkouda.util import map
   >>> a = ak.array([2, 3, 2, 3, 4])
   >>> a
   array([2 3 2 3 4])
   >>> map(a, {4: 25.0, 2: 30.0, 1: 7.0, 3: 5.0})
   array([30.00000000000000000 5.00000000000000000 30.00000000000000000
   5.00000000000000000 25.00000000000000000])
   >>> s = ak.Series(ak.array(["a","b","c","d"]), index = ak.array([4,2,1,3]))
   >>> map(a, s)
   array(['b', 'b', 'd', 'd', 'a'])


.. py:function:: most_common(g, values)


.. py:function:: register(obj, name)

   Register an arkouda object with a user-specified name. Backwards compatible
   with earlier arkouda versions.


.. py:function:: register_all(data: dict)

   Register all objects in the provided dictionary

   :param data: Maps name to register the object to the object. For example, {"MyArray": ak.array([0, 1, 2])
   :type data: dict

   :rtype: None


.. py:function:: report_mem(pre='')


.. py:function:: sparse_sum_help(idx1, idx2, val1, val2, merge=True, percent_transfer_limit=100)

   Helper for summing two sparse matrices together

   Return is equivalent to
   ak.GroupBy(ak.concatenate([idx1, idx2])).sum(ak.concatenate((val1, val2)))

   :param idx1: indices for the first sparse matrix
   :type idx1: pdarray
   :param idx2: indices for the second sparse matrix
   :type idx2: pdarray
   :param val1: values for the first sparse matrix
   :type val1: pdarray
   :param val2: values for the second sparse matrix
   :type val2: pdarray
   :param merge: If true the indices are combined using a merge based workflow,
                 otherwise they are combine using a sort based workflow.
   :type merge: bool
   :param percent_transfer_limit: Only used when merge is true. This is the maximum percentage of the data allowed
                                  to be moved between locales during the merge workflow. If we would exceed this percentage,
                                  we fall back to using the sort based workflow.
   :type percent_transfer_limit: int

   :returns: indices and values for the summed sparse matrix
   :rtype: (pdarray, pdarray)

   .. rubric:: Examples

   >>> idx1 = ak.array([0, 1, 3, 4, 7, 9])
   >>> idx2 = ak.array([0, 1, 3, 6, 9])
   >>> vals1 = idx1
   >>> vals2 = ak.array([10, 11, 13, 16, 19])
   >>> ak.util.sparse_sum_help(idx1, inds2, vals1, vals2)
   (array([0 1 3 4 6 7 9]), array([10 12 16 4 16 7 28]))

   >>> ak.GroupBy(ak.concatenate([idx1, idx2])).sum(ak.concatenate((vals1, vals2)))
   (array([0 1 3 4 6 7 9]), array([10 12 16 4 16 7 28]))


.. py:function:: unregister(name: str) -> str


.. py:function:: unregister_all(names: list)

   Unregister all names provided

   :param names: List of names used to register objects to be unregistered
   :type names: list

   :rtype: None


