arkouda.matcher
===============

.. py:module:: arkouda.matcher


Attributes
----------

.. autoapisummary::

   arkouda.matcher.MatchType
   arkouda.matcher.generic_msg


Classes
-------

.. autoapisummary::

   arkouda.matcher.Match
   arkouda.matcher.Matcher
   arkouda.matcher.pdarray
   arkouda.matcher.str_scalars


Functions
---------

.. autoapisummary::

   arkouda.matcher.create_pdarray
   arkouda.matcher.getArkoudaLogger
   arkouda.matcher.list_symbol_table


Package Contents
----------------

.. py:class:: Match(matched: arkouda.numpy.pdarrayclass.pdarray, starts: arkouda.numpy.pdarrayclass.pdarray, lengths: arkouda.numpy.pdarrayclass.pdarray, indices: arkouda.numpy.pdarrayclass.pdarray, parent_entry_name: str, match_type: MatchType, pattern: str)

   .. py:method:: end() -> arkouda.numpy.pdarrayclass.pdarray

      Return the ends of matches.

      :returns: The end positions of matches
      :rtype: pdarray

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> strings = ak.array(['1_2___', '____', '3', '__4___5____6___7', ''])
      >>> strings.search('_+').end()
      array([2 4 2])



   .. py:method:: find_matches(return_match_origins: bool = False)

      Return all matches as a new Strings object.

      :param return_match_origins: If True, return a pdarray containing the index of the original string each pattern
                                   match is from
      :type return_match_origins: bool

      :returns: * *Strings* -- Strings object containing only matches
                * *pdarray, int64 (optional)* -- The index of the original string each pattern match is from

      :raises RuntimeError: Raised if there is a server-side error thrown

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> strings = ak.array(['1_2___', '____', '3', '__4___5____6___7', ''])
      >>> strings.search('_+').find_matches(return_match_origins=True)
      (array(['_', '____', '__']), array([0 1 3]))



   .. py:method:: group(group_num: int = 0, return_group_origins: bool = False)

      Return a new Strings containing the capture group corresponding to group_num.

      For the default, group_num=0, return the full match.

      :param group_num: The index of the capture group to be returned
      :type group_num: int
      :param return_group_origins: If True, return a pdarray containing the index of the original string each
                                   capture group is from
      :type return_group_origins: bool

      :returns: * *Strings* -- Strings object containing only the capture groups corresponding to group_num
                * *pdarray, int64 (optional)* -- The index of the original string each group is from

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> strings = ak.array(["Isaac Newton, physics", '<-calculus->', 'Gottfried Leibniz, math'])
      >>> m = strings.search("(\\w+) (\\w+)")
      >>> m.group()
      array(['Isaac Newton', 'Gottfried Leibniz'])
      >>> m.group(1)
      array(['Isaac', 'Gottfried'])
      >>> m.group(2, return_group_origins=True)
      (array(['Newton', 'Leibniz']), array([0 2]))



   .. py:method:: match_type() -> str

      Return the type of the Match object.

      :returns: MatchType of the Match object
      :rtype: str

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> strings = ak.array(['1_2___', '____', '3', '__4___5____6___7', ''])
      >>> strings.search('_+').match_type()
      'SEARCH'



   .. py:method:: matched() -> arkouda.numpy.pdarrayclass.pdarray

      Return a boolean array indiciating whether each element matched.

      :returns: True for elements that match, False otherwise
      :rtype: pdarray

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> strings = ak.array(['1_2___', '____', '3', '__4___5____6___7', ''])
      >>> strings.search('_+').matched()
      array([True True False True False])



   .. py:attribute:: re


   .. py:method:: start() -> arkouda.numpy.pdarrayclass.pdarray

      Return the starts of matches.

      :returns: The start positions of matches
      :rtype: pdarray

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> strings = ak.array(['1_2___', '____', '3', '__4___5____6___7', ''])
      >>> strings.search('_+').start()
      array([1 0 0])



.. py:data:: MatchType

.. py:class:: Matcher(pattern: arkouda.numpy.dtypes.str_scalars, parent_entry_name: str)

   .. py:attribute:: LocationsInfo


   .. py:method:: find_locations() -> None

      Populate Matcher object by finding the positions of matches.



   .. py:method:: findall(return_match_origins: bool = False)

      Return all non-overlapping matches of pattern in Strings as a new Strings object.



   .. py:attribute:: full_match_bool
      :type:  arkouda.numpy.pdarrayclass.pdarray


   .. py:attribute:: full_match_ind
      :type:  arkouda.numpy.pdarrayclass.pdarray


   .. py:method:: get_match(match_type: arkouda.pandas.match.MatchType, parent: object = None) -> arkouda.pandas.match.Match

      Create a Match object of type match_type.



   .. py:attribute:: indices
      :type:  arkouda.numpy.pdarrayclass.pdarray


   .. py:attribute:: lengths
      :type:  arkouda.numpy.pdarrayclass.pdarray


   .. py:attribute:: logger


   .. py:attribute:: match_bool
      :type:  arkouda.numpy.pdarrayclass.pdarray


   .. py:attribute:: match_ind
      :type:  arkouda.numpy.pdarrayclass.pdarray


   .. py:attribute:: num_matches
      :type:  arkouda.numpy.pdarrayclass.pdarray


   .. py:attribute:: objType
      :value: 'Matcher'



   .. py:attribute:: parent_entry_name


   .. py:attribute:: populated
      :value: False



   .. py:attribute:: search_bool
      :type:  arkouda.numpy.pdarrayclass.pdarray


   .. py:attribute:: search_ind
      :type:  arkouda.numpy.pdarrayclass.pdarray


   .. py:method:: split(maxsplit: int = 0, return_segments: bool = False)

      Split string by the occurrences of pattern.
      If maxsplit is nonzero, at most maxsplit splits occur.



   .. py:attribute:: starts
      :type:  arkouda.numpy.pdarrayclass.pdarray


   .. py:method:: sub(repl: str, count: int = 0, return_num_subs: bool = False)

      Return the Strings obtained by replacing non-overlapping occurrences of pattern
      with the replacement repl.
      If count is nonzero, at most count substitutions occur
      If return_num_subs is True, return the number of substitutions that occurred



.. py:function:: create_pdarray(repMsg: str, max_bits=None) -> pdarray

   Return a pdarray instance pointing to an array created by the arkouda server.
   The user should not call this function directly.

   :param repMsg: space-delimited string containing the pdarray name, datatype, size
                  dimension, shape,and itemsize
   :type repMsg: str

   :returns: A pdarray with the same attributes and data as the pdarray; on GPU
   :rtype: pdarray

   :raises ValueError: If there's an error in parsing the repMsg parameter into the six
       values needed to create the pdarray instance
   :raises RuntimeError: Raised if a server-side error is thrown in the process of creating
       the pdarray instance


.. py:data:: generic_msg

.. py:function:: getArkoudaLogger(name: str, handlers: Optional[List[logging.Handler]] = None, logFormat: Optional[str] = ArkoudaLogger.DEFAULT_LOG_FORMAT, logLevel: Optional[LogLevel] = None) -> ArkoudaLogger

   Instantiate an ArkoudaLogger that retrieves the logging level from ARKOUDA_LOG_LEVEL env variable.

   :param name: The name of the ArkoudaLogger
   :type name: str
   :param handlers: A list of logging.Handler objects, if None, a list consisting of
                    one StreamHandler named 'console-handler' is generated and configured
   :type handlers: List[Handler]
   :param logFormat: The format for log messages, defaults to the following format:
                     '[%(name)s] Line %(lineno)d %(levelname)s: %(message)s'
   :type logFormat: str

   :rtype: ArkoudaLogger

   :raises TypeError: Raised if either name or logFormat is not a str object or if handlers
       is not a list of str objects

   .. rubric:: Notes

   Important note: if a list of 1..n logging.Handler objects is passed in, and
   dynamic changes to 1..n handlers is desired, set a name for each Handler
   object as follows: handler.name = <desired name>, which will enable retrieval
   and updates for the specified handler.


.. py:function:: list_symbol_table() -> List[str]

   Return a list containing the names of all objects in the symbol table.

   :returns: List of all object names in the symbol table
   :rtype: list

   :raises RuntimeError: Raised if there's a server-side error thrown


.. py:class:: pdarray(name: str, mydtype: numpy.dtype, size: arkouda.numpy.dtypes.int_scalars, ndim: arkouda.numpy.dtypes.int_scalars, shape: Tuple[int, Ellipsis], itemsize: arkouda.numpy.dtypes.int_scalars, max_bits: Optional[int] = None)

   The basic arkouda array class. This class contains only the
   attributes of the array; the data resides on the arkouda
   server. When a server operation results in a new array, arkouda
   will create a pdarray instance that points to the array data on
   the server. As such, the user should not initialize pdarray
   instances directly.

   .. attribute:: name

      The server-side identifier for the array

      :type: str

   .. attribute:: dtype

      The element dtype of the array

      :type: type

   .. attribute:: size

      The number of elements in the array

      :type: int_scalars

   .. attribute:: ndim

      The rank of the array

      :type: int_scalars

   .. attribute:: shape

      A tuple containing the sizes of each dimension of the array

      :type: Tuple[int, ...]

   .. attribute:: itemsize

      The size in bytes of each element

      :type: int_scalars


   .. py:attribute:: BinOps


   .. py:attribute:: OpEqOps


   .. py:method:: all(axis: Optional[Union[int, Tuple[int, Ellipsis]]] = None, keepdims: bool = False) -> Union[arkouda.numpy.dtypes.bool_scalars, pdarray]

      Return True iff all elements of the array along the given axis evaluate to True.

      :param axis: The axis or axes along which to do the operation
                   If None, the computation is done across the entire array.
      :type axis: int, Tuple[int, ...], optional, default = None
      :param keepdims: Whether to keep the singleton dimension(s) along `axis` in the result.
      :type keepdims: bool, optional, default = False

      :returns: boolean if axis is omitted, pdarray if axis is supplied
      :rtype: boolean or pdarray

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> ak.all(ak.array([True,False,False]))
      np.False_
      >>> ak.all(ak.array([[True,True,False],[False,True,True]]),axis=0)
      array([False True False])
      >>> ak.all(ak.array([[True,True,True],[False,False,False]]),axis=0,keepdims=True)
      array([array([False False False])])
      >>> ak.all(ak.array([[True,True,True],[False,False,False]]),axis=1,keepdims=True)
      array([array([True]) array([False])])
      >>> ak.array([True,False,False]).all()
      np.False_

      :raises TypeError: Raised if pda is not a pdarray instance
      :raises RuntimeError: Raised if there's a server-side error thrown

      .. rubric:: Notes

      Works as a method of a pdarray (e.g. a.any()) or a standalone function (e.g. ak.all(a))



   .. py:method:: any(axis: Optional[Union[int, Tuple[int, Ellipsis]]] = None, keepdims: bool = False) -> Union[arkouda.numpy.dtypes.bool_scalars, pdarray]

      Return True iff any element of the array along the given axis evaluates to True.

      :param axis: The axis or axes along which to do the operation
                   If None, the computation is done across the entire array.
      :type axis: int, Tuple[int, ...], optional, default = None
      :param keepdims: Whether to keep the singleton dimension(s) along `axis` in the result.
      :type keepdims: bool, optional, default = False

      :returns: boolean if axis is omitted, else pdarray if axis is supplied
      :rtype: boolean or pdarray

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> ak.any(ak.array([True,False,False]))
      np.True_
      >>> ak.any(ak.array([[True,True,False],[False,True,True]]),axis=0)
      array([True True True])
      >>> ak.any(ak.array([[True,True,True],[False,False,False]]),axis=0,keepdims=True)
      array([array([True True True])])
      >>> ak.any(ak.array([[True,True,True],[False,False,False]]),axis=1,keepdims=True)
      array([array([True]) array([False])])
      >>> ak.array([True,False,False]).any()
      np.True_

      :raises TypeError: Raised if pda is not a pdarray instance
      :raises RuntimeError: Raised if there's a server-side error thrown

      .. rubric:: Notes

      Works as a method of a pdarray (e.g. a.any()) or a standalone function (e.g. ak.any(a))



   .. py:method:: argmax(axis: Optional[Union[int, None]] = None, keepdims: bool = False) -> Union[numpy.int64, numpy.uint64, pdarray]

      Return index of the first occurrence of the maximum along the given axis.

      :param axis: The axis or axes along which to do the operation
                   If None, the computation is done across the entire array.
      :type axis: int, Tuple[int, ...], optional, default = None
      :param keepdims: Whether to keep the singleton dimension(s) along `axis` in the result.
      :type keepdims: bool, optional, default = False

      :returns: int64 or uint64 if axis is omitted, in which case operation is done over entire array
                pdarray if axis is supplied, in which case the operation is done along that axis
      :rtype: int64, uint64 or pdarray

      :raises TypeError: Raised if pda is not a pdarray instance
      :raises RuntimeError: Raised if there's a server-side error thrown

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> ak.argmax(ak.array([1,2,3,4,5]))
      np.int64(4)
      >>> ak.argmax(ak.array([5.5,4.5,3.5,2.5,1.5]))
      np.int64(0)
      >>> ak.array([[1,2,3],[5,4,3]]).argmax(axis=1)
      array([2 0])

      .. rubric:: Notes

      Works as a method of a pdarray (e.g. a.argmax()) or a standalone function (e.g. ak.argmax(a))



   .. py:method:: argmaxk(k: arkouda.numpy.dtypes.int_scalars) -> pdarray

      Finds the indices corresponding to the `k` maximum values of an array.
      See ``arkouda.argmaxk`` for details.



   .. py:method:: argmin(axis: Optional[Union[int, None]] = None, keepdims: bool = False) -> Union[numpy.int64, numpy.uint64, pdarray]

      Return index of the first occurrence of the minimum along the given axis.

      :param axis: The axis or axes along which to do the operation
                   If None, the computation is done across the entire array.
      :type axis: int, Tuple[int, ...], optional, default = None
      :param keepdims: Whether to keep the singleton dimension(s) along `axis` in the result.
      :type keepdims: bool, optional, default = False

      :returns: int64 or uint64 if axis is omitted, in which case operation is done over entire array
                pdarray if axis is supplied, in which case the operation is done along that axis
      :rtype: int64, uint64 or pdarray

      :raises TypeError: Raised if pda is not a pdarray instance
      :raises RuntimeError: Raised if there's a server-side error thrown

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> ak.argmin(ak.array([1,2,3,4,5]))
      np.int64(0)
      >>> ak.argmin(ak.array([5.5,4.5,3.5,2.5,1.5]))
      np.int64(4)
      >>> ak.array([[1,2,3],[5,4,3]]).argmin(axis=1)
      array([0 2])

      .. rubric:: Notes

      Works as a method of a pdarray (e.g. a.argmin()) or a standalone function (e.g. ak.argmin(a))



   .. py:method:: argmink(k: arkouda.numpy.dtypes.int_scalars) -> pdarray

      Finds the indices corresponding to the `k` minimum values of an array.
      See ``arkouda.argmink`` for details.



   .. py:method:: argsort(algorithm: arkouda.numpy.sorting.SortingAlgorithm = SortingAlgorithm.RadixSortLSD, axis: arkouda.numpy.dtypes.int_scalars = 0, ascending: bool = True) -> pdarray

      Return the permutation that sorts the pdarray.

      :param algorithm: The algorithm to use for sorting.
      :type algorithm: SortingAlgorithm, default SortingAlgorithm.RadixSortLSD
      :param axis: The axis to sort along. Must be between -1 and the array rank.
      :type axis: int_scalars, default 0
      :param ascending: Whether to sort in ascending order. If False, returns a reversed permutation.
                        Note: ascending=False is only supported for 1D arrays.
      :type ascending: bool, default True

      :returns: The indices that would sort the array.
      :rtype: pdarray

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> a = ak.array([42, 7, 19])
      >>> a.argsort()
      array([1 2 0])
      >>> a[a.argsort()]
      array([7 19 42])
      >>> a.argsort(ascending=False)
      array([0 2 1])



   .. py:method:: astype(dtype) -> pdarray

      Cast values of pdarray to provided dtype

      :param dtype: Dtype to cast to
      :type dtype: np.dtype or str

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> ak.array([1,2,3]).astype(ak.float64)
      array([1.00000000000000000 2.00000000000000000 3.00000000000000000])
      >>> ak.array([1.5,2.5]).astype(ak.int64)
      array([1 2])
      >>> ak.array([True,False]).astype(ak.int64)
      array([1 0])

      :returns: An arkouda pdarray with values converted to the specified data type
      :rtype: ak.pdarray

      .. rubric:: Notes

      This is essentially shorthand for ak.cast(x, '<dtype>') where x is a pdarray.



   .. py:method:: bigint_to_uint_arrays() -> List[pdarray]

      Create a list of uint pdarrays from a bigint pdarray.
      The first item in return will be the highest 64 bits of the
      bigint pdarray and the last item will be the lowest 64 bits.

      :returns: A list of uint pdarrays where:
                The first item in return will be the highest 64 bits of the
                bigint pdarray and the last item will be the lowest 64 bits.
      :rtype: List[pdarrays]

      :raises RuntimeError: Raised if there is a server-side error thrown

      .. seealso:: :py:obj:`pdarraycreation.bigint_from_uint_arrays`

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> a = ak.arange(2**64, 2**64 + 5)
      >>> a
      array([18446744073709551616 18446744073709551617 18446744073709551618
      18446744073709551619 18446744073709551620])
      >>> a.bigint_to_uint_arrays()
      [array([1 1 1 1 1]), array([0 1 2 3 4])]



   .. py:method:: clz() -> pdarray

      Count the number of leading zeros in each element. See `ak.clz`.



   .. py:method:: corr(y: pdarray) -> numpy.float64

      Compute the correlation between self and y using pearson correlation coefficient.
      See ``arkouda.corr`` for details.



   .. py:method:: cov(y: pdarray) -> numpy.float64

      Compute the covariance between self and y.



   .. py:method:: ctz() -> pdarray

      Count the number of trailing zeros in each element. See `ak.ctz`.



   .. py:attribute:: dtype
      :type:  numpy.dtype


   .. py:method:: equals(other) -> arkouda.numpy.dtypes.bool_scalars

      Whether pdarrays are the same size and all entries are equal.

      :param other: object to compare.
      :type other: object

      :returns: True if the pdarrays are the same, o.w. False.
      :rtype: bool_scalars

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> a = ak.array([1, 2, 3])
      >>> a_cpy = ak.array([1, 2, 3])
      >>> a.equals(a_cpy)
      np.True_
      >>> a2 = ak.array([1, 2, 5])
      >>> a.equals(a2)
      np.False_



   .. py:method:: fill(value: arkouda.numpy.dtypes.numeric_scalars) -> None

      Fill the array (in place) with a constant value.

      :param value:
      :type value: numeric_scalars

      :raises TypeError: Raised if value is not an int, int64, float, or float64



   .. py:method:: flatten()

      Return a copy of the array collapsed into one dimension.

      :rtype: A copy of the input array, flattened to one dimension.

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> a = ak.array([[3,2,1],[2,3,1]])
      >>> a.flatten()
      array([3 2 1 2 3 1])



   .. py:method:: format_other(other) -> str

      Attempt to cast scalar other to the element dtype of this pdarray,
      and print the resulting value to a string (e.g. for sending to a
      server command). The user should not call this function directly.

      :param other: The scalar to be cast to the pdarray.dtype
      :type other: object

      :rtype: string representation of np.dtype corresponding to the other parameter

      :raises TypeError: Raised if the other parameter cannot be converted to
          Numpy dtype



   .. py:property:: inferred_type
      :type: Union[str, None]


      Return a string of the type inferred from the values.


   .. py:method:: info() -> str

      Return a JSON formatted string containing information about all components of self.

      :returns: JSON string containing information about all components of self
      :rtype: str



   .. py:method:: is_registered() -> numpy.bool_

      Return True iff the object is contained in the registry

      :returns: Indicates if the object is contained in the registry
      :rtype: bool

      :raises RuntimeError: Raised if there's a server-side error thrown

      .. note::

         This will return True if the object is registered itself or as a component
         of another object



   .. py:method:: is_sorted(axis: Optional[Union[int, Tuple[int, Ellipsis]]] = None, keepdims: bool = False) -> Union[arkouda.numpy.dtypes.bool_scalars, pdarray]

      Return True iff the array (or given axis of the array) is monotonically non-decreasing.

      :param axis: The axis or axes along which to do the operation
                   If None, the computation is done across the entire array.
      :type axis: int, Tuple[int, ...], optional, default = None
      :param keepdims: Whether to keep the singleton dimension(s) along `axis` in the result.
      :type keepdims: bool, optional, default = False

      :returns: boolean if axis is omitted, else pdarray if axis is supplied
      :rtype: boolean or pdarray

      :raises TypeError: Raised if pda is not a pdarray instance
      :raises RuntimeError: Raised if there's a server-side error thrown

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> ak.is_sorted(ak.array([1,2,3,4,5]))
      np.True_
      >>> ak.is_sorted(ak.array([5,4,3,2,1]))
      np.False_
      >>> ak.array([[1,2,3],[5,4,3]]).is_sorted(axis=1)
      array([True False])

      .. rubric:: Notes

      Works as a method of a pdarray (e.g. a.is_sorted()) or a
      standalone function (e.g. ak.is_sorted(a))



   .. py:attribute:: itemsize
      :type:  arkouda.numpy.dtypes.int_scalars


   .. py:method:: max(axis: Optional[Union[int, Tuple[int, Ellipsis]]] = None, keepdims: bool = False) -> Union[arkouda.numpy.dtypes.numeric_scalars, pdarray]

      Return max of array elements along the given axis.

      :param axis: The axis or axes along which to do the operation
                   If None, the computation is done across the entire array.
      :type axis: int, Tuple[int, ...], optional, default = None
      :param keepdims: Whether to keep the singleton dimension(s) along `axis` in the result.
      :type keepdims: bool, optional, default = False

      :returns: numeric_scalar if axis is omitted, in which case operation is done over entire array
                pdarray if axis is supplied, in which case the operation is done along that axis
      :rtype: numeric_scalar or pdarray

      :raises TypeError: Raised if pda is not a pdarray instance
      :raises RuntimeError: Raised if there's a server-side error thrown

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> ak.max(ak.array([1,2,3,4,5]))
      np.int64(5)
      >>> ak.max(ak.array([5.5,4.5,3.5,2.5,1.5]))
      np.float64(5.5)
      >>> ak.array([[1,2,3],[5,4,3]]).max(axis=1)
      array([3 5])

      .. rubric:: Notes

      Works as a method of a pdarray (e.g. a.max()) or a standalone function (e.g. ak.max(a))



   .. py:property:: max_bits


   .. py:method:: maxk(k: arkouda.numpy.dtypes.int_scalars) -> pdarray

      Compute the maximum "k" values.  See ``arkouda.maxk`` for details.



   .. py:method:: mean(axis: Optional[Union[int, Tuple[int, Ellipsis]]] = None, keepdims: bool = False) -> Union[arkouda.numpy.dtypes.numeric_scalars, pdarray]

      Return the mean of the array.

      :param axis: The axis or axes along which to do the operation
                   If None, the computation is done across the entire array.
      :type axis: int, Tuple[int, ...], optional, default = None
      :param keepdims: Whether to keep the singleton dimension(s) along `axis` in the result.
      :type keepdims: bool, optional, default = False

      :returns: The mean calculated from the pda sum and size, along the axis/axes if
                those are given.
      :rtype: Union[np.float64, pdarray]

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> a = ak.arange(10)
      >>> ak.mean(a)
      np.float64(4.5)
      >>> a.mean()
      np.float64(4.5)
      >>> a = ak.arange(10).reshape(2,5)
      >>> a.mean(axis=0)
      array([2.5 3.5 4.5 5.5 6.5])
      >>> ak.mean(a,axis=0)
      array([2.5 3.5 4.5 5.5 6.5])
      >>> a.mean(axis=1)
      array([2.00000000000000000 7.00000000000000000])
      >>> ak.mean(a,axis=1)
      array([2.00000000000000000 7.00000000000000000])

      Raises
          Raised if pda is not a pdarray instance
      RuntimeError
          Raised if there's a server-side error thrown



   .. py:method:: min(axis: Optional[Union[int, Tuple[int, Ellipsis]]] = None, keepdims: bool = False) -> Union[arkouda.numpy.dtypes.numeric_scalars, pdarray]

      Return min of array elements along the given axis.

      :param axis: The axis or axes along which to do the operation
                   If None, the computation is done across the entire array.
      :type axis: int, Tuple[int, ...], optional, default = None
      :param keepdims: Whether to keep the singleton dimension(s) along `axis` in the result.
      :type keepdims: bool, optional, default = False

      :returns: numeric_scalar if axis is omitted, in which case operation is done over entire array
                pdarray if axis is supplied, in which case the operation is done along that axis
      :rtype: numeric_scalar or pdarray

      :raises TypeError: Raised if pda is not a pdarray instance
      :raises RuntimeError: Raised if there's a server-side error thrown

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> ak.min(ak.array([1,2,3,4,5]))
      np.int64(1)
      >>> ak.min(ak.array([5.5,4.5,3.5,2.5,1.5]))
      np.float64(1.5)
      >>> ak.array([[1,2,3],[5,4,3]]).min(axis=1)
      array([1 3])

      .. rubric:: Notes

      Works as a method of a pdarray (e.g. a.min()) or a standalone function (e.g. ak.min(a))



   .. py:method:: mink(k: arkouda.numpy.dtypes.int_scalars) -> pdarray

      Compute the minimum "k" values.  See ``arkouda.mink`` for details.



   .. py:attribute:: name
      :type:  str


   .. py:property:: nbytes

      The size of the pdarray in bytes.

      :returns: The size of the pdarray in bytes.
      :rtype: int


   .. py:attribute:: ndim
      :type:  arkouda.numpy.dtypes.int_scalars


   .. py:attribute:: objType
      :value: 'pdarray'



   .. py:method:: opeq(other, op)


   .. py:method:: parity() -> pdarray

      Find the parity (XOR of all bits) in each element. See `ak.parity`.



   .. py:method:: popcount() -> pdarray

      Find the population (number of bits set) in each element. See `ak.popcount`.



   .. py:method:: pretty_print_info() -> None

      Print information about all components of self in a human-readable format.



   .. py:method:: prod(axis: Optional[Union[int, Tuple[int, Ellipsis]]] = None, keepdims: bool = False) -> Union[arkouda.numpy.dtypes.numeric_scalars, pdarray]

      Return prod of array elements along the given axis.

      :param axis: The axis or axes along which to do the operation
                   If None, the computation is done across the entire array.
      :type axis: int, Tuple[int, ...], optional, defalt = None
      :param keepdims: Whether to keep the singleton dimension(s) along `axis` in the result.
      :type keepdims: bool, optional, default = False

      :returns: numeric_scalars if axis is omitted, in which case operation is done over entire array
                pdarray if axis is supplied, in which case the operation is done along that axis
      :rtype: numeric_scalars or pdarray

      :raises TypeError: Raised if pda is not a pdarray instance
      :raises RuntimeError: Raised if there's a server-side error thrown

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> ak.prod(ak.array([1,2,3,4,5]))
      np.int64(120)
      >>> ak.prod(ak.array([5.5,4.5,3.5,2.5,1.5]))
      np.float64(324.84375)
      >>> ak.array([[1,2,3],[5,4,3]]).prod(axis=1)
      array([6 60])

      .. rubric:: Notes

      Works as a method of a pdarray (e.g. a.prod()) or a standalone function (e.g. ak.prod(a))



   .. py:method:: register(user_defined_name: str) -> pdarray

      Register this pdarray with a user defined name in the arkouda server
      so it can be attached to later using pdarray.attach()
      This is an in-place operation, registering a pdarray more than once will
      update the name in the registry and remove the previously registered name.
      A name can only be registered to one pdarray at a time.

      :param user_defined_name: user defined name array is to be registered under
      :type user_defined_name: str

      :returns: The same pdarray which is now registered with the arkouda server and has an updated name.
                This is an in-place modification, the original is returned to support a
                fluid programming style.
                Please note you cannot register two different pdarrays with the same name.
      :rtype: pdarray

      :raises TypeError: Raised if user_defined_name is not a str
      :raises RegistrationError: If the server was unable to register the pdarray with the user_defined_name
          If the user is attempting to register more than one pdarray with the same name,
          the former should be unregistered first to free up the registration name.

      .. seealso:: :py:obj:`attach`, :py:obj:`unregister`, :py:obj:`is_registered`, :py:obj:`list_registry`, :py:obj:`unregister_pdarray_by_name`

      .. rubric:: Notes

      Registered names/pdarrays in the server are immune to deletion
      until they are unregistered.

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> a = ak.zeros(3)
      >>> a.register("my_zeros")
      array([0.00000000000000000 0.00000000000000000 0.00000000000000000])

      potentially disconnect from server and reconnect to server
      >>> b = ak.attach("my_zeros")
      >>> b.unregister()



   .. py:attribute:: registered_name
      :type:  Optional[str]
      :value: None



   .. py:method:: reshape(*shape)

      Gives a new shape to an array without changing its data.

      :param shape: The new shape should be compatible with the original shape.
      :type shape: int, tuple of ints, or pdarray

      :returns: a pdarray with the same data, reshaped to the new shape
      :rtype: pdarray

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> a = ak.array([[3,2,1],[2,3,1]])
      >>> a.reshape((3,2))
      array([array([3 2]) array([1 2]) array([3 1])])
      >>> a.reshape(3,2)
      array([array([3 2]) array([1 2]) array([3 1])])
      >>> a.reshape((6,1))
      array([array([3]) array([2]) array([1]) array([2]) array([3]) array([1])])

      .. rubric:: Notes

      only available as a method, not as a standalone function, i.e.,
      a.reshape(compatibleShape) is valid, but ak.reshape(a,compatibleShape) is not.



   .. py:method:: rotl(other) -> pdarray

      Rotate bits left by <other>.



   .. py:method:: rotr(other) -> pdarray

      Rotate bits right by <other>.



   .. py:property:: shape

      Return the shape of an array.

      :returns: The elements of the shape tuple give the lengths of the corresponding array dimensions.
      :rtype: tuple of int


   .. py:attribute:: size
      :type:  arkouda.numpy.dtypes.int_scalars


   .. py:method:: slice_bits(low, high) -> pdarray

      Return a pdarray containing only bits from low to high of self.

      This is zero indexed and inclusive on both ends, so slicing the bottom 64 bits is
      pda.slice_bits(0, 63)

      :param low: The lowest bit included in the slice (inclusive)
                  zero indexed, so the first bit is 0
      :type low: int
      :param high: The highest bit included in the slice (inclusive)
      :type high: int

      :returns: A new pdarray containing the bits of self from low to high
      :rtype: pdarray

      :raises RuntimeError: Raised if there is a server-side error thrown

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> p = ak.array([2**65 + (2**64 - 1)])
      >>> bin(p[0])
      '0b101111111111111111111111111111111111111111111111111111111111111111'
      >>> bin(p.slice_bits(64, 65)[0])
      '0b10'
      >>> a = ak.array([143,15])
      >>> a.slice_bits(1,3)
      array([7 7])
      >>> a.slice_bits(4,9)
      array([8 0])
      >>> a.slice_bits(1,9)
      array([71 7])



   .. py:method:: std(ddof: arkouda.numpy.dtypes.int_scalars = 0, axis: Optional[Union[int, Tuple[int, Ellipsis]]] = None, keepdims: Optional[bool] = False) -> Union[numpy.float64, pdarray]

      Return the standard deviation of values in the array. The standard
      deviation is implemented as the square root of the variance.

      :param ddof: "Delta Degrees of Freedom" used in calculating std
      :type ddof: int_scalars
      :param axis: The axis or axes along which to do the operation
                   If None, the computation is done across the entire array.
      :type axis: int, Tuple[int, ...], optional, default = None
      :param keepdims: Whether to keep the singleton dimension(s) along `axis` in the result.
      :type keepdims: bool, optional, default = False

      :returns:

                The scalar standard deviation of the array, or the standard deviation
                 along the axis/axes if supplied
      :rtype: Union[np.float64, pdarray]

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> a = ak.arange(10)
      >>> ak.std(a)
      np.float64(2.8722813232690143)
      >>> a.std()
      np.float64(2.8722813232690143)
      >>> a = ak.arange(10).reshape(2,5)
      >>> a.std(axis=0)
      array([2.5 2.5 2.5 2.5 2.5])
      >>> ak.std(a,axis=0)
      array([2.5 2.5 2.5 2.5 2.5])
      >>> a.std(axis=1)
      array([1.4142135623730951 1.4142135623730951])
      >>> ak.std(a,axis=1)
      array([1.4142135623730951 1.4142135623730951])

      :raises TypeError: Raised if pda is not a pdarray instance or ddof is not an integer
      :raises ValueError: Raised if ddof is an integer < 0
      :raises RuntimeError: Raised if there's a server-side error thrown

      .. seealso:: :py:obj:`mean`, :py:obj:`var`

      .. rubric:: Notes

      The standard deviation is the square root of the average of the squared
      deviations from the mean, i.e., ``std = sqrt(mean((x - x.mean())**2))``.

      The average squared deviation is normally calculated as
      ``x.sum() / N``, where ``N = len(x)``.  If, however, `ddof` is specified,
      the divisor ``N - ddof`` is used instead. In standard statistical
      practice, ``ddof=1`` provides an unbiased estimator of the variance
      of the infinite population. ``ddof=0`` provides a maximum likelihood
      estimate of the variance for normally distributed variables. The
      standard deviation computed in this function is the square root of
      the estimated variance, so even with ``ddof=1``, it will not be an
      unbiased estimate of the standard deviation per se.



   .. py:method:: sum(axis: Optional[Union[int, Tuple[int, Ellipsis]]] = None, keepdims: bool = False) -> Union[arkouda.numpy.dtypes.numeric_scalars, pdarray]

      Return sum of array elements along the given axis.

      :param axis: The axis or axes along which to do the operation
                   If None, the computation is done across the entire array.
      :type axis: int, Tuple[int, ...], optional, default = None
      :param keepdims: Whether to keep the singleton dimension(s) along `axis` in the result.
      :type keepdims: bool, optional, default = False

      :returns: numeric_scalars if axis is omitted, in which case operation is done over entire array
                pdarray if axis is supplied, in which case the operation is done along that axis
      :rtype: numeric_scalars or pdarray

      :raises TypeError: Raised if pda is not a pdarray instance
      :raises RuntimeError: Raised if there's a server-side error thrown

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> ak.sum(ak.array([1,2,3,4,5]))
      np.int64(15)
      >>> ak.sum(ak.array([5.5,4.5,3.5,2.5,1.5]))
      np.float64(17.5)
      >>> ak.array([[1,2,3],[5,4,3]]).sum(axis=1)
      array([6 12])

      .. rubric:: Notes

      Works as a method of a pdarray (e.g. a.sum()) or a standalone function (e.g. ak.sum(a))



   .. py:method:: to_csv(prefix_path: str, dataset: str = 'array', col_delim: str = ',', overwrite: bool = False)

      Write pdarry to CSV file(s).  File will contain a single column
      with the pdarray data.  All CSV files written by Arkouda include
      a header denoting data types of the columns.

      :param prefix_path: filename prefix to be used for saving files.  Files will have
                          _LOCALE#### appended when they are written to disk.
      :type prefix_path: str
      :param dataset: column name to save the pdarray under.
      :type dataset: str, defaults to "array"
      :param col_delim: value to be used to separate columns within the file.  Please
                        be sure that the value used DOES NOT appear in your dataset.
      :type col_delim: str, defaults to ","
      :param overwrite: If True, existing files matching the provided path will be overwritten.
                        if False and existing files are found, an error will be returned.
      :type overwrite: bool, defaults to False

      :returns: **response message**
      :rtype: str

      :raises ValueError: Raised if all datasets are not present in all parquet files or if one
          or more of the specified files do not exist
      :raises RuntimeError: Raised if one or more of the specified files cannot be opened.
          if 'allow_errors' is true, this may be raised if no values are returned
          from the server.
      :raises TypeError: Raise if the server returns an unknown arkouda_type

      .. rubric:: Notes

      - CSV format is not currently supported by load/load_all operations
      - The column delimiter is expected to be the same for all column names and data
      - Be sure that column delimiters are not found within your data.
      - All CSV files must delimit rows using newline ("\n") at this time.



   .. py:method:: to_cuda()

      Convert the array to a Numba DeviceND array, transferring array data from the
      arkouda server to Python via ndarray. If the array exceeds a builtin size limit,
      a RuntimeError is raised.

      :returns: A Numba ndarray with the same attributes and data as the pdarray; on GPU
      :rtype: numba.DeviceNDArray

      :raises ImportError: Raised if CUDA is not available
      :raises ModuleNotFoundError: Raised if Numba is either not installed or not enabled
      :raises RuntimeError: Raised if there is a server-side error thrown in the course of retrieving
          the pdarray.

      .. rubric:: Notes

      The number of bytes in the array cannot exceed ``client.maxTransferBytes``,
      otherwise a ``RuntimeError`` will be raised. This is to protect the user
      from overflowing the memory of the system on which the Python client
      is running, under the assumption that the server is running on a
      distributed system with much more memory than the client. The user
      may override this limit by setting client.maxTransferBytes to a larger
      value, but proceed with caution.

      .. seealso:: :py:obj:`array`

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> a = ak.arange(0, 5, 1)
      >>> a.to_cuda() # doctest: +SKIP
      array([0, 1, 2, 3, 4])
      >>> type(a.to_cuda()) # doctest: +SKIP
      numpy.devicendarray



   .. py:method:: to_hdf(prefix_path: str, dataset: str = 'array', mode: str = 'truncate', file_type: str = 'distribute') -> str

      Save the pdarray to HDF5.
      The object can be saved to a collection of files or single file.

      :param prefix_path: Directory and filename prefix that all output files share
      :type prefix_path: str
      :param dataset: Name of the dataset to create in files (must not already exist)
      :type dataset: str
      :param mode: By default, truncate (overwrite) output files, if they exist.
                   If 'append', attempt to create new dataset in existing files.
      :type mode: str {'truncate' | 'append'}
      :param file_type: Default: "distribute"
                        When set to single, dataset is written to a single file.
                        When distribute, dataset is written on a file per locale.
                        This is only supported by HDF5 files and will have no impact of Parquet Files.
      :type file_type: str ("single" | "distribute")

      :rtype: string message indicating result of save operation

      :raises RuntimeError: Raised if a server-side error is thrown saving the pdarray

      .. rubric:: Notes

      - The prefix_path must be visible to the arkouda server and the user must
      have write permission.
      - Output files have names of the form ``<prefix_path>_LOCALE<i>``, where ``<i>``
      ranges from 0 to ``numLocales`` for `file_type='distribute'`. Otherwise,
      the file name will be `prefix_path`.
      - If any of the output files already exist and
      the mode is 'truncate', they will be overwritten. If the mode is 'append'
      and the number of output files is less than the number of locales or a
      dataset with the same name already exists, a ``RuntimeError`` will result.
      - Any file extension can be used.The file I/O does not rely on the extension to
      determine the file format.

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> a = ak.arange(25)

      Saving without an extension
      >>> a.to_hdf('path/prefix', dataset='array') # doctest: +SKIP
      Saves the array to numLocales HDF5 files with the name ``cwd/path/name_prefix_LOCALE####``

      Saving with an extension (HDF5)
      >>> a.to_hdf('path/prefix.h5', dataset='array') # doctest: +SKIP
      Saves the array to numLocales HDF5 files with the name
      ``cwd/path/name_prefix_LOCALE####.h5`` where #### is replaced by each locale number

      Saving to a single file
      >>> a.to_hdf('path/prefix.hdf5', dataset='array', file_type='single') # doctest: +SKIP
      Saves the array in to single hdf5 file on the root node.
      ``cwd/path/name_prefix.hdf5``



   .. py:method:: to_list() -> List[arkouda.numpy.dtypes.numeric_scalars]

      Convert the array to a list, transferring array data from the
      Arkouda server to client-side Python. Note: if the pdarray size exceeds
      client.maxTransferBytes, a RuntimeError is raised.

      :returns: A list with the same data as the pdarray
      :rtype: List[numeric_scalars]

      :raises RuntimeError: Raised if there is a server-side error thrown, if the pdarray size
          exceeds the built-in client.maxTransferBytes size limit, or if the bytes
          received does not match expected number of bytes

      .. rubric:: Notes

      The number of bytes in the array cannot exceed ``client.maxTransferBytes``,
      otherwise a ``RuntimeError`` will be raised. This is to protect the user
      from overflowing the memory of the system on which the Python client
      is running, under the assumption that the server is running on a
      distributed system with much more memory than the client. The user
      may override this limit by setting client.maxTransferBytes to a larger
      value, but proceed with caution.

      .. seealso:: :py:obj:`to_ndarray`

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> a = ak.arange(0, 5, 1)
      >>> a.to_list()
      [0, 1, 2, 3, 4]
      >>> type(a.to_list())
      <class 'list'>



   .. py:method:: to_ndarray() -> numpy.ndarray

      Convert the array to a np.ndarray, transferring array data from the
      Arkouda server to client-side Python. Note: if the pdarray size exceeds
      client.maxTransferBytes, a RuntimeError is raised.

      :returns: A numpy ndarray with the same attributes and data as the pdarray
      :rtype: np.ndarray

      :raises RuntimeError: Raised if there is a server-side error thrown, if the pdarray size
          exceeds the built-in client.maxTransferBytes size limit, or if the bytes
          received does not match expected number of bytes

      .. rubric:: Notes

      The number of bytes in the array cannot exceed ``client.maxTransferBytes``,
      otherwise a ``RuntimeError`` will be raised. This is to protect the user
      from overflowing the memory of the system on which the Python client
      is running, under the assumption that the server is running on a
      distributed system with much more memory than the client. The user
      may override this limit by setting client.maxTransferBytes to a larger
      value, but proceed with caution.

      .. seealso:: :py:obj:`array`, :py:obj:`to_list`

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> a = ak.arange(0, 5, 1)
      >>> a.to_ndarray()
      array([0, 1, 2, 3, 4])
      >>> type(a.to_ndarray())
      <class 'numpy.ndarray'>



   .. py:method:: to_parquet(prefix_path: str, dataset: str = 'array', mode: str = 'truncate', compression: Optional[str] = None) -> str

      Save the pdarray to Parquet. The result is a collection of files,
      one file per locale of the arkouda server, where each filename starts
      with prefix_path. Each locale saves its chunk of the array to its
      corresponding file.

      :param prefix_path: Directory and filename prefix that all output files share
      :type prefix_path: str
      :param dataset: Name of the dataset to create in files (must not already exist)
      :type dataset: str
      :param mode: By default, truncate (overwrite) output files, if they exist.
                   If 'append', attempt to create new dataset in existing files.
      :type mode: str {'truncate' | 'append'}
      :param compression: (None | "snappy" | "gzip" | "brotli" | "zstd" | "lz4")
                          Sets the compression type used with Parquet files
      :type compression: str (Optional)

      :rtype: string message indicating result of save operation

      :raises RuntimeError: Raised if a server-side error is thrown saving the pdarray

      .. rubric:: Notes

      - The prefix_path must be visible to the arkouda server and the user must
      have write permission.
      - Output files have names of the form ``<prefix_path>_LOCALE<i>``, where ``<i>``
      ranges from 0 to ``numLocales`` for `file_type='distribute'`.
      - 'append' write mode is supported, but is not efficient.
      - If any of the output files already exist and
      the mode is 'truncate', they will be overwritten. If the mode is 'append'
      and the number of output files is less than the number of locales or a
      dataset with the same name already exists, a ``RuntimeError`` will result.
      - Any file extension can be used.The file I/O does not rely on the extension to
      determine the file format.

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> a = ak.arange(25)

      Saving without an extension
      >>> a.to_parquet('path/prefix', dataset='array') # doctest: +SKIP
      Saves the array to numLocales HDF5 files with the name ``cwd/path/name_prefix_LOCALE####``

      Saving with an extension (HDF5)
      >>> a.to_parqet('path/prefix.parquet', dataset='array') # doctest: +SKIP
      Saves the array to numLocales HDF5 files with the name
      ``cwd/path/name_prefix_LOCALE####.parquet`` where #### is replaced by each locale number



   .. py:method:: transfer(hostname: str, port: arkouda.numpy.dtypes.int_scalars)

      Send a pdarray to a different Arkouda server.

      :param hostname: The hostname where the Arkouda server intended to
                       receive the pdarray is running.
      :type hostname: str
      :param port: The port to send the array over. This needs to be an
                   open port (i.e., not one that the Arkouda server is
                   running on). This will open up `numLocales` ports,
                   each of which in succession, so will use ports of the
                   range {port..(port+numLocales)} (e.g., running an
                   Arkouda server of 4 nodes, port 1234 is passed as
                   `port`, Arkouda will use ports 1234, 1235, 1236,
                   and 1237 to send the array data).
                   This port much match the port passed to the call to
                   `ak.receive_array()`.
      :type port: int_scalars

      :rtype: A message indicating a complete transfer

      :raises ValueError: Raised if the op is not within the pdarray.BinOps set
      :raises TypeError: Raised if other is not a pdarray or the pdarray.dtype is not
          a supported dtype



   .. py:method:: unregister() -> None

      Unregister a pdarray in the arkouda server which was previously
      registered using register() and/or attahced to using attach()

      :raises RuntimeError: Raised if the server could not find the internal name/symbol to remove

      .. seealso:: :py:obj:`register`, :py:obj:`unregister`, :py:obj:`is_registered`, :py:obj:`unregister_pdarray_by_name`, :py:obj:`list_registry`

      .. rubric:: Notes

      Registered names/pdarrays in the server are immune to deletion until
      they are unregistered.

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> a = ak.zeros(3)
      >>> a.register("my_zeros")
      array([0.00000000000000000 0.00000000000000000 0.00000000000000000])

      potentially disconnect from server and reconnect to server
      >>> b = ak.attach("my_zeros")
      >>> b.unregister()



   .. py:method:: update_hdf(prefix_path: str, dataset: str = 'array', repack: bool = True)

      Overwrite the dataset with the name provided with this pdarray. If
      the dataset does not exist it is added

      :param prefix_path: Directory and filename prefix that all output files share
      :type prefix_path: str
      :param dataset: Name of the dataset to create in files
      :type dataset: str
      :param repack: Default: True
                     HDF5 does not release memory on delete. When True, the inaccessible
                     data (that was overwritten) is removed. When False, the data remains, but is
                     inaccessible. Setting to false will yield better performance, but will cause
                     file sizes to expand.
      :type repack: bool

      :rtype: str - success message if successful

      :raises RuntimeError: Raised if a server-side error is thrown saving the pdarray

      .. rubric:: Notes

      - If file does not contain File_Format attribute to indicate how it was saved,
        the file name is checked for _LOCALE#### to determine if it is distributed.
      - If the dataset provided does not exist, it will be added



   .. py:method:: value_counts()

      Count the occurrences of the unique values of self.

      :returns:

                unique_values : pdarray
                    The unique values, sorted in ascending order

                counts : pdarray, int64
                    The number of times the corresponding unique value occurs
      :rtype: pdarray, pdarray|int64

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> ak.array([2, 0, 2, 4, 0, 0]).value_counts()
      (array([0 2 4]), array([3 2 1]))



   .. py:method:: var(ddof: arkouda.numpy.dtypes.int_scalars = 0, axis: Optional[Union[int, Tuple[int, Ellipsis]]] = None, keepdims: Optional[bool] = False) -> Union[numpy.float64, pdarray]

      Return the variance of values in the array.

      :param ddof: "Delta Degrees of Freedom" used in calculating var
      :type ddof: int_scalars
      :param axis: The axis or axes along which to do the operation
                   If None, the computation is done across the entire array.
      :type axis: int, Tuple[int, ...], optional, default = None
      :param keepdims: Whether to keep the singleton dimension(s) along `axis` in the result.
      :type keepdims: bool, optional, default = False

      :returns: The scalar variance of the array, or the variance along the axis/axes
                if supplied
      :rtype: Union[np.float64, pdarray]

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> a = ak.arange(10)
      >>> ak.var(a)
      np.float64(8.25)
      >>> a.var()
      np.float64(8.25)
      >>> a = ak.arange(10).reshape(2,5)
      >>> a.var(axis=0)
      array([6.25 6.25 6.25 6.25 6.25])
      >>> ak.var(a,axis=0)
      array([6.25 6.25 6.25 6.25 6.25])
      >>> a.var(axis=1)
      array([2.00000000000000000 2.00000000000000000])
      >>> ak.var(a,axis=1)
      array([2.00000000000000000 2.00000000000000000])

      :raises TypeError: Raised if pda is not a pdarray instance
      :raises ValueError: Raised if the ddof >= pdarray size
      :raises RuntimeError: Raised if there's a server-side error thrown

      .. seealso:: :py:obj:`mean`, :py:obj:`std`

      .. rubric:: Notes

      The variance is the average of the squared deviations from the mean,
      i.e.,  ``var = mean((x - x.mean())**2)``.

      The mean is normally calculated as ``x.sum() / N``, where ``N = len(x)``.
      If, however, `ddof` is specified, the divisor ``N - ddof`` is used
      instead.  In standard statistical practice, ``ddof=1`` provides an
      unbiased estimator of the variance of a hypothetical infinite population.
      ``ddof=0`` provides a maximum likelihood estimate of the variance for
      normally distributed variables.



.. py:class:: str_scalars

   Bases: :py:obj:`_NotIterable`


   Mixin to prevent iteration, without being compatible with Iterable.

   That is, we could do::

       def __iter__(self): raise TypeError()

   But this would make users of this mixin duck type-compatible with
   collections.abc.Iterable - isinstance(foo, Iterable) would be True.

   Luckily, we can instead prevent iteration by setting __iter__ to None, which
   is treated specially.


   .. py:method:: copy_with(params)


