arkouda.pandas
==============

.. py:module:: arkouda.pandas


Submodules
----------

.. toctree::
   :maxdepth: 1

   /autoapi/arkouda/pandas/categorical/index
   /autoapi/arkouda/pandas/dataframe/index
   /autoapi/arkouda/pandas/extension/index
   /autoapi/arkouda/pandas/groupbyclass/index
   /autoapi/arkouda/pandas/index/index
   /autoapi/arkouda/pandas/io/index
   /autoapi/arkouda/pandas/io_util/index
   /autoapi/arkouda/pandas/join/index
   /autoapi/arkouda/pandas/match/index
   /autoapi/arkouda/pandas/matcher/index
   /autoapi/arkouda/pandas/row/index
   /autoapi/arkouda/pandas/series/index


Classes
-------

.. autoapisummary::

   arkouda.pandas.ArkoudaArray
   arkouda.pandas.ArkoudaBigintDtype
   arkouda.pandas.ArkoudaBoolDtype
   arkouda.pandas.ArkoudaCategoricalArray
   arkouda.pandas.ArkoudaCategoricalDtype
   arkouda.pandas.ArkoudaFloat64Dtype
   arkouda.pandas.ArkoudaInt64Dtype
   arkouda.pandas.ArkoudaStringArray
   arkouda.pandas.ArkoudaStringDtype
   arkouda.pandas.ArkoudaUint64Dtype
   arkouda.pandas.ArkoudaUint8Dtype
   arkouda.pandas.Row
   arkouda.pandas.Series


Functions
---------

.. autoapisummary::

   arkouda.pandas.compute_join_size
   arkouda.pandas.gen_ranges
   arkouda.pandas.join_on_eq_with_dt


Package Contents
----------------

.. py:class:: ArkoudaArray(data)

   Bases: :py:obj:`arkouda.pandas.extension._arkouda_extension_array.ArkoudaExtensionArray`, :py:obj:`pandas.api.extensions.ExtensionArray`


   Abstract base class for custom 1-D array types.

   pandas will recognize instances of this class as proper arrays
   with a custom type and will not attempt to coerce them to objects. They
   may be stored directly inside a :class:`DataFrame` or :class:`Series`.

   .. attribute:: dtype



   .. attribute:: nbytes



   .. attribute:: ndim



   .. attribute:: shape



   .. method:: argsort

   .. method:: astype

   .. method:: copy

   .. method:: dropna

   .. method:: duplicated

   .. method:: factorize

   .. method:: fillna

   .. method:: equals

   .. method:: insert

   .. method:: interpolate

   .. method:: isin

   .. method:: isna

   .. method:: ravel

   .. method:: repeat

   .. method:: searchsorted

   .. method:: shift

   .. method:: take

   .. method:: tolist

   .. method:: unique

   .. method:: view

   .. method:: _accumulate

   .. method:: _concat_same_type

   .. method:: _explode

   .. method:: _formatter

   .. method:: _from_factorized

   .. method:: _from_sequence

   .. method:: _from_sequence_of_strings

   .. method:: _hash_pandas_object

   .. method:: _pad_or_backfill

   .. method:: _reduce

   .. method:: _values_for_argsort

   .. method:: _values_for_factorize



   .. rubric:: Notes

   The interface includes the following abstract methods that must be
   implemented by subclasses:

   * _from_sequence
   * _from_factorized
   * __getitem__
   * __len__
   * __eq__
   * dtype
   * nbytes
   * isna
   * take
   * copy
   * _concat_same_type
   * interpolate

   A default repr displaying the type, (truncated) data, length,
   and dtype is provided. It can be customized or replaced by
   by overriding:

   * __repr__ : A default repr for the ExtensionArray.
   * _formatter : Print scalars inside a Series or DataFrame.

   Some methods require casting the ExtensionArray to an ndarray of Python
   objects with ``self.astype(object)``, which may be expensive. When
   performance is a concern, we highly recommend overriding the following
   methods:

   * fillna
   * _pad_or_backfill
   * dropna
   * unique
   * factorize / _values_for_factorize
   * argsort, argmax, argmin / _values_for_argsort
   * searchsorted
   * map

   The remaining methods implemented on this class should be performant,
   as they only compose abstract methods. Still, a more efficient
   implementation may be available, and these methods can be overridden.

   One can implement methods to handle array accumulations or reductions.

   * _accumulate
   * _reduce

   One can implement methods to handle parsing from strings that will be used
   in methods such as ``pandas.io.parsers.read_csv``.

   * _from_sequence_of_strings

   This class does not inherit from 'abc.ABCMeta' for performance reasons.
   Methods and properties required by the interface raise
   ``pandas.errors.AbstractMethodError`` and no ``register`` method is
   provided for registering virtual subclasses.

   ExtensionArrays are limited to 1 dimension.

   They may be backed by none, one, or many NumPy arrays. For example,
   ``pandas.Categorical`` is an extension array backed by two arrays,
   one for codes and one for categories. An array of IPv6 address may
   be backed by a NumPy structured array with two fields, one for the
   lower 64 bits and one for the upper 64 bits. Or they may be backed
   by some other storage type, like Python lists. Pandas makes no
   assumptions on how the data are stored, just that it can be converted
   to a NumPy array.
   The ExtensionArray interface does not impose any rules on how this data
   is stored. However, currently, the backing data cannot be stored in
   attributes called ``.values`` or ``._values`` to ensure full compatibility
   with pandas internals. But other names as ``.data``, ``._data``,
   ``._items``, ... can be freely used.

   If implementing NumPy's ``__array_ufunc__`` interface, pandas expects
   that

   1. You defer by returning ``NotImplemented`` when any Series are present
      in `inputs`. Pandas will extract the arrays and call the ufunc again.
   2. You define a ``_HANDLED_TYPES`` tuple as an attribute on the class.
      Pandas inspect this to determine whether the ufunc is valid for the
      types present.

   See :ref:`extending.extension.ufunc` for more.

   By default, ExtensionArrays are not hashable.  Immutable subclasses may
   override this behavior.

   .. rubric:: Examples

   Please see the following:

   https://github.com/pandas-dev/pandas/blob/main/pandas/tests/extension/list/array.py


   .. py:method:: astype(dtype, copy: bool = False)

      Cast to a NumPy array or ExtensionArray with 'dtype'.

      :param dtype: Typecode or data-type to which the array is cast.
      :type dtype: str or dtype
      :param copy: Whether to copy the data, even if not necessary. If False,
                   a copy is made only if the old dtype does not match the
                   new dtype.
      :type copy: bool, default True

      :returns: An ``ExtensionArray`` if ``dtype`` is ``ExtensionDtype``,
                otherwise a Numpy ndarray with ``dtype`` for its dtype.
      :rtype: np.ndarray or pandas.api.extensions.ExtensionArray

      .. rubric:: Examples

      >>> arr = pd.array([1, 2, 3])
      >>> arr
      <IntegerArray>
      [1, 2, 3]
      Length: 3, dtype: Int64

      Casting to another ``ExtensionDtype`` returns an ``ExtensionArray``:

      >>> arr1 = arr.astype('Float64')
      >>> arr1
      <FloatingArray>
      [1.0, 2.0, 3.0]
      Length: 3, dtype: Float64
      >>> arr1.dtype
      Float64Dtype()

      Otherwise, we will get a Numpy ndarray:

      >>> arr2 = arr.astype('float64')
      >>> arr2
      array([1., 2., 3.])
      >>> arr2.dtype
      dtype('float64')



   .. py:method:: copy()

      Return a copy of the array.

      :rtype: ExtensionArray

      .. rubric:: Examples

      >>> arr = pd.array([1, 2, 3])
      >>> arr2 = arr.copy()
      >>> arr[0] = 2
      >>> arr2
      <IntegerArray>
      [1, 2, 3]
      Length: 3, dtype: Int64



   .. py:attribute:: default_fill_value
      :value: -1



   .. py:property:: dtype

      An instance of ExtensionDtype.

      .. rubric:: Examples

      >>> pd.array([1, 2, 3]).dtype
      Int64Dtype()


   .. py:method:: equals(other)

      Return if another array is equivalent to this array.

      Equivalent means that both arrays have the same shape and dtype, and
      all values compare equal. Missing values in the same location are
      considered equal (in contrast with normal equality).

      :param other: Array to compare to this Array.
      :type other: ExtensionArray

      :returns: Whether the arrays are equivalent.
      :rtype: boolean

      .. rubric:: Examples

      >>> arr1 = pd.array([1, 2, np.nan])
      >>> arr2 = pd.array([1, 2, np.nan])
      >>> arr1.equals(arr2)
      True



   .. py:method:: factorize(*, sort=False, use_na_sentinel=True, **kwargs)

      Encode the extension array as an enumerated type.

      :param use_na_sentinel: If True, the sentinel -1 will be used for NaN values. If False,
                              NaN values will be encoded as non-negative integers and will not drop the
                              NaN from the uniques of the values.

                              .. versionadded:: 1.5.0
      :type use_na_sentinel: bool, default True

      :returns: * **codes** (*ndarray*) -- An integer NumPy array that's an indexer into the original
                  ExtensionArray.
                * **uniques** (*ExtensionArray*) -- An ExtensionArray containing the unique values of `self`.

                  .. note::

                     uniques will *not* contain an entry for the NA value of
                     the ExtensionArray if there are any missing values present
                     in `self`.

      .. seealso::

         :py:obj:`factorize`
             Top-level factorize method that dispatches here.

      .. rubric:: Notes

      :meth:`pandas.factorize` offers a `sort` keyword as well.

      .. rubric:: Examples

      >>> idx1 = pd.PeriodIndex(["2014-01", "2014-01", "2014-02", "2014-02",
      ...                       "2014-03", "2014-03"], freq="M")
      >>> arr, idx = idx1.factorize()
      >>> arr
      array([0, 0, 1, 1, 2, 2])
      >>> idx
      PeriodIndex(['2014-01', '2014-02', '2014-03'], dtype='period[M]')



   .. py:method:: isna() -> pandas.api.extensions.ExtensionArray | numpy.ndarray[Any, Any]

      A 1-D array indicating if each value is missing.

      :returns: In most cases, this should return a NumPy ndarray. For
                exceptional cases like ``SparseArray``, where returning
                an ndarray would be expensive, an ExtensionArray may be
                returned.
      :rtype: numpy.ndarray or pandas.api.extensions.ExtensionArray

      .. rubric:: Notes

      If returning an ExtensionArray, then

      * ``na_values._is_boolean`` should be True
      * `na_values` should implement :func:`ExtensionArray._reduce`
      * ``na_values.any`` and ``na_values.all`` should be implemented

      .. rubric:: Examples

      >>> arr = pd.array([1, 2, np.nan, np.nan])
      >>> arr.isna()
      array([False, False,  True,  True])



   .. py:property:: nbytes

      The number of bytes needed to store this object in memory.

      .. rubric:: Examples

      >>> pd.array([1, 2, 3]).nbytes
      27


.. py:class:: ArkoudaBigintDtype

   Bases: :py:obj:`_ArkoudaBaseDtype`


   Arkouda-backed arbitrary-precision integer dtype.

   This dtype integrates Arkouda's server-backed ``pdarray<bigint>`` with
   the pandas ExtensionArray interface via :class:`ArkoudaArray`. It enables
   pandas objects (Series, DataFrame) to hold and operate on very large
   integers that exceed 64-bit precision, while keeping the data distributed
   on the Arkouda server.

   .. method:: construct_array_type()

      Returns the :class:`ArkoudaArray` class used for storage.



   .. py:method:: construct_array_type()
      :classmethod:


      Return the ExtensionArray subclass that handles storage for this dtype.

      :returns: The :class:`ArkoudaArray` class associated with this dtype.
      :rtype: type



   .. py:attribute:: kind
      :value: 'O'


      A character code (one of 'biufcmMOSUV'), default 'O'

      This should match the NumPy dtype used when the array is
      converted to an ndarray, which is probably 'O' for object if
      the extension type cannot be represented as a built-in NumPy
      type.

      .. seealso:: :py:obj:`numpy.dtype.kind`


   .. py:attribute:: na_value
      :value: -1


      Default NA value to use for this type.

      This is used in e.g. ExtensionArray.take. This should be the
      user-facing "boxed" version of the NA value, not the physical NA value
      for storage.  e.g. for JSONArray, this is an empty dictionary.


   .. py:attribute:: name
      :value: 'bigint'


      A string identifying the data type.

      Will be used for display in, e.g. ``Series.dtype``


   .. py:attribute:: type

      The scalar type for the array, e.g. ``int``

      It's expected ``ExtensionArray[item]`` returns an instance
      of ``ExtensionDtype.type`` for scalar ``item``, assuming
      that value is valid (not NA). NA values do not need to be
      instances of `type`.


.. py:class:: ArkoudaBoolDtype

   Bases: :py:obj:`_ArkoudaBaseDtype`


   Arkouda-backed boolean dtype.

   This dtype integrates Arkouda's server-backed `pdarray<bool>` with
   the pandas ExtensionArray interface via :class:`ArkoudaArray`. It allows
   pandas objects (Series, DataFrame) to store and manipulate distributed
   boolean arrays without materializing them on the client.

   .. method:: construct_array_type()

      Returns the :class:`ArkoudaArray` class used for storage.



   .. py:method:: construct_array_type()
      :classmethod:


      Return the ExtensionArray subclass that handles storage for this dtype.

      :returns: The :class:`ArkoudaArray` class associated with this dtype.
      :rtype: type



   .. py:attribute:: kind
      :value: 'b'


      A character code (one of 'biufcmMOSUV'), default 'O'

      This should match the NumPy dtype used when the array is
      converted to an ndarray, which is probably 'O' for object if
      the extension type cannot be represented as a built-in NumPy
      type.

      .. seealso:: :py:obj:`numpy.dtype.kind`


   .. py:attribute:: na_value
      :value: False


      Default NA value to use for this type.

      This is used in e.g. ExtensionArray.take. This should be the
      user-facing "boxed" version of the NA value, not the physical NA value
      for storage.  e.g. for JSONArray, this is an empty dictionary.


   .. py:attribute:: name
      :value: 'bool_'


      A string identifying the data type.

      Will be used for display in, e.g. ``Series.dtype``


   .. py:attribute:: type

      The scalar type for the array, e.g. ``int``

      It's expected ``ExtensionArray[item]`` returns an instance
      of ``ExtensionDtype.type`` for scalar ``item``, assuming
      that value is valid (not NA). NA values do not need to be
      instances of `type`.


.. py:class:: ArkoudaCategoricalArray(data)

   Bases: :py:obj:`arkouda.pandas.extension._arkouda_extension_array.ArkoudaExtensionArray`, :py:obj:`pandas.api.extensions.ExtensionArray`


   Abstract base class for custom 1-D array types.

   pandas will recognize instances of this class as proper arrays
   with a custom type and will not attempt to coerce them to objects. They
   may be stored directly inside a :class:`DataFrame` or :class:`Series`.

   .. attribute:: dtype



   .. attribute:: nbytes



   .. attribute:: ndim



   .. attribute:: shape



   .. method:: argsort

   .. method:: astype

   .. method:: copy

   .. method:: dropna

   .. method:: duplicated

   .. method:: factorize

   .. method:: fillna

   .. method:: equals

   .. method:: insert

   .. method:: interpolate

   .. method:: isin

   .. method:: isna

   .. method:: ravel

   .. method:: repeat

   .. method:: searchsorted

   .. method:: shift

   .. method:: take

   .. method:: tolist

   .. method:: unique

   .. method:: view

   .. method:: _accumulate

   .. method:: _concat_same_type

   .. method:: _explode

   .. method:: _formatter

   .. method:: _from_factorized

   .. method:: _from_sequence

   .. method:: _from_sequence_of_strings

   .. method:: _hash_pandas_object

   .. method:: _pad_or_backfill

   .. method:: _reduce

   .. method:: _values_for_argsort

   .. method:: _values_for_factorize



   .. rubric:: Notes

   The interface includes the following abstract methods that must be
   implemented by subclasses:

   * _from_sequence
   * _from_factorized
   * __getitem__
   * __len__
   * __eq__
   * dtype
   * nbytes
   * isna
   * take
   * copy
   * _concat_same_type
   * interpolate

   A default repr displaying the type, (truncated) data, length,
   and dtype is provided. It can be customized or replaced by
   by overriding:

   * __repr__ : A default repr for the ExtensionArray.
   * _formatter : Print scalars inside a Series or DataFrame.

   Some methods require casting the ExtensionArray to an ndarray of Python
   objects with ``self.astype(object)``, which may be expensive. When
   performance is a concern, we highly recommend overriding the following
   methods:

   * fillna
   * _pad_or_backfill
   * dropna
   * unique
   * factorize / _values_for_factorize
   * argsort, argmax, argmin / _values_for_argsort
   * searchsorted
   * map

   The remaining methods implemented on this class should be performant,
   as they only compose abstract methods. Still, a more efficient
   implementation may be available, and these methods can be overridden.

   One can implement methods to handle array accumulations or reductions.

   * _accumulate
   * _reduce

   One can implement methods to handle parsing from strings that will be used
   in methods such as ``pandas.io.parsers.read_csv``.

   * _from_sequence_of_strings

   This class does not inherit from 'abc.ABCMeta' for performance reasons.
   Methods and properties required by the interface raise
   ``pandas.errors.AbstractMethodError`` and no ``register`` method is
   provided for registering virtual subclasses.

   ExtensionArrays are limited to 1 dimension.

   They may be backed by none, one, or many NumPy arrays. For example,
   ``pandas.Categorical`` is an extension array backed by two arrays,
   one for codes and one for categories. An array of IPv6 address may
   be backed by a NumPy structured array with two fields, one for the
   lower 64 bits and one for the upper 64 bits. Or they may be backed
   by some other storage type, like Python lists. Pandas makes no
   assumptions on how the data are stored, just that it can be converted
   to a NumPy array.
   The ExtensionArray interface does not impose any rules on how this data
   is stored. However, currently, the backing data cannot be stored in
   attributes called ``.values`` or ``._values`` to ensure full compatibility
   with pandas internals. But other names as ``.data``, ``._data``,
   ``._items``, ... can be freely used.

   If implementing NumPy's ``__array_ufunc__`` interface, pandas expects
   that

   1. You defer by returning ``NotImplemented`` when any Series are present
      in `inputs`. Pandas will extract the arrays and call the ufunc again.
   2. You define a ``_HANDLED_TYPES`` tuple as an attribute on the class.
      Pandas inspect this to determine whether the ufunc is valid for the
      types present.

   See :ref:`extending.extension.ufunc` for more.

   By default, ExtensionArrays are not hashable.  Immutable subclasses may
   override this behavior.

   .. rubric:: Examples

   Please see the following:

   https://github.com/pandas-dev/pandas/blob/main/pandas/tests/extension/list/array.py


   .. py:method:: astype(x, dtype)
      :abstractmethod:


      Cast to a NumPy array or ExtensionArray with 'dtype'.

      :param dtype: Typecode or data-type to which the array is cast.
      :type dtype: str or dtype
      :param copy: Whether to copy the data, even if not necessary. If False,
                   a copy is made only if the old dtype does not match the
                   new dtype.
      :type copy: bool, default True

      :returns: An ``ExtensionArray`` if ``dtype`` is ``ExtensionDtype``,
                otherwise a Numpy ndarray with ``dtype`` for its dtype.
      :rtype: np.ndarray or pandas.api.extensions.ExtensionArray

      .. rubric:: Examples

      >>> arr = pd.array([1, 2, 3])
      >>> arr
      <IntegerArray>
      [1, 2, 3]
      Length: 3, dtype: Int64

      Casting to another ``ExtensionDtype`` returns an ``ExtensionArray``:

      >>> arr1 = arr.astype('Float64')
      >>> arr1
      <FloatingArray>
      [1.0, 2.0, 3.0]
      Length: 3, dtype: Float64
      >>> arr1.dtype
      Float64Dtype()

      Otherwise, we will get a Numpy ndarray:

      >>> arr2 = arr.astype('float64')
      >>> arr2
      array([1., 2., 3.])
      >>> arr2.dtype
      dtype('float64')



   .. py:method:: copy()

      Return a copy of the array.

      :rtype: ExtensionArray

      .. rubric:: Examples

      >>> arr = pd.array([1, 2, 3])
      >>> arr2 = arr.copy()
      >>> arr[0] = 2
      >>> arr2
      <IntegerArray>
      [1, 2, 3]
      Length: 3, dtype: Int64



   .. py:attribute:: default_fill_value
      :type:  str
      :value: ''



   .. py:property:: dtype

      An instance of ExtensionDtype.

      .. rubric:: Examples

      >>> pd.array([1, 2, 3]).dtype
      Int64Dtype()


   .. py:method:: factorize(*, sort=False, use_na_sentinel=True, **kwargs)

      Encode the extension array as an enumerated type.

      :param use_na_sentinel: If True, the sentinel -1 will be used for NaN values. If False,
                              NaN values will be encoded as non-negative integers and will not drop the
                              NaN from the uniques of the values.

                              .. versionadded:: 1.5.0
      :type use_na_sentinel: bool, default True

      :returns: * **codes** (*ndarray*) -- An integer NumPy array that's an indexer into the original
                  ExtensionArray.
                * **uniques** (*ExtensionArray*) -- An ExtensionArray containing the unique values of `self`.

                  .. note::

                     uniques will *not* contain an entry for the NA value of
                     the ExtensionArray if there are any missing values present
                     in `self`.

      .. seealso::

         :py:obj:`factorize`
             Top-level factorize method that dispatches here.

      .. rubric:: Notes

      :meth:`pandas.factorize` offers a `sort` keyword as well.

      .. rubric:: Examples

      >>> idx1 = pd.PeriodIndex(["2014-01", "2014-01", "2014-02", "2014-02",
      ...                       "2014-03", "2014-03"], freq="M")
      >>> arr, idx = idx1.factorize()
      >>> arr
      array([0, 0, 1, 1, 2, 2])
      >>> idx
      PeriodIndex(['2014-01', '2014-02', '2014-03'], dtype='period[M]')



   .. py:method:: isna()

      A 1-D array indicating if each value is missing.

      :returns: In most cases, this should return a NumPy ndarray. For
                exceptional cases like ``SparseArray``, where returning
                an ndarray would be expensive, an ExtensionArray may be
                returned.
      :rtype: numpy.ndarray or pandas.api.extensions.ExtensionArray

      .. rubric:: Notes

      If returning an ExtensionArray, then

      * ``na_values._is_boolean`` should be True
      * `na_values` should implement :func:`ExtensionArray._reduce`
      * ``na_values.any`` and ``na_values.all`` should be implemented

      .. rubric:: Examples

      >>> arr = pd.array([1, 2, np.nan, np.nan])
      >>> arr.isna()
      array([False, False,  True,  True])



.. py:class:: ArkoudaCategoricalDtype

   Bases: :py:obj:`_ArkoudaBaseDtype`


   Arkouda-backed categorical dtype.

   This dtype integrates Arkouda's distributed ``Categorical`` type with
   the pandas ExtensionArray interface via :class:`ArkoudaCategoricalArray`.
   It enables pandas objects (Series, DataFrame) to hold categorical data
   stored and processed on the Arkouda server, while exposing familiar
   pandas APIs.

   .. method:: construct_array_type()

      Returns the :class:`ArkoudaCategoricalArray` used as the storage class.



   .. py:method:: construct_array_type()
      :classmethod:


      Return the ExtensionArray subclass that handles storage for this dtype.

      :returns: The :class:`ArkoudaCategoricalArray` class associated with this dtype.
      :rtype: type



   .. py:attribute:: kind
      :value: 'O'


      A character code (one of 'biufcmMOSUV'), default 'O'

      This should match the NumPy dtype used when the array is
      converted to an ndarray, which is probably 'O' for object if
      the extension type cannot be represented as a built-in NumPy
      type.

      .. seealso:: :py:obj:`numpy.dtype.kind`


   .. py:attribute:: na_value
      :value: -1


      Default NA value to use for this type.

      This is used in e.g. ExtensionArray.take. This should be the
      user-facing "boxed" version of the NA value, not the physical NA value
      for storage.  e.g. for JSONArray, this is an empty dictionary.


   .. py:attribute:: name
      :value: 'category'


      A string identifying the data type.

      Will be used for display in, e.g. ``Series.dtype``


   .. py:attribute:: type

      The scalar type for the array, e.g. ``int``

      It's expected ``ExtensionArray[item]`` returns an instance
      of ``ExtensionDtype.type`` for scalar ``item``, assuming
      that value is valid (not NA). NA values do not need to be
      instances of `type`.


.. py:class:: ArkoudaFloat64Dtype

   Bases: :py:obj:`_ArkoudaBaseDtype`


   Arkouda-backed 64-bit floating-point dtype.

   This dtype integrates Arkouda's server-backed `pdarray<float64>` with
   the pandas ExtensionArray interface via :class:`ArkoudaArray`. It allows
   pandas objects (Series, DataFrame) to store and manipulate large
   distributed float64 arrays without materializing them on the client.

   .. method:: construct_array_type()

      Returns the :class:`ArkoudaArray` class used for storage.



   .. py:method:: construct_array_type()
      :classmethod:


      Return the ExtensionArray subclass that handles storage for this dtype.

      :returns: The :class:`ArkoudaArray` class associated with this dtype.
      :rtype: type



   .. py:attribute:: kind
      :value: 'f'


      A character code (one of 'biufcmMOSUV'), default 'O'

      This should match the NumPy dtype used when the array is
      converted to an ndarray, which is probably 'O' for object if
      the extension type cannot be represented as a built-in NumPy
      type.

      .. seealso:: :py:obj:`numpy.dtype.kind`


   .. py:attribute:: na_value

      Default NA value to use for this type.

      This is used in e.g. ExtensionArray.take. This should be the
      user-facing "boxed" version of the NA value, not the physical NA value
      for storage.  e.g. for JSONArray, this is an empty dictionary.


   .. py:attribute:: name
      :value: 'float64'


      A string identifying the data type.

      Will be used for display in, e.g. ``Series.dtype``


   .. py:attribute:: type

      The scalar type for the array, e.g. ``int``

      It's expected ``ExtensionArray[item]`` returns an instance
      of ``ExtensionDtype.type`` for scalar ``item``, assuming
      that value is valid (not NA). NA values do not need to be
      instances of `type`.


.. py:class:: ArkoudaInt64Dtype

   Bases: :py:obj:`_ArkoudaBaseDtype`


   Extension dtype for Arkouda-backed 64-bit integers.

   This dtype allows seamless use of Arkouda's distributed ``int64``
   arrays inside pandas objects (``Series``, ``Index``, ``DataFrame``).
   It is backed by :class:`arkouda.pdarray` with ``dtype='int64'``
   and integrates with pandas via the
   :class:`~arkouda.pandas.extension._arkouda_array.ArkoudaArray`
   extension array.

   .. method:: construct_array_type()

      Return the associated extension array class
      (:class:`ArkoudaArray`).



   .. py:method:: construct_array_type()
      :classmethod:


      Return the associated pandas ExtensionArray type.

      This is part of the pandas ExtensionDtype interface and is used
      internally by pandas when constructing arrays of this dtype.
      It ensures that operations like ``Series(..., dtype=ArkoudaInt64Dtype())``
      produce the correct Arkouda-backed extension array.

      :returns: The :class:`ArkoudaArray` class that implements the storage
                and behavior for this dtype.
      :rtype: type

      .. rubric:: Notes

      - This hook tells pandas which ExtensionArray to instantiate
        whenever this dtype is requested.
      - All Arkouda dtypes defined in this module will return
        :class:`ArkoudaArray` (or a subclass thereof).

      .. rubric:: Examples

      >>> from arkouda.pandas.extension import ArkoudaInt64Dtype
      >>> ArkoudaInt64Dtype.construct_array_type()
      <class 'arkouda.pandas.extension._arkouda_array.ArkoudaArray'>



   .. py:attribute:: kind
      :value: 'i'


      A character code (one of 'biufcmMOSUV'), default 'O'

      This should match the NumPy dtype used when the array is
      converted to an ndarray, which is probably 'O' for object if
      the extension type cannot be represented as a built-in NumPy
      type.

      .. seealso:: :py:obj:`numpy.dtype.kind`


   .. py:attribute:: na_value
      :value: -1


      Default NA value to use for this type.

      This is used in e.g. ExtensionArray.take. This should be the
      user-facing "boxed" version of the NA value, not the physical NA value
      for storage.  e.g. for JSONArray, this is an empty dictionary.


   .. py:attribute:: name
      :value: 'int64'


      A string identifying the data type.

      Will be used for display in, e.g. ``Series.dtype``


   .. py:attribute:: type

      The scalar type for the array, e.g. ``int``

      It's expected ``ExtensionArray[item]`` returns an instance
      of ``ExtensionDtype.type`` for scalar ``item``, assuming
      that value is valid (not NA). NA values do not need to be
      instances of `type`.


.. py:class:: ArkoudaStringArray(data)

   Bases: :py:obj:`arkouda.pandas.extension._arkouda_extension_array.ArkoudaExtensionArray`, :py:obj:`pandas.api.extensions.ExtensionArray`


   Abstract base class for custom 1-D array types.

   pandas will recognize instances of this class as proper arrays
   with a custom type and will not attempt to coerce them to objects. They
   may be stored directly inside a :class:`DataFrame` or :class:`Series`.

   .. attribute:: dtype



   .. attribute:: nbytes



   .. attribute:: ndim



   .. attribute:: shape



   .. method:: argsort

   .. method:: astype

   .. method:: copy

   .. method:: dropna

   .. method:: duplicated

   .. method:: factorize

   .. method:: fillna

   .. method:: equals

   .. method:: insert

   .. method:: interpolate

   .. method:: isin

   .. method:: isna

   .. method:: ravel

   .. method:: repeat

   .. method:: searchsorted

   .. method:: shift

   .. method:: take

   .. method:: tolist

   .. method:: unique

   .. method:: view

   .. method:: _accumulate

   .. method:: _concat_same_type

   .. method:: _explode

   .. method:: _formatter

   .. method:: _from_factorized

   .. method:: _from_sequence

   .. method:: _from_sequence_of_strings

   .. method:: _hash_pandas_object

   .. method:: _pad_or_backfill

   .. method:: _reduce

   .. method:: _values_for_argsort

   .. method:: _values_for_factorize



   .. rubric:: Notes

   The interface includes the following abstract methods that must be
   implemented by subclasses:

   * _from_sequence
   * _from_factorized
   * __getitem__
   * __len__
   * __eq__
   * dtype
   * nbytes
   * isna
   * take
   * copy
   * _concat_same_type
   * interpolate

   A default repr displaying the type, (truncated) data, length,
   and dtype is provided. It can be customized or replaced by
   by overriding:

   * __repr__ : A default repr for the ExtensionArray.
   * _formatter : Print scalars inside a Series or DataFrame.

   Some methods require casting the ExtensionArray to an ndarray of Python
   objects with ``self.astype(object)``, which may be expensive. When
   performance is a concern, we highly recommend overriding the following
   methods:

   * fillna
   * _pad_or_backfill
   * dropna
   * unique
   * factorize / _values_for_factorize
   * argsort, argmax, argmin / _values_for_argsort
   * searchsorted
   * map

   The remaining methods implemented on this class should be performant,
   as they only compose abstract methods. Still, a more efficient
   implementation may be available, and these methods can be overridden.

   One can implement methods to handle array accumulations or reductions.

   * _accumulate
   * _reduce

   One can implement methods to handle parsing from strings that will be used
   in methods such as ``pandas.io.parsers.read_csv``.

   * _from_sequence_of_strings

   This class does not inherit from 'abc.ABCMeta' for performance reasons.
   Methods and properties required by the interface raise
   ``pandas.errors.AbstractMethodError`` and no ``register`` method is
   provided for registering virtual subclasses.

   ExtensionArrays are limited to 1 dimension.

   They may be backed by none, one, or many NumPy arrays. For example,
   ``pandas.Categorical`` is an extension array backed by two arrays,
   one for codes and one for categories. An array of IPv6 address may
   be backed by a NumPy structured array with two fields, one for the
   lower 64 bits and one for the upper 64 bits. Or they may be backed
   by some other storage type, like Python lists. Pandas makes no
   assumptions on how the data are stored, just that it can be converted
   to a NumPy array.
   The ExtensionArray interface does not impose any rules on how this data
   is stored. However, currently, the backing data cannot be stored in
   attributes called ``.values`` or ``._values`` to ensure full compatibility
   with pandas internals. But other names as ``.data``, ``._data``,
   ``._items``, ... can be freely used.

   If implementing NumPy's ``__array_ufunc__`` interface, pandas expects
   that

   1. You defer by returning ``NotImplemented`` when any Series are present
      in `inputs`. Pandas will extract the arrays and call the ufunc again.
   2. You define a ``_HANDLED_TYPES`` tuple as an attribute on the class.
      Pandas inspect this to determine whether the ufunc is valid for the
      types present.

   See :ref:`extending.extension.ufunc` for more.

   By default, ExtensionArrays are not hashable.  Immutable subclasses may
   override this behavior.

   .. rubric:: Examples

   Please see the following:

   https://github.com/pandas-dev/pandas/blob/main/pandas/tests/extension/list/array.py


   .. py:method:: astype(dtype, copy: bool = False)

      Cast to a NumPy array or ExtensionArray with 'dtype'.

      :param dtype: Typecode or data-type to which the array is cast.
      :type dtype: str or dtype
      :param copy: Whether to copy the data, even if not necessary. If False,
                   a copy is made only if the old dtype does not match the
                   new dtype.
      :type copy: bool, default True

      :returns: An ``ExtensionArray`` if ``dtype`` is ``ExtensionDtype``,
                otherwise a Numpy ndarray with ``dtype`` for its dtype.
      :rtype: np.ndarray or pandas.api.extensions.ExtensionArray

      .. rubric:: Examples

      >>> arr = pd.array([1, 2, 3])
      >>> arr
      <IntegerArray>
      [1, 2, 3]
      Length: 3, dtype: Int64

      Casting to another ``ExtensionDtype`` returns an ``ExtensionArray``:

      >>> arr1 = arr.astype('Float64')
      >>> arr1
      <FloatingArray>
      [1.0, 2.0, 3.0]
      Length: 3, dtype: Float64
      >>> arr1.dtype
      Float64Dtype()

      Otherwise, we will get a Numpy ndarray:

      >>> arr2 = arr.astype('float64')
      >>> arr2
      array([1., 2., 3.])
      >>> arr2.dtype
      dtype('float64')



   .. py:method:: copy()

      Return a copy of the array.

      :rtype: ExtensionArray

      .. rubric:: Examples

      >>> arr = pd.array([1, 2, 3])
      >>> arr2 = arr.copy()
      >>> arr[0] = 2
      >>> arr2
      <IntegerArray>
      [1, 2, 3]
      Length: 3, dtype: Int64



   .. py:attribute:: default_fill_value
      :value: ''



   .. py:property:: dtype

      An instance of ExtensionDtype.

      .. rubric:: Examples

      >>> pd.array([1, 2, 3]).dtype
      Int64Dtype()


   .. py:method:: factorize(*, sort=False, use_na_sentinel=True, **kwargs)

      Encode the extension array as an enumerated type.

      :param use_na_sentinel: If True, the sentinel -1 will be used for NaN values. If False,
                              NaN values will be encoded as non-negative integers and will not drop the
                              NaN from the uniques of the values.

                              .. versionadded:: 1.5.0
      :type use_na_sentinel: bool, default True

      :returns: * **codes** (*ndarray*) -- An integer NumPy array that's an indexer into the original
                  ExtensionArray.
                * **uniques** (*ExtensionArray*) -- An ExtensionArray containing the unique values of `self`.

                  .. note::

                     uniques will *not* contain an entry for the NA value of
                     the ExtensionArray if there are any missing values present
                     in `self`.

      .. seealso::

         :py:obj:`factorize`
             Top-level factorize method that dispatches here.

      .. rubric:: Notes

      :meth:`pandas.factorize` offers a `sort` keyword as well.

      .. rubric:: Examples

      >>> idx1 = pd.PeriodIndex(["2014-01", "2014-01", "2014-02", "2014-02",
      ...                       "2014-03", "2014-03"], freq="M")
      >>> arr, idx = idx1.factorize()
      >>> arr
      array([0, 0, 1, 1, 2, 2])
      >>> idx
      PeriodIndex(['2014-01', '2014-02', '2014-03'], dtype='period[M]')



   .. py:method:: isna()

      A 1-D array indicating if each value is missing.

      :returns: In most cases, this should return a NumPy ndarray. For
                exceptional cases like ``SparseArray``, where returning
                an ndarray would be expensive, an ExtensionArray may be
                returned.
      :rtype: numpy.ndarray or pandas.api.extensions.ExtensionArray

      .. rubric:: Notes

      If returning an ExtensionArray, then

      * ``na_values._is_boolean`` should be True
      * `na_values` should implement :func:`ExtensionArray._reduce`
      * ``na_values.any`` and ``na_values.all`` should be implemented

      .. rubric:: Examples

      >>> arr = pd.array([1, 2, np.nan, np.nan])
      >>> arr.isna()
      array([False, False,  True,  True])



.. py:class:: ArkoudaStringDtype

   Bases: :py:obj:`_ArkoudaBaseDtype`


   Arkouda-backed string dtype.

   This dtype integrates Arkouda's distributed ``Strings`` type with the
   pandas ExtensionArray interface via :class:`ArkoudaStringArray`. It
   enables pandas objects (Series, DataFrame) to hold large, server-backed
   string columns without converting to NumPy or Python objects.

   .. method:: construct_array_type()

      Returns the :class:`ArkoudaStringArray` used as the storage class.



   .. py:method:: construct_array_type()
      :classmethod:


      Return the ExtensionArray subclass that handles storage for this dtype.

      :returns: The :class:`ArkoudaStringArray` class associated with this dtype.
      :rtype: type



   .. py:attribute:: kind
      :value: 'O'


      A character code (one of 'biufcmMOSUV'), default 'O'

      This should match the NumPy dtype used when the array is
      converted to an ndarray, which is probably 'O' for object if
      the extension type cannot be represented as a built-in NumPy
      type.

      .. seealso:: :py:obj:`numpy.dtype.kind`


   .. py:attribute:: na_value
      :value: ''


      Default NA value to use for this type.

      This is used in e.g. ExtensionArray.take. This should be the
      user-facing "boxed" version of the NA value, not the physical NA value
      for storage.  e.g. for JSONArray, this is an empty dictionary.


   .. py:attribute:: name
      :value: 'string'


      A string identifying the data type.

      Will be used for display in, e.g. ``Series.dtype``


   .. py:attribute:: type

      The scalar type for the array, e.g. ``int``

      It's expected ``ExtensionArray[item]`` returns an instance
      of ``ExtensionDtype.type`` for scalar ``item``, assuming
      that value is valid (not NA). NA values do not need to be
      instances of `type`.


.. py:class:: ArkoudaUint64Dtype

   Bases: :py:obj:`_ArkoudaBaseDtype`


   Arkouda-backed unsigned 64-bit integer dtype.

   This dtype integrates Arkouda’s ``uint64`` arrays with pandas,
   allowing users to create :class:`pandas.Series` or
   :class:`pandas.DataFrame` objects that store their data on
   the Arkouda server while still conforming to the pandas
   ExtensionArray API.

   .. method:: construct_array_type()

      Return the :class:`ArkoudaArray` class used as the storage
      container for this dtype.


   .. rubric:: Examples

   >>> import arkouda as ak
   >>> import pandas as pd
   >>> from arkouda.pandas.extension import ArkoudaUint64Dtype, ArkoudaArray

   >>> arr = ArkoudaArray(ak.array([1, 2, 3], dtype="uint64"))
   >>> s = pd.Series(arr, dtype=ArkoudaUint64Dtype())
   >>> s
   0    1
   1    2
   2    3
   dtype: uint64


   .. py:method:: construct_array_type()
      :classmethod:


      Return the ExtensionArray class associated with this dtype.

      This is required by the pandas ExtensionDtype API. It tells pandas
      which :class:`~pandas.api.extensions.ExtensionArray` subclass should
      be used to hold data of this dtype inside a :class:`pandas.Series`
      or :class:`pandas.DataFrame`.

      :returns: The :class:`ArkoudaArray` class, which implements the storage
                and operations for Arkouda-backed arrays.
      :rtype: type



   .. py:attribute:: kind
      :value: 'u'


      A character code (one of 'biufcmMOSUV'), default 'O'

      This should match the NumPy dtype used when the array is
      converted to an ndarray, which is probably 'O' for object if
      the extension type cannot be represented as a built-in NumPy
      type.

      .. seealso:: :py:obj:`numpy.dtype.kind`


   .. py:attribute:: na_value
      :value: -1


      Default NA value to use for this type.

      This is used in e.g. ExtensionArray.take. This should be the
      user-facing "boxed" version of the NA value, not the physical NA value
      for storage.  e.g. for JSONArray, this is an empty dictionary.


   .. py:attribute:: name
      :value: 'uint64'


      A string identifying the data type.

      Will be used for display in, e.g. ``Series.dtype``


   .. py:attribute:: type

      The scalar type for the array, e.g. ``int``

      It's expected ``ExtensionArray[item]`` returns an instance
      of ``ExtensionDtype.type`` for scalar ``item``, assuming
      that value is valid (not NA). NA values do not need to be
      instances of `type`.


.. py:class:: ArkoudaUint8Dtype

   Bases: :py:obj:`_ArkoudaBaseDtype`


   Arkouda-backed unsigned 8-bit integer dtype.

   This dtype integrates Arkouda's ``uint8`` arrays with the pandas
   ExtensionArray API, allowing pandas ``Series`` and ``DataFrame``
   objects to store and operate on Arkouda-backed unsigned 8-bit
   integers. The underlying storage is an Arkouda ``pdarray<uint8>``,
   exposed through the :class:`ArkoudaArray` extension array.

   .. method:: construct_array_type()

      Returns the :class:`ArkoudaArray` type that provides the storage
      and behavior for this dtype.



   .. py:method:: construct_array_type()
      :classmethod:


      Return the ExtensionArray subclass that handles storage for this dtype.

      This method is required by the pandas ExtensionDtype interface.
      It tells pandas which ExtensionArray class to use when creating
      arrays of this dtype (for example, when calling
      ``Series(..., dtype="arkouda.uint8")``).

      :returns: The :class:`ArkoudaArray` class associated with this dtype.
      :rtype: type



   .. py:attribute:: kind
      :value: 'u'


      A character code (one of 'biufcmMOSUV'), default 'O'

      This should match the NumPy dtype used when the array is
      converted to an ndarray, which is probably 'O' for object if
      the extension type cannot be represented as a built-in NumPy
      type.

      .. seealso:: :py:obj:`numpy.dtype.kind`


   .. py:attribute:: na_value
      :value: -1


      Default NA value to use for this type.

      This is used in e.g. ExtensionArray.take. This should be the
      user-facing "boxed" version of the NA value, not the physical NA value
      for storage.  e.g. for JSONArray, this is an empty dictionary.


   .. py:attribute:: name
      :value: 'uint8'


      A string identifying the data type.

      Will be used for display in, e.g. ``Series.dtype``


   .. py:attribute:: type

      The scalar type for the array, e.g. ``int``

      It's expected ``ExtensionArray[item]`` returns an instance
      of ``ExtensionDtype.type`` for scalar ``item``, assuming
      that value is valid (not NA). NA values do not need to be
      instances of `type`.


.. py:class:: Row(dict=None, /, **kwargs)

   Bases: :py:obj:`collections.UserDict`


   A dictionary‐like representation of a single row in an Arkouda DataFrame.

   Wraps the column→value mapping for one row and provides convenient ASCII
   and HTML formatting for display.

   :param data: Mapping of column names to their corresponding values for this row.
   :type data: dict

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> from arkouda.row import Row
   >>> df = ak.DataFrame({'x': ak.array([10, 20]), 'y': ak.array(['a', 'b'])})

   Suppose df[0] returns {'x': 10, 'y': 'a'}
   >>> row = Row({'x': 10, 'y': 'a'})
   >>> print(row)
   keys    values
   ------  --------
   x       10
   y       a


.. py:class:: Series(data: Union[Tuple, List, arkouda.pandas.groupbyclass.groupable_element_type, Series, arkouda.numpy.segarray.SegArray, pandas.Series, pandas.Categorical], name=None, index: Optional[Union[arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.strings.Strings, Tuple, List, arkouda.pandas.index.Index]] = None)

   One-dimensional arkouda array with axis labels.

   :param index: an array of indices associated with the data array.
                 If empty, it will default to a range of ints whose size match the size of the data.
                 optional
   :type index: pdarray, Strings
   :param data: a 1D array. Must not be None.
   :type data: Tuple, List, groupable_element_type, Series, SegArray

   :raises TypeError: Raised if index is not a pdarray or Strings object
       Raised if data is not a pdarray, Strings, or Categorical object
   :raises ValueError: Raised if the index size does not match data size

   .. rubric:: Notes

   The Series class accepts either positional arguments or keyword arguments.
   If entering positional arguments,
       2 arguments entered:
           argument 1 - data
           argument 2 - index
       1 argument entered:
           argument 1 - data
   If entering 1 positional argument, it is assumed that this is the data argument.
   If only 'data' argument is passed in, Index will automatically be generated.
   If entering keywords,
       'data' (see Parameters)
       'index' (optional) must match size of 'data'


   .. py:method:: add(b: Series) -> Series


   .. py:property:: at
      :type: _LocIndexer


      Accesses entries of a Series by label.

      :returns: An indexer for label-based access to Series entries.
      :rtype: _LocIndexer


   .. py:method:: concat(arrays: List, axis: int = 0, index_labels: Union[List[str], None] = None, value_labels: Union[List[str], None] = None, ordered: bool = False) -> Union[arkouda.pandas.dataframe.DataFrame, Series]
      :staticmethod:


      Concatenate a list of Arkouda Series or grouped arrays horizontally or vertically.

      If a list of grouped Arkouda arrays is passed, they are converted to Series. Each grouping
      is a 2-tuple where the first item is the key(s) and the second is the value. If concatenating
      horizontally (axis=1), all series/groupings must have the same length and the same index.
      The index is converted to a column in the resulting DataFrame; if it's a MultiIndex,
      each level is converted to a separate column.

      :param arrays: A list of Series or groupings (tuples of index and values) to concatenate.
      :type arrays: List
      :param axis: The axis to concatenate along:
                   - 0 = vertical (stack series into one)
                   - 1 = horizontal (align by index and produce a DataFrame)
                   Defaults to 0.
      :type axis: int
      :param index_labels: Column name(s) to label the index when axis=1.
      :type index_labels: List[str] or None, optional
      :param value_labels: Column names to label the values of each Series.
      :type value_labels: List[str] or None, optional
      :param ordered: Unused parameter. Reserved for future support of deterministic
                      vs. performance-optimized concatenation. Defaults to False.
      :type ordered: bool

      :returns:

                - If axis=0: a new Series
                - If axis=1: a new DataFrame
      :rtype: Series or DataFrame



   .. py:method:: diff() -> Series

      Diffs consecutive values of the series.

      Returns a new series with the same index and length.  First value is set to NaN.



   .. py:attribute:: dt


   .. py:property:: dtype
      :type: numpy.dtype



   .. py:method:: fillna(value: Union[supported_scalars, Series, arkouda.numpy.pdarrayclass.pdarray]) -> Series

      Fill NA/NaN values using the specified method.

      :param value: Value to use to fill holes (e.g. 0), alternately a
                    Series of values specifying which value to use for
                    each index.  Values not in the Series will not be filled.
                    This value cannot be a list.
      :type value: supported_scalars, Series, or pdarray

      :returns: Object with missing values filled.
      :rtype: Series

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> from arkouda import Series
      >>> import numpy as np

      >>> data = ak.Series([1, np.nan, 3, np.nan, 5])
      >>> data
      0    1.0
      1    NaN
      2    3.0
      3    NaN
      4    5.0
      dtype: float64

      >>> fill_values1 = ak.ones(5)
      >>> data.fillna(fill_values1)
      0    1.0
      1    1.0
      2    3.0
      3    1.0
      4    5.0
      dtype: float64

      >>> fill_values2 = Series(ak.ones(5))
      >>> data.fillna(fill_values2)
      0    1.0
      1    1.0
      2    3.0
      3    1.0
      4    5.0
      dtype: float64

      >>> fill_values3 = 100.0
      >>> data.fillna(fill_values3)
      0      1.0
      1    100.0
      2      3.0
      3    100.0
      4      5.0
      dtype: float64



   .. py:method:: from_return_msg(repMsg: str) -> Series
      :classmethod:


      Return a Series instance pointing to components created by the arkouda server.

      The user should not call this function directly.

      :param repMsg:
                     + delimited string containing the values and indexes.
      :type repMsg: builtin_str

      :returns: A Series representing a set of pdarray components on the server.
      :rtype: Series

      :raises RuntimeError: Raised if a server-side error is thrown in the process of creating
          the Series instance.



   .. py:method:: has_repeat_labels() -> bool

      Return whether the Series has any labels that appear more than once.



   .. py:method:: hasnans() -> arkouda.numpy.dtypes.bool_scalars

      Return True if there are any NaNs.

      :rtype: bool

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> from arkouda import Series
      >>> import numpy as np

      >>> s = ak.Series(ak.array([1, 2, 3, np.nan]))
      >>> s
      0    1.0
      1    2.0
      2    3.0
      3    NaN
      dtype: float64

      >>> s.hasnans()
      np.True_



   .. py:method:: head(n: int = 10) -> Series

      Return the first n values of the series.



   .. py:property:: iat
      :type: _iLocIndexer


      Accesses entries of a Series by position.

      :returns: An indexer for position-based access to a single element.
      :rtype: _iLocIndexer


   .. py:property:: iloc
      :type: _iLocIndexer


      Accesses entries of a Series by position.

      :returns: An indexer for position-based access to Series entries.
      :rtype: _iLocIndexer


   .. py:method:: is_registered() -> bool

      Return True iff the object is contained in the registry or is a component of a
       registered object.

      :returns: Indicates if the object is contained in the registry
      :rtype: bool

      :raises RegistrationError: Raised if there's a server-side error or a mis-match of registered components

      .. seealso:: :py:obj:`register`, :py:obj:`attach`, :py:obj:`unregister`

      .. rubric:: Notes

      Objects registered with the server are immune to deletion until
      they are unregistered.



   .. py:method:: isin(lst: Union[arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.strings.Strings, List]) -> Series

      Find Series elements whose values are in the specified list.

      :param lst: Either a Python list or an Arkouda array to check membership against.
      :type lst: pdarray, Strings, or List

      :returns: A Series of booleans that is True for elements found in the list,
                and False otherwise.
      :rtype: Series



   .. py:method:: isna() -> Series

      Detect missing values.

      Return a boolean same-sized object indicating if the values are NA. NA values,
      such as numpy.NaN, gets mapped to True values.
      Everything else gets mapped to False values.
      Characters such as empty strings '' are not considered NA values.

      :returns: Mask of bool values for each element in Series
                that indicates whether an element is an NA value.
      :rtype: Series

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> from arkouda import Series
      >>> import numpy as np

      >>> s = Series(ak.array([1, 2, np.nan]), index = ak.array([1, 2, 4]))
      >>> s.isna()
      1    False
      2    False
      4     True
      dtype: bool



   .. py:method:: isnull() -> Series

      Series.isnull is an alias for Series.isna.

      Detect missing values.

      Return a boolean same-sized object indicating if the values are NA. NA values,
      such as numpy.NaN, gets mapped to True values.
      Everything else gets mapped to False values.
      Characters such as empty strings '' are not considered NA values.

      :returns: Mask of bool values for each element in Series
                that indicates whether an element is an NA value.
      :rtype: Series

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> from arkouda import Series
      >>> import numpy as np

      >>> s = Series(ak.array([1, 2, np.nan]), index = ak.array([1, 2, 4]))
      >>> s.isnull()
      1    False
      2    False
      4     True
      dtype: bool



   .. py:property:: loc
      :type: _LocIndexer


      Accesses entries of a Series by label.

      :returns: An indexer for label-based access to Series entries.
      :rtype: _LocIndexer


   .. py:method:: locate(key: Union[int, arkouda.numpy.pdarrayclass.pdarray, arkouda.pandas.index.Index, Series, List, Tuple]) -> Series

      Lookup values by index label.

      :param key: The key or keys to look up. This can be:
                  - A scalar
                  - A list of scalars
                  - A list of lists (for MultiIndex)
                  - A Series (in which case labels are preserved, and its values are used as keys)

                  Keys will be converted to Arkouda arrays as needed.
      :type key: int, pdarray, Index, Series, List, or Tuple

      :returns: A Series containing the values corresponding to the key.
      :rtype: Series



   .. py:method:: map(arg: Union[dict, arkouda.Series]) -> arkouda.Series

      Map values of Series according to an input mapping.

      :param arg: The mapping correspondence.
      :type arg: dict or Series

      :returns: A new series with the same index as the caller.
                When the input Series has Categorical values,
                the return Series will have Strings values.
                Otherwise, the return type will match the input type.
      :rtype: Series

      :raises TypeError: Raised if arg is not of type dict or arkouda.Series.
          Raised if series values not of type pdarray, Categorical, or Strings.

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> s = ak.Series(ak.array([2, 3, 2, 3, 4]))
      >>> s
      0    2
      1    3
      2    2
      3    3
      4    4
      dtype: int64

      >>> s.map({4: 25.0, 2: 30.0, 1: 7.0, 3: 5.0})
      0    30.0
      1     5.0
      2    30.0
      3     5.0
      4    25.0
      dtype: float64

      >>> s2 = ak.Series(ak.array(["a","b","c","d"]), index = ak.array([4,2,1,3]))
      >>> s.map(s2)
      0    b
      1    d
      2    b
      3    d
      4    a
      dtype: object



   .. py:method:: memory_usage(index: bool = True, unit: Literal['B', 'KB', 'MB', 'GB'] = 'B') -> int

      Return the memory usage of the Series.

      The memory usage can optionally include the contribution of
      the index.

      :param index: Specifies whether to include the memory usage of the Series index.
                    Defaults to True.
      :type index: bool
      :param unit: Unit to return. One of {'B', 'KB', 'MB', 'GB'}. Defaults to "B".
      :type unit: {"B", "KB", "MB", "GB"}

      :returns: Bytes of memory consumed.
      :rtype: int

      .. seealso:: :py:obj:`arkouda.numpy.pdarrayclass.nbytes`, :py:obj:`arkouda.Index.memory_usage`, :py:obj:`arkouda.pandas.series.Series.memory_usage`, :py:obj:`arkouda.pandas.datafame.DataFrame.memory_usage`

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> from arkouda.series import Series
      >>> s = ak.Series(ak.arange(3))
      >>> s.memory_usage()
      48

      Not including the index gives the size of the rest of the data, which
      is necessarily smaller:

      >>> s.memory_usage(index=False)
      24

      Select the units:

      >>> s = ak.Series(ak.arange(3000))
      >>> s.memory_usage(unit="KB")
      46.875



   .. py:property:: ndim
      :type: int



   .. py:method:: notna() -> Series

      Detect existing (non-missing) values.

      Return a boolean same-sized object indicating if the values are not NA.
      Non-missing values get mapped to True.
      Characters such as empty strings '' are not considered NA values.
      NA values, such as numpy.NaN, get mapped to False values.

      :returns: Mask of bool values for each element in Series
                that indicates whether an element is not an NA value.
      :rtype: Series

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> from arkouda import Series
      >>> import numpy as np

      >>> s = Series(ak.array([1, 2, np.nan]), index = ak.array([1, 2, 4]))
      >>> s.notna()
      1     True
      2     True
      4    False
      dtype: bool



   .. py:method:: notnull() -> Series

      Series.notnull is an alias for Series.notna.

      Detect existing (non-missing) values.

      Return a boolean same-sized object indicating if the values are not NA.
      Non-missing values get mapped to True.
      Characters such as empty strings '' are not considered NA values.
      NA values, such as numpy.NaN, get mapped to False values.

      :returns: Mask of bool values for each element in Series
                that indicates whether an element is not an NA value.
      :rtype: Series

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> from arkouda import Series
      >>> import numpy as np

      >>> s = Series(ak.array([1, 2, np.nan]), index = ak.array([1, 2, 4]))
      >>> s.notnull()
      1     True
      2     True
      4    False
      dtype: bool



   .. py:attribute:: objType
      :value: 'Series'



   .. py:method:: pdconcat(arrays: List, axis: int = 0, labels: Union[arkouda.numpy.strings.Strings, None] = None) -> Union[pandas.Series, pandas.DataFrame]
      :staticmethod:


      Concatenate a list of Arkouda Series or grouped arrays, returning a local pandas object.

      If a list of grouped Arkouda arrays is passed, they are converted to Series. Each grouping
      is a 2-tuple with the first item being the key(s) and the second the value.

      If `axis=1` (horizontal), each Series or grouping must have the same length and the same index.
      The index is converted to a column in the resulting DataFrame. If it is a MultiIndex,
      each level is converted to a separate column.

      :param arrays: A list of Series or groupings (tuples of index and values) to concatenate.
      :type arrays: List
      :param axis: The axis along which to concatenate:
                   - 0 = vertical (stack into a Series)
                   - 1 = horizontal (align by index into a DataFrame)
                   Defaults to 0.
      :type axis: int
      :param labels: Names to assign to the resulting columns in the DataFrame.
      :type labels: Strings or None, optional

      :returns:

                - If axis=0: a local pandas Series
                - If axis=1: a local pandas DataFrame
      :rtype: Series or DataFrame



   .. py:method:: register(user_defined_name: str)

      Register this Series object and underlying components with the Arkouda server.

      :param user_defined_name: User-defined name the Series is to be registered under.
                                This will be the root name for the underlying components.
      :type user_defined_name: builtin_str

      :returns: The same Series which is now registered with the arkouda server and has an updated name.
                This is an in-place modification, the original is returned to support
                a fluid programming style.
                Please note you cannot register two different Series with the same name.
      :rtype: Series

      :raises TypeError: Raised if user_defined_name is not a str
      :raises RegistrationError: If the server was unable to register the Series with the user_defined_name

      .. seealso:: :py:obj:`unregister`, :py:obj:`attach`, :py:obj:`is_registered`

      .. rubric:: Notes

      Objects registered with the server are immune to deletion until
      they are unregistered.



   .. py:attribute:: registered_name
      :type:  Optional[str]
      :value: None



   .. py:property:: shape
      :type: Tuple[int]



   .. py:attribute:: size


   .. py:method:: sort_index(ascending: bool = True) -> Series

      Sort the Series by its index.

      :param ascending: Whether to sort the index in ascending (default) or descending order.
                        Defaults to True.
      :type ascending: bool

      :returns: A new Series sorted by index.
      :rtype: Series



   .. py:method:: sort_values(ascending: bool = True) -> Series

      Sort the Series by its values.

      :param ascending: Whether to sort values in ascending (default) or descending order.
                        Defaults to True.
      :type ascending: bool

      :returns: A new Series sorted by its values.
      :rtype: Series



   .. py:attribute:: str


   .. py:method:: tail(n: int = 10) -> Series

      Return the last n values of the series.



   .. py:method:: to_dataframe(index_labels: Union[List[str], None] = None, value_label: Union[str, None] = None) -> arkouda.pandas.dataframe.DataFrame

      Convert the Series to an Arkouda DataFrame.

      :param index_labels: Column name(s) to label the index.
      :type index_labels: list of str or None, optional
      :param value_label: Column name to label the values.
      :type value_label: str or None, optional

      :returns: An Arkouda DataFrame representing the Series.
      :rtype: DataFrame



   .. py:method:: to_markdown(mode='wt', index=True, tablefmt='grid', storage_options=None, **kwargs)

      Print Series in Markdown-friendly format.

      :param mode: Mode in which file is opened, "wt" by default.
      :type mode: str, optional
      :param index: Add index (row) labels.
      :type index: bool, optional, default True
      :param tablefmt: Table format to call from tablulate:
                       https://pypi.org/project/tabulate/
      :type tablefmt: str = "grid"
      :param storage_options: Extra options that make sense for a particular storage connection,
                              e.g. host, port, username, password, etc., if using a URL that will be parsed by fsspec,
                              e.g., starting “s3://”, “gcs://”.
                              An error will be raised if providing this argument with a non-fsspec URL.
                              See the fsspec and backend storage implementation docs for the set
                              of allowed keys and values.
      :type storage_options: dict, optional
      :param \*\*kwargs: These parameters will be passed to tabulate.

      .. note::

         This function should only be called on small Series as it calls pandas.Series.to_markdown:
         https://pandas.pydata.org/docs/reference/api/pandas.Series.to_markdown.html

      .. rubric:: Examples

      >>> import arkouda as ak

      >>> s = ak.Series(["elk", "pig", "dog", "quetzal"], name="animal")
      >>> print(s.to_markdown())
      +----+----------+
      |    | animal   |
      +====+==========+
      |  0 | elk      |
      +----+----------+
      |  1 | pig      |
      +----+----------+
      |  2 | dog      |
      +----+----------+
      |  3 | quetzal  |
      +----+----------+

      Output markdown with a tabulate option.

      >>> print(s.to_markdown(tablefmt="grid"))
      +----+----------+
      |    | animal   |
      +====+==========+
      |  0 | elk      |
      +----+----------+
      |  1 | pig      |
      +----+----------+
      |  2 | dog      |
      +----+----------+
      |  3 | quetzal  |
      +----+----------+



   .. py:method:: to_ndarray() -> numpy.ndarray


   .. py:method:: to_pandas() -> pandas.Series

      Convert the series to a local PANDAS series.



   .. py:method:: tolist() -> list


   .. py:method:: topn(n: int = 10) -> Series

      Return the top values of the Series.

      :param n: Number of values to return. Defaults to 10.
      :type n: int

      :returns: A new Series containing the top `n` values.
      :rtype: Series



   .. py:method:: unregister()

      Unregister this Series object in the arkouda server which was previously
      registered using register() and/or attached to using attach().

      :raises RegistrationError: If the object is already unregistered or if there is a server error
          when attempting to unregister

      .. seealso:: :py:obj:`register`, :py:obj:`attach`, :py:obj:`is_registered`

      .. rubric:: Notes

      Objects registered with the server are immune to deletion until
      they are unregistered.



   .. py:method:: validate_key(key: Union[Series, arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.strings.Strings, arkouda.categorical.Categorical, List, supported_scalars, arkouda.numpy.segarray.SegArray]) -> Union[arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.strings.Strings, arkouda.categorical.Categorical, supported_scalars, arkouda.numpy.segarray.SegArray]

      Validate type requirements for keys when reading or writing the Series.

      Also converts list and tuple arguments into pdarrays.

      :param key: The key or container of keys that might be used to index into the Series.
      :type key: Series, pdarray, Strings, Categorical, List, supported_scalars, or SegArray

      :rtype: The validated key(s), with lists and tuples converted to pdarrays

      :raises TypeError: Raised if keys are not boolean values or the type of the labels
          Raised if key is not one of the supported types
      :raises KeyError: Raised if container of keys has keys not present in the Series
      :raises IndexError: Raised if the length of a boolean key array is different
          from the Series



   .. py:method:: validate_val(val: Union[arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.strings.Strings, supported_scalars, List]) -> Union[arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.strings.Strings, supported_scalars]

      Validate type requirements for values being written into the Series.

      Also converts list and tuple arguments into pdarrays.

      :param val: The value or container of values that might be assigned into the Series.
      :type val: pdarray, Strings, supported_scalars, or List

      :rtype: The validated value, with lists converted to pdarrays

      :raises TypeError: Raised if val is not the same type or a container with elements
            of the same time as the Series
          Raised if val is a string or Strings type.
          Raised if val is not one of the supported types



   .. py:method:: value_counts(sort: bool = True) -> Series

      Return a Series containing counts of unique values.

      :param sort: Whether to sort the result by count in descending order. If False,
                   the order of the results is not guaranteed. Defaults to True.
      :type sort: bool

      :returns: A Series where the index contains the unique values and the values are
                their counts in the original Series.
      :rtype: Series



.. py:function:: compute_join_size(a: arkouda.numpy.pdarrayclass.pdarray, b: arkouda.numpy.pdarrayclass.pdarray) -> Tuple[int, int]

   Compute the internal size of a hypothetical join between a and b. Returns
   both the number of elements and number of bytes required for the join.


.. py:function:: gen_ranges(starts, ends, stride=1, return_lengths=False)

   Generate a segmented array of variable-length, contiguous ranges between pairs of
   start- and end-points.

   :param starts: The start value of each range
   :type starts: pdarray, int64
   :param ends: The end value (exclusive) of each range
   :type ends: pdarray, int64
   :param stride: Difference between successive elements of each range
   :type stride: int
   :param return_lengths: Whether or not to return the lengths of each segment. Default False.
   :type return_lengths: bool, optional

   :returns:

             segments : pdarray, int64
                 The starting index of each range in the resulting array
             ranges : pdarray, int64
                 The actual ranges, flattened into a single array
             lengths : pdarray, int64
                 The lengths of each segment. Only returned if return_lengths=True.
   :rtype: pdarray|int64, pdarray|int64, pdarray|int64


.. py:function:: join_on_eq_with_dt(a1: arkouda.numpy.pdarrayclass.pdarray, a2: arkouda.numpy.pdarrayclass.pdarray, t1: arkouda.numpy.pdarrayclass.pdarray, t2: arkouda.numpy.pdarrayclass.pdarray, dt: Union[int, numpy.int64], pred: str, result_limit: Union[int, numpy.int64] = 1000) -> Tuple[arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.pdarrayclass.pdarray]

   Inner-join on equality between two integer arrays where the time-window predicate is also true.

   :param a1: Values to join (must be int64 dtype).
   :type a1: pdarray
   :param a2: Values to join (must be int64 dtype).
   :type a2: pdarray
   :param t1: timestamps in millis corresponding to the a1 pdarray
   :type t1: pdarray
   :param t2: timestamps in millis corresponding to the a2 pdarray
   :type t2: pdarray
   :param dt: time delta
   :type dt: Union[int,np.int64]
   :param pred: time window predicate
   :type pred: str
   :param result_limit: size limit for returned result
   :type result_limit: Union[int,np.int64]

   :returns:

             result_array_one : pdarray, int64
                 a1 indices where a1 == a2
             result_array_one : pdarray, int64
                 a2 indices where a2 == a1
   :rtype: Tuple[pdarray, pdarray]

   :raises TypeError: Raised if a1, a2, t1, or t2 is not a pdarray, or if dt or
       result_limit is not an int
   :raises ValueError: if a1, a2, t1, or t2 dtype is not int64, pred is not
       'true_dt', 'abs_dt', or 'pos_dt', or result_limit is < 0


