:mod:`arkouda.pdarrayclass`
===========================

.. py:module:: arkouda.pdarrayclass


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   arkouda.pdarrayclass.pdarray



Functions
~~~~~~~~~

.. autoapisummary::

   arkouda.pdarrayclass.info
   arkouda.pdarrayclass.clear
   arkouda.pdarrayclass.any
   arkouda.pdarrayclass.all
   arkouda.pdarrayclass.is_sorted
   arkouda.pdarrayclass.sum
   arkouda.pdarrayclass.prod
   arkouda.pdarrayclass.min
   arkouda.pdarrayclass.max
   arkouda.pdarrayclass.argmin
   arkouda.pdarrayclass.argmax
   arkouda.pdarrayclass.mean
   arkouda.pdarrayclass.var
   arkouda.pdarrayclass.std
   arkouda.pdarrayclass.mink
   arkouda.pdarrayclass.maxk
   arkouda.pdarrayclass.argmink
   arkouda.pdarrayclass.argmaxk
   arkouda.pdarrayclass.register_pdarray
   arkouda.pdarrayclass.attach_pdarray
   arkouda.pdarrayclass.unregister_pdarray


.. class:: pdarray(name: str, mydtype: numpy.dtype, size: arkouda.dtypes.int_scalars, ndim: arkouda.dtypes.int_scalars, shape: Sequence[int], itemsize: arkouda.dtypes.int_scalars)


   The basic arkouda array class. This class contains only the
   attributies of the array; the data resides on the arkouda
   server. When a server operation results in a new array, arkouda
   will create a pdarray instance that points to the array data on
   the server. As such, the user should not initialize pdarray
   instances directly.

   .. attribute:: name

      The server-side identifier for the array

      :type: str

   .. attribute:: dtype

      The element type of the array

      :type: dtype

   .. attribute:: size

      The number of elements in the array

      :type: int_scalars

   .. attribute:: ndim

      The rank of the array (currently only rank 1 arrays supported)

      :type: int_scalars

   .. attribute:: shape

      A list or tuple containing the sizes of each dimension of the array

      :type: Sequence[int]

   .. attribute:: itemsize

      The size in bytes of each element

      :type: int_scalars

   .. attribute:: BinOps
      

      

   .. attribute:: OpEqOps
      

      

   .. attribute:: objtype
      :annotation: = pdarray

      

   .. attribute:: __array_priority__
      :annotation: = 1000

      

   .. method:: __del__(self)


   .. method:: __bool__(self) -> bool


   .. method:: __len__(self)


   .. method:: __str__(self)

      Return str(self).


   .. method:: __repr__(self)

      Return repr(self).


   .. method:: format_other(self, other: object) -> numpy.dtype

      Attempt to cast scalar other to the element dtype of this pdarray,
      and print the resulting value to a string (e.g. for sending to a
      server command). The user should not call this function directly.

      :param other: The scalar to be cast to the pdarray.dtype
      :type other: object

      :returns:
      :rtype: np.dtype corresponding to the other parameter

      :raises TypeError: Raised if the other parameter cannot be converted to
          Numpy dtype


   .. method:: _binop(self, other: arkouda.pdarrayclass.pdarray, op: str) -> arkouda.pdarrayclass.pdarray

      Executes binary operation specified by the op string

      :param other: The pdarray upon which the binop is to be executed
      :type other: pdarray
      :param op: The binop to be executed
      :type op: str

      :returns: A pdarray encapsulating the binop result
      :rtype: pdarray

      :raises ValueError: Raised if the op is not within the pdarray.BinOps set, or if the
          pdarray sizes don't match
      :raises TypeError: Raised if other is not a pdarray or the pdarray.dtype is not
          a supported dtype


   .. method:: _r_binop(self, other: arkouda.pdarrayclass.pdarray, op: str) -> arkouda.pdarrayclass.pdarray

      Executes reverse binary operation specified by the op string

      :param other: The pdarray upon which the reverse binop is to be executed
      :type other: pdarray
      :param op: The name of the reverse binop to be executed
      :type op: str

      :returns: A pdarray encapsulating the reverse binop result
      :rtype: pdarray

      :raises ValueError: Raised if the op is not within the pdarray.BinOps set
      :raises TypeError: Raised if other is not a pdarray or the pdarray.dtype is not
          a supported dtype


   .. method:: __add__(self, other)


   .. method:: __radd__(self, other)


   .. method:: __sub__(self, other)


   .. method:: __rsub__(self, other)


   .. method:: __mul__(self, other)


   .. method:: __rmul__(self, other)


   .. method:: __truediv__(self, other)


   .. method:: __rtruediv__(self, other)


   .. method:: __floordiv__(self, other)


   .. method:: __rfloordiv__(self, other)


   .. method:: __mod__(self, other)


   .. method:: __rmod__(self, other)


   .. method:: __lshift__(self, other)


   .. method:: __rlshift__(self, other)


   .. method:: __rshift__(self, other)


   .. method:: __rrshift__(self, other)


   .. method:: __and__(self, other)


   .. method:: __rand__(self, other)


   .. method:: __or__(self, other)


   .. method:: __ror__(self, other)


   .. method:: __xor__(self, other)


   .. method:: __rxor__(self, other)


   .. method:: __pow__(self, other)


   .. method:: __rpow__(self, other)


   .. method:: __lt__(self, other)

      Return self<value.


   .. method:: __gt__(self, other)

      Return self>value.


   .. method:: __le__(self, other)

      Return self<=value.


   .. method:: __ge__(self, other)

      Return self>=value.


   .. method:: __eq__(self, other)

      Return self==value.


   .. method:: __ne__(self, other)

      Return self!=value.


   .. method:: __neg__(self)


   .. method:: __invert__(self)


   .. method:: opeq(self, other, op)


   .. method:: __iadd__(self, other)


   .. method:: __isub__(self, other)


   .. method:: __imul__(self, other)


   .. method:: __itruediv__(self, other)


   .. method:: __ifloordiv__(self, other)


   .. method:: __ilshift__(self, other)


   .. method:: __irshift__(self, other)


   .. method:: __iand__(self, other)


   .. method:: __ior__(self, other)


   .. method:: __ixor__(self, other)


   .. method:: __ipow__(self, other)


   .. method:: __iter__(self)
      :abstractmethod:


   .. method:: __getitem__(self, key)


   .. method:: __setitem__(self, key, value)


   .. method:: fill(self, value: arkouda.dtypes.numeric_scalars) -> None

      Fill the array (in place) with a constant value.

      :param value:
      :type value: numeric_scalars

      :raises TypeError: Raised if value is not an int, int64, float, or float64


   .. method:: any(self) -> numpy.bool_

      Return True iff any element of the array evaluates to True.


   .. method:: all(self) -> numpy.bool_

      Return True iff all elements of the array evaluate to True.


   .. method:: is_sorted(self) -> numpy.bool_

      Return True iff the array is monotonically non-decreasing.

      :param None:

      :returns: Indicates if the array is monotonically non-decreasing
      :rtype: bool

      :raises TypeError: Raised if pda is not a pdarray instance
      :raises RuntimeError: Raised if there's a server-side error thrown


   .. method:: sum(self) -> arkouda.dtypes.numpy_scalars

      Return the sum of all elements in the array.


   .. method:: prod(self) -> numpy.float64

      Return the product of all elements in the array. Return value is
      always a np.float64 or np.int64.


   .. method:: min(self) -> arkouda.dtypes.numpy_scalars

      Return the minimum value of the array.


   .. method:: max(self) -> arkouda.dtypes.numpy_scalars

      Return the maximum value of the array.


   .. method:: argmin(self) -> numpy.int64

      Return the index of the first occurrence of the array min value


   .. method:: argmax(self) -> numpy.int64

      Return the index of the first occurrence of the array max value.


   .. method:: mean(self) -> numpy.float64

      Return the mean of the array.


   .. method:: var(self, ddof: arkouda.dtypes.int_scalars = 0) -> numpy.float64

      Compute the variance. See ``arkouda.var`` for details.

      :param ddof: "Delta Degrees of Freedom" used in calculating var
      :type ddof: int_scalars

      :returns: The scalar variance of the array
      :rtype: np.float64

      :raises TypeError: Raised if pda is not a pdarray instance
      :raises ValueError: Raised if the ddof >= pdarray size
      :raises RuntimeError: Raised if there's a server-side error thrown


   .. method:: std(self, ddof: arkouda.dtypes.int_scalars = 0) -> numpy.float64

      Compute the standard deviation. See ``arkouda.std`` for details.

      :param ddof: "Delta Degrees of Freedom" used in calculating std
      :type ddof: int_scalars

      :returns: The scalar standard deviation of the array
      :rtype: np.float64

      :raises TypeError: Raised if pda is not a pdarray instance
      :raises RuntimeError: Raised if there's a server-side error thrown


   .. method:: mink(self, k: arkouda.dtypes.int_scalars) -> arkouda.pdarrayclass.pdarray

      Compute the minimum "k" values.

      :param k: The desired count of maximum values to be returned by the output.
      :type k: int_scalars

      :returns: The maximum `k` values from pda
      :rtype: pdarray, int

      :raises TypeError: Raised if pda is not a pdarray


   .. method:: maxk(self, k: arkouda.dtypes.int_scalars) -> arkouda.pdarrayclass.pdarray

      Compute the maximum "k" values.

      :param k: The desired count of maximum values to be returned by the output.
      :type k: int_scalars

      :returns: The maximum `k` values from pda
      :rtype: pdarray, int

      :raises TypeError: Raised if pda is not a pdarray


   .. method:: argmink(self, k: arkouda.dtypes.int_scalars) -> arkouda.pdarrayclass.pdarray

      Compute the minimum "k" values.

      :param k: The desired count of maximum values to be returned by the output.
      :type k: int_scalars

      :returns: Indices corresponding to the maximum `k` values from pda
      :rtype: pdarray, int

      :raises TypeError: Raised if pda is not a pdarray


   .. method:: argmaxk(self, k: arkouda.dtypes.int_scalars) -> arkouda.pdarrayclass.pdarray

      Finds the indices corresponding to the maximum "k" values.

      :param k: The desired count of maximum values to be returned by the output.
      :type k: int_scalars

      :returns: Indices corresponding to the  maximum `k` values, sorted
      :rtype: pdarray, int

      :raises TypeError: Raised if pda is not a pdarray


   .. method:: to_ndarray(self) -> numpy.ndarray

      Convert the array to a np.ndarray, transferring array data from the
      Arkouda server to client-side Python. Note: if the pdarray size exceeds
      client.maxTransferBytes, a RuntimeError is raised.

      :returns: A numpy ndarray with the same attributes and data as the pdarray
      :rtype: np.ndarray

      :raises RuntimeError: Raised if there is a server-side error thrown, if the pdarray size
          exceeds the built-in client.maxTransferBytes size limit, or if the bytes
          received does not match expected number of bytes

      .. rubric:: Notes

      The number of bytes in the array cannot exceed ``client.maxTransferBytes``,
      otherwise a ``RuntimeError`` will be raised. This is to protect the user
      from overflowing the memory of the system on which the Python client
      is running, under the assumption that the server is running on a
      distributed system with much more memory than the client. The user
      may override this limit by setting client.maxTransferBytes to a larger
      value, but proceed with caution.

      .. seealso:: :obj:`array`

      .. rubric:: Examples

      >>> a = ak.arange(0, 5, 1)
      >>> a.to_ndarray()
      array([0, 1, 2, 3, 4])

      >>> type(a.to_ndarray())
      numpy.ndarray


   .. method:: to_cuda(self)

      Convert the array to a Numba DeviceND array, transferring array data from the
      arkouda server to Python via ndarray. If the array exceeds a builtin size limit,
      a RuntimeError is raised.

      :returns: A Numba ndarray with the same attributes and data as the pdarray; on GPU
      :rtype: numba.DeviceNDArray

      :raises ImportError: Raised if CUDA is not available
      :raises ModuleNotFoundError: Raised if Numba is either not installed or not enabled
      :raises RuntimeError: Raised if there is a server-side error thrown in the course of retrieving
          the pdarray.

      .. rubric:: Notes

      The number of bytes in the array cannot exceed ``client.maxTransferBytes``,
      otherwise a ``RuntimeError`` will be raised. This is to protect the user
      from overflowing the memory of the system on which the Python client
      is running, under the assumption that the server is running on a
      distributed system with much more memory than the client. The user
      may override this limit by setting client.maxTransferBytes to a larger
      value, but proceed with caution.

      .. seealso:: :obj:`array`

      .. rubric:: Examples

      >>> a = ak.arange(0, 5, 1)
      >>> a.to_cuda()
      array([0, 1, 2, 3, 4])

      >>> type(a.to_cuda())
      numpy.devicendarray


   .. method:: save(self, prefix_path: str, dataset: str = 'array', mode: str = 'truncate') -> str

      Save the pdarray to HDF5. The result is a collection of HDF5 files,
      one file per locale of the arkouda server, where each filename starts
      with prefix_path. Each locale saves its chunk of the array to its
      corresponding file.

      :param prefix_path: Directory and filename prefix that all output files share
      :type prefix_path: str
      :param dataset: Name of the dataset to create in HDF5 files (must not already exist)
      :type dataset: str
      :param mode: By default, truncate (overwrite) output files, if they exist.
                   If 'append', attempt to create new dataset in existing files.
      :type mode: str {'truncate' | 'append'}

      :returns:
      :rtype: string message indicating result of save operation

      :raises RuntimeError: Raised if a server-side error is thrown saving the pdarray
      :raises ValueError: Raised if there is an error in parsing the prefix path pointing to
          file write location or if the mode parameter is neither truncate
          nor append
      :raises TypeError: Raised if any one of the prefix_path, dataset, or mode parameters
          is not a string

      .. seealso:: :obj:`save_all`, :obj:`load`, :obj:`read_hdf`, :obj:`read_all`

      .. rubric:: Notes

      The prefix_path must be visible to the arkouda server and the user must
      have write permission.

      Output files have names of the form ``<prefix_path>_LOCALE<i>.hdf``, where ``<i>``
      ranges from 0 to ``numLocales``. If any of the output files already exist and
      the mode is 'truncate', they will be overwritten. If the mode is 'append'
      and the number of output files is less than the number of locales or a
      dataset with the same name already exists, a ``RuntimeError`` will result.

      .. rubric:: Examples

      >>> a = ak.arange(0, 100, 1)
      >>> a.save('arkouda_range', dataset='array')

      Array is saved in numLocales files with names like ``tmp/arkouda_range_LOCALE0.hdf``

      The array can be read back in as follows

      >>> b = ak.load('arkouda_range', dataset='array')
      >>> (a == b).all()
      True


   .. method:: register(self, user_defined_name: str) -> arkouda.pdarrayclass.pdarray

      Return a pdarray with a user defined name in the arkouda server
      so it can be attached to later using pdarray.attach()

      :param user_defined_name: user defined name array is to be registered under
      :type user_defined_name: str

      :returns: pdarray which points to original input pdarray but is also
                registered with user defined name in the arkouda server
      :rtype: pdarray

      :raises TypeError: Raised if pda is neither a pdarray nor a str or if
          user_defined_name is not a str

      .. seealso:: :obj:`attach`, :obj:`unregister`

      .. rubric:: Notes

      Registered names/pdarrays in the server are immune to deletion
      until they are unregistered.

      .. rubric:: Examples

      >>> a = zeros(100)
      >>> r_pda = a.register("my_zeros")
      >>> # potentially disconnect from server and reconnect to server
      >>> b = ak.pdarray.attach("my_zeros")
      >>> # ...other work...
      >>> b.unregister()


   .. method:: unregister(self) -> None

      Unregister a pdarray in the arkouda server which was previously
      registered using register() and/or attahced to using attach()

      :param user_defined_name: which array was registered under
      :type user_defined_name: str

      :returns:
      :rtype: None

      :raises TypeError: Raised if pda is neither a pdarray nor a str

      .. seealso:: :obj:`register`, :obj:`unregister`

      .. rubric:: Notes

      Registered names/pdarrays in the server are immune to deletion until
      they are unregistered.

      .. rubric:: Examples

      >>> a = zeros(100)
      >>> r_pda = a.register("my_zeros")
      >>> # potentially disconnect from server and reconnect to server
      >>> b = ak.pdarray.attach("my_zeros")
      >>> # ...other work...
      >>> b.unregister()


   .. method:: attach(user_defined_name: str) -> arkouda.pdarrayclass.pdarray
      :staticmethod:

      class method to return a pdarray attached to the a registered name in the arkouda
      server which was registered using register()

      :param user_defined_name: user defined name which array was registered under
      :type user_defined_name: str

      :returns: pdarray which points to pdarray registered with user defined
                name in the arkouda server
      :rtype: pdarray

      :raises TypeError: Raised if user_defined_name is not a str

      .. seealso:: :obj:`register`, :obj:`unregister`

      .. rubric:: Notes

      Registered names/pdarrays in the server are immune to deletion
      until they are unregistered.

      .. rubric:: Examples

      >>> a = zeros(100)
      >>> r_pda = a.register("my_zeros")
      >>> # potentially disconnect from server and reconnect to server
      >>> b = ak.pdarray.attach("my_zeros")
      >>> # ...other work...
      >>> b.unregister()



.. function:: info(pda: Union[(pdarray, str)]) -> str

   Returns information about the pdarray instance

   :param pda: pda is either the pdarray instance or the pdarray.name string
   :type pda: Union[pdarray, str]

   :returns: Information regarding the pdarray in the form of a string
   :rtype: str

   :raises TypeError: Raised if the parameter is neither a pdarray or string
   :raises RuntimeError: Raised if a server-side error is thrown in the process of
       retrieving information about the pdarray


.. function:: clear() -> None

   Send a clear message to clear all unregistered data from the server symbol table

   :returns:
   :rtype: None

   :raises RuntimeError: Raised if there is a server-side error in executing clear request


.. function:: any(pda: arkouda.pdarrayclass.pdarray) -> numpy.bool_

   Return True iff any element of the array evaluates to True.

   :param pda: The pdarray instance to be evaluated
   :type pda: pdarray

   :returns: Indicates if 1..n pdarray elements evaluate to True
   :rtype: bool

   :raises TypeError: Raised if pda is not a pdarray instance
   :raises RuntimeError: Raised if there's a server-side error thrown


.. function:: all(pda: arkouda.pdarrayclass.pdarray) -> numpy.bool_

   Return True iff all elements of the array evaluate to True.

   :param pda: The pdarray instance to be evaluated
   :type pda: pdarray

   :returns: Indicates if all pdarray elements evaluate to True
   :rtype: bool

   :raises TypeError: Raised if pda is not a pdarray instance
   :raises RuntimeError: Raised if there's a server-side error thrown


.. function:: is_sorted(pda: arkouda.pdarrayclass.pdarray) -> numpy.bool_

   Return True iff the array is monotonically non-decreasing.

   :param pda: The pdarray instance to be evaluated
   :type pda: pdarray

   :returns: Indicates if the array is monotonically non-decreasing
   :rtype: bool

   :raises TypeError: Raised if pda is not a pdarray instance
   :raises RuntimeError: Raised if there's a server-side error thrown


.. function:: sum(pda: arkouda.pdarrayclass.pdarray) -> numpy.float64

   Return the sum of all elements in the array.

   :param pda: Values for which to calculate the sum
   :type pda: pdarray

   :returns: The sum of all elements in the array
   :rtype: np.float64

   :raises TypeError: Raised if pda is not a pdarray instance
   :raises RuntimeError: Raised if there's a server-side error thrown


.. function:: prod(pda: arkouda.pdarrayclass.pdarray) -> numpy.float64

   Return the product of all elements in the array. Return value is
   always a np.float64 or np.int64

   :param pda: Values for which to calculate the product
   :type pda: pdarray

   :returns: The product calculated from the pda
   :rtype: numpy_scalars

   :raises TypeError: Raised if pda is not a pdarray instance
   :raises RuntimeError: Raised if there's a server-side error thrown


.. function:: min(pda: arkouda.pdarrayclass.pdarray) -> arkouda.dtypes.numpy_scalars

   Return the minimum value of the array.

   :param pda: Values for which to calculate the min
   :type pda: pdarray

   :returns: The min calculated from the pda
   :rtype: numpy_scalars

   :raises TypeError: Raised if pda is not a pdarray instance
   :raises RuntimeError: Raised if there's a server-side error thrown


.. function:: max(pda: arkouda.pdarrayclass.pdarray) -> arkouda.dtypes.numpy_scalars

   Return the maximum value of the array.

   :param pda: Values for which to calculate the max
   :type pda: pdarray

   :returns: The max calculated from the pda
   :rtype: numpy_scalars

   :raises TypeError: Raised if pda is not a pdarray instance
   :raises RuntimeError: Raised if there's a server-side error thrown


.. function:: argmin(pda: arkouda.pdarrayclass.pdarray) -> numpy.int64

   Return the index of the first occurrence of the array min value.

   :param pda: Values for which to calculate the argmin
   :type pda: pdarray

   :returns: The index of the argmin calculated from the pda
   :rtype: np.int64

   :raises TypeError: Raised if pda is not a pdarray instance
   :raises RuntimeError: Raised if there's a server-side error thrown


.. function:: argmax(pda: arkouda.pdarrayclass.pdarray) -> numpy.int64

   Return the index of the first occurrence of the array max value.

   :param pda: Values for which to calculate the argmax
   :type pda: pdarray

   :returns: The index of the argmax calculated from the pda
   :rtype: np.int64

   :raises TypeError: Raised if pda is not a pdarray instance
   :raises RuntimeError: Raised if there's a server-side error thrown


.. function:: mean(pda: arkouda.pdarrayclass.pdarray) -> numpy.float64

   Return the mean of the array.

   :param pda: Values for which to calculate the mean
   :type pda: pdarray

   :returns: The mean calculated from the pda sum and size
   :rtype: np.float64

   :raises TypeError: Raised if pda is not a pdarray instance
   :raises RuntimeError: Raised if there's a server-side error thrown


.. function:: var(pda: arkouda.pdarrayclass.pdarray, ddof: arkouda.dtypes.int_scalars = 0) -> numpy.float64

   Return the variance of values in the array.

   :param pda: Values for which to calculate the variance
   :type pda: pdarray
   :param ddof: "Delta Degrees of Freedom" used in calculating var
   :type ddof: int_scalars

   :returns: The scalar variance of the array
   :rtype: np.float64

   :raises TypeError: Raised if pda is not a pdarray instance
   :raises ValueError: Raised if the ddof >= pdarray size
   :raises RuntimeError: Raised if there's a server-side error thrown

   .. seealso:: :obj:`mean`, :obj:`std`

   .. rubric:: Notes

   The variance is the average of the squared deviations from the mean,
   i.e.,  ``var = mean((x - x.mean())**2)``.

   The mean is normally calculated as ``x.sum() / N``, where ``N = len(x)``.
   If, however, `ddof` is specified, the divisor ``N - ddof`` is used
   instead.  In standard statistical practice, ``ddof=1`` provides an
   unbiased estimator of the variance of a hypothetical infinite population.
   ``ddof=0`` provides a maximum likelihood estimate of the variance for
   normally distributed variables.


.. function:: std(pda: arkouda.pdarrayclass.pdarray, ddof: arkouda.dtypes.int_scalars = 0) -> numpy.float64

   Return the standard deviation of values in the array. The standard
   deviation is implemented as the square root of the variance.

   :param pda: values for which to calculate the standard deviation
   :type pda: pdarray
   :param ddof: "Delta Degrees of Freedom" used in calculating std
   :type ddof: int_scalars

   :returns: The scalar standard deviation of the array
   :rtype: np.float64

   :raises TypeError: Raised if pda is not a pdarray instance or ddof is not an integer
   :raises ValueError: Raised if ddof is an integer < 0
   :raises RuntimeError: Raised if there's a server-side error thrown

   .. seealso:: :obj:`mean`, :obj:`var`

   .. rubric:: Notes

   The standard deviation is the square root of the average of the squared
   deviations from the mean, i.e., ``std = sqrt(mean((x - x.mean())**2))``.

   The average squared deviation is normally calculated as
   ``x.sum() / N``, where ``N = len(x)``.  If, however, `ddof` is specified,
   the divisor ``N - ddof`` is used instead. In standard statistical
   practice, ``ddof=1`` provides an unbiased estimator of the variance
   of the infinite population. ``ddof=0`` provides a maximum likelihood
   estimate of the variance for normally distributed variables. The
   standard deviation computed in this function is the square root of
   the estimated variance, so even with ``ddof=1``, it will not be an
   unbiased estimate of the standard deviation per se.


.. function:: mink(pda: arkouda.pdarrayclass.pdarray, k: arkouda.dtypes.int_scalars) -> arkouda.pdarrayclass.pdarray

   Find the `k` minimum values of an array.

   Returns the smallest `k` values of an array, sorted

   :param pda: Input array.
   :type pda: pdarray
   :param k: The desired count of minimum values to be returned by the output.
   :type k: int_scalars

   :returns: The minimum `k` values from pda, sorted
   :rtype: pdarray

   :raises TypeError: Raised if pda is not a pdarray
   :raises ValueError: Raised if the pda is empty or k < 1

   .. rubric:: Notes

   This call is equivalent in value to:

       a[ak.argsort(a)[:k]]

   and generally outperforms this operation.

   This reduction will see a significant drop in performance as `k` grows
   beyond a certain value. This value is system dependent, but generally
   about a `k` of 5 million is where performance degredation has been observed.

   .. rubric:: Examples

   >>> A = ak.array([10,5,1,3,7,2,9,0])
   >>> ak.mink(A, 3)
   array([0, 1, 2])
   >>> ak.mink(A, 4)
   array([0, 1, 2, 3])


.. function:: maxk(pda: arkouda.pdarrayclass.pdarray, k: arkouda.dtypes.int_scalars) -> arkouda.pdarrayclass.pdarray

   Find the `k` maximum values of an array.

   Returns the largest `k` values of an array, sorted

   :param pda: Input array.
   :type pda: pdarray
   :param k: The desired count of maximum values to be returned by the output.
   :type k: int_scalars

   :returns: The maximum `k` values from pda, sorted
   :rtype: pdarray, int

   :raises TypeError: Raised if pda is not a pdarray or k is not an integer
   :raises ValueError: Raised if the pda is empty or k < 1

   .. rubric:: Notes

   This call is equivalent in value to:

       a[ak.argsort(a)[k:]]

   and generally outperforms this operation.

   This reduction will see a significant drop in performance as `k` grows
   beyond a certain value. This value is system dependent, but generally
   about a `k` of 5 million is where performance degredation has been observed.

   .. rubric:: Examples

   >>> A = ak.array([10,5,1,3,7,2,9,0])
   >>> ak.maxk(A, 3)
   array([7, 9, 10])
   >>> ak.maxk(A, 4)
   array([5, 7, 9, 10])


.. function:: argmink(pda: arkouda.pdarrayclass.pdarray, k: arkouda.dtypes.int_scalars) -> arkouda.pdarrayclass.pdarray

   Finds the indices corresponding to the `k` minimum values of an array.

   :param pda: Input array.
   :type pda: pdarray
   :param k: The desired count of indices corresponding to minimum array values
   :type k: int_scalars

   :returns: The indices of the minimum `k` values from the pda, sorted
   :rtype: pdarray, int

   :raises TypeError: Raised if pda is not a pdarray or k is not an integer
   :raises ValueError: Raised if the pda is empty or k < 1

   .. rubric:: Notes

   This call is equivalent in value to:

       ak.argsort(a)[:k]

   and generally outperforms this operation.

   This reduction will see a significant drop in performance as `k` grows
   beyond a certain value. This value is system dependent, but generally
   about a `k` of 5 million is where performance degradation has been observed.

   .. rubric:: Examples

   >>> A = ak.array([10,5,1,3,7,2,9,0])
   >>> ak.argmink(A, 3)
   array([7, 2, 5])
   >>> ak.argmink(A, 4)
   array([7, 2, 5, 3])


.. function:: argmaxk(pda: arkouda.pdarrayclass.pdarray, k: arkouda.dtypes.int_scalars) -> arkouda.pdarrayclass.pdarray

   Find the indices corresponding to the `k` maximum values of an array.

   Returns the largest `k` values of an array, sorted

   :param pda: Input array.
   :type pda: pdarray
   :param k: The desired count of indices corresponding to maxmum array values
   :type k: int_scalars

   :returns: The indices of the maximum `k` values from the pda, sorted
   :rtype: pdarray, int

   :raises TypeError: Raised if pda is not a pdarray or k is not an integer
   :raises ValueError: Raised if the pda is empty or k < 1

   .. rubric:: Notes

   This call is equivalent in value to:

       ak.argsort(a)[k:]

   and generally outperforms this operation.

   This reduction will see a significant drop in performance as `k` grows
   beyond a certain value. This value is system dependent, but generally
   about a `k` of 5 million is where performance degradation has been observed.

   .. rubric:: Examples

   >>> A = ak.array([10,5,1,3,7,2,9,0])
   >>> ak.argmaxk(A, 3)
   array([4, 6, 0])
   >>> ak.argmaxk(A, 4)
   array([1, 4, 6, 0])


.. function:: register_pdarray(pda: Union[(str, pdarray)], user_defined_name: str) -> arkouda.pdarrayclass.pdarray

   Return a pdarray with a user defined name in the arkouda server
   so it can be attached to later using attach_pdarray()

   :param pda: the array to register
   :type pda: str or pdarray
   :param user_defined_name: user defined name array is to be registered under
   :type user_defined_name: str

   :returns: pdarray which points to original input pdarray but is also
             registered with user defined name in the arkouda server
   :rtype: pdarray

   :raises TypeError: Raised if pda is neither a pdarray nor a str or if
       user_defined_name is not a str

   .. seealso:: :obj:`attach_pdarray`, :obj:`unregister_pdarray`

   .. rubric:: Notes

   Registered names/pdarrays in the server are immune to deletion
   until they are unregistered.

   .. rubric:: Examples

   >>> a = zeros(100)
   >>> r_pda = ak.register_pda(a, "my_zeros")
   >>> # potentially disconnect from server and reconnect to server
   >>> b = ak.attach_pda("my_zeros")
   >>> # ...other work...
   >>> ak.unregister_pda(b)


.. function:: attach_pdarray(user_defined_name: str) -> arkouda.pdarrayclass.pdarray

   Return a pdarray attached to the a registered name in the arkouda
   server which was registered using register_pdarray()

   :param user_defined_name: user defined name which array was registered under
   :type user_defined_name: str

   :returns: pdarray which points to pdarray registered with user defined
             name in the arkouda server
   :rtype: pdarray

   :raises TypeError: Raised if user_defined_name is not a str

   .. seealso:: :obj:`register_pdarray`, :obj:`unregister_pdarray`

   .. rubric:: Notes

   Registered names/pdarrays in the server are immune to deletion
   until they are unregistered.

   .. rubric:: Examples

   >>> a = zeros(100)
   >>> r_pda = ak.register_pdarray(a, "my_zeros")
   >>> # potentially disconnect from server and reconnect to server
   >>> b = ak.attach_pdarray("my_zeros")
   >>> # ...other work...
   >>> ak.unregister_pdarray(b)


.. function:: unregister_pdarray(pda: Union[(str, pdarray)]) -> None

   Unregister a pdarray in the arkouda server which was previously
   registered using register_pdarray() and/or attached to using attach_pdarray()

   :param pda: user define name which array was registered under
   :type pda: str or pdarray

   :returns:
   :rtype: None

   :raises TypeError: Raised if pda is neither a pdarray nor a str

   .. seealso:: :obj:`register_pdarray`, :obj:`unregister_pdarray`

   .. rubric:: Notes

   Registered names/pdarrays in the server are immune to deletion until
   they are unregistered.

   .. rubric:: Examples

   >>> a = zeros(100)
   >>> r_pda = ak.register_pdarray(a, "my_zeros")
   >>> # potentially disconnect from server and reconnect to server
   >>> b = ak.attach_pdarray("my_zeros")
   >>> # ...other work...
   >>> ak.unregister_pdarray(b)


