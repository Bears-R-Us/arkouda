:py:mod:`arkouda.alignment`
===========================

.. py:module:: arkouda.alignment


Module Contents
---------------


Functions
~~~~~~~~~

.. autoapisummary::

   arkouda.alignment.unsqueeze
   arkouda.alignment.zero_up
   arkouda.alignment.align
   arkouda.alignment.right_align
   arkouda.alignment.left_align
   arkouda.alignment.find
   arkouda.alignment.lookup
   arkouda.alignment.in1d_intervals
   arkouda.alignment.search_intervals
   arkouda.alignment.is_cosorted
   arkouda.alignment.interval_lookup



.. py:function:: unsqueeze(p)


.. py:function:: zero_up(vals)

   Map an array of sparse values to 0-up indices.

   :param vals: Array to map to dense index
   :type vals: pdarray

   :returns: **aligned** -- Array with values replaced by 0-up indices
   :rtype: pdarray


.. py:function:: align(*args)

   Map multiple arrays of sparse identifiers to a common 0-up index.

   :param \*args: Arrays to map to dense index
   :type \*args: pdarrays

   :returns: **aligned** -- Arrays with values replaced by 0-up indices
   :rtype: list of pdarrays


.. py:function:: right_align(left, right)

   Map two arrays of sparse values to the 0-up index set implied by the right array,
   discarding values from left that do not appear in right.

   :param left: Left-hand identifiers
   :type left: pdarray
   :param right: Right-hand identifiers that define the index
   :type right: pdarray

   :returns: * **keep** (*pdarray, bool*) -- Logical index of left-hand values that survived
             * **aligned** (*(pdarray, pdarray)*) -- Left and right arrays with values replaced by 0-up indices


.. py:function:: left_align(left, right)

   Map two arrays of sparse identifiers to the 0-up index set implied by the left array,
   discarding values from right that do not appear in left.


.. py:exception:: NonUniqueError

   Bases: :py:obj:`ValueError`

   Inappropriate argument value (of correct type).


.. py:function:: find(query, space)

   Return indices of query items in a search list of items (-1 if not found).

   :param query: The items to search for. If multiple arrays, each "row" is an item.
   :type query: (sequence of) array-like
   :param space: The set of items in which to search. Must have same shape/dtype as query.
   :type space: (sequence of) array-like

   :returns: **indices** -- For each item in query, its index in space or -1 if not found.
   :rtype: pdarray, int64


.. py:function:: lookup(keys, values, arguments, fillvalue=-1)

   Apply the function defined by the mapping keys --> values to arguments.

   :param keys: The domain of the function. Entries must be unique (if a sequence of
                arrays is given, each row is treated as a tuple-valued entry).
   :type keys: (sequence of) array-like
   :param values: The range of the function. Must be same length as keys.
   :type values: pdarray
   :param arguments: The arguments on which to evaluate the function. Must have same dtype
                     (or tuple of dtypes, for a sequence) as keys.
   :type arguments: (sequence of) array-like
   :param fillvalue: The default value to return for arguments not in keys.
   :type fillvalue: scalar

   :returns: **evaluated** -- The result of evaluating the function over arguments.
   :rtype: pdarray

   .. rubric:: Notes

   While the values cannot be Strings (or other complex objects), the same
   result can be achieved by passing an arange as the values, then using
   the return as indices into the desired object.

   .. rubric:: Examples

   # Lookup numbers by two-word name
   >>> keys1 = ak.array(['twenty' for _ in range(5)])
   >>> keys2 = ak.array(['one', 'two', 'three', 'four', 'five'])
   >>> values = ak.array([21, 22, 23, 24, 25])
   >>> args1 = ak.array(['twenty', 'thirty', 'twenty'])
   >>> args2 = ak.array(['four', 'two', 'two'])
   >>> aku.lookup([keys1, keys2], values, [args1, args2])
   array([24, -1, 22])

   # Other direction requires an intermediate index
   >>> revkeys = values
   >>> revindices = ak.arange(values.size)
   >>> revargs = ak.array([24, 21, 22])
   >>> idx = aku.lookup(revkeys, revindices, revargs)
   >>> keys1[idx], keys2[idx]
   (array(['twenty', 'twenty', 'twenty']),
   array(['four', 'one', 'two']))


.. py:function:: in1d_intervals(vals, intervals, symmetric=False)

   Test each value for membership in *any* of a set of half-open (pythonic)
   intervals.

   :param vals: Values to test for membership in intervals
   :type vals: pdarray(int, float)
   :param intervals: Non-overlapping, half-open intervals, as a tuple of
                     (lower_bounds_inclusive, upper_bounds_exclusive)
   :type intervals: 2-tuple of pdarrays
   :param symmetric: If True, also return boolean pdarray indicating which intervals
                     contained one or more query values.
   :type symmetric: bool

   :returns: * *pdarray(bool)* -- Array of same length as <vals>, True if corresponding value is
               included in any of the ranges defined by (low[i], high[i]) inclusive.
             * *pdarray(bool) (if symmetric=True)* -- Array of same length as number of intervals, True if corresponding
               interval contains any of the values in <vals>.

   .. rubric:: Notes

   First return array is equivalent to the following:
       ((vals >= intervals[0][0]) & (vals < intervals[1][0])) |
       ((vals >= intervals[0][1]) & (vals < intervals[1][1])) |
       ...
       ((vals >= intervals[0][-1]) & (vals < intervals[1][-1]))
   But much faster when testing many ranges.

   Second (optional) return array is equivalent to:
       ((intervals[0] <= vals[0]) & (intervals[1] > vals[0])) |
       ((intervals[0] <= vals[1]) & (intervals[1] > vals[1])) |
       ...
       ((intervals[0] <= vals[-1]) & (intervals[1] > vals[-1]))
   But much faster when vals is non-trivial size.


.. py:function:: search_intervals(vals, intervals, tiebreak=None, hierarchical=True)

   Given an array of query vals and non-overlapping, closed intervals, return
   the index of the best (see tiebreak) interval containing each query value,
   or -1 if not present in any interval.

   :param vals: Values to search for in intervals. If multiple arrays, each "row" is an item.
   :type vals: (sequence of) pdarray(int, uint, float)
   :param intervals: Non-overlapping, half-open intervals, as a tuple of
                     (lower_bounds_inclusive, upper_bounds_exclusive)
                     Must have same dtype(s) as vals.
   :type intervals: 2-tuple of (sequences of) pdarrays
   :param tiebreak: When a value is present in more than one interval, the interval with the
                    lowest tiebreak value will be chosen. If no tiebreak is given, the
                    first containing interval will be chosen.
   :type tiebreak: (optional) pdarray, numeric
   :param hierarchical: When True, sequences of pdarrays will be treated as components specifying
                        a single dimension (i.e. hierarchical)
                        When False, sequences of pdarrays will be specifying multi-dimensional intervals
   :type hierarchical: boolean

   :returns: **idx** -- Index of interval containing each query value, or -1 if not found
   :rtype: pdarray(int64)

   .. rubric:: Notes

   The return idx satisfies the following condition:
       present = idx > -1
       ((intervals[0][idx[present]] <= vals[present]) &
        (intervals[1][idx[present]] >= vals[present])).all()

   .. rubric:: Examples

   >>> starts = (ak.array([0, 5]), ak.array([0, 11]))
   >>> ends = (ak.array([5, 9]), ak.array([10, 20]))
   >>> vals = (ak.array([0, 0, 2, 5, 5, 6, 6, 9]), ak.array([0, 20, 1, 5, 15, 0, 12, 30]))
   >>> ak.search_intervals(vals, (starts, ends))
   array([0 -1 0 0 1 -1 1 -1])
   >>> ak.search_intervals(vals, (starts, ends), hierarchical=True)
   array([0 0 0 0 1 1 1 -1])


.. py:function:: is_cosorted(arrays)

   Return True iff the arrays are cosorted, i.e., if the arrays were columns in a table
   then the rows are sorted.

   :param arrays: Arrays to check for cosortedness
   :type arrays: list-like of pdarrays

   :returns: True iff arrays are cosorted.
   :rtype: bool

   :raises ValueError: Raised if arrays are not the same length
   :raises TypeError: Raised if arrays is not a list-like of pdarrays


.. py:function:: interval_lookup(keys, values, arguments, fillvalue=-1, tiebreak=None, hierarchical=False)

   Apply a function defined over intervals to an array of arguments.

   :param keys: Tuple of closed intervals expressed as (lower_bounds_inclusive, upper_bounds_inclusive).
                Must have same dtype(s) as vals.
   :type keys: 2-tuple of (sequences of) pdarrays
   :param values: Function value to return for each entry in keys.
   :type values: pdarray
   :param arguments: Values to search for in intervals. If multiple arrays, each "row" is an item.
   :type arguments: (sequences of) pdarray
   :param fillvalue: Default value to return when argument is not in any interval.
   :type fillvalue: scalar
   :param tiebreak: When an argument is present in more than one key interval, the interval with the
                    lowest tiebreak value will be chosen. If no tiebreak is given, the
                    first valid key interval will be chosen.
   :type tiebreak: (optional) pdarray, numeric

   :returns: Value of function corresponding to the keys interval
             containing each argument, or fillvalue if argument not
             in any interval.
   :rtype: pdarray


