arkouda
=======

.. py:module:: arkouda

.. autoapi-nested-parse::

   Arkouda: Exploratory data science at scale.

   Arkouda is a Python API for exploratory data analysis on massive datasets. It
   leverages a Chapel-based backend to enable high-performance computing on
   distributed systems, while exposing a familiar NumPy- and Pandas-like interface
   to Python users.

   Key Features
   ------------
   - `pdarray` and `Strings` types for working with large numeric and string arrays.
   - `Categorical`, `Series`, `DataFrame`, and `Index` for labeled data analysis.
   - High-performance `GroupBy`, reductions, and broadcasting operations.
   - Interoperability with NumPy and Pandas for ease of use.
   - A scalable architecture suitable for HPC and cloud environments.

   Example:
   -------
   >>> import arkouda as ak
   >>> ak.connect()
   >>> a = ak.array([1, 2, 3])
   >>> b = a + 5
   >>> print(b)
   array([6 7 8])

   For full documentation, visit: https://bears-r-us.github.io/arkouda/



Submodules
----------

.. toctree::
   :maxdepth: 1

   /autoapi/arkouda/accessor/index
   /autoapi/arkouda/alignment/index
   /autoapi/arkouda/apply/index
   /autoapi/arkouda/array_api/index
   /autoapi/arkouda/client/index
   /autoapi/arkouda/client_dtypes/index
   /autoapi/arkouda/comm_diagnostics/index
   /autoapi/arkouda/core/index
   /autoapi/arkouda/history/index
   /autoapi/arkouda/infoclass/index
   /autoapi/arkouda/logger/index
   /autoapi/arkouda/message/index
   /autoapi/arkouda/numpy/index
   /autoapi/arkouda/pandas/index
   /autoapi/arkouda/plotting/index
   /autoapi/arkouda/scipy/index
   /autoapi/arkouda/security/index
   /autoapi/arkouda/testing/index


Attributes
----------

.. autoapisummary::

   arkouda.AllSymbols
   arkouda.ArkoudaArrayLike
   arkouda.RegisteredSymbols


Classes
-------

.. autoapisummary::

   arkouda.ArkoudaArray
   arkouda.ArkoudaBigintDtype
   arkouda.ArkoudaBoolDtype
   arkouda.ArkoudaCategoricalArray
   arkouda.ArkoudaCategoricalDtype
   arkouda.ArkoudaFloat64Dtype
   arkouda.ArkoudaInt64Dtype
   arkouda.ArkoudaStringArray
   arkouda.ArkoudaStringDtype
   arkouda.ArkoudaUint64Dtype
   arkouda.ArkoudaUint8Dtype
   arkouda.CachedAccessor
   arkouda.DatetimeAccessor
   arkouda.LogLevel
   arkouda.Power_divergenceResult
   arkouda.Properties
   arkouda.Row
   arkouda.Series
   arkouda.StringAccessor


Functions
---------

.. autoapisummary::

   arkouda.apply
   arkouda.assert_almost_equal
   arkouda.assert_almost_equivalent
   arkouda.assert_arkouda_array_equal
   arkouda.assert_arkouda_array_equivalent
   arkouda.assert_arkouda_pdarray_equal
   arkouda.assert_arkouda_segarray_equal
   arkouda.assert_arkouda_strings_equal
   arkouda.assert_attr_equal
   arkouda.assert_categorical_equal
   arkouda.assert_class_equal
   arkouda.assert_contains_all
   arkouda.assert_copy
   arkouda.assert_dict_equal
   arkouda.assert_equal
   arkouda.assert_equivalent
   arkouda.assert_frame_equal
   arkouda.assert_frame_equivalent
   arkouda.assert_index_equal
   arkouda.assert_index_equivalent
   arkouda.assert_is_sorted
   arkouda.assert_series_equal
   arkouda.assert_series_equivalent
   arkouda.chisquare
   arkouda.compute_join_size
   arkouda.date_operators
   arkouda.disableVerbose
   arkouda.disable_verbose
   arkouda.enableVerbose
   arkouda.enable_verbose
   arkouda.from_series
   arkouda.gen_ranges
   arkouda.information
   arkouda.join_on_eq_with_dt
   arkouda.list_registry
   arkouda.list_symbol_table
   arkouda.power_divergence
   arkouda.pretty_print_information
   arkouda.string_operators
   arkouda.write_log
   arkouda.xlogy


Package Contents
----------------

.. py:data:: AllSymbols
   :value: '__AllSymbols__'


.. py:class:: ArkoudaArray(data: arkouda.numpy.pdarrayclass.pdarray | numpy.ndarray | Sequence[Any] | ArkoudaArray, dtype: Any = None, copy: bool = False)

   Bases: :py:obj:`arkouda.pandas.extension._arkouda_extension_array.ArkoudaExtensionArray`, :py:obj:`pandas.api.extensions.ExtensionArray`


   Arkouda-backed numeric/bool pandas ExtensionArray.

   Wraps or converts supported inputs into an Arkouda ``pdarray`` to serve as the
   backing store. Ensures the underlying array is 1-D and lives on the Arkouda server.

   :param data: Input to wrap or convert.
                - If an Arkouda ``pdarray``, it is used directly unless ``dtype`` is given
                  or ``copy=True``, in which case a new array is created via ``ak.array``.
                - If a NumPy array, it is transferred to Arkouda via ``ak.array``.
                - If a Python sequence, it is converted to NumPy then to Arkouda.
                - If another ``ArkoudaArray``, its underlying ``pdarray`` is reused.
   :type data: pdarray | ndarray | Sequence[Any] | ArkoudaArray
   :param dtype: Desired dtype to cast to (NumPy dtype or Arkouda dtype string). If omitted,
                 dtype is inferred from ``data``.
   :type dtype: Any, optional
   :param copy: If True, attempt to copy the underlying data when converting/wrapping.
                Default is False.
   :type copy: bool

   :raises TypeError: If ``data`` cannot be interpreted as an Arkouda array-like object.
   :raises ValueError: If the resulting array is not one-dimensional.

   .. attribute:: default_fill_value

      Sentinel used when filling missing values (default: -1).

      :type: int

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> from arkouda.pandas.extension import ArkoudaArray
   >>> ArkoudaArray(ak.arange(5))
   ArkoudaArray([0 1 2 3 4])
   >>> ArkoudaArray([10, 20, 30])
   ArkoudaArray([10 20 30])


   .. py:method:: all(axis=0, skipna=True, **kwargs)

      Return whether all elements are True.

      This is mainly to support pandas' BaseExtensionArray.equals, which
      calls `.all()` on the result of a boolean expression.



   .. py:method:: any(axis=0, skipna=True, **kwargs)

      Return whether any element is True.

      Added for symmetry with `.all()` and to support potential pandas
      boolean-reduction calls.



   .. py:method:: astype(dtype: numpy.dtype[Any], copy: bool = True) -> numpy.typing.NDArray[Any]
                  astype(dtype: pandas.core.dtypes.dtypes.ExtensionDtype, copy: bool = True) -> pandas.api.extensions.ExtensionArray
                  astype(dtype: Any, copy: bool = True) -> Union[pandas.api.extensions.ExtensionArray, numpy.typing.NDArray[Any]]

      Cast the array to a specified dtype.

      Casting rules:

      * If ``dtype`` requests ``object``, returns a NumPy ``NDArray[Any]`` of
        dtype ``object`` containing the array values.
      * Otherwise, the target dtype is normalized using Arkouda's dtype
        resolution rules.
      * If the normalized dtype matches the current dtype and ``copy=False``,
        returns ``self``.
      * In all other cases, casts the underlying Arkouda array to the target
        dtype and returns an Arkouda-backed ``ArkoudaExtensionArray``.

      :param dtype: Target dtype. May be a NumPy dtype, pandas dtype, Arkouda dtype,
                    or any dtype-like object accepted by Arkouda.
      :type dtype: Any
      :param copy: Whether to force a copy when the target dtype matches the current dtype.
                   Default is True.
      :type copy: bool

      :returns: The cast result. Returns a NumPy array only when casting to ``object``;
                otherwise returns an Arkouda-backed ExtensionArray.
      :rtype: Union[ExtensionArray, NDArray[Any]]

      .. rubric:: Examples

      Basic numeric casting returns an Arkouda-backed array:

      >>> import arkouda as ak
      >>> from arkouda.pandas.extension import ArkoudaArray
      >>> a = ArkoudaArray(ak.array([1, 2, 3], dtype="int64"))
      >>> a.astype("float64").to_ndarray()
      array([1., 2., 3.])

      Casting to the same dtype with ``copy=False`` returns the original object:

      >>> b = a.astype("int64", copy=False)
      >>> b is a
      True

      Forcing a copy when the dtype is unchanged returns a new array:

      >>> c = a.astype("int64", copy=True)
      >>> c is a
      False
      >>> c.to_ndarray()
      array([1, 2, 3])

      Casting to ``object`` materializes the data to a NumPy array:

      >>> a.astype(object)
      array([1, 2, 3], dtype=object)

      NumPy and pandas dtype objects are also accepted:

      >>> import numpy as np
      >>> a.astype(np.dtype("bool")).to_ndarray()
      array([ True,  True,  True])



   .. py:attribute:: default_fill_value
      :type:  int
      :value: -1



   .. py:property:: dtype

      An instance of ExtensionDtype.

      .. seealso::

         :py:obj:`api.extensions.ExtensionDtype`
             Base class for extension dtypes.

         :py:obj:`api.extensions.ExtensionArray`
             Base class for extension array types.

         :py:obj:`api.extensions.ExtensionArray.dtype`
             The dtype of an ExtensionArray.

         :py:obj:`Series.dtype`
             The dtype of a Series.

         :py:obj:`DataFrame.dtype`
             The dtype of a DataFrame.

      .. rubric:: Examples

      >>> pd.array([1, 2, 3]).dtype
      Int64Dtype()


   .. py:method:: equals(other)

      Return if another array is equivalent to this array.

      Equivalent means that both arrays have the same shape and dtype, and
      all values compare equal. Missing values in the same location are
      considered equal (in contrast with normal equality).

      :param other: Array to compare to this Array.
      :type other: ExtensionArray

      :returns: Whether the arrays are equivalent.
      :rtype: boolean

      .. seealso::

         :py:obj:`numpy.array_equal`
             Equivalent method for numpy array.

         :py:obj:`Series.equals`
             Equivalent method for Series.

         :py:obj:`DataFrame.equals`
             Equivalent method for DataFrame.

      .. rubric:: Examples

      >>> arr1 = pd.array([1, 2, np.nan])
      >>> arr2 = pd.array([1, 2, np.nan])
      >>> arr1.equals(arr2)
      True

      >>> arr1 = pd.array([1, 3, np.nan])
      >>> arr2 = pd.array([1, 2, np.nan])
      >>> arr1.equals(arr2)
      False



   .. py:method:: isna() -> numpy.ndarray

      Return a boolean mask indicating missing values.

      This method implements the pandas ExtensionArray.isna contract
      and always returns a NumPy ndarray of dtype ``bool`` with the
      same length as the array.

      :returns: A boolean mask where ``True`` marks elements considered missing.
      :rtype: np.ndarray

      :raises TypeError: If the underlying data buffer does not support missing-value
          detection or cannot produce a boolean mask.



   .. py:method:: isnull()

      Alias for isna().



   .. py:property:: nbytes

      The number of bytes needed to store this object in memory.

      .. seealso::

         :py:obj:`ExtensionArray.shape`
             Return a tuple of the array dimensions.

         :py:obj:`ExtensionArray.size`
             The number of elements in the array.

      .. rubric:: Examples

      >>> pd.array([1, 2, 3]).nbytes
      27


   .. py:method:: value_counts(dropna: bool = True) -> pandas.Series

      Return counts of unique values as a pandas Series.

      This method computes the frequency of each distinct value in the
      underlying Arkouda array and returns the result as a pandas
      ``Series``, with the unique values as the index and their counts
      as the data.

      :param dropna: Whether to exclude missing values. Currently, missing-value
                     handling is supported only for floating-point data, where
                     ``NaN`` values are treated as missing. Default is True.
      :type dropna: bool

      :returns: A Series containing the counts of unique values.
                The index is an ``ArkoudaArray`` of unique values, and the
                values are an ``ArkoudaArray`` of counts.
      :rtype: pd.Series

      .. rubric:: Notes

      - Only ``dropna=True`` is supported.
      - The following pandas options are not yet implemented:
        ``normalize``, ``sort``, and ``bins``.
      - Counting is performed server-side in Arkouda; only the small
        result (unique values and counts) is materialized on the client.

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> from arkouda.pandas.extension import ArkoudaArray
      >>>
      >>> a = ArkoudaArray(ak.array([1, 2, 1, 3, 2, 1]))
      >>> a.value_counts()
      1    3
      2    2
      3    1
      dtype: int64

      Floating-point data with NaN values:

      >>> b = ArkoudaArray(ak.array([1.0, 2.0, float("nan"), 1.0]))
      >>> b.value_counts()
      1.0    2
      2.0    1
      dtype: int64



.. py:data:: ArkoudaArrayLike

.. py:class:: ArkoudaBigintDtype

   Bases: :py:obj:`_ArkoudaBaseDtype`


   Arkouda-backed arbitrary-precision integer dtype.

   This dtype integrates Arkouda's server-backed ``pdarray<bigint>`` with
   the pandas ExtensionArray interface via :class:`ArkoudaArray`. It enables
   pandas objects (Series, DataFrame) to hold and operate on very large
   integers that exceed 64-bit precision, while keeping the data distributed
   on the Arkouda server.

   .. method:: construct_array_type()

      Returns the :class:`ArkoudaArray` class used for storage.



   .. py:method:: construct_array_type()
      :classmethod:


      Return the ExtensionArray subclass that handles storage for this dtype.

      :returns: The :class:`ArkoudaArray` class associated with this dtype.
      :rtype: type



   .. py:attribute:: kind
      :value: 'O'


      A character code (one of 'biufcmMOSUV'), default 'O'

      This should match the NumPy dtype used when the array is
      converted to an ndarray, which is probably 'O' for object if
      the extension type cannot be represented as a built-in NumPy
      type.

      .. seealso:: :py:obj:`numpy.dtype.kind`


   .. py:attribute:: na_value
      :value: -1


      Default NA value to use for this type.

      This is used in e.g. ExtensionArray.take. This should be the
      user-facing "boxed" version of the NA value, not the physical NA value
      for storage.  e.g. for JSONArray, this is an empty dictionary.


   .. py:attribute:: name
      :value: 'bigint'


      A string identifying the data type.

      Will be used for display in, e.g. ``Series.dtype``


   .. py:attribute:: type

      The scalar type for the array, e.g. ``int``

      It's expected ``ExtensionArray[item]`` returns an instance
      of ``ExtensionDtype.type`` for scalar ``item``, assuming
      that value is valid (not NA). NA values do not need to be
      instances of `type`.


.. py:class:: ArkoudaBoolDtype

   Bases: :py:obj:`_ArkoudaBaseDtype`


   Arkouda-backed boolean dtype.

   This dtype integrates Arkouda's server-backed `pdarray<bool>` with
   the pandas ExtensionArray interface via :class:`ArkoudaArray`. It allows
   pandas objects (Series, DataFrame) to store and manipulate distributed
   boolean arrays without materializing them on the client.

   .. method:: construct_array_type()

      Returns the :class:`ArkoudaArray` class used for storage.



   .. py:method:: construct_array_type()
      :classmethod:


      Return the ExtensionArray subclass that handles storage for this dtype.

      :returns: The :class:`ArkoudaArray` class associated with this dtype.
      :rtype: type



   .. py:attribute:: kind
      :value: 'b'


      A character code (one of 'biufcmMOSUV'), default 'O'

      This should match the NumPy dtype used when the array is
      converted to an ndarray, which is probably 'O' for object if
      the extension type cannot be represented as a built-in NumPy
      type.

      .. seealso:: :py:obj:`numpy.dtype.kind`


   .. py:attribute:: na_value
      :value: False


      Default NA value to use for this type.

      This is used in e.g. ExtensionArray.take. This should be the
      user-facing "boxed" version of the NA value, not the physical NA value
      for storage.  e.g. for JSONArray, this is an empty dictionary.


   .. py:attribute:: name
      :value: 'bool_'


      A string identifying the data type.

      Will be used for display in, e.g. ``Series.dtype``


   .. py:attribute:: type

      The scalar type for the array, e.g. ``int``

      It's expected ``ExtensionArray[item]`` returns an instance
      of ``ExtensionDtype.type`` for scalar ``item``, assuming
      that value is valid (not NA). NA values do not need to be
      instances of `type`.


.. py:class:: ArkoudaCategoricalArray(data: arkouda.categorical.Categorical | ArkoudaCategoricalArray | numpy.ndarray | Sequence[Any])

   Bases: :py:obj:`arkouda.pandas.extension._arkouda_extension_array.ArkoudaExtensionArray`, :py:obj:`pandas.api.extensions.ExtensionArray`


   Arkouda-backed categorical pandas ExtensionArray.

   Ensures the underlying data is an Arkouda ``Categorical``. Accepts an existing
   ``Categorical`` or converts from Python/NumPy sequences of labels.

   :param data: Input to wrap or convert.
                - If ``Categorical``, used directly.
                - If another ``ArkoudaCategoricalArray``, its backing object is reused.
                - If list/tuple/ndarray, converted via ``ak.Categorical(ak.array(data))``.
   :type data: Categorical | ArkoudaCategoricalArray | ndarray | Sequence[Any]

   :raises TypeError: If ``data`` cannot be converted to Arkouda ``Categorical``.

   .. attribute:: default_fill_value

      Sentinel used when filling missing values (default: "").

      :type: str


   .. py:method:: add_categories(*args, **kwargs)


   .. py:method:: as_ordered(*args, **kwargs)


   .. py:method:: as_unordered(*args, **kwargs)


   .. py:method:: astype(dtype: numpy.dtype[Any], copy: bool = True) -> numpy.typing.NDArray[Any]
                  astype(dtype: pandas.core.dtypes.dtypes.ExtensionDtype, copy: bool = True) -> pandas.api.extensions.ExtensionArray
                  astype(dtype: Any, copy: bool = True) -> Union[pandas.api.extensions.ExtensionArray, numpy.typing.NDArray[Any]]

      Cast to a specified dtype.

      * If ``dtype`` is categorical (pandas ``category`` / ``CategoricalDtype`` /
        ``ArkoudaCategoricalDtype``), returns an Arkouda-backed
        ``ArkoudaCategoricalArray`` (optionally copied).
      * If ``dtype`` requests ``object``, returns a NumPy ``ndarray`` of dtype object
        containing the category labels (materialized to the client).
      * If ``dtype`` requests a string dtype, returns an Arkouda-backed
        ``ArkoudaStringArray`` containing the labels as strings.
      * Otherwise, casts the labels (as strings) to the requested dtype and returns an
        Arkouda-backed ExtensionArray.

      :param dtype: Target dtype.
      :type dtype: Any
      :param copy: Whether to force a copy when possible. If categorical-to-categorical and
                   ``copy=True``, attempts to copy the underlying Arkouda ``Categorical`` (if
                   supported). Default is True.
      :type copy: bool

      :returns: The cast result. Returns a NumPy array only when casting to ``object``;
                otherwise returns an Arkouda-backed ExtensionArray.
      :rtype: Union[ExtensionArray, NDArray[Any]]

      .. rubric:: Examples

      Casting to ``category`` returns an Arkouda-backed categorical array:

      >>> import arkouda as ak
      >>> from arkouda.pandas.extension import ArkoudaCategoricalArray
      >>> c = ArkoudaCategoricalArray(ak.Categorical(ak.array(["x", "y", "x"])))
      >>> out = c.astype("category")
      >>> out is c
      False

      Forcing a copy when casting to the same categorical dtype returns a new array:

      >>> out2 = c.astype("category", copy=True)
      >>> out2 is c
      False
      >>> out2.to_ndarray()
      array(['x', 'y', 'x'], dtype='<U...')

      Casting to ``object`` materializes the category labels to a NumPy object array:

      >>> c.astype(object)
      array(['x', 'y', 'x'], dtype=object)

      Casting to a string dtype returns an Arkouda-backed string array of labels:

      >>> s = c.astype("string")
      >>> s.to_ndarray()
      array(['x', 'y', 'x'], dtype='<U1')

      Casting to another dtype casts the labels-as-strings and returns an Arkouda-backed array:

      >>> c_num = ArkoudaCategoricalArray(ak.Categorical(ak.array(["1", "2", "3"])))
      >>> a = c_num.astype("int64")
      >>> a.to_ndarray()
      array([1, 2, 3])



   .. py:method:: check_for_ordered(*args, **kwargs)


   .. py:attribute:: default_fill_value
      :type:  str
      :value: ''



   .. py:method:: describe(*args, **kwargs)


   .. py:property:: dtype

      An instance of ExtensionDtype.

      .. seealso::

         :py:obj:`api.extensions.ExtensionDtype`
             Base class for extension dtypes.

         :py:obj:`api.extensions.ExtensionArray`
             Base class for extension array types.

         :py:obj:`api.extensions.ExtensionArray.dtype`
             The dtype of an ExtensionArray.

         :py:obj:`Series.dtype`
             The dtype of a Series.

         :py:obj:`DataFrame.dtype`
             The dtype of a DataFrame.

      .. rubric:: Examples

      >>> pd.array([1, 2, 3]).dtype
      Int64Dtype()


   .. py:method:: from_codes(*args, **kwargs)
      :classmethod:

      :abstractmethod:



   .. py:method:: isna()

      A 1-D array indicating if each value is missing.

      :returns: In most cases, this should return a NumPy ndarray. For
                exceptional cases like ``SparseArray``, where returning
                an ndarray would be expensive, an ExtensionArray may be
                returned.
      :rtype: numpy.ndarray or pandas.api.extensions.ExtensionArray

      .. seealso::

         :py:obj:`ExtensionArray.dropna`
             Return ExtensionArray without NA values.

         :py:obj:`ExtensionArray.fillna`
             Fill NA/NaN values using the specified method.

      .. rubric:: Notes

      If returning an ExtensionArray, then

      * ``na_values._is_boolean`` should be True
      * ``na_values`` should implement :func:`ExtensionArray._reduce`
      * ``na_values`` should implement :func:`ExtensionArray._accumulate`
      * ``na_values.any`` and ``na_values.all`` should be implemented

      .. rubric:: Examples

      >>> arr = pd.array([1, 2, np.nan, np.nan])
      >>> arr.isna()
      array([False, False,  True,  True])



   .. py:method:: isnull(*args, **kwargs)


   .. py:method:: max(*args, **kwargs)


   .. py:method:: memory_usage(*args, **kwargs)


   .. py:method:: min(*args, **kwargs)


   .. py:method:: notna(*args, **kwargs)


   .. py:method:: notnull(*args, **kwargs)


   .. py:method:: remove_categories(*args, **kwargs)


   .. py:method:: remove_unused_categories(*args, **kwargs)


   .. py:method:: rename_categories(*args, **kwargs)


   .. py:method:: reorder_categories(*args, **kwargs)


   .. py:method:: set_categories(*args, **kwargs)


   .. py:method:: set_ordered(*args, **kwargs)


   .. py:method:: sort_values(*args, **kwargs)


   .. py:method:: to_list(*args, **kwargs)


   .. py:method:: value_counts(dropna: bool = True) -> pandas.Series

      Return counts of categories as a pandas Series.

      This method computes category frequencies from the underlying Arkouda
      ``Categorical`` and returns them as a pandas ``Series``, where the
      index contains the category labels and the values contain the
      corresponding counts.

      :param dropna: Whether to drop missing values from the result. When ``True``,
                     the result is filtered using the categorical's ``na_value``.
                     When ``False``, all categories returned by the underlying
                     computation are included. Default is True.
      :type dropna: bool

      :returns: A Series containing category counts.
                The index is an ``ArkoudaStringArray`` of category labels and the
                values are an ``ArkoudaArray`` of counts.
      :rtype: pd.Series

      .. rubric:: Notes

      - The result is computed server-side in Arkouda; only the (typically small)
        output of categories and counts is materialized for the pandas ``Series``.
      - This method does not yet support pandas options such as ``normalize``,
        ``sort``, or ``bins``.
      - The handling of missing values depends on the Arkouda ``Categorical``
        definition of ``na_value``.

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> from arkouda.pandas.extension import ArkoudaCategoricalArray
      >>>
      >>> a = ArkoudaCategoricalArray(["a", "b", "a", "c", "b", "a"])
      >>> a.value_counts()
      a    3
      b    2
      c    1
      dtype: int64



.. py:class:: ArkoudaCategoricalDtype

   Bases: :py:obj:`_ArkoudaBaseDtype`


   Arkouda-backed categorical dtype.

   This dtype integrates Arkouda's distributed ``Categorical`` type with
   the pandas ExtensionArray interface via :class:`ArkoudaCategoricalArray`.
   It enables pandas objects (Series, DataFrame) to hold categorical data
   stored and processed on the Arkouda server, while exposing familiar
   pandas APIs.

   .. method:: construct_array_type()

      Returns the :class:`ArkoudaCategoricalArray` used as the storage class.



   .. py:method:: construct_array_type()
      :classmethod:


      Return the ExtensionArray subclass that handles storage for this dtype.

      :returns: The :class:`ArkoudaCategoricalArray` class associated with this dtype.
      :rtype: type



   .. py:attribute:: kind
      :value: 'O'


      A character code (one of 'biufcmMOSUV'), default 'O'

      This should match the NumPy dtype used when the array is
      converted to an ndarray, which is probably 'O' for object if
      the extension type cannot be represented as a built-in NumPy
      type.

      .. seealso:: :py:obj:`numpy.dtype.kind`


   .. py:attribute:: na_value
      :value: -1


      Default NA value to use for this type.

      This is used in e.g. ExtensionArray.take. This should be the
      user-facing "boxed" version of the NA value, not the physical NA value
      for storage.  e.g. for JSONArray, this is an empty dictionary.


   .. py:attribute:: name
      :value: 'category'


      A string identifying the data type.

      Will be used for display in, e.g. ``Series.dtype``


   .. py:attribute:: type

      The scalar type for the array, e.g. ``int``

      It's expected ``ExtensionArray[item]`` returns an instance
      of ``ExtensionDtype.type`` for scalar ``item``, assuming
      that value is valid (not NA). NA values do not need to be
      instances of `type`.


.. py:class:: ArkoudaFloat64Dtype

   Bases: :py:obj:`_ArkoudaBaseDtype`


   Arkouda-backed 64-bit floating-point dtype.

   This dtype integrates Arkouda's server-backed `pdarray<float64>` with
   the pandas ExtensionArray interface via :class:`ArkoudaArray`. It allows
   pandas objects (Series, DataFrame) to store and manipulate large
   distributed float64 arrays without materializing them on the client.

   .. method:: construct_array_type()

      Returns the :class:`ArkoudaArray` class used for storage.



   .. py:method:: construct_array_type()
      :classmethod:


      Return the ExtensionArray subclass that handles storage for this dtype.

      :returns: The :class:`ArkoudaArray` class associated with this dtype.
      :rtype: type



   .. py:attribute:: kind
      :value: 'f'


      A character code (one of 'biufcmMOSUV'), default 'O'

      This should match the NumPy dtype used when the array is
      converted to an ndarray, which is probably 'O' for object if
      the extension type cannot be represented as a built-in NumPy
      type.

      .. seealso:: :py:obj:`numpy.dtype.kind`


   .. py:attribute:: na_value

      Default NA value to use for this type.

      This is used in e.g. ExtensionArray.take. This should be the
      user-facing "boxed" version of the NA value, not the physical NA value
      for storage.  e.g. for JSONArray, this is an empty dictionary.


   .. py:attribute:: name
      :value: 'float64'


      A string identifying the data type.

      Will be used for display in, e.g. ``Series.dtype``


   .. py:attribute:: type

      The scalar type for the array, e.g. ``int``

      It's expected ``ExtensionArray[item]`` returns an instance
      of ``ExtensionDtype.type`` for scalar ``item``, assuming
      that value is valid (not NA). NA values do not need to be
      instances of `type`.


.. py:class:: ArkoudaInt64Dtype

   Bases: :py:obj:`_ArkoudaBaseDtype`


   Extension dtype for Arkouda-backed 64-bit integers.

   This dtype allows seamless use of Arkouda's distributed ``int64``
   arrays inside pandas objects (``Series``, ``Index``, ``DataFrame``).
   It is backed by :class:`arkouda.pdarray` with ``dtype='int64'``
   and integrates with pandas via the
   :class:`~arkouda.pandas.extension._arkouda_array.ArkoudaArray`
   extension array.

   .. method:: construct_array_type()

      Return the associated extension array class
      (:class:`ArkoudaArray`).



   .. py:method:: construct_array_type()
      :classmethod:


      Return the associated pandas ExtensionArray type.

      This is part of the pandas ExtensionDtype interface and is used
      internally by pandas when constructing arrays of this dtype.
      It ensures that operations like ``Series(..., dtype=ArkoudaInt64Dtype())``
      produce the correct Arkouda-backed extension array.

      :returns: The :class:`ArkoudaArray` class that implements the storage
                and behavior for this dtype.
      :rtype: type

      .. rubric:: Notes

      - This hook tells pandas which ExtensionArray to instantiate
        whenever this dtype is requested.
      - All Arkouda dtypes defined in this module will return
        :class:`ArkoudaArray` (or a subclass thereof).

      .. rubric:: Examples

      >>> from arkouda.pandas.extension import ArkoudaInt64Dtype
      >>> ArkoudaInt64Dtype.construct_array_type()
      <class 'arkouda.pandas.extension._arkouda_array.ArkoudaArray'>



   .. py:attribute:: kind
      :value: 'i'


      A character code (one of 'biufcmMOSUV'), default 'O'

      This should match the NumPy dtype used when the array is
      converted to an ndarray, which is probably 'O' for object if
      the extension type cannot be represented as a built-in NumPy
      type.

      .. seealso:: :py:obj:`numpy.dtype.kind`


   .. py:attribute:: na_value
      :value: -1


      Default NA value to use for this type.

      This is used in e.g. ExtensionArray.take. This should be the
      user-facing "boxed" version of the NA value, not the physical NA value
      for storage.  e.g. for JSONArray, this is an empty dictionary.


   .. py:attribute:: name
      :value: 'int64'


      A string identifying the data type.

      Will be used for display in, e.g. ``Series.dtype``


   .. py:attribute:: type

      The scalar type for the array, e.g. ``int``

      It's expected ``ExtensionArray[item]`` returns an instance
      of ``ExtensionDtype.type`` for scalar ``item``, assuming
      that value is valid (not NA). NA values do not need to be
      instances of `type`.


.. py:class:: ArkoudaStringArray(data: arkouda.numpy.strings.Strings | numpy.ndarray | Sequence[Any] | ArkoudaStringArray)

   Bases: :py:obj:`arkouda.pandas.extension._arkouda_extension_array.ArkoudaExtensionArray`, :py:obj:`pandas.api.extensions.ExtensionArray`


   Arkouda-backed string pandas ExtensionArray.

   Ensures the underlying data is an Arkouda ``Strings`` object. Accepts existing
   ``Strings`` or converts from NumPy arrays and Python sequences of strings.

   :param data: Input to wrap or convert.
                - If ``Strings``, used directly.
                - If NumPy/sequence, converted via ``ak.array``.
                - If another ``ArkoudaStringArray``, its backing ``Strings`` is reused.
   :type data: Strings | ndarray | Sequence[Any] | ArkoudaStringArray

   :raises TypeError: If ``data`` cannot be converted to Arkouda ``Strings``.

   .. attribute:: default_fill_value

      Sentinel used when filling missing values (default: "").

      :type: str


   .. py:method:: all(*args, **kwargs)


   .. py:method:: any(*args, **kwargs)


   .. py:method:: argpartition(*args, **kwargs)


   .. py:method:: astype(dtype: numpy.dtype[Any], copy: bool = True) -> numpy.typing.NDArray[Any]
                  astype(dtype: pandas.core.dtypes.dtypes.ExtensionDtype, copy: bool = True) -> pandas.api.extensions.ExtensionArray
                  astype(dtype: Any, copy: bool = True) -> Union[pandas.api.extensions.ExtensionArray, numpy.typing.NDArray[Any]]

      Cast to a specified dtype.

      Casting rules:

      * If ``dtype`` requests ``object``, returns a NumPy ``NDArray[Any]`` of dtype
        ``object`` containing the string values.
      * If ``dtype`` is a string dtype (e.g. pandas ``StringDtype``, NumPy unicode,
        or Arkouda string dtype), returns an ``ArkoudaStringArray``. If ``copy=True``,
        attempts to copy the underlying Arkouda ``Strings`` data.
      * For all other dtypes, casts the underlying Arkouda ``Strings`` using
        ``Strings.astype`` and returns an Arkouda-backed ``ArkoudaExtensionArray``
        constructed from the result.

      :param dtype: Target dtype. May be a NumPy dtype, pandas dtype, or Arkouda dtype.
      :type dtype: Any
      :param copy: Whether to force a copy when the result is an ``ArkoudaStringArray``.
                   Default is True.
      :type copy: bool

      :returns: The cast result. Returns a NumPy array only when casting to ``object``;
                otherwise returns an Arkouda-backed ExtensionArray.
      :rtype: Union[ExtensionArray, NDArray[Any]]

      .. rubric:: Examples

      Casting to a string dtype returns an Arkouda-backed string array:

      >>> import arkouda as ak
      >>> from arkouda.pandas.extension import ArkoudaStringArray
      >>> s = ArkoudaStringArray(ak.array(["a", "b", "c"]))
      >>> out = s.astype("string")
      >>> out is s
      False

      Forcing a copy when casting to a string dtype returns a new array:

      >>> out2 = s.astype("string", copy=True)
      >>> out2 is s
      False
      >>> out2.to_ndarray()
      array(['a', 'b', 'c'], dtype='<U1')

      Casting to ``object`` materializes the data to a NumPy array:

      >>> s.astype(object)
      array(['a', 'b', 'c'], dtype=object)

      Casting to a non-string dtype uses Arkouda to cast the underlying strings
      and returns an Arkouda-backed ExtensionArray:

      >>> s_num = ArkoudaStringArray(ak.array(["1", "2", "3"]))
      >>> a = s_num.astype("int64")
      >>> a.to_ndarray()
      array([1, 2, 3])

      NumPy and pandas dtype objects are also accepted:

      >>> import numpy as np
      >>> a = s_num.astype(np.dtype("float64"))
      >>> a.to_ndarray()
      array([1., 2., 3.])



   .. py:method:: byteswap(*args, **kwargs)


   .. py:method:: choose(*args, **kwargs)


   .. py:method:: clip(*args, **kwargs)


   .. py:method:: compress(*args, **kwargs)


   .. py:method:: conj(*args, **kwargs)


   .. py:method:: conjugate(*args, **kwargs)


   .. py:method:: cumprod(*args, **kwargs)


   .. py:method:: cumsum(*args, **kwargs)


   .. py:attribute:: default_fill_value
      :type:  str
      :value: ''



   .. py:method:: diagonal(*args, **kwargs)


   .. py:method:: dot(*args, **kwargs)


   .. py:property:: dtype

      An instance of ExtensionDtype.

      .. seealso::

         :py:obj:`api.extensions.ExtensionDtype`
             Base class for extension dtypes.

         :py:obj:`api.extensions.ExtensionArray`
             Base class for extension array types.

         :py:obj:`api.extensions.ExtensionArray.dtype`
             The dtype of an ExtensionArray.

         :py:obj:`Series.dtype`
             The dtype of a Series.

         :py:obj:`DataFrame.dtype`
             The dtype of a DataFrame.

      .. rubric:: Examples

      >>> pd.array([1, 2, 3]).dtype
      Int64Dtype()


   .. py:method:: dump(*args, **kwargs)


   .. py:method:: dumps(*args, **kwargs)


   .. py:method:: fill(*args, **kwargs)


   .. py:method:: flatten(*args, **kwargs)


   .. py:method:: getfield(*args, **kwargs)


   .. py:method:: isna()

      A 1-D array indicating if each value is missing.

      :returns: In most cases, this should return a NumPy ndarray. For
                exceptional cases like ``SparseArray``, where returning
                an ndarray would be expensive, an ExtensionArray may be
                returned.
      :rtype: numpy.ndarray or pandas.api.extensions.ExtensionArray

      .. seealso::

         :py:obj:`ExtensionArray.dropna`
             Return ExtensionArray without NA values.

         :py:obj:`ExtensionArray.fillna`
             Fill NA/NaN values using the specified method.

      .. rubric:: Notes

      If returning an ExtensionArray, then

      * ``na_values._is_boolean`` should be True
      * ``na_values`` should implement :func:`ExtensionArray._reduce`
      * ``na_values`` should implement :func:`ExtensionArray._accumulate`
      * ``na_values.any`` and ``na_values.all`` should be implemented

      .. rubric:: Examples

      >>> arr = pd.array([1, 2, np.nan, np.nan])
      >>> arr.isna()
      array([False, False,  True,  True])



   .. py:method:: item(*args, **kwargs)


   .. py:method:: max(*args, **kwargs)


   .. py:method:: mean(*args, **kwargs)


   .. py:method:: min(*args, **kwargs)


   .. py:method:: nonzero(*args, **kwargs)


   .. py:method:: partition(*args, **kwargs)


   .. py:method:: prod(*args, **kwargs)


   .. py:method:: put(*args, **kwargs)


   .. py:method:: resize(*args, **kwargs)


   .. py:method:: round(*args, **kwargs)


   .. py:method:: setfield(*args, **kwargs)


   .. py:method:: setflags(*args, **kwargs)


   .. py:method:: sort(*args, **kwargs)


   .. py:method:: std(*args, **kwargs)


   .. py:method:: sum(*args, **kwargs)


   .. py:method:: swapaxes(*args, **kwargs)


   .. py:method:: to_device(*args, **kwargs)


   .. py:method:: tobytes(*args, **kwargs)


   .. py:method:: tofile(*args, **kwargs)


   .. py:method:: trace(*args, **kwargs)


   .. py:method:: value_counts(dropna: bool = True) -> pandas.Series

      Return counts of unique strings as a pandas Series.

      This method computes the frequency of each distinct string value in the
      underlying Arkouda ``Strings`` object and returns the result as a pandas
      ``Series``, with the unique string values as the index and their counts
      as the data.

      :param dropna: Whether to exclude missing values. Missing-value handling for
                     Arkouda string arrays is not yet implemented, so this parameter is
                     accepted for pandas compatibility but currently has no effect.
                     Default is True.
      :type dropna: bool

      :returns: A Series containing the counts of unique string values.
                The index is an ``ArkoudaStringArray`` of unique values, and the
                values are an ``ArkoudaArray`` of counts.
      :rtype: pd.Series

      .. rubric:: Notes

      - The following pandas options are not yet implemented:
        ``normalize``, ``sort``, and ``bins``.
      - Counting is performed server-side in Arkouda; only the small result
        (unique values and counts) is materialized on the client.

      .. rubric:: Examples

      Basic usage:

      >>> import arkouda as ak
      >>> from arkouda.pandas.extension import ArkoudaStringArray
      >>>
      >>> s = ArkoudaStringArray(["red", "blue", "red", "green", "blue", "red"])
      >>> s.value_counts()
      red      3
      blue     2
      green    1
      dtype: int64

      Empty input:

      >>> empty = ArkoudaStringArray([])
      >>> empty.value_counts()
      Series([], dtype: int64)



   .. py:method:: var(*args, **kwargs)


.. py:class:: ArkoudaStringDtype

   Bases: :py:obj:`_ArkoudaBaseDtype`


   Arkouda-backed string dtype.

   This dtype integrates Arkouda's distributed ``Strings`` type with the
   pandas ExtensionArray interface via :class:`ArkoudaStringArray`. It
   enables pandas objects (Series, DataFrame) to hold large, server-backed
   string columns without converting to NumPy or Python objects.

   .. method:: construct_array_type()

      Returns the :class:`ArkoudaStringArray` used as the storage class.



   .. py:method:: construct_array_type()
      :classmethod:


      Return the ExtensionArray subclass that handles storage for this dtype.

      :returns: The :class:`ArkoudaStringArray` class associated with this dtype.
      :rtype: type



   .. py:attribute:: kind
      :value: 'O'


      A character code (one of 'biufcmMOSUV'), default 'O'

      This should match the NumPy dtype used when the array is
      converted to an ndarray, which is probably 'O' for object if
      the extension type cannot be represented as a built-in NumPy
      type.

      .. seealso:: :py:obj:`numpy.dtype.kind`


   .. py:attribute:: na_value
      :value: ''


      Default NA value to use for this type.

      This is used in e.g. ExtensionArray.take. This should be the
      user-facing "boxed" version of the NA value, not the physical NA value
      for storage.  e.g. for JSONArray, this is an empty dictionary.


   .. py:attribute:: name
      :value: 'string'


      A string identifying the data type.

      Will be used for display in, e.g. ``Series.dtype``


   .. py:attribute:: type

      The scalar type for the array, e.g. ``int``

      It's expected ``ExtensionArray[item]`` returns an instance
      of ``ExtensionDtype.type`` for scalar ``item``, assuming
      that value is valid (not NA). NA values do not need to be
      instances of `type`.


.. py:class:: ArkoudaUint64Dtype

   Bases: :py:obj:`_ArkoudaBaseDtype`


   Arkouda-backed unsigned 64-bit integer dtype.

   This dtype integrates Arkoudaâ€™s ``uint64`` arrays with pandas,
   allowing users to create :class:`pandas.Series` or
   :class:`pandas.DataFrame` objects that store their data on
   the Arkouda server while still conforming to the pandas
   ExtensionArray API.

   .. method:: construct_array_type()

      Return the :class:`ArkoudaArray` class used as the storage
      container for this dtype.


   .. rubric:: Examples

   >>> import arkouda as ak
   >>> import pandas as pd
   >>> from arkouda.pandas.extension import ArkoudaUint64Dtype, ArkoudaArray

   >>> arr = ArkoudaArray(ak.array([1, 2, 3], dtype="uint64"))
   >>> s = pd.Series(arr, dtype=ArkoudaUint64Dtype())
   >>> s
   0    1
   1    2
   2    3
   dtype: uint64


   .. py:method:: construct_array_type()
      :classmethod:


      Return the ExtensionArray class associated with this dtype.

      This is required by the pandas ExtensionDtype API. It tells pandas
      which :class:`~pandas.api.extensions.ExtensionArray` subclass should
      be used to hold data of this dtype inside a :class:`pandas.Series`
      or :class:`pandas.DataFrame`.

      :returns: The :class:`ArkoudaArray` class, which implements the storage
                and operations for Arkouda-backed arrays.
      :rtype: type



   .. py:attribute:: kind
      :value: 'u'


      A character code (one of 'biufcmMOSUV'), default 'O'

      This should match the NumPy dtype used when the array is
      converted to an ndarray, which is probably 'O' for object if
      the extension type cannot be represented as a built-in NumPy
      type.

      .. seealso:: :py:obj:`numpy.dtype.kind`


   .. py:attribute:: na_value
      :value: -1


      Default NA value to use for this type.

      This is used in e.g. ExtensionArray.take. This should be the
      user-facing "boxed" version of the NA value, not the physical NA value
      for storage.  e.g. for JSONArray, this is an empty dictionary.


   .. py:attribute:: name
      :value: 'uint64'


      A string identifying the data type.

      Will be used for display in, e.g. ``Series.dtype``


   .. py:attribute:: type

      The scalar type for the array, e.g. ``int``

      It's expected ``ExtensionArray[item]`` returns an instance
      of ``ExtensionDtype.type`` for scalar ``item``, assuming
      that value is valid (not NA). NA values do not need to be
      instances of `type`.


.. py:class:: ArkoudaUint8Dtype

   Bases: :py:obj:`_ArkoudaBaseDtype`


   Arkouda-backed unsigned 8-bit integer dtype.

   This dtype integrates Arkouda's ``uint8`` arrays with the pandas
   ExtensionArray API, allowing pandas ``Series`` and ``DataFrame``
   objects to store and operate on Arkouda-backed unsigned 8-bit
   integers. The underlying storage is an Arkouda ``pdarray<uint8>``,
   exposed through the :class:`ArkoudaArray` extension array.

   .. method:: construct_array_type()

      Returns the :class:`ArkoudaArray` type that provides the storage
      and behavior for this dtype.



   .. py:method:: construct_array_type()
      :classmethod:


      Return the ExtensionArray subclass that handles storage for this dtype.

      This method is required by the pandas ExtensionDtype interface.
      It tells pandas which ExtensionArray class to use when creating
      arrays of this dtype (for example, when calling
      ``Series(..., dtype="arkouda.uint8")``).

      :returns: The :class:`ArkoudaArray` class associated with this dtype.
      :rtype: type



   .. py:attribute:: kind
      :value: 'u'


      A character code (one of 'biufcmMOSUV'), default 'O'

      This should match the NumPy dtype used when the array is
      converted to an ndarray, which is probably 'O' for object if
      the extension type cannot be represented as a built-in NumPy
      type.

      .. seealso:: :py:obj:`numpy.dtype.kind`


   .. py:attribute:: na_value
      :value: -1


      Default NA value to use for this type.

      This is used in e.g. ExtensionArray.take. This should be the
      user-facing "boxed" version of the NA value, not the physical NA value
      for storage.  e.g. for JSONArray, this is an empty dictionary.


   .. py:attribute:: name
      :value: 'uint8'


      A string identifying the data type.

      Will be used for display in, e.g. ``Series.dtype``


   .. py:attribute:: type

      The scalar type for the array, e.g. ``int``

      It's expected ``ExtensionArray[item]`` returns an instance
      of ``ExtensionDtype.type`` for scalar ``item``, assuming
      that value is valid (not NA). NA values do not need to be
      instances of `type`.


.. py:class:: CachedAccessor(name: str, accessor)

   Descriptor for caching namespace-based accessors.

   This custom property-like object enables lazy initialization of accessors
   (e.g., `.str`, `.dt`) on Series-like objects, similar to pandas-style extension
   accessors.

   :param name: The name of the namespace to be accessed (e.g., ``df.foo``).
   :type name: str
   :param accessor: A class implementing the accessor logic.
   :type accessor: type

   .. rubric:: Notes

   The `accessor` class's ``__init__`` method must accept a single positional
   argument, which should be one of ``Series``, ``DataFrame``, or ``Index``.


.. py:class:: DatetimeAccessor(series)

   Bases: :py:obj:`Properties`


   Accessor for datetime-like operations on Arkouda Series.

   Provides datetime methods such as `.floor()`, `.ceil()`, and `.round()`,
   mirroring the `.dt` accessor in pandas.

   This accessor is automatically attached to Series objects that wrap
   `arkouda.Datetime` values. It should not be instantiated directly.

   :param series: The Series object containing `Datetime` values.
   :type series: arkouda.pandas.Series

   :raises AttributeError: If the underlying Series values are not of type `arkouda.Datetime`.

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> from arkouda import Datetime, Series
   >>> s = Series(Datetime(ak.array([1_000_000_000_000])))
   >>> s.dt.floor("D")
   0   1970-01-01
   dtype: datetime64[ns]


   .. py:attribute:: series


.. py:class:: LogLevel(*args, **kwds)

   Bases: :py:obj:`enum.Enum`


   Enum for defining valid log levels used by ArkoudaLogger.

   Members
   -------
   INFO : str
       Confirmation that things are working as expected.
   DEBUG : str
       Detailed information, typically of interest only when diagnosing problems.
   WARN : str
       An indication that something unexpected happened, or indicative of some problem.
   ERROR : str
       A more serious problem, the software has not been able to perform some function.
   CRITICAL : str
       An extremely serious error, indicating the program itself may be unable to continue.

   .. rubric:: Notes

   This enum provides a controlled vocabulary for setting log levels on ArkoudaLogger
   instances. These are mapped internally to the standard Python `logging` levels.


   .. py:attribute:: CRITICAL
      :value: 'CRITICAL'



   .. py:attribute:: DEBUG
      :value: 'DEBUG'



   .. py:attribute:: ERROR
      :value: 'ERROR'



   .. py:attribute:: INFO
      :value: 'INFO'



   .. py:attribute:: WARN
      :value: 'WARN'



.. py:class:: Power_divergenceResult

   Bases: :py:obj:`Power_divergenceResult`


   The results of a power divergence statistical test.

   .. attribute:: statistic



      :type: float64

   .. attribute:: pvalue



      :type: float64


.. py:class:: Properties

   Base class for accessor implementations in Arkouda.

   Provides the `_make_op` class method to dynamically generate accessor methods
   that wrap underlying `Strings` or `Datetime` operations and return new Series.

   .. rubric:: Notes

   This class is subclassed by `StringAccessor` and `DatetimeAccessor`, and is not
   intended to be used directly.

   .. rubric:: Examples

   Subclasses should define `_make_op("operation_name")`, which will generate
   a method that applies `series.values.operation_name(...)` and returns a new Series.


.. py:data:: RegisteredSymbols
   :value: '__RegisteredSymbols__'


.. py:class:: Row(dict=None, /, **kwargs)

   Bases: :py:obj:`collections.UserDict`


   A dictionaryâ€like representation of a single row in an Arkouda DataFrame.

   Wraps the columnâ†’value mapping for one row and provides convenient ASCII
   and HTML formatting for display.

   :param data: Mapping of column names to their corresponding values for this row.
   :type data: dict

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> from arkouda.row import Row
   >>> df = ak.DataFrame({'x': ak.array([10, 20]), 'y': ak.array(['a', 'b'])})

   Suppose df[0] returns {'x': 10, 'y': 'a'}
   >>> row = Row({'x': 10, 'y': 'a'})
   >>> print(row)
   keys    values
   ------  --------
   x       10
   y       a


.. py:class:: Series(data: Union[Tuple, List, arkouda.pandas.groupbyclass.groupable_element_type, Series, arkouda.numpy.segarray.SegArray, pandas.Series, pandas.Categorical], name=None, index: Optional[Union[arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.strings.Strings, Tuple, List, arkouda.pandas.index.Index]] = None)

   One-dimensional arkouda array with axis labels.

   :param index: an array of indices associated with the data array.
                 If empty, it will default to a range of ints whose size match the size of the data.
                 optional
   :type index: pdarray, Strings
   :param data: a 1D array. Must not be None.
   :type data: Tuple, List, groupable_element_type, Series, SegArray

   :raises TypeError: Raised if index is not a pdarray or Strings object
       Raised if data is not a pdarray, Strings, or Categorical object
   :raises ValueError: Raised if the index size does not match data size

   .. rubric:: Notes

   The Series class accepts either positional arguments or keyword arguments.
   If entering positional arguments,
       2 arguments entered:
           argument 1 - data
           argument 2 - index
       1 argument entered:
           argument 1 - data
   If entering 1 positional argument, it is assumed that this is the data argument.
   If only 'data' argument is passed in, Index will automatically be generated.
   If entering keywords,
       'data' (see Parameters)
       'index' (optional) must match size of 'data'


   .. py:method:: add(b: Series) -> Series


   .. py:property:: at
      :type: _LocIndexer


      Accesses entries of a Series by label.

      :returns: An indexer for label-based access to Series entries.
      :rtype: _LocIndexer


   .. py:method:: concat(arrays: List, axis: int = 0, index_labels: Union[List[str], None] = None, value_labels: Union[List[str], None] = None, ordered: bool = False) -> Union[arkouda.pandas.dataframe.DataFrame, Series]
      :staticmethod:


      Concatenate a list of Arkouda Series or grouped arrays horizontally or vertically.

      If a list of grouped Arkouda arrays is passed, they are converted to Series. Each grouping
      is a 2-tuple where the first item is the key(s) and the second is the value. If concatenating
      horizontally (axis=1), all series/groupings must have the same length and the same index.
      The index is converted to a column in the resulting DataFrame; if it's a MultiIndex,
      each level is converted to a separate column.

      :param arrays: A list of Series or groupings (tuples of index and values) to concatenate.
      :type arrays: List
      :param axis: The axis to concatenate along:
                   - 0 = vertical (stack series into one)
                   - 1 = horizontal (align by index and produce a DataFrame)
                   Defaults to 0.
      :type axis: int
      :param index_labels: Column name(s) to label the index when axis=1.
      :type index_labels: List[str] or None, optional
      :param value_labels: Column names to label the values of each Series.
      :type value_labels: List[str] or None, optional
      :param ordered: Unused parameter. Reserved for future support of deterministic
                      vs. performance-optimized concatenation. Defaults to False.
      :type ordered: bool

      :returns:

                - If axis=0: a new Series
                - If axis=1: a new DataFrame
      :rtype: Series or DataFrame



   .. py:method:: diff() -> Series

      Diffs consecutive values of the series.

      Returns a new series with the same index and length.  First value is set to NaN.



   .. py:attribute:: dt


   .. py:property:: dtype
      :type: numpy.dtype



   .. py:method:: fillna(value: Union[supported_scalars, Series, arkouda.numpy.pdarrayclass.pdarray]) -> Series

      Fill NA/NaN values using the specified method.

      :param value: Value to use to fill holes (e.g. 0), alternately a
                    Series of values specifying which value to use for
                    each index.  Values not in the Series will not be filled.
                    This value cannot be a list.
      :type value: supported_scalars, Series, or pdarray

      :returns: Object with missing values filled.
      :rtype: Series

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> from arkouda import Series
      >>> import numpy as np

      >>> data = ak.Series([1, np.nan, 3, np.nan, 5])
      >>> data
      0    1.0
      1    NaN
      2    3.0
      3    NaN
      4    5.0
      dtype: float64

      >>> fill_values1 = ak.ones(5)
      >>> data.fillna(fill_values1)
      0    1.0
      1    1.0
      2    3.0
      3    1.0
      4    5.0
      dtype: float64

      >>> fill_values2 = Series(ak.ones(5))
      >>> data.fillna(fill_values2)
      0    1.0
      1    1.0
      2    3.0
      3    1.0
      4    5.0
      dtype: float64

      >>> fill_values3 = 100.0
      >>> data.fillna(fill_values3)
      0      1.0
      1    100.0
      2      3.0
      3    100.0
      4      5.0
      dtype: float64



   .. py:method:: from_return_msg(rep_msg: str) -> Series
      :classmethod:


      Return a Series instance pointing to components created by the arkouda server.

      The user should not call this function directly.

      :param rep_msg:
                      + delimited string containing the values and indexes.
      :type rep_msg: builtin_str

      :returns: A Series representing a set of pdarray components on the server.
      :rtype: Series

      :raises RuntimeError: Raised if a server-side error is thrown in the process of creating
          the Series instance.



   .. py:method:: has_repeat_labels() -> bool

      Return whether the Series has any labels that appear more than once.



   .. py:method:: hasnans() -> arkouda.numpy.dtypes.bool_scalars

      Return True if there are any NaNs.

      :rtype: bool

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> from arkouda import Series
      >>> import numpy as np

      >>> s = ak.Series(ak.array([1, 2, 3, np.nan]))
      >>> s
      0    1.0
      1    2.0
      2    3.0
      3    NaN
      dtype: float64

      >>> s.hasnans()
      np.True_



   .. py:method:: head(n: int = 10) -> Series

      Return the first n values of the series.



   .. py:property:: iat
      :type: _iLocIndexer


      Accesses entries of a Series by position.

      :returns: An indexer for position-based access to a single element.
      :rtype: _iLocIndexer


   .. py:property:: iloc
      :type: _iLocIndexer


      Accesses entries of a Series by position.

      :returns: An indexer for position-based access to Series entries.
      :rtype: _iLocIndexer


   .. py:method:: is_registered() -> bool

      Return True iff the object is contained in the registry or is a component of a
       registered object.

      :returns: Indicates if the object is contained in the registry
      :rtype: bool

      :raises RegistrationError: Raised if there's a server-side error or a mis-match of registered components

      .. seealso:: :py:obj:`register`, :py:obj:`attach`, :py:obj:`unregister`

      .. rubric:: Notes

      Objects registered with the server are immune to deletion until
      they are unregistered.



   .. py:method:: isin(lst: Union[arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.strings.Strings, List]) -> Series

      Find Series elements whose values are in the specified list.

      :param lst: Either a Python list or an Arkouda array to check membership against.
      :type lst: pdarray, Strings, or List

      :returns: A Series of booleans that is True for elements found in the list,
                and False otherwise.
      :rtype: Series



   .. py:method:: isna() -> Series

      Detect missing values.

      Return a boolean same-sized object indicating if the values are NA. NA values,
      such as numpy.NaN, gets mapped to True values.
      Everything else gets mapped to False values.
      Characters such as empty strings '' are not considered NA values.

      :returns: Mask of bool values for each element in Series
                that indicates whether an element is an NA value.
      :rtype: Series

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> from arkouda import Series
      >>> import numpy as np

      >>> s = Series(ak.array([1, 2, np.nan]), index = ak.array([1, 2, 4]))
      >>> s.isna()
      1    False
      2    False
      4     True
      dtype: bool



   .. py:method:: isnull() -> Series

      Series.isnull is an alias for Series.isna.

      Detect missing values.

      Return a boolean same-sized object indicating if the values are NA. NA values,
      such as numpy.NaN, gets mapped to True values.
      Everything else gets mapped to False values.
      Characters such as empty strings '' are not considered NA values.

      :returns: Mask of bool values for each element in Series
                that indicates whether an element is an NA value.
      :rtype: Series

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> from arkouda import Series
      >>> import numpy as np

      >>> s = Series(ak.array([1, 2, np.nan]), index = ak.array([1, 2, 4]))
      >>> s.isnull()
      1    False
      2    False
      4     True
      dtype: bool



   .. py:property:: loc
      :type: _LocIndexer


      Accesses entries of a Series by label.

      :returns: An indexer for label-based access to Series entries.
      :rtype: _LocIndexer


   .. py:method:: locate(key: Union[int, arkouda.numpy.pdarrayclass.pdarray, arkouda.pandas.index.Index, Series, List, Tuple]) -> Series

      Lookup values by index label.

      :param key: The key or keys to look up. This can be:
                  - A scalar
                  - A list of scalars
                  - A list of lists (for MultiIndex)
                  - A Series (in which case labels are preserved, and its values are used as keys)

                  Keys will be converted to Arkouda arrays as needed.
      :type key: int, pdarray, Index, Series, List, or Tuple

      :returns: A Series containing the values corresponding to the key.
      :rtype: Series



   .. py:method:: map(arg: Union[dict, arkouda.Series]) -> arkouda.Series

      Map values of Series according to an input mapping.

      :param arg: The mapping correspondence.
      :type arg: dict or Series

      :returns: A new series with the same index as the caller.
                When the input Series has Categorical values,
                the return Series will have Strings values.
                Otherwise, the return type will match the input type.
      :rtype: Series

      :raises TypeError: Raised if arg is not of type dict or arkouda.Series.
          Raised if series values not of type pdarray, Categorical, or Strings.

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> s = ak.Series(ak.array([2, 3, 2, 3, 4]))
      >>> s
      0    2
      1    3
      2    2
      3    3
      4    4
      dtype: int64

      >>> s.map({4: 25.0, 2: 30.0, 1: 7.0, 3: 5.0})
      0    30.0
      1     5.0
      2    30.0
      3     5.0
      4    25.0
      dtype: float64

      >>> s2 = ak.Series(ak.array(["a","b","c","d"]), index = ak.array([4,2,1,3]))
      >>> s.map(s2)
      0    b
      1    d
      2    b
      3    d
      4    a
      dtype: ...



   .. py:method:: memory_usage(index: bool = True, unit: Literal['B', 'KB', 'MB', 'GB'] = 'B') -> int

      Return the memory usage of the Series.

      The memory usage can optionally include the contribution of
      the index.

      :param index: Specifies whether to include the memory usage of the Series index.
                    Defaults to True.
      :type index: bool
      :param unit: Unit to return. One of {'B', 'KB', 'MB', 'GB'}. Defaults to "B".
      :type unit: {"B", "KB", "MB", "GB"}

      :returns: Bytes of memory consumed.
      :rtype: int

      .. seealso:: :py:obj:`arkouda.numpy.pdarrayclass.nbytes`, :py:obj:`arkouda.Index.memory_usage`, :py:obj:`arkouda.pandas.series.Series.memory_usage`, :py:obj:`arkouda.pandas.datafame.DataFrame.memory_usage`

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> from arkouda.series import Series
      >>> s = ak.Series(ak.arange(3))
      >>> s.memory_usage()
      48

      Not including the index gives the size of the rest of the data, which
      is necessarily smaller:

      >>> s.memory_usage(index=False)
      24

      Select the units:

      >>> s = ak.Series(ak.arange(3000))
      >>> s.memory_usage(unit="KB")
      46.875



   .. py:property:: ndim
      :type: int



   .. py:method:: notna() -> Series

      Detect existing (non-missing) values.

      Return a boolean same-sized object indicating if the values are not NA.
      Non-missing values get mapped to True.
      Characters such as empty strings '' are not considered NA values.
      NA values, such as numpy.NaN, get mapped to False values.

      :returns: Mask of bool values for each element in Series
                that indicates whether an element is not an NA value.
      :rtype: Series

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> from arkouda import Series
      >>> import numpy as np

      >>> s = Series(ak.array([1, 2, np.nan]), index = ak.array([1, 2, 4]))
      >>> s.notna()
      1     True
      2     True
      4    False
      dtype: bool



   .. py:method:: notnull() -> Series

      Series.notnull is an alias for Series.notna.

      Detect existing (non-missing) values.

      Return a boolean same-sized object indicating if the values are not NA.
      Non-missing values get mapped to True.
      Characters such as empty strings '' are not considered NA values.
      NA values, such as numpy.NaN, get mapped to False values.

      :returns: Mask of bool values for each element in Series
                that indicates whether an element is not an NA value.
      :rtype: Series

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> from arkouda import Series
      >>> import numpy as np

      >>> s = Series(ak.array([1, 2, np.nan]), index = ak.array([1, 2, 4]))
      >>> s.notnull()
      1     True
      2     True
      4    False
      dtype: bool



   .. py:attribute:: objType
      :value: 'Series'



   .. py:method:: pdconcat(arrays: List, axis: int = 0, labels: Union[arkouda.numpy.strings.Strings, None] = None) -> Union[pandas.Series, pandas.DataFrame]
      :staticmethod:


      Concatenate a list of Arkouda Series or grouped arrays, returning a local pandas object.

      If a list of grouped Arkouda arrays is passed, they are converted to Series. Each grouping
      is a 2-tuple with the first item being the key(s) and the second the value.

      If `axis=1` (horizontal), each Series or grouping must have the same length and the same index.
      The index is converted to a column in the resulting DataFrame. If it is a MultiIndex,
      each level is converted to a separate column.

      :param arrays: A list of Series or groupings (tuples of index and values) to concatenate.
      :type arrays: List
      :param axis: The axis along which to concatenate:
                   - 0 = vertical (stack into a Series)
                   - 1 = horizontal (align by index into a DataFrame)
                   Defaults to 0.
      :type axis: int
      :param labels: Names to assign to the resulting columns in the DataFrame.
      :type labels: Strings or None, optional

      :returns:

                - If axis=0: a local pandas Series
                - If axis=1: a local pandas DataFrame
      :rtype: Series or DataFrame



   .. py:method:: register(user_defined_name: str)

      Register this Series object and underlying components with the Arkouda server.

      :param user_defined_name: User-defined name the Series is to be registered under.
                                This will be the root name for the underlying components.
      :type user_defined_name: builtin_str

      :returns: The same Series which is now registered with the arkouda server and has an updated name.
                This is an in-place modification, the original is returned to support
                a fluid programming style.
                Please note you cannot register two different Series with the same name.
      :rtype: Series

      :raises TypeError: Raised if user_defined_name is not a str
      :raises RegistrationError: If the server was unable to register the Series with the user_defined_name

      .. seealso:: :py:obj:`unregister`, :py:obj:`attach`, :py:obj:`is_registered`

      .. rubric:: Notes

      Objects registered with the server are immune to deletion until
      they are unregistered.



   .. py:attribute:: registered_name
      :type:  Optional[str]
      :value: None



   .. py:property:: shape
      :type: Tuple[int]



   .. py:attribute:: size


   .. py:method:: sort_index(ascending: bool = True) -> Series

      Sort the Series by its index.

      :param ascending: Whether to sort the index in ascending (default) or descending order.
                        Defaults to True.
      :type ascending: bool

      :returns: A new Series sorted by index.
      :rtype: Series



   .. py:method:: sort_values(ascending: bool = True) -> Series

      Sort the Series by its values.

      :param ascending: Whether to sort values in ascending (default) or descending order.
                        Defaults to True.
      :type ascending: bool

      :returns: A new Series sorted by its values.
      :rtype: Series



   .. py:attribute:: str


   .. py:method:: tail(n: int = 10) -> Series

      Return the last n values of the series.



   .. py:method:: to_dataframe(index_labels: Union[List[str], None] = None, value_label: Union[str, None] = None) -> arkouda.pandas.dataframe.DataFrame

      Convert the Series to an Arkouda DataFrame.

      :param index_labels: Column name(s) to label the index.
      :type index_labels: list of str or None, optional
      :param value_label: Column name to label the values.
      :type value_label: str or None, optional

      :returns: An Arkouda DataFrame representing the Series.
      :rtype: DataFrame



   .. py:method:: to_markdown(mode='wt', index=True, tablefmt='grid', storage_options=None, **kwargs)

      Print Series in Markdown-friendly format.

      :param mode: Mode in which file is opened, "wt" by default.
      :type mode: str, optional
      :param index: Add index (row) labels.
      :type index: bool, optional, default True
      :param tablefmt: Table format to call from tablulate:
                       https://pypi.org/project/tabulate/
      :type tablefmt: str = "grid"
      :param storage_options: Extra options that make sense for a particular storage connection,
                              e.g. host, port, username, password, etc., if using a URL that will be parsed by fsspec,
                              e.g., starting â€œs3://â€, â€œgcs://â€.
                              An error will be raised if providing this argument with a non-fsspec URL.
                              See the fsspec and backend storage implementation docs for the set
                              of allowed keys and values.
      :type storage_options: dict, optional
      :param \*\*kwargs: These parameters will be passed to tabulate.

      .. note::

         This function should only be called on small Series as it calls pandas.Series.to_markdown:
         https://pandas.pydata.org/docs/reference/api/pandas.Series.to_markdown.html

      .. rubric:: Examples

      >>> import arkouda as ak

      >>> s = ak.Series(["elk", "pig", "dog", "quetzal"], name="animal")
      >>> print(s.to_markdown())
      +----+----------+
      |    | animal   |
      +====+==========+
      |  0 | elk      |
      +----+----------+
      |  1 | pig      |
      +----+----------+
      |  2 | dog      |
      +----+----------+
      |  3 | quetzal  |
      +----+----------+

      Output markdown with a tabulate option.

      >>> print(s.to_markdown(tablefmt="grid"))
      +----+----------+
      |    | animal   |
      +====+==========+
      |  0 | elk      |
      +----+----------+
      |  1 | pig      |
      +----+----------+
      |  2 | dog      |
      +----+----------+
      |  3 | quetzal  |
      +----+----------+



   .. py:method:: to_ndarray() -> numpy.ndarray


   .. py:method:: to_pandas() -> pandas.Series

      Convert the series to a local PANDAS series.



   .. py:method:: tolist() -> list


   .. py:method:: topn(n: int = 10) -> Series

      Return the top values of the Series.

      :param n: Number of values to return. Defaults to 10.
      :type n: int

      :returns: A new Series containing the top `n` values.
      :rtype: Series



   .. py:method:: unregister()

      Unregister this Series object in the arkouda server which was previously
      registered using register() and/or attached to using attach().

      :raises RegistrationError: If the object is already unregistered or if there is a server error
          when attempting to unregister

      .. seealso:: :py:obj:`register`, :py:obj:`attach`, :py:obj:`is_registered`

      .. rubric:: Notes

      Objects registered with the server are immune to deletion until
      they are unregistered.



   .. py:method:: validate_key(key: Union[Series, arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.strings.Strings, arkouda.categorical.Categorical, List, supported_scalars, arkouda.numpy.segarray.SegArray]) -> Union[arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.strings.Strings, arkouda.categorical.Categorical, supported_scalars, arkouda.numpy.segarray.SegArray]

      Validate type requirements for keys when reading or writing the Series.

      Also converts list and tuple arguments into pdarrays.

      :param key: The key or container of keys that might be used to index into the Series.
      :type key: Series, pdarray, Strings, Categorical, List, supported_scalars, or SegArray

      :rtype: The validated key(s), with lists and tuples converted to pdarrays

      :raises TypeError: Raised if keys are not boolean values or the type of the labels
          Raised if key is not one of the supported types
      :raises KeyError: Raised if container of keys has keys not present in the Series
      :raises IndexError: Raised if the length of a boolean key array is different
          from the Series



   .. py:method:: validate_val(val: Union[arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.strings.Strings, supported_scalars, List]) -> Union[arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.strings.Strings, supported_scalars]

      Validate type requirements for values being written into the Series.

      Also converts list and tuple arguments into pdarrays.

      :param val: The value or container of values that might be assigned into the Series.
      :type val: pdarray, Strings, supported_scalars, or List

      :rtype: The validated value, with lists converted to pdarrays

      :raises TypeError: Raised if val is not the same type or a container with elements
            of the same time as the Series
          Raised if val is a string or Strings type.
          Raised if val is not one of the supported types



   .. py:method:: value_counts(sort: bool = True) -> Series

      Return a Series containing counts of unique values.

      :param sort: Whether to sort the result by count in descending order. If False,
                   the order of the results is not guaranteed. Defaults to True.
      :type sort: bool

      :returns: A Series where the index contains the unique values and the values are
                their counts in the original Series.
      :rtype: Series



.. py:class:: StringAccessor(series)

   Bases: :py:obj:`Properties`


   Accessor for string operations on Arkouda Series.

   Provides string-like methods such as `.contains()`, `.startswith()`, and
   `.endswith()` via the `.str` accessor, similar to pandas.

   This accessor is automatically attached to Series objects that wrap
   `arkouda.Strings` or `arkouda.Categorical` values. It should not be instantiated directly.

   :param series: The Series object containing `Strings` or `Categorical` values.
   :type series: arkouda.pandas.Series

   :raises AttributeError: If the underlying Series values are not `Strings` or `Categorical`.

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> from arkouda import Series
   >>> s = Series(["apple", "banana", "apricot"])
   >>> s.str.startswith("a")
   0     True
   1    False
   2     True
   dtype: bool


   .. py:attribute:: series


.. py:function:: apply(arr: arkouda.numpy.pdarrayclass.pdarray, func: Union[Callable, str], result_dtype: Optional[Union[numpy.dtype, str]] = None) -> arkouda.numpy.pdarrayclass.pdarray

   Apply a python function to a pdarray.

   The function should take one argument
   and return a new value. The function will then be called on each element in
   the pdarray.



   Warning: This function is experimental and may not work as expected.
   Known limitations:
   - Any python modules used inside of the function must be installed on the server.

   :param arr: The pdarray to which the function is applied
   :type arr: pdarray
   :param func: The function to apply to the array. This can be a callable function or
                a string, but either way it should take a single argument and return a
                single value. If a string, it should be a lambda function that takes a
                single argument, e.g. "lambda x,: x+1". Note the dangling comma after
                the argument, this is required for string functions.
   :type func: Union[Callable, str]
   :param result_dtype: The dtype of the resulting pdarray. If None, the dtype of the resulting
                        pdarray will be the same as the input pdarray. If a string, it should be
                        a valid numpy dtype string, e.g. "float64". If a numpy dtype, it should
                        be a valid numpy dtype object, e.g. np.float64. This is not supported
                        for functions passed as strings.
   :type result_dtype: Optional[Union[np.dtype, str]]

   :returns: The pdarray resulting from applying the function to the input array
   :rtype: pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> arr = ak.apply(ak.array([1, 2, 3]), lambda x: x+1)
   >>> arr
   array([2 3 4])

   Or,
   >>> import math
   >>> arr = ak.randint(0, 10, 4, seed=1)
   >>> def times_pi(x):
   ...        return x*math.pi
   >>> arr = ak.apply(arr, times_pi, "float64")
   >>> arr
   array([21.991148575128552 28.274333882308138 15.707963267948966 3.1415926535897931])


.. py:function:: assert_almost_equal(left, right, rtol: float = 1e-05, atol: float = 1e-08, **kwargs) -> None

   Check that the left and right objects are approximately equal.

   By approximately equal, we refer to objects that are numbers or that
   contain numbers which may be equivalent to specific levels of precision.

   :param left:
   :type left: object
   :param right:
   :type right: object
   :param rtol: Relative tolerance.
   :type rtol: float, default 1e-5
   :param atol: Absolute tolerance.
   :type atol: float, default 1e-8

   .. warning::

      This function cannot be used on pdarray of size > ak.core.client.maxTransferBytes
      because it converts pdarrays to numpy arrays and calls np.allclose.


.. py:function:: assert_almost_equivalent(left, right, rtol: float = 1e-05, atol: float = 1e-08) -> None

   Check that two objects are approximately equal.

   By approximately equal, we refer to objects that are numbers or that
   contain numbers which may be equivalent to specific levels of precision.

   If the objects are pandas or numpy objects, they are converted to Arkouda objects.
   Then assert_almost_equal is applied to the result.

   :param left: First object to compare.
   :type left: object
   :param right: Second object to compare.
   :type right: object
   :param rtol: Relative tolerance. Default is 1e-5.
   :type rtol: float
   :param atol: Absolute tolerance. Default is 1e-8.
   :type atol: float

   :raises TypeError: If either input is not a supported numeric-like type.

   .. warning::

      This function cannot be used on pdarrays of size > ak.core.client.maxTransferBytes
      because it converts pdarrays to numpy arrays and calls np.allclose.

   .. seealso:: :py:obj:`assert_almost_equal`

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> from arkouda.testing import assert_almost_equivalent
   >>> assert_almost_equivalent(0.123456, 0.123457, rtol=1e-4)


.. py:function:: assert_arkouda_array_equal(left: arkouda.pdarray | arkouda.Strings | arkouda.Categorical | arkouda.SegArray, right: arkouda.pdarray | arkouda.Strings | arkouda.Categorical | arkouda.SegArray, check_dtype: bool = True, err_msg=None, check_same=None, obj: str = 'pdarray', index_values=None) -> None

   Check that two Arkouda arrays are equivalent. Supports pdarray, Strings,
   Categorical, and SegArray.

   :param left: The first array to compare.
   :type left: pdarray or Strings or Categorical or SegArray
   :param right: The second array to compare.
   :type right: pdarray or Strings or Categorical or SegArray
   :param check_dtype: Whether to check dtype if both `left` and `right` are ak.pdarray.
                       Defaults to True.
   :type check_dtype: bool
   :param err_msg: Custom assertion message, if provided. Defaults to None.
   :type err_msg: str or None
   :param check_same: If not None, assert whether `left` and `right` share the same memory.
                      - `'copy'`: assert that they do **not** share memory.
                      - `'same'`: assert that they **do** share memory.
                      Defaults to None.
   :type check_same: {'copy', 'same'} or None
   :param obj: Object name used in assertion error messages. Defaults to 'pdarray'.
   :type obj: str
   :param index_values: Optional index shared by both `left` and `right`, used to enhance
                        output in error messages. Defaults to None.
   :type index_values: Index or pdarray or None


.. py:function:: assert_arkouda_array_equivalent(left: arkouda.pdarray | arkouda.Strings | arkouda.Categorical | arkouda.SegArray | numpy.ndarray | pandas.Categorical, right: arkouda.pdarray | arkouda.Strings | arkouda.Categorical | arkouda.SegArray | numpy.ndarray | pandas.Categorical, check_dtype: bool = True, err_msg=None, check_same=None, obj: str = 'pdarray', index_values=None) -> None

    Check that two Arkouda-compatible arrays are equal.

   Supported types include numpy arrays, pandas Categorical, and Arkouda arrays.

   :param left: First array to compare.
   :type left: pdarray, Strings, Categorical, SegArray, np.ndarray, or pd.Categorical
   :param right: Second array to compare.
   :type right: pdarray, Strings, Categorical, SegArray, np.ndarray, or pd.Categorical
   :param check_dtype: Whether to verify that dtypes match. Default is True.
   :type check_dtype: bool
   :param err_msg: Optional message to display on failure.
   :type err_msg: str or None
   :param check_same: Whether to ensure identity or separation in memory. Default is None.
   :type check_same: None or {"copy", "same"}
   :param obj: Object label for error messages. Default is "pdarray".
   :type obj: str
   :param index_values: Shared index used in error output. Default is None.
   :type index_values: Index or pdarray, optional

   :raises TypeError: If either input is not a supported array type.

   .. seealso:: :py:obj:`assert_arkouda_array_equal`

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> from arkouda import Strings
   >>> from arkouda.testing import assert_arkouda_array_equivalent
   >>> a = ak.array([1, 2, 3])
   >>> b = ak.array([1, 2, 3])
   >>> assert_arkouda_array_equivalent(a, b)
   >>> s1 = ak.array(['x', 'y'])
   >>> s2 = ak.array(['x', 'y'])
   >>> assert_arkouda_array_equivalent(s1, s2)


.. py:function:: assert_arkouda_pdarray_equal(left: arkouda.pdarray, right: arkouda.pdarray, check_dtype: bool = True, err_msg=None, check_same=None, obj: str = 'pdarray', index_values=None) -> None

   Check that two Arkouda pdarray objects are equivalent.

   :param left: The first array to compare.
   :type left: pdarray
   :param right: The second array to compare.
   :type right: pdarray
   :param check_dtype: Whether to check dtype if both arrays are pdarrays. Defaults to True.
   :type check_dtype: bool
   :param err_msg: Custom assertion message to display on failure. Defaults to None.
   :type err_msg: str or None
   :param check_same: If not None, asserts whether `left` and `right` share the same memory:
                      - 'copy': assert they do **not** share memory
                      - 'same': assert they **do** share memory
                      Defaults to None.
   :type check_same: {'copy', 'same'} or None
   :param obj: A name for the object being compared, used in assertion messages.
               Defaults to 'pdarray'.
   :type obj: str
   :param index_values: Optional index shared by both arrays, used to enhance output on failure.
                        Defaults to None.
   :type index_values: Index or pdarray or None


.. py:function:: assert_arkouda_segarray_equal(left: arkouda.SegArray, right: arkouda.SegArray, check_dtype: bool = True, err_msg=None, check_same=None, obj: str = 'segarray') -> None

   Check that two Arkouda SegArray objects are equivalent.

   :param left: The first SegArray to compare.
   :type left: SegArray
   :param right: The second SegArray to compare.
   :type right: SegArray
   :param check_dtype: Whether to check dtype if both arrays contain pdarrays. Defaults to True.
   :type check_dtype: bool
   :param err_msg: Custom assertion message. Defaults to None.
   :type err_msg: str or None
   :param check_same: If not None, asserts whether `left` and `right` share the same memory.
                      - 'copy': assert that they do **not** share memory.
                      - 'same': assert that they **do** share memory.
                      Defaults to None.
   :type check_same: {'copy', 'same'} or None
   :param obj: Name of the object being compared (used in assertion messages).
               Defaults to 'segarray'.
   :type obj: str


.. py:function:: assert_arkouda_strings_equal(left, right, err_msg=None, check_same=None, obj: str = 'Strings', index_values=None) -> None

   Check that two `ak.Strings` arrays are equivalent.

   :param left: The first Strings object to compare.
   :type left: Strings
   :param right: The second Strings object to compare.
   :type right: Strings
   :param err_msg: Custom assertion message. Defaults to None.
   :type err_msg: str or None
   :param check_same: If not None, assert whether `left` and `right` share the same memory.
                      - 'copy': assert that they do **not** share memory
                      - 'same': assert that they **do** share memory
                      Defaults to None.
   :type check_same: {'copy', 'same'} or None
   :param obj: A name for the object being compared, used in assertion messages.
               Defaults to 'Strings'.
   :type obj: str
   :param index_values: Optional index shared by both arrays, used in output. Defaults to None.
   :type index_values: Index or pdarray or None


.. py:function:: assert_attr_equal(attr: str, left, right, obj: str = 'Attributes') -> None

   Check that attributes are equal. Both objects must have the given attribute.

   :param attr: The name of the attribute being compared.
   :type attr: str
   :param left: The first object to compare.
   :type left: object
   :param right: The second object to compare.
   :type right: object
   :param obj: A name for the object being compared, used in assertion messages.
               Defaults to 'Attributes'.
   :type obj: str


.. py:function:: assert_categorical_equal(left, right, check_dtype: bool = True, check_category_order: bool = True, obj: str = 'Categorical') -> None

   Test that Categoricals are equivalent.

   :param left: The first Categorical to compare.
   :type left: Categorical
   :param right: The second Categorical to compare.
   :type right: Categorical
   :param check_dtype: Whether to check that the integer dtype of the codes is the same.
                       Defaults to True.
   :type check_dtype: bool
   :param check_category_order: Whether to compare the order of the categories (which implies identical integer codes).
                                If False, only the resulting values are compared. The `ordered` attribute is
                                always checked. Defaults to True.
   :type check_category_order: bool
   :param obj: A name for the object being compared, used in assertion messages.
               Defaults to 'Categorical'.
   :type obj: str


.. py:function:: assert_class_equal(left, right, exact: bool = True, obj: str = 'Input') -> None

   Check classes are equal.


.. py:function:: assert_contains_all(iterable, dic) -> None

   Assert that a dictionary contains all the elements of an iterable.

   :param iterable:
   :type iterable: iterable
   :param dic:
   :type dic: dict


.. py:function:: assert_copy(iter1, iter2, **eql_kwargs) -> None

   Check that the elements are equal, but not the same object.

   Does not check that items in sequences are also not the same object.

   :param iter1: Iterables that produce elements comparable with assert_almost_equal.
   :type iter1: iterable
   :param iter2: Iterables that produce elements comparable with assert_almost_equal.
   :type iter2: iterable


.. py:function:: assert_dict_equal(left, right, compare_keys: bool = True) -> None

   Assert that two dictionaries are equal.

   Values must be arkouda objects.

   :param left: The dictionaries to be compared.
   :type left: dict
   :param right: The dictionaries to be compared.
   :type right: dict
   :param compare_keys: Whether to compare the keys. Defaults to True.
                        If False, only the values are compared.
   :type compare_keys: bool


.. py:function:: assert_equal(left, right, **kwargs) -> None

   Wrap tm.assert_*_equal to dispatch to the appropriate test function.

   :param left: The two items to be compared.
   :type left: Index, Series, DataFrame, or pdarray
   :param right: The two items to be compared.
   :type right: Index, Series, DataFrame, or pdarray
   :param \*\*kwargs: All keyword arguments are passed through to the underlying assert method.


.. py:function:: assert_equivalent(left, right, **kwargs) -> None

   Dispatch to the appropriate assertion function depending on object types.

   :param left: First object to compare. Type determines which assertion function is used.
   :type left: Any
   :param right: Second object to compare.
   :type right: Any
   :param \*\*kwargs: Keyword arguments passed to the specific assertion function.
   :type \*\*kwargs: dict

   :raises AssertionError: If values are not equivalent.

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> import pandas as pd
   >>> from arkouda.testing import assert_equivalent
   >>> ak_series = ak.Series([1, 2, 3])
   >>> pd_series = pd.Series([1, 2, 3])
   >>> assert_equivalent(ak_series, pd_series)


.. py:function:: assert_frame_equal(left: arkouda.DataFrame, right: arkouda.DataFrame, check_dtype: bool = True, check_index_type: bool = True, check_column_type: bool | Literal['equiv'] = 'equiv', check_frame_type: bool = True, check_names: bool = True, check_exact: bool = True, check_categorical: bool = True, check_like: bool = False, rtol: float = 1e-05, atol: float = 1e-08, obj: str = 'DataFrame') -> None

   Check that left and right DataFrame are equal.

   This function is intended to compare two DataFrames and output any
   differences. It is mostly intended for use in unit tests.
   Additional parameters allow varying the strictness of the
   equality checks performed.

   :param left: First DataFrame to compare.
   :type left: DataFrame
   :param right: Second DataFrame to compare.
   :type right: DataFrame
   :param check_dtype: Whether to check the DataFrame dtype is identical. Defaults to True.
   :type check_dtype: bool
   :param check_index_type: Whether to check the Index class, dtype, and inferred_type are identical.
                            Defaults to True.
   :type check_index_type: bool
   :param check_column_type: Whether to check the column class, dtype, and inferred_type are identical.
                             Passed as the ``exact`` argument of :func:`assert_index_equal`.
                             Defaults to 'equiv'.
   :type check_column_type: bool or {'equiv'}
   :param check_frame_type: Whether to check the DataFrame class is identical. Defaults to True.
   :type check_frame_type: bool
   :param check_names: Whether to check that the `names` attribute for both the `index`
                       and `column` attributes of the DataFrame is identical. Defaults to True.
   :type check_names: bool
   :param check_exact: Whether to compare numbers exactly. Defaults to False.
   :type check_exact: bool
   :param check_categorical: Whether to compare internal Categoricals exactly. Defaults to True.
   :type check_categorical: bool
   :param check_like: If True, ignore the order of index and columns.
                      Note: index labels must match their respective rows (as in columns);
                      same labels must be with the same data. Defaults to False.
   :type check_like: bool
   :param rtol: Relative tolerance. Only used when `check_exact` is False. Defaults to 1e-5.
   :type rtol: float
   :param atol: Absolute tolerance. Only used when `check_exact` is False. Defaults to 1e-8.
   :type atol: float
   :param obj: A name for the object being compared, used in assertion messages.
               Defaults to 'DataFrame'.
   :type obj: str

   .. seealso::

      :py:obj:`assert_series_equal`
          Equivalent method for asserting Series equality.

   .. rubric:: Examples

   >>> import arkouda as ak

   This example shows comparing two DataFrames that are equal
   but with columns of differing dtypes.

   >>> from arkouda.testing import assert_frame_equal
   >>> df1 = ak.DataFrame({'a': [1, 2], 'b': [3, 4]})
   >>> df2 = ak.DataFrame({'a': [1, 2], 'b': [3.0, 4.0]})

   df1 equals itself.
   >>> assert_frame_equal(df1, df1)

   df1 differs from df2 as column 'b' is of a different type.
   >>> assert_frame_equal(df1, df2) # doctest: +SKIP
   Traceback (most recent call last):
   ...
   AssertionError: Attributes of DataFrame.iloc[:, 1] (column name="b") are different

   Attribute "dtype" are different
   [left]:  int64
   [right]: float64

   Ignore differing dtypes in columns with check_dtype.

   >>> assert_frame_equal(df1, df2, check_dtype=False)


.. py:function:: assert_frame_equivalent(left: arkouda.DataFrame | pandas.DataFrame, right: arkouda.DataFrame | pandas.DataFrame, check_dtype: bool = True, check_index_type: bool = True, check_column_type: bool = True, check_frame_type: bool = True, check_names: bool = True, check_exact: bool = True, check_categorical: bool = True, check_like: bool = False, rtol: float = 1e-05, atol: float = 1e-08, obj: str = 'DataFrame') -> None

   Check that two DataFrames are equal.

   This function compares two DataFrames and raises an assertion if they differ.
   It is intended primarily for use in unit tests. pandas DataFrames are converted to
   Arkouda equivalents before comparison.

   :param left: First DataFrame to compare.
   :type left: DataFrame or pd.DataFrame
   :param right: Second DataFrame to compare.
   :type right: DataFrame or pd.DataFrame
   :param check_dtype: Whether to check that dtypes are identical. Default is True.
   :type check_dtype: bool
   :param check_index_type: Whether to check that index class, dtype, and inferred type are identical. Default is True.
   :type check_index_type: bool
   :param check_column_type: Whether to check that column class, dtype, and inferred type are identical. Default is True.
   :type check_column_type: bool
   :param check_frame_type: Whether to check that the DataFrame class is identical. Default is True.
   :type check_frame_type: bool
   :param check_names: Whether to check that the index and column names are identical. Default is True.
   :type check_names: bool
   :param check_exact: Whether to compare values exactly. Default is True.
   :type check_exact: bool
   :param check_categorical: Whether to compare internal categoricals exactly. Default is True.
   :type check_categorical: bool
   :param check_like: Whether to ignore the order of index and columns. Labels must still match their data. /
                      Default is False.
   :type check_like: bool
   :param rtol: Relative tolerance used when check_exact is False. Default is 1e-5.
   :type rtol: float
   :param atol: Absolute tolerance used when check_exact is False. Default is 1e-8.
   :type atol: float
   :param obj: Object name used in error messages. Default is "DataFrame".
   :type obj: str

   :raises TypeError: If either input is not a DataFrame or pd.DataFrame.

   .. seealso:: :py:obj:`assert_frame_equal`

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> import pandas as pd
   >>> from arkouda.testing import assert_frame_equivalent
   >>> df1 = ak.DataFrame({'a': [1, 2], 'b': [3, 4]})
   >>> df2 = pd.DataFrame({'a': [1, 2], 'b': [3.0, 4.0]})

   Fails because dtypes are different:
   >>> assert_frame_equivalent(df1, df2)  # doctest: +SKIP


.. py:function:: assert_index_equal(left: arkouda.Index, right: arkouda.Index, exact: bool = True, check_names: bool = True, check_exact: bool = True, check_categorical: bool = True, check_order: bool = True, rtol: float = 1e-05, atol: float = 1e-08, obj: str = 'Index') -> None

   Check that left and right Index are equal.

   :param left: The first Index to compare.
   :type left: Index
   :param right: The second Index to compare.
   :type right: Index
   :param exact: Whether to check that the Index class, dtype, and inferred_type
                 are identical. Defaults to True.
   :type exact: bool
   :param check_names: Whether to check the `name` attribute. Defaults to True.
   :type check_names: bool
   :param check_exact: Whether to compare numbers exactly. Defaults to True.
   :type check_exact: bool
   :param check_categorical: Whether to compare internal Categorical values exactly. Defaults to True.
   :type check_categorical: bool
   :param check_order: Whether to compare the order of index entries as well as their values.
                       If True, both indexes must contain the same elements, in the same order.
                       If False, both indexes must contain the same elements, but in any order.
                       Defaults to True.
   :type check_order: bool
   :param rtol: Relative tolerance. Only used when `check_exact` is False.
                Defaults to 1e-5.
   :type rtol: float
   :param atol: Absolute tolerance. Only used when `check_exact` is False.
                Defaults to 1e-8.
   :type atol: float
   :param obj: A name for the object being compared, used in assertion messages.
               Defaults to 'Index'.
   :type obj: str

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> from arkouda import testing as tm
   >>> a = ak.Index([1, 2, 3])
   >>> b = ak.Index([1, 2, 3])
   >>> tm.assert_index_equal(a, b)


.. py:function:: assert_index_equivalent(left: arkouda.Index | pandas.Index, right: arkouda.Index | pandas.Index, exact: bool = True, check_names: bool = True, check_exact: bool = True, check_categorical: bool = True, check_order: bool = True, rtol: float = 1e-05, atol: float = 1e-08, obj: str = 'Index') -> None

   Check that two Index objects are equal.

   If the objects are pandas Index, they are converted to Arkouda Index.
   Then assert_index_equal is applied to the result.

   :param left: First Index to compare.
   :type left: Index or pd.Index
   :param right: Second Index to compare.
   :type right: Index or pd.Index
   :param exact: Whether to check that class, dtype, and inferred type are identical. Default is True.
   :type exact: bool
   :param check_names: Whether to check the names attribute. Default is True.
   :type check_names: bool
   :param check_exact: Whether to compare values exactly. Default is True.
   :type check_exact: bool
   :param check_categorical: Whether to compare internal Categoricals exactly. Default is True.
   :type check_categorical: bool
   :param check_order: Whether to require identical order in index values. Default is True.
   :type check_order: bool
   :param rtol: Relative tolerance used when check_exact is False. Default is 1e-5.
   :type rtol: float
   :param atol: Absolute tolerance used when check_exact is False. Default is 1e-8.
   :type atol: float
   :param obj: Object name used in error messages. Default is "Index".
   :type obj: str

   :raises TypeError: If either input is not an Index or pd.Index.

   .. seealso:: :py:obj:`assert_index_equal`

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> from arkouda import testing as tm
   >>> import pandas as pd
   >>> a = ak.Index([1, 2, 3])
   >>> b = pd.Index([1, 2, 3])
   >>> tm.assert_index_equivalent(a, b)


.. py:function:: assert_is_sorted(seq) -> None

   Assert that the sequence is sorted.


.. py:function:: assert_series_equal(left, right, check_dtype: bool = True, check_index_type: bool = True, check_series_type: bool = True, check_names: bool = True, check_exact: bool = False, check_categorical: bool = True, check_category_order: bool = True, rtol: float = 1e-05, atol: float = 1e-08, obj: str = 'Series', *, check_index: bool = True, check_like: bool = False) -> None

   Check that left and right Series are equal.

   :param left: First Series to compare.
   :type left: Series
   :param right: Second Series to compare.
   :type right: Series
   :param check_dtype: Whether to check the Series dtype is identical. Defaults to True.
   :type check_dtype: bool
   :param check_index_type: Whether to check the Index class, dtype, and inferred_type are identical. Defaults to True.
   :type check_index_type: bool
   :param check_series_type: Whether to check that the Series class is identical. Defaults to True.
   :type check_series_type: bool
   :param check_names: Whether to check the Series and Index `name` attribute. Defaults to True.
   :type check_names: bool
   :param check_exact: Whether to compare numbers exactly. Defaults to False.
   :type check_exact: bool
   :param check_categorical: Whether to compare internal Categoricals exactly. Defaults to True.
   :type check_categorical: bool
   :param check_category_order: Whether to compare the category order of internal Categoricals. Defaults to True.
   :type check_category_order: bool
   :param rtol: Relative tolerance. Only used when `check_exact` is False. Defaults to 1e-5.
   :type rtol: float
   :param atol: Absolute tolerance. Only used when `check_exact` is False. Defaults to 1e-8.
   :type atol: float
   :param obj: Name of the object being compared, used in assertion messages. Defaults to 'Series'.
   :type obj: str
   :param check_index: Whether to check index equivalence. If False, only the values are compared. Defaults to True.
   :type check_index: bool
   :param check_like: If True, ignore the order of the index.
                      Must be False if `check_index` is False.
                      Note: same labels must be with the same data. Defaults to False.
   :type check_like: bool

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> from arkouda import testing as tm
   >>> a = ak.Series([1, 2, 3, 4])
   >>> b = ak.Series([1, 2, 3, 4])
   >>> tm.assert_series_equal(a, b)


.. py:function:: assert_series_equivalent(left: arkouda.Series | pandas.Series, right: arkouda.Series | pandas.Series, check_dtype: bool = True, check_index_type: bool = True, check_series_type: bool = True, check_names: bool = True, check_exact: bool = False, check_categorical: bool = True, check_category_order: bool = True, rtol: float = 1e-05, atol: float = 1e-08, obj: str = 'Series', *, check_index: bool = True, check_like: bool = False) -> None

   Check that two Series are equal.

   This function compares two Series and raises an assertion if they differ.
   pandas Series are converted to Arkouda equivalents before comparison.
   The comparison can be customized using the provided keyword arguments.

   :param left: First Series to compare.
   :type left: Series or pd.Series
   :param right: Second Series to compare.
   :type right: Series or pd.Series
   :param check_dtype: Whether to check that dtypes are identical. Default is True.
   :type check_dtype: bool
   :param check_index_type: Whether to check that index class, dtype, and inferred type are identical. Default is True.
   :type check_index_type: bool
   :param check_series_type: Whether to check that the Series class is identical. Default is True.
   :type check_series_type: bool
   :param check_names: Whether to check that the Series and Index name attributes are identical. Default is True.
   :type check_names: bool
   :param check_exact: Whether to compare numbers exactly. Default is False.
   :type check_exact: bool
   :param check_categorical: Whether to compare internal Categoricals exactly. Default is True.
   :type check_categorical: bool
   :param check_category_order: Whether to compare category order in internal Categoricals. Default is True.
   :type check_category_order: bool
   :param rtol: Relative tolerance used when check_exact is False. Default is 1e-5.
   :type rtol: float
   :param atol: Absolute tolerance used when check_exact is False. Default is 1e-8.
   :type atol: float
   :param obj: Object name used in error messages. Default is "Series".
   :type obj: str
   :param check_index: Whether to check index equivalence. If False, only values are compared. Default is True.
   :type check_index: bool
   :param check_like: If True, ignore the order of the index. Must be False if check_index is False.
                      Note: identical labels must still correspond to the same data. Default is False.
   :type check_like: bool

   :raises TypeError: If either input is not a Series or pd.Series.

   .. seealso:: :py:obj:`assert_series_equal`

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> from arkouda import testing as tm
   >>> import pandas as pd
   >>> a = ak.Series([1, 2, 3, 4])
   >>> b = pd.Series([1, 2, 3, 4])
   >>> tm.assert_series_equivalent(a, b)


.. py:function:: chisquare(f_obs, f_exp=None, ddof=0)

   Computes the chi square statistic and p-value.

   :param f_obs: The observed frequency.
   :type f_obs: pdarray
   :param f_exp: The expected frequency.
   :type f_exp: pdarray, default = None
   :param ddof: The delta degrees of freedom.
   :type ddof: int

   :rtype: arkouda.akstats.Power_divergenceResult

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> from arkouda.scipy import chisquare
   >>> chisquare(ak.array([10, 20, 30, 10]), ak.array([10, 30, 20, 10]))
   Power_divergenceResult(statistic=np.float64(8.333333333333334), pvalue=np.float64(0.03960235520...))

   .. seealso:: :py:obj:`scipy.stats.chisquare`, :py:obj:`arkouda.akstats.power_divergence`

   .. rubric:: References

   [1] â€œChi-squared testâ€, https://en.wikipedia.org/wiki/Chi-squared_test

   [2] "scipy.stats.chisquare",
   https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.chisquare.html


.. py:function:: compute_join_size(a: arkouda.numpy.pdarrayclass.pdarray, b: arkouda.numpy.pdarrayclass.pdarray) -> Tuple[int, int]

   Compute the internal size of a hypothetical join between a and b. Returns
   both the number of elements and number of bytes required for the join.


.. py:function:: date_operators(cls)

   Add common datetime operation methods to a DatetimeAccessor class.

   This class decorator dynamically attaches datetime operations (`floor`,
   `ceil`, `round`) to the given class using the `_make_op` helper.

   :param cls: The accessor class to decorate.
   :type cls: type

   :returns: The accessor class with datetime methods added.
   :rtype: type

   .. rubric:: Notes

   Used internally to implement the `.dt` accessor API.


.. py:function:: disableVerbose(logLevel: LogLevel = LogLevel.INFO)

   Deprecated alias for :func:`disable_verbose`.

   This function exists for backward compatibility only. Use
   :func:`disable_verbose` instead.

   :param logLevel: The log level to apply to all ArkoudaLoggers, disabling
                    verbose (DEBUG-level) output.
   :type logLevel: LogLevel, default LogLevel.INFO

   :rtype: None

   :Warns: **DeprecationWarning** -- Always raised. ``disableVerbose`` is deprecated and will be removed
           in a future release.

   .. seealso::

      :py:obj:`disable_verbose`
          Disable verbose logging for all loggers.

      :py:obj:`enable_verbose`
          Enable verbose logging for all loggers.


.. py:function:: disable_verbose(logLevel: LogLevel = LogLevel.INFO) -> None

   Disables verbose logging.

   Disables verbose logging (DEBUG log level) for all ArkoudaLoggers, setting
   the log level for each to the logLevel parameter.

   :param logLevel: The new log level, defaultts to LogLevel.INFO
   :type logLevel: LogLevel

   :raises TypeError: Raised if logLevel is not a LogLevel enum


.. py:function:: enableVerbose()

   Deprecated alias for :func:`enable_verbose`.

   This function exists for backward compatibility only. Use
   :func:`enable_verbose` instead.

   :rtype: None

   :Warns: **DeprecationWarning** -- Always raised. ``enableVerbose`` is deprecated and will be removed
           in a future release.

   .. seealso::

      :py:obj:`enable_verbose`
          Enable verbose (DEBUG-level) logging for all loggers.


.. py:function:: enable_verbose() -> None

   Enable verbose logging (DEBUG log level) for all ArkoudaLoggers.


.. py:function:: from_series(series: pandas.Series, dtype: Optional[Union[type, str]] = None) -> Union[arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.strings.Strings]

   Convert a pandas ``Series`` to an Arkouda ``pdarray`` or ``Strings``.

   If ``dtype`` is not provided, the dtype is inferred from the pandas
   ``Series`` (using pandas' dtype metadata). If ``dtype`` is provided, it
   is used as an override and normalized via Arkouda's dtype resolution rules.

   In addition to the core numeric/bool types, this function supports
   datetime and timedelta Series of **any** resolution (``ns``, ``us``, ``ms``,
   etc.) by converting them to an ``int64`` pdarray of nanoseconds.

   :param series: The pandas Series to convert.
   :type series: pd.Series
   :param dtype: Optional dtype override. This may be a Python type (e.g. ``bool``),
                 a NumPy scalar type (e.g. ``np.int64``), or a dtype string.

                 String-like spellings are normalized to Arkouda string dtype, including:
                 ``"object"``, ``"str"``, ``"string"``, ``"string[python]"``,
                 and ``"string[pyarrow]"``.
   :type dtype: Optional[Union[type, str]], optional

   :returns: An Arkouda ``pdarray`` for numeric/bool/datetime/timedelta inputs, or an
             Arkouda ``Strings`` for string inputs.
   :rtype: Union[pdarray, Strings]

   :raises ValueError: Raised if the dtype cannot be interpreted or is unsupported for conversion.

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> import numpy as np
   >>> import pandas as pd

   # ints
   >>> np.random.seed(1701)
   >>> ak.from_series(pd.Series(np.random.randint(0, 10, 5)))
   array([4 3 3 5 0])

   >>> ak.from_series(pd.Series(['1', '2', '3', '4', '5']), dtype=np.int64)
   array([1 2 3 4 5])

   # floats
   >>> np.random.seed(1701)
   >>> ak.from_series(pd.Series(np.random.uniform(low=0.0, high=1.0, size=3)))
   array([0.089433234324597599 0.1153776854774361 0.51874393620990389])

   # bools
   >>> np.random.seed(1864)
   >>> ak.from_series(pd.Series(np.random.choice([True, False], size=5)))
   array([True True True False False])

   # strings: pandas dtype spellings normalized to Arkouda Strings
   >>> ak.from_series(pd.Series(['a', 'b', 'c', 'd', 'e'], dtype="string"))
   array(['a', 'b', 'c', 'd', 'e'])

   >>> ak.from_series(pd.Series(['a', 'b', 'c'], dtype="string[pyarrow]"))
   array(['a', 'b', 'c'])

   # datetime: any resolution is accepted, returned as int64 nanoseconds
   >>> ak.from_series(pd.Series(pd.to_datetime(['1/1/2018', np.datetime64('2018-01-01')])))
   array([1514764800000000000 1514764800000000000])

   .. rubric:: Notes

   - Datetime and timedelta Series are converted to ``int64`` nanoseconds.
   - String-like pandas dtypes (including ``object``) are treated as string and
     converted to Arkouda ``Strings``.


.. py:function:: gen_ranges(starts, ends, stride=1, return_lengths=False)

   Generate a segmented array of variable-length, contiguous ranges between pairs of
   start- and end-points.

   :param starts: The start value of each range
   :type starts: pdarray, int64
   :param ends: The end value (exclusive) of each range
   :type ends: pdarray, int64
   :param stride: Difference between successive elements of each range
   :type stride: int
   :param return_lengths: Whether or not to return the lengths of each segment. Default False.
   :type return_lengths: bool, optional

   :returns:

             segments : pdarray, int64
                 The starting index of each range in the resulting array
             ranges : pdarray, int64
                 The actual ranges, flattened into a single array
             lengths : pdarray, int64
                 The lengths of each segment. Only returned if return_lengths=True.
   :rtype: pdarray|int64, pdarray|int64, pdarray|int64


.. py:function:: information(names: Union[List[str], str] = RegisteredSymbols) -> str

   Return a JSON formatted string containing information about the objects in names.

   :param names: names is either the name of an object or list of names of objects to retrieve info
                 if names is ak.AllSymbols, retrieves info for all symbols in the symbol table
                 if names is ak.RegisteredSymbols, retrieves info for all symbols in the registry
   :type names: Union[List[str], str]

   :returns: JSON formatted string containing a list of information for each object in names
   :rtype: str

   :raises RuntimeError: Raised if a server-side error is thrown in the process of
       retrieving information about the objects in names


.. py:function:: join_on_eq_with_dt(a1: arkouda.numpy.pdarrayclass.pdarray, a2: arkouda.numpy.pdarrayclass.pdarray, t1: arkouda.numpy.pdarrayclass.pdarray, t2: arkouda.numpy.pdarrayclass.pdarray, dt: Union[int, numpy.int64], pred: str, result_limit: Union[int, numpy.int64] = 1000) -> Tuple[arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.pdarrayclass.pdarray]

   Inner-join on equality between two integer arrays where the time-window predicate is also true.

   :param a1: Values to join (must be int64 dtype).
   :type a1: pdarray
   :param a2: Values to join (must be int64 dtype).
   :type a2: pdarray
   :param t1: timestamps in millis corresponding to the a1 pdarray
   :type t1: pdarray
   :param t2: timestamps in millis corresponding to the a2 pdarray
   :type t2: pdarray
   :param dt: time delta
   :type dt: Union[int,np.int64]
   :param pred: time window predicate
   :type pred: str
   :param result_limit: size limit for returned result
   :type result_limit: Union[int,np.int64]

   :returns:

             result_array_one : pdarray, int64
                 a1 indices where a1 == a2
             result_array_one : pdarray, int64
                 a2 indices where a2 == a1
   :rtype: Tuple[pdarray, pdarray]

   :raises TypeError: Raised if a1, a2, t1, or t2 is not a pdarray, or if dt or
       result_limit is not an int
   :raises ValueError: if a1, a2, t1, or t2 dtype is not int64, pred is not
       'true_dt', 'abs_dt', or 'pos_dt', or result_limit is < 0


.. py:function:: list_registry(detailed: bool = False)

   Return a list containing the names of all registered objects.

   :param detailed: Default = False
                    Return details of registry objects. Currently includes object type for any objects
   :type detailed: bool

   :returns: Dict containing keys "Components" and "Objects".
   :rtype: dict

   :raises RuntimeError: Raised if there's a server-side error thrown


.. py:function:: list_symbol_table() -> List[str]

   Return a list containing the names of all objects in the symbol table.

   :returns: List of all object names in the symbol table
   :rtype: list

   :raises RuntimeError: Raised if there's a server-side error thrown


.. py:function:: power_divergence(f_obs, f_exp=None, ddof=0, lambda_=None)

   Computes the power divergence statistic and p-value.

   :param f_obs: The observed frequency.
   :type f_obs: pdarray
   :param f_exp: The expected frequency.
   :type f_exp: pdarray, default = None
   :param ddof: The delta degrees of freedom.
   :type ddof: int
   :param lambda_: The power in the Cressie-Read power divergence statistic.
                   Allowed values: "pearson", "log-likelihood", "freeman-tukey", "mod-log-likelihood",
                   "neyman", "cressie-read"

                   Powers correspond as follows:

                   "pearson": 1

                   "log-likelihood": 0

                   "freeman-tukey": -0.5

                   "mod-log-likelihood": -1

                   "neyman": -2

                   "cressie-read": 2 / 3
   :type lambda_: string, default = "pearson"

   :rtype: arkouda.akstats.Power_divergenceResult

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> from arkouda.scipy import power_divergence
   >>> x = ak.array([10, 20, 30, 10])
   >>> y = ak.array([10, 30, 20, 10])
   >>> power_divergence(x, y, lambda_="pearson")
   Power_divergenceResult(statistic=np.float64(8.333333333333334), pvalue=np.float64(0.03960235520...))
   >>> power_divergence(x, y, lambda_="log-likelihood")
   Power_divergenceResult(statistic=np.float64(8.109302162163285), pvalue=np.float64(0.04380595350...))

   .. seealso:: :py:obj:`scipy.stats.power_divergence`, :py:obj:`arkouda.akstats.chisquare`

   .. rubric:: Notes

   This is a modified version of scipy.stats.power_divergence [2]
   in order to scale using arkouda pdarrays.

   .. rubric:: References

   [1] "scipy.stats.power_divergence",
   https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.power_divergence.html

   [2] Scipy contributors (2024) scipy (Version v1.12.0) [Source code].
   https://github.com/scipy/scipy


.. py:function:: pretty_print_information(names: Union[List[str], str] = RegisteredSymbols) -> None

   Print verbose information for each object in names in a human readable format.

   :param names: names is either the name of an object or list of names of objects to retrieve info
                 if names is ak.AllSymbols, retrieves info for all symbols in the symbol table
                 if names is ak.RegisteredSymbols, retrieves info for all symbols in the registry
   :type names: Union[List[str], str]

   :raises RuntimeError: Raised if a server-side error is thrown in the process of
       retrieving information about the objects in names


.. py:function:: string_operators(cls)

   Add common string operation methods to a StringAccessor class.

   This class decorator dynamically attaches string operations (`contains`,
   `startswith`, `endswith`) to the given class using the `_make_op` helper.

   :param cls: The accessor class to decorate.
   :type cls: type

   :returns: The accessor class with string methods added.
   :rtype: type

   .. rubric:: Notes

   Used internally to implement the `.str` accessor API.


.. py:function:: write_log(log_msg: str, tag: str = 'ClientGeneratedLog', log_lvl: LogLevel = LogLevel.INFO)

   Allow the user to write custom logs.

   :param log_msg: The message to be added to the server log
   :type log_msg: str
   :param tag: The tag to use in the log. This takes the place of the server function name.
               Allows for easy identification of custom logs.
               Defaults to "ClientGeneratedLog"
   :type tag: str
   :param log_lvl: The type of log to be written
                   Defaults to LogLevel.INFO
   :type log_lvl: LogLevel

   .. seealso:: :py:obj:`LogLevel`


.. py:function:: xlogy(x: Union[arkouda.numpy.pdarrayclass.pdarray, numpy.float64], y: arkouda.numpy.pdarrayclass.pdarray)

   Computes x * log(y).

   :param x: x must have a datatype that is castable to float64
   :type x: pdarray or np.float64
   :param y:
   :type y: pdarray

   :rtype: arkouda.numpy.pdarrayclass.pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> from arkouda.scipy.special import xlogy
   >>> xlogy( ak.array([1, 2, 3, 4]),  ak.array([5,6,7,8]))
   array([1.6094379124341003 3.5835189384561099 5.8377304471659395 8.317766166719343])
   >>> xlogy( 5.0, ak.array([1, 2, 3, 4]))
   array([0.00000000000000000 3.4657359027997265 5.4930614433405491 6.9314718055994531])


