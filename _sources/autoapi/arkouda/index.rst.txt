arkouda
=======

.. py:module:: arkouda

.. autoapi-nested-parse::

   Arkouda: Exploratory data science at scale.

   Arkouda is a Python API for exploratory data analysis on massive datasets. It
   leverages a Chapel-based backend to enable high-performance computing on
   distributed systems, while exposing a familiar NumPy- and Pandas-like interface
   to Python users.

   Key Features
   ------------
   - `pdarray` and `Strings` types for working with large numeric and string arrays.
   - `Categorical`, `Series`, `DataFrame`, and `Index` for labeled data analysis.
   - High-performance `GroupBy`, reductions, and broadcasting operations.
   - Interoperability with NumPy and Pandas for ease of use.
   - A scalable architecture suitable for HPC and cloud environments.

   Example:
   -------
   >>> import arkouda as ak
   >>> ak.connect()
   >>> a = ak.array([1, 2, 3])
   >>> b = a + 5
   >>> print(b)
   array([6 7 8])

   For full documentation, visit: https://bears-r-us.github.io/arkouda/



Submodules
----------

.. toctree::
   :maxdepth: 1

   /autoapi/arkouda/accessor/index
   /autoapi/arkouda/alignment/index
   /autoapi/arkouda/apply/index
   /autoapi/arkouda/array_api/index
   /autoapi/arkouda/client/index
   /autoapi/arkouda/client_dtypes/index
   /autoapi/arkouda/comm_diagnostics/index
   /autoapi/arkouda/history/index
   /autoapi/arkouda/infoclass/index
   /autoapi/arkouda/logger/index
   /autoapi/arkouda/numpy/index
   /autoapi/arkouda/pandas/index
   /autoapi/arkouda/plotting/index
   /autoapi/arkouda/scipy/index
   /autoapi/arkouda/security/index
   /autoapi/arkouda/testing/index


Attributes
----------

.. autoapisummary::

   arkouda.AllSymbols
   arkouda.RegisteredSymbols
   arkouda.SortingAlgorithm
   arkouda.e
   arkouda.euler_gamma
   arkouda.inf
   arkouda.nan
   arkouda.newaxis
   arkouda.pi


Exceptions
----------

.. autoapisummary::

   arkouda.NonUniqueError
   arkouda.RegistrationError


Classes
-------

.. autoapisummary::

   arkouda.ARKOUDA_SUPPORTED_DTYPES
   arkouda.ARKOUDA_SUPPORTED_INTS
   arkouda.ArkoudaArray
   arkouda.ArkoudaBigintDtype
   arkouda.ArkoudaBoolDtype
   arkouda.ArkoudaCategoricalArray
   arkouda.ArkoudaCategoricalDtype
   arkouda.ArkoudaFloat64Dtype
   arkouda.ArkoudaInt64Dtype
   arkouda.ArkoudaStringArray
   arkouda.ArkoudaStringDtype
   arkouda.ArkoudaUint64Dtype
   arkouda.ArkoudaUint8Dtype
   arkouda.BoolDType
   arkouda.ByteDType
   arkouda.BytesDType
   arkouda.CLongDoubleDType
   arkouda.CachedAccessor
   arkouda.Complex128DType
   arkouda.Complex64DType
   arkouda.DType
   arkouda.DTypeObjects
   arkouda.DTypes
   arkouda.DateTime64DType
   arkouda.Datetime
   arkouda.DatetimeAccessor
   arkouda.ErrorMode
   arkouda.False_
   arkouda.Float16DType
   arkouda.Float32DType
   arkouda.Float64DType
   arkouda.Int16DType
   arkouda.Int32DType
   arkouda.Int64DType
   arkouda.Int8DType
   arkouda.IntDType
   arkouda.LogLevel
   arkouda.LongDType
   arkouda.LongDoubleDType
   arkouda.LongLongDType
   arkouda.NUMBER_FORMAT_STRINGS
   arkouda.NumericDTypes
   arkouda.ObjectDType
   arkouda.Power_divergenceResult
   arkouda.Properties
   arkouda.Row
   arkouda.ScalarDTypes
   arkouda.ScalarType
   arkouda.SegArray
   arkouda.Series
   arkouda.SeriesDTypes
   arkouda.ShortDType
   arkouda.StrDType
   arkouda.StringAccessor
   arkouda.Strings
   arkouda.TimeDelta64DType
   arkouda.Timedelta
   arkouda.True_
   arkouda.UByteDType
   arkouda.UInt16DType
   arkouda.UInt32DType
   arkouda.UInt64DType
   arkouda.UInt8DType
   arkouda.UIntDType
   arkouda.ULongDType
   arkouda.ULongLongDType
   arkouda.UShortDType
   arkouda.VoidDType
   arkouda.all_scalars
   arkouda.bigint
   arkouda.bitType
   arkouda.bool
   arkouda.bool_scalars
   arkouda.byte
   arkouda.bytes_
   arkouda.cdouble
   arkouda.clongdouble
   arkouda.complex128
   arkouda.complex64
   arkouda.csingle
   arkouda.datetime64
   arkouda.double
   arkouda.finfo
   arkouda.flexible
   arkouda.float16
   arkouda.float32
   arkouda.float64
   arkouda.float_scalars
   arkouda.floating
   arkouda.half
   arkouda.iinfo
   arkouda.inexact
   arkouda.int16
   arkouda.int32
   arkouda.int64
   arkouda.int8
   arkouda.intTypes
   arkouda.int_scalars
   arkouda.intc
   arkouda.intp
   arkouda.longdouble
   arkouda.longlong
   arkouda.number
   arkouda.numeric_and_bool_scalars
   arkouda.numeric_scalars
   arkouda.numpy_scalars
   arkouda.pdarray
   arkouda.sctypeDict
   arkouda.short
   arkouda.signedinteger
   arkouda.single
   arkouda.str_
   arkouda.str_scalars
   arkouda.timedelta64
   arkouda.ubyte
   arkouda.uint
   arkouda.uint16
   arkouda.uint32
   arkouda.uint64
   arkouda.uint8
   arkouda.uintc
   arkouda.uintp
   arkouda.ulonglong
   arkouda.unsignedinteger
   arkouda.ushort
   arkouda.void


Functions
---------

.. autoapisummary::

   arkouda.abs
   arkouda.align
   arkouda.append
   arkouda.apply
   arkouda.arange
   arkouda.arccos
   arkouda.arccosh
   arkouda.arcsin
   arkouda.arcsinh
   arkouda.arctan
   arkouda.arctan2
   arkouda.arctanh
   arkouda.argmaxk
   arkouda.argmink
   arkouda.argsort
   arkouda.array
   arkouda.array_equal
   arkouda.assert_almost_equal
   arkouda.assert_almost_equivalent
   arkouda.assert_arkouda_array_equal
   arkouda.assert_arkouda_array_equivalent
   arkouda.assert_arkouda_pdarray_equal
   arkouda.assert_arkouda_segarray_equal
   arkouda.assert_arkouda_strings_equal
   arkouda.assert_attr_equal
   arkouda.assert_categorical_equal
   arkouda.assert_class_equal
   arkouda.assert_contains_all
   arkouda.assert_copy
   arkouda.assert_dict_equal
   arkouda.assert_equal
   arkouda.assert_equivalent
   arkouda.assert_frame_equal
   arkouda.assert_frame_equivalent
   arkouda.assert_index_equal
   arkouda.assert_index_equivalent
   arkouda.assert_is_sorted
   arkouda.assert_series_equal
   arkouda.assert_series_equivalent
   arkouda.attach
   arkouda.attach_all
   arkouda.base_repr
   arkouda.bigint_from_uint_arrays
   arkouda.binary_repr
   arkouda.broadcast_arrays
   arkouda.broadcast_dims
   arkouda.broadcast_shapes
   arkouda.broadcast_to
   arkouda.can_cast
   arkouda.cast
   arkouda.ceil
   arkouda.chisquare
   arkouda.clear
   arkouda.clip
   arkouda.clz
   arkouda.coargsort
   arkouda.compute_join_size
   arkouda.concatenate
   arkouda.copy
   arkouda.corr
   arkouda.cos
   arkouda.cosh
   arkouda.count_nonzero
   arkouda.cov
   arkouda.ctz
   arkouda.cumprod
   arkouda.cumsum
   arkouda.date_operators
   arkouda.date_range
   arkouda.deg2rad
   arkouda.delete
   arkouda.diff
   arkouda.disableVerbose
   arkouda.divmod
   arkouda.dot
   arkouda.dtype
   arkouda.enableVerbose
   arkouda.errstate
   arkouda.exp
   arkouda.expm1
   arkouda.eye
   arkouda.fabs
   arkouda.find
   arkouda.flip
   arkouda.floor
   arkouda.fmod
   arkouda.format_float_positional
   arkouda.format_float_scientific
   arkouda.from_series
   arkouda.full
   arkouda.full_like
   arkouda.gen_ranges
   arkouda.get_byteorder
   arkouda.get_server_byteorder
   arkouda.geterr
   arkouda.geterrcall
   arkouda.hash
   arkouda.hist_all
   arkouda.histogram
   arkouda.histogram2d
   arkouda.histogramdd
   arkouda.hstack
   arkouda.in1d
   arkouda.in1d_intervals
   arkouda.indexof1d
   arkouda.information
   arkouda.intersect1d
   arkouda.interval_lookup
   arkouda.isSupportedBool
   arkouda.isSupportedDType
   arkouda.isSupportedFloat
   arkouda.isSupportedInt
   arkouda.isSupportedNumber
   arkouda.is_cosorted
   arkouda.is_registered
   arkouda.isfinite
   arkouda.isinf
   arkouda.isnan
   arkouda.isnumeric
   arkouda.isscalar
   arkouda.issubdtype
   arkouda.join_on_eq_with_dt
   arkouda.left_align
   arkouda.linspace
   arkouda.list_registry
   arkouda.list_symbol_table
   arkouda.log
   arkouda.log10
   arkouda.log1p
   arkouda.log2
   arkouda.logspace
   arkouda.lookup
   arkouda.matmul
   arkouda.maxk
   arkouda.may_share_memory
   arkouda.median
   arkouda.mink
   arkouda.mod
   arkouda.nextafter
   arkouda.ones
   arkouda.ones_like
   arkouda.parity
   arkouda.percentile
   arkouda.plot_dist
   arkouda.popcount
   arkouda.power
   arkouda.power_divergence
   arkouda.pretty_print_information
   arkouda.promote_to_common_dtype
   arkouda.putmask
   arkouda.quantile
   arkouda.rad2deg
   arkouda.randint
   arkouda.random_strings_lognormal
   arkouda.random_strings_uniform
   arkouda.register_all
   arkouda.repeat
   arkouda.resolve_scalar_dtype
   arkouda.result_type
   arkouda.right_align
   arkouda.rotl
   arkouda.rotr
   arkouda.round
   arkouda.scalar_array
   arkouda.search_intervals
   arkouda.searchsorted
   arkouda.setdiff1d
   arkouda.seterr
   arkouda.seterrcall
   arkouda.setxor1d
   arkouda.shape
   arkouda.shares_memory
   arkouda.sign
   arkouda.sin
   arkouda.sinh
   arkouda.sort
   arkouda.sqrt
   arkouda.square
   arkouda.squeeze
   arkouda.standard_normal
   arkouda.string_operators
   arkouda.take
   arkouda.tan
   arkouda.tanh
   arkouda.tile
   arkouda.timedelta_range
   arkouda.transpose
   arkouda.tril
   arkouda.triu
   arkouda.trunc
   arkouda.typename
   arkouda.uniform
   arkouda.union1d
   arkouda.unregister
   arkouda.unregister_all
   arkouda.unsqueeze
   arkouda.value_counts
   arkouda.vecdot
   arkouda.vstack
   arkouda.where
   arkouda.write_log
   arkouda.xlogy
   arkouda.zero_up
   arkouda.zeros
   arkouda.zeros_like


Package Contents
----------------

.. py:class:: ARKOUDA_SUPPORTED_DTYPES

   Built-in immutable sequence.

   If no argument is given, the constructor returns an empty tuple.
   If iterable is specified the tuple is initialized from iterable's items.

   If the argument is a tuple, the return value is the same object.


   .. py:method:: count(value, /)

      Return number of occurrences of value.



   .. py:method:: index(value, start=0, stop=9223372036854775807, /)

      Return first index of value.

      Raises ValueError if the value is not present.



.. py:class:: ARKOUDA_SUPPORTED_INTS

   Built-in immutable sequence.

   If no argument is given, the constructor returns an empty tuple.
   If iterable is specified the tuple is initialized from iterable's items.

   If the argument is a tuple, the return value is the same object.


   .. py:method:: count(value, /)

      Return number of occurrences of value.



   .. py:method:: index(value, start=0, stop=9223372036854775807, /)

      Return first index of value.

      Raises ValueError if the value is not present.



.. py:data:: AllSymbols
   :value: '__AllSymbols__'


.. py:class:: ArkoudaArray(data)

   Bases: :py:obj:`arkouda.pandas.extension._arkouda_base_array.ArkoudaBaseArray`, :py:obj:`pandas.api.extensions.ExtensionArray`


   Abstract base class for custom 1-D array types.

   pandas will recognize instances of this class as proper arrays
   with a custom type and will not attempt to coerce them to objects. They
   may be stored directly inside a :class:`DataFrame` or :class:`Series`.

   .. attribute:: dtype



   .. attribute:: nbytes



   .. attribute:: ndim



   .. attribute:: shape



   .. method:: argsort

   .. method:: astype

   .. method:: copy

   .. method:: dropna

   .. method:: duplicated

   .. method:: factorize

   .. method:: fillna

   .. method:: equals

   .. method:: insert

   .. method:: interpolate

   .. method:: isin

   .. method:: isna

   .. method:: ravel

   .. method:: repeat

   .. method:: searchsorted

   .. method:: shift

   .. method:: take

   .. method:: tolist

   .. method:: unique

   .. method:: view

   .. method:: _accumulate

   .. method:: _concat_same_type

   .. method:: _explode

   .. method:: _formatter

   .. method:: _from_factorized

   .. method:: _from_sequence

   .. method:: _from_sequence_of_strings

   .. method:: _hash_pandas_object

   .. method:: _pad_or_backfill

   .. method:: _reduce

   .. method:: _values_for_argsort

   .. method:: _values_for_factorize



   .. rubric:: Notes

   The interface includes the following abstract methods that must be
   implemented by subclasses:

   * _from_sequence
   * _from_factorized
   * __getitem__
   * __len__
   * __eq__
   * dtype
   * nbytes
   * isna
   * take
   * copy
   * _concat_same_type
   * interpolate

   A default repr displaying the type, (truncated) data, length,
   and dtype is provided. It can be customized or replaced by
   by overriding:

   * __repr__ : A default repr for the ExtensionArray.
   * _formatter : Print scalars inside a Series or DataFrame.

   Some methods require casting the ExtensionArray to an ndarray of Python
   objects with ``self.astype(object)``, which may be expensive. When
   performance is a concern, we highly recommend overriding the following
   methods:

   * fillna
   * _pad_or_backfill
   * dropna
   * unique
   * factorize / _values_for_factorize
   * argsort, argmax, argmin / _values_for_argsort
   * searchsorted
   * map

   The remaining methods implemented on this class should be performant,
   as they only compose abstract methods. Still, a more efficient
   implementation may be available, and these methods can be overridden.

   One can implement methods to handle array accumulations or reductions.

   * _accumulate
   * _reduce

   One can implement methods to handle parsing from strings that will be used
   in methods such as ``pandas.io.parsers.read_csv``.

   * _from_sequence_of_strings

   This class does not inherit from 'abc.ABCMeta' for performance reasons.
   Methods and properties required by the interface raise
   ``pandas.errors.AbstractMethodError`` and no ``register`` method is
   provided for registering virtual subclasses.

   ExtensionArrays are limited to 1 dimension.

   They may be backed by none, one, or many NumPy arrays. For example,
   ``pandas.Categorical`` is an extension array backed by two arrays,
   one for codes and one for categories. An array of IPv6 address may
   be backed by a NumPy structured array with two fields, one for the
   lower 64 bits and one for the upper 64 bits. Or they may be backed
   by some other storage type, like Python lists. Pandas makes no
   assumptions on how the data are stored, just that it can be converted
   to a NumPy array.
   The ExtensionArray interface does not impose any rules on how this data
   is stored. However, currently, the backing data cannot be stored in
   attributes called ``.values`` or ``._values`` to ensure full compatibility
   with pandas internals. But other names as ``.data``, ``._data``,
   ``._items``, ... can be freely used.

   If implementing NumPy's ``__array_ufunc__`` interface, pandas expects
   that

   1. You defer by returning ``NotImplemented`` when any Series are present
      in `inputs`. Pandas will extract the arrays and call the ufunc again.
   2. You define a ``_HANDLED_TYPES`` tuple as an attribute on the class.
      Pandas inspect this to determine whether the ufunc is valid for the
      types present.

   See :ref:`extending.extension.ufunc` for more.

   By default, ExtensionArrays are not hashable.  Immutable subclasses may
   override this behavior.

   .. rubric:: Examples

   Please see the following:

   https://github.com/pandas-dev/pandas/blob/main/pandas/tests/extension/list/array.py


   .. py:method:: argsort(ascending=True)

      Return the indices that would sort this array.

      :param ascending: Whether the indices should result in an ascending
                        or descending sort.
      :type ascending: bool, default True
      :param kind: Sorting algorithm.
      :type kind: {'quicksort', 'mergesort', 'heapsort', 'stable'}, optional
      :param na_position: If ``'first'``, put ``NaN`` values at the beginning.
                          If ``'last'``, put ``NaN`` values at the end.
      :type na_position: {'first', 'last'}, default 'last'
      :param \*args: Passed through to :func:`numpy.argsort`.
      :param \*\*kwargs: Passed through to :func:`numpy.argsort`.

      :returns: Array of indices that sort ``self``. If NaN values are contained,
                NaN values are placed at the end.
      :rtype: np.ndarray[np.intp]

      .. seealso::

         :py:obj:`numpy.argsort`
             Sorting implementation used internally.

      .. rubric:: Examples

      >>> arr = pd.array([3, 1, 2, 5, 4])
      >>> arr.argsort()
      array([1, 2, 0, 4, 3])



   .. py:method:: astype(dtype, copy: bool = False)

      Cast to a NumPy array or ExtensionArray with 'dtype'.

      :param dtype: Typecode or data-type to which the array is cast.
      :type dtype: str or dtype
      :param copy: Whether to copy the data, even if not necessary. If False,
                   a copy is made only if the old dtype does not match the
                   new dtype.
      :type copy: bool, default True

      :returns: An ``ExtensionArray`` if ``dtype`` is ``ExtensionDtype``,
                otherwise a Numpy ndarray with ``dtype`` for its dtype.
      :rtype: np.ndarray or pandas.api.extensions.ExtensionArray

      .. rubric:: Examples

      >>> arr = pd.array([1, 2, 3])
      >>> arr
      <IntegerArray>
      [1, 2, 3]
      Length: 3, dtype: Int64

      Casting to another ``ExtensionDtype`` returns an ``ExtensionArray``:

      >>> arr1 = arr.astype('Float64')
      >>> arr1
      <FloatingArray>
      [1.0, 2.0, 3.0]
      Length: 3, dtype: Float64
      >>> arr1.dtype
      Float64Dtype()

      Otherwise, we will get a Numpy ndarray:

      >>> arr2 = arr.astype('float64')
      >>> arr2
      array([1., 2., 3.])
      >>> arr2.dtype
      dtype('float64')



   .. py:method:: copy()

      Return a copy of the array.

      :rtype: ExtensionArray

      .. rubric:: Examples

      >>> arr = pd.array([1, 2, 3])
      >>> arr2 = arr.copy()
      >>> arr[0] = 2
      >>> arr2
      <IntegerArray>
      [1, 2, 3]
      Length: 3, dtype: Int64



   .. py:attribute:: default_fill_value
      :value: -1



   .. py:property:: dtype

      An instance of ExtensionDtype.

      .. rubric:: Examples

      >>> pd.array([1, 2, 3]).dtype
      Int64Dtype()


   .. py:method:: equals(other)

      Return if another array is equivalent to this array.

      Equivalent means that both arrays have the same shape and dtype, and
      all values compare equal. Missing values in the same location are
      considered equal (in contrast with normal equality).

      :param other: Array to compare to this Array.
      :type other: ExtensionArray

      :returns: Whether the arrays are equivalent.
      :rtype: boolean

      .. rubric:: Examples

      >>> arr1 = pd.array([1, 2, np.nan])
      >>> arr2 = pd.array([1, 2, np.nan])
      >>> arr1.equals(arr2)
      True



   .. py:method:: factorize(*, sort=False, use_na_sentinel=True, **kwargs)

      Encode the extension array as an enumerated type.

      :param use_na_sentinel: If True, the sentinel -1 will be used for NaN values. If False,
                              NaN values will be encoded as non-negative integers and will not drop the
                              NaN from the uniques of the values.

                              .. versionadded:: 1.5.0
      :type use_na_sentinel: bool, default True

      :returns: * **codes** (*ndarray*) -- An integer NumPy array that's an indexer into the original
                  ExtensionArray.
                * **uniques** (*ExtensionArray*) -- An ExtensionArray containing the unique values of `self`.

                  .. note::

                     uniques will *not* contain an entry for the NA value of
                     the ExtensionArray if there are any missing values present
                     in `self`.

      .. seealso::

         :py:obj:`factorize`
             Top-level factorize method that dispatches here.

      .. rubric:: Notes

      :meth:`pandas.factorize` offers a `sort` keyword as well.

      .. rubric:: Examples

      >>> idx1 = pd.PeriodIndex(["2014-01", "2014-01", "2014-02", "2014-02",
      ...                       "2014-03", "2014-03"], freq="M")
      >>> arr, idx = idx1.factorize()
      >>> arr
      array([0, 0, 1, 1, 2, 2])
      >>> idx
      PeriodIndex(['2014-01', '2014-02', '2014-03'], dtype='period[M]')



   .. py:method:: isna() -> pandas.api.extensions.ExtensionArray | numpy.ndarray[Any, Any]

      A 1-D array indicating if each value is missing.

      :returns: In most cases, this should return a NumPy ndarray. For
                exceptional cases like ``SparseArray``, where returning
                an ndarray would be expensive, an ExtensionArray may be
                returned.
      :rtype: numpy.ndarray or pandas.api.extensions.ExtensionArray

      .. rubric:: Notes

      If returning an ExtensionArray, then

      * ``na_values._is_boolean`` should be True
      * `na_values` should implement :func:`ExtensionArray._reduce`
      * ``na_values.any`` and ``na_values.all`` should be implemented

      .. rubric:: Examples

      >>> arr = pd.array([1, 2, np.nan, np.nan])
      >>> arr.isna()
      array([False, False,  True,  True])



   .. py:property:: nbytes

      The number of bytes needed to store this object in memory.

      .. rubric:: Examples

      >>> pd.array([1, 2, 3]).nbytes
      27


.. py:class:: ArkoudaBigintDtype

   Bases: :py:obj:`_ArkoudaBaseDtype`


   Arkouda-backed arbitrary-precision integer dtype.

   This dtype integrates Arkouda's server-backed ``pdarray<bigint>`` with
   the pandas ExtensionArray interface via :class:`ArkoudaArray`. It enables
   pandas objects (Series, DataFrame) to hold and operate on very large
   integers that exceed 64-bit precision, while keeping the data distributed
   on the Arkouda server.

   .. method:: construct_array_type()

      Returns the :class:`ArkoudaArray` class used for storage.



   .. py:method:: construct_array_type()
      :classmethod:


      Return the ExtensionArray subclass that handles storage for this dtype.

      :returns: The :class:`ArkoudaArray` class associated with this dtype.
      :rtype: type



   .. py:attribute:: kind
      :value: 'O'


      A character code (one of 'biufcmMOSUV'), default 'O'

      This should match the NumPy dtype used when the array is
      converted to an ndarray, which is probably 'O' for object if
      the extension type cannot be represented as a built-in NumPy
      type.

      .. seealso:: :py:obj:`numpy.dtype.kind`


   .. py:attribute:: na_value
      :value: -1


      Default NA value to use for this type.

      This is used in e.g. ExtensionArray.take. This should be the
      user-facing "boxed" version of the NA value, not the physical NA value
      for storage.  e.g. for JSONArray, this is an empty dictionary.


   .. py:attribute:: name
      :value: 'bigint'


      A string identifying the data type.

      Will be used for display in, e.g. ``Series.dtype``


   .. py:attribute:: type

      The scalar type for the array, e.g. ``int``

      It's expected ``ExtensionArray[item]`` returns an instance
      of ``ExtensionDtype.type`` for scalar ``item``, assuming
      that value is valid (not NA). NA values do not need to be
      instances of `type`.


.. py:class:: ArkoudaBoolDtype

   Bases: :py:obj:`_ArkoudaBaseDtype`


   Arkouda-backed boolean dtype.

   This dtype integrates Arkouda's server-backed `pdarray<bool>` with
   the pandas ExtensionArray interface via :class:`ArkoudaArray`. It allows
   pandas objects (Series, DataFrame) to store and manipulate distributed
   boolean arrays without materializing them on the client.

   .. method:: construct_array_type()

      Returns the :class:`ArkoudaArray` class used for storage.



   .. py:method:: construct_array_type()
      :classmethod:


      Return the ExtensionArray subclass that handles storage for this dtype.

      :returns: The :class:`ArkoudaArray` class associated with this dtype.
      :rtype: type



   .. py:attribute:: kind
      :value: 'b'


      A character code (one of 'biufcmMOSUV'), default 'O'

      This should match the NumPy dtype used when the array is
      converted to an ndarray, which is probably 'O' for object if
      the extension type cannot be represented as a built-in NumPy
      type.

      .. seealso:: :py:obj:`numpy.dtype.kind`


   .. py:attribute:: na_value
      :value: False


      Default NA value to use for this type.

      This is used in e.g. ExtensionArray.take. This should be the
      user-facing "boxed" version of the NA value, not the physical NA value
      for storage.  e.g. for JSONArray, this is an empty dictionary.


   .. py:attribute:: name
      :value: 'bool_'


      A string identifying the data type.

      Will be used for display in, e.g. ``Series.dtype``


   .. py:attribute:: type

      The scalar type for the array, e.g. ``int``

      It's expected ``ExtensionArray[item]`` returns an instance
      of ``ExtensionDtype.type`` for scalar ``item``, assuming
      that value is valid (not NA). NA values do not need to be
      instances of `type`.


.. py:class:: ArkoudaCategoricalArray(data)

   Bases: :py:obj:`arkouda.pandas.extension._arkouda_base_array.ArkoudaBaseArray`, :py:obj:`pandas.api.extensions.ExtensionArray`


   Abstract base class for custom 1-D array types.

   pandas will recognize instances of this class as proper arrays
   with a custom type and will not attempt to coerce them to objects. They
   may be stored directly inside a :class:`DataFrame` or :class:`Series`.

   .. attribute:: dtype



   .. attribute:: nbytes



   .. attribute:: ndim



   .. attribute:: shape



   .. method:: argsort

   .. method:: astype

   .. method:: copy

   .. method:: dropna

   .. method:: duplicated

   .. method:: factorize

   .. method:: fillna

   .. method:: equals

   .. method:: insert

   .. method:: interpolate

   .. method:: isin

   .. method:: isna

   .. method:: ravel

   .. method:: repeat

   .. method:: searchsorted

   .. method:: shift

   .. method:: take

   .. method:: tolist

   .. method:: unique

   .. method:: view

   .. method:: _accumulate

   .. method:: _concat_same_type

   .. method:: _explode

   .. method:: _formatter

   .. method:: _from_factorized

   .. method:: _from_sequence

   .. method:: _from_sequence_of_strings

   .. method:: _hash_pandas_object

   .. method:: _pad_or_backfill

   .. method:: _reduce

   .. method:: _values_for_argsort

   .. method:: _values_for_factorize



   .. rubric:: Notes

   The interface includes the following abstract methods that must be
   implemented by subclasses:

   * _from_sequence
   * _from_factorized
   * __getitem__
   * __len__
   * __eq__
   * dtype
   * nbytes
   * isna
   * take
   * copy
   * _concat_same_type
   * interpolate

   A default repr displaying the type, (truncated) data, length,
   and dtype is provided. It can be customized or replaced by
   by overriding:

   * __repr__ : A default repr for the ExtensionArray.
   * _formatter : Print scalars inside a Series or DataFrame.

   Some methods require casting the ExtensionArray to an ndarray of Python
   objects with ``self.astype(object)``, which may be expensive. When
   performance is a concern, we highly recommend overriding the following
   methods:

   * fillna
   * _pad_or_backfill
   * dropna
   * unique
   * factorize / _values_for_factorize
   * argsort, argmax, argmin / _values_for_argsort
   * searchsorted
   * map

   The remaining methods implemented on this class should be performant,
   as they only compose abstract methods. Still, a more efficient
   implementation may be available, and these methods can be overridden.

   One can implement methods to handle array accumulations or reductions.

   * _accumulate
   * _reduce

   One can implement methods to handle parsing from strings that will be used
   in methods such as ``pandas.io.parsers.read_csv``.

   * _from_sequence_of_strings

   This class does not inherit from 'abc.ABCMeta' for performance reasons.
   Methods and properties required by the interface raise
   ``pandas.errors.AbstractMethodError`` and no ``register`` method is
   provided for registering virtual subclasses.

   ExtensionArrays are limited to 1 dimension.

   They may be backed by none, one, or many NumPy arrays. For example,
   ``pandas.Categorical`` is an extension array backed by two arrays,
   one for codes and one for categories. An array of IPv6 address may
   be backed by a NumPy structured array with two fields, one for the
   lower 64 bits and one for the upper 64 bits. Or they may be backed
   by some other storage type, like Python lists. Pandas makes no
   assumptions on how the data are stored, just that it can be converted
   to a NumPy array.
   The ExtensionArray interface does not impose any rules on how this data
   is stored. However, currently, the backing data cannot be stored in
   attributes called ``.values`` or ``._values`` to ensure full compatibility
   with pandas internals. But other names as ``.data``, ``._data``,
   ``._items``, ... can be freely used.

   If implementing NumPy's ``__array_ufunc__`` interface, pandas expects
   that

   1. You defer by returning ``NotImplemented`` when any Series are present
      in `inputs`. Pandas will extract the arrays and call the ufunc again.
   2. You define a ``_HANDLED_TYPES`` tuple as an attribute on the class.
      Pandas inspect this to determine whether the ufunc is valid for the
      types present.

   See :ref:`extending.extension.ufunc` for more.

   By default, ExtensionArrays are not hashable.  Immutable subclasses may
   override this behavior.

   .. rubric:: Examples

   Please see the following:

   https://github.com/pandas-dev/pandas/blob/main/pandas/tests/extension/list/array.py


   .. py:method:: astype(x, dtype)
      :abstractmethod:


      Cast to a NumPy array or ExtensionArray with 'dtype'.

      :param dtype: Typecode or data-type to which the array is cast.
      :type dtype: str or dtype
      :param copy: Whether to copy the data, even if not necessary. If False,
                   a copy is made only if the old dtype does not match the
                   new dtype.
      :type copy: bool, default True

      :returns: An ``ExtensionArray`` if ``dtype`` is ``ExtensionDtype``,
                otherwise a Numpy ndarray with ``dtype`` for its dtype.
      :rtype: np.ndarray or pandas.api.extensions.ExtensionArray

      .. rubric:: Examples

      >>> arr = pd.array([1, 2, 3])
      >>> arr
      <IntegerArray>
      [1, 2, 3]
      Length: 3, dtype: Int64

      Casting to another ``ExtensionDtype`` returns an ``ExtensionArray``:

      >>> arr1 = arr.astype('Float64')
      >>> arr1
      <FloatingArray>
      [1.0, 2.0, 3.0]
      Length: 3, dtype: Float64
      >>> arr1.dtype
      Float64Dtype()

      Otherwise, we will get a Numpy ndarray:

      >>> arr2 = arr.astype('float64')
      >>> arr2
      array([1., 2., 3.])
      >>> arr2.dtype
      dtype('float64')



   .. py:method:: copy()

      Return a copy of the array.

      :rtype: ExtensionArray

      .. rubric:: Examples

      >>> arr = pd.array([1, 2, 3])
      >>> arr2 = arr.copy()
      >>> arr[0] = 2
      >>> arr2
      <IntegerArray>
      [1, 2, 3]
      Length: 3, dtype: Int64



   .. py:attribute:: default_fill_value
      :type:  str
      :value: ''



   .. py:property:: dtype

      An instance of ExtensionDtype.

      .. rubric:: Examples

      >>> pd.array([1, 2, 3]).dtype
      Int64Dtype()


   .. py:method:: factorize(*, sort=False, use_na_sentinel=True, **kwargs)

      Encode the extension array as an enumerated type.

      :param use_na_sentinel: If True, the sentinel -1 will be used for NaN values. If False,
                              NaN values will be encoded as non-negative integers and will not drop the
                              NaN from the uniques of the values.

                              .. versionadded:: 1.5.0
      :type use_na_sentinel: bool, default True

      :returns: * **codes** (*ndarray*) -- An integer NumPy array that's an indexer into the original
                  ExtensionArray.
                * **uniques** (*ExtensionArray*) -- An ExtensionArray containing the unique values of `self`.

                  .. note::

                     uniques will *not* contain an entry for the NA value of
                     the ExtensionArray if there are any missing values present
                     in `self`.

      .. seealso::

         :py:obj:`factorize`
             Top-level factorize method that dispatches here.

      .. rubric:: Notes

      :meth:`pandas.factorize` offers a `sort` keyword as well.

      .. rubric:: Examples

      >>> idx1 = pd.PeriodIndex(["2014-01", "2014-01", "2014-02", "2014-02",
      ...                       "2014-03", "2014-03"], freq="M")
      >>> arr, idx = idx1.factorize()
      >>> arr
      array([0, 0, 1, 1, 2, 2])
      >>> idx
      PeriodIndex(['2014-01', '2014-02', '2014-03'], dtype='period[M]')



   .. py:method:: isna()

      A 1-D array indicating if each value is missing.

      :returns: In most cases, this should return a NumPy ndarray. For
                exceptional cases like ``SparseArray``, where returning
                an ndarray would be expensive, an ExtensionArray may be
                returned.
      :rtype: numpy.ndarray or pandas.api.extensions.ExtensionArray

      .. rubric:: Notes

      If returning an ExtensionArray, then

      * ``na_values._is_boolean`` should be True
      * `na_values` should implement :func:`ExtensionArray._reduce`
      * ``na_values.any`` and ``na_values.all`` should be implemented

      .. rubric:: Examples

      >>> arr = pd.array([1, 2, np.nan, np.nan])
      >>> arr.isna()
      array([False, False,  True,  True])



.. py:class:: ArkoudaCategoricalDtype

   Bases: :py:obj:`_ArkoudaBaseDtype`


   Arkouda-backed categorical dtype.

   This dtype integrates Arkouda's distributed ``Categorical`` type with
   the pandas ExtensionArray interface via :class:`ArkoudaCategoricalArray`.
   It enables pandas objects (Series, DataFrame) to hold categorical data
   stored and processed on the Arkouda server, while exposing familiar
   pandas APIs.

   .. method:: construct_array_type()

      Returns the :class:`ArkoudaCategoricalArray` used as the storage class.



   .. py:method:: construct_array_type()
      :classmethod:


      Return the ExtensionArray subclass that handles storage for this dtype.

      :returns: The :class:`ArkoudaCategoricalArray` class associated with this dtype.
      :rtype: type



   .. py:attribute:: kind
      :value: 'O'


      A character code (one of 'biufcmMOSUV'), default 'O'

      This should match the NumPy dtype used when the array is
      converted to an ndarray, which is probably 'O' for object if
      the extension type cannot be represented as a built-in NumPy
      type.

      .. seealso:: :py:obj:`numpy.dtype.kind`


   .. py:attribute:: na_value
      :value: -1


      Default NA value to use for this type.

      This is used in e.g. ExtensionArray.take. This should be the
      user-facing "boxed" version of the NA value, not the physical NA value
      for storage.  e.g. for JSONArray, this is an empty dictionary.


   .. py:attribute:: name
      :value: 'category'


      A string identifying the data type.

      Will be used for display in, e.g. ``Series.dtype``


   .. py:attribute:: type

      The scalar type for the array, e.g. ``int``

      It's expected ``ExtensionArray[item]`` returns an instance
      of ``ExtensionDtype.type`` for scalar ``item``, assuming
      that value is valid (not NA). NA values do not need to be
      instances of `type`.


.. py:class:: ArkoudaFloat64Dtype

   Bases: :py:obj:`_ArkoudaBaseDtype`


   Arkouda-backed 64-bit floating-point dtype.

   This dtype integrates Arkouda's server-backed `pdarray<float64>` with
   the pandas ExtensionArray interface via :class:`ArkoudaArray`. It allows
   pandas objects (Series, DataFrame) to store and manipulate large
   distributed float64 arrays without materializing them on the client.

   .. method:: construct_array_type()

      Returns the :class:`ArkoudaArray` class used for storage.



   .. py:method:: construct_array_type()
      :classmethod:


      Return the ExtensionArray subclass that handles storage for this dtype.

      :returns: The :class:`ArkoudaArray` class associated with this dtype.
      :rtype: type



   .. py:attribute:: kind
      :value: 'f'


      A character code (one of 'biufcmMOSUV'), default 'O'

      This should match the NumPy dtype used when the array is
      converted to an ndarray, which is probably 'O' for object if
      the extension type cannot be represented as a built-in NumPy
      type.

      .. seealso:: :py:obj:`numpy.dtype.kind`


   .. py:attribute:: na_value

      Default NA value to use for this type.

      This is used in e.g. ExtensionArray.take. This should be the
      user-facing "boxed" version of the NA value, not the physical NA value
      for storage.  e.g. for JSONArray, this is an empty dictionary.


   .. py:attribute:: name
      :value: 'float64'


      A string identifying the data type.

      Will be used for display in, e.g. ``Series.dtype``


   .. py:attribute:: type

      The scalar type for the array, e.g. ``int``

      It's expected ``ExtensionArray[item]`` returns an instance
      of ``ExtensionDtype.type`` for scalar ``item``, assuming
      that value is valid (not NA). NA values do not need to be
      instances of `type`.


.. py:class:: ArkoudaInt64Dtype

   Bases: :py:obj:`_ArkoudaBaseDtype`


   Extension dtype for Arkouda-backed 64-bit integers.

   This dtype allows seamless use of Arkouda's distributed ``int64``
   arrays inside pandas objects (``Series``, ``Index``, ``DataFrame``).
   It is backed by :class:`arkouda.pdarray` with ``dtype='int64'``
   and integrates with pandas via the
   :class:`~arkouda.pandas.extension._arkouda_array.ArkoudaArray`
   extension array.

   .. method:: construct_array_type()

      Return the associated extension array class
      (:class:`ArkoudaArray`).



   .. py:method:: construct_array_type()
      :classmethod:


      Return the associated pandas ExtensionArray type.

      This is part of the pandas ExtensionDtype interface and is used
      internally by pandas when constructing arrays of this dtype.
      It ensures that operations like ``Series(..., dtype=ArkoudaInt64Dtype())``
      produce the correct Arkouda-backed extension array.

      :returns: The :class:`ArkoudaArray` class that implements the storage
                and behavior for this dtype.
      :rtype: type

      .. rubric:: Notes

      - This hook tells pandas which ExtensionArray to instantiate
        whenever this dtype is requested.
      - All Arkouda dtypes defined in this module will return
        :class:`ArkoudaArray` (or a subclass thereof).

      .. rubric:: Examples

      >>> from arkouda.pandas.extension import ArkoudaInt64Dtype
      >>> ArkoudaInt64Dtype.construct_array_type()
      <class 'arkouda.pandas.extension._arkouda_array.ArkoudaArray'>



   .. py:attribute:: kind
      :value: 'i'


      A character code (one of 'biufcmMOSUV'), default 'O'

      This should match the NumPy dtype used when the array is
      converted to an ndarray, which is probably 'O' for object if
      the extension type cannot be represented as a built-in NumPy
      type.

      .. seealso:: :py:obj:`numpy.dtype.kind`


   .. py:attribute:: na_value
      :value: -1


      Default NA value to use for this type.

      This is used in e.g. ExtensionArray.take. This should be the
      user-facing "boxed" version of the NA value, not the physical NA value
      for storage.  e.g. for JSONArray, this is an empty dictionary.


   .. py:attribute:: name
      :value: 'int64'


      A string identifying the data type.

      Will be used for display in, e.g. ``Series.dtype``


   .. py:attribute:: type

      The scalar type for the array, e.g. ``int``

      It's expected ``ExtensionArray[item]`` returns an instance
      of ``ExtensionDtype.type`` for scalar ``item``, assuming
      that value is valid (not NA). NA values do not need to be
      instances of `type`.


.. py:class:: ArkoudaStringArray(data)

   Bases: :py:obj:`arkouda.pandas.extension._arkouda_base_array.ArkoudaBaseArray`, :py:obj:`pandas.api.extensions.ExtensionArray`


   Abstract base class for custom 1-D array types.

   pandas will recognize instances of this class as proper arrays
   with a custom type and will not attempt to coerce them to objects. They
   may be stored directly inside a :class:`DataFrame` or :class:`Series`.

   .. attribute:: dtype



   .. attribute:: nbytes



   .. attribute:: ndim



   .. attribute:: shape



   .. method:: argsort

   .. method:: astype

   .. method:: copy

   .. method:: dropna

   .. method:: duplicated

   .. method:: factorize

   .. method:: fillna

   .. method:: equals

   .. method:: insert

   .. method:: interpolate

   .. method:: isin

   .. method:: isna

   .. method:: ravel

   .. method:: repeat

   .. method:: searchsorted

   .. method:: shift

   .. method:: take

   .. method:: tolist

   .. method:: unique

   .. method:: view

   .. method:: _accumulate

   .. method:: _concat_same_type

   .. method:: _explode

   .. method:: _formatter

   .. method:: _from_factorized

   .. method:: _from_sequence

   .. method:: _from_sequence_of_strings

   .. method:: _hash_pandas_object

   .. method:: _pad_or_backfill

   .. method:: _reduce

   .. method:: _values_for_argsort

   .. method:: _values_for_factorize



   .. rubric:: Notes

   The interface includes the following abstract methods that must be
   implemented by subclasses:

   * _from_sequence
   * _from_factorized
   * __getitem__
   * __len__
   * __eq__
   * dtype
   * nbytes
   * isna
   * take
   * copy
   * _concat_same_type
   * interpolate

   A default repr displaying the type, (truncated) data, length,
   and dtype is provided. It can be customized or replaced by
   by overriding:

   * __repr__ : A default repr for the ExtensionArray.
   * _formatter : Print scalars inside a Series or DataFrame.

   Some methods require casting the ExtensionArray to an ndarray of Python
   objects with ``self.astype(object)``, which may be expensive. When
   performance is a concern, we highly recommend overriding the following
   methods:

   * fillna
   * _pad_or_backfill
   * dropna
   * unique
   * factorize / _values_for_factorize
   * argsort, argmax, argmin / _values_for_argsort
   * searchsorted
   * map

   The remaining methods implemented on this class should be performant,
   as they only compose abstract methods. Still, a more efficient
   implementation may be available, and these methods can be overridden.

   One can implement methods to handle array accumulations or reductions.

   * _accumulate
   * _reduce

   One can implement methods to handle parsing from strings that will be used
   in methods such as ``pandas.io.parsers.read_csv``.

   * _from_sequence_of_strings

   This class does not inherit from 'abc.ABCMeta' for performance reasons.
   Methods and properties required by the interface raise
   ``pandas.errors.AbstractMethodError`` and no ``register`` method is
   provided for registering virtual subclasses.

   ExtensionArrays are limited to 1 dimension.

   They may be backed by none, one, or many NumPy arrays. For example,
   ``pandas.Categorical`` is an extension array backed by two arrays,
   one for codes and one for categories. An array of IPv6 address may
   be backed by a NumPy structured array with two fields, one for the
   lower 64 bits and one for the upper 64 bits. Or they may be backed
   by some other storage type, like Python lists. Pandas makes no
   assumptions on how the data are stored, just that it can be converted
   to a NumPy array.
   The ExtensionArray interface does not impose any rules on how this data
   is stored. However, currently, the backing data cannot be stored in
   attributes called ``.values`` or ``._values`` to ensure full compatibility
   with pandas internals. But other names as ``.data``, ``._data``,
   ``._items``, ... can be freely used.

   If implementing NumPy's ``__array_ufunc__`` interface, pandas expects
   that

   1. You defer by returning ``NotImplemented`` when any Series are present
      in `inputs`. Pandas will extract the arrays and call the ufunc again.
   2. You define a ``_HANDLED_TYPES`` tuple as an attribute on the class.
      Pandas inspect this to determine whether the ufunc is valid for the
      types present.

   See :ref:`extending.extension.ufunc` for more.

   By default, ExtensionArrays are not hashable.  Immutable subclasses may
   override this behavior.

   .. rubric:: Examples

   Please see the following:

   https://github.com/pandas-dev/pandas/blob/main/pandas/tests/extension/list/array.py


   .. py:method:: astype(dtype, copy: bool = False)

      Cast to a NumPy array or ExtensionArray with 'dtype'.

      :param dtype: Typecode or data-type to which the array is cast.
      :type dtype: str or dtype
      :param copy: Whether to copy the data, even if not necessary. If False,
                   a copy is made only if the old dtype does not match the
                   new dtype.
      :type copy: bool, default True

      :returns: An ``ExtensionArray`` if ``dtype`` is ``ExtensionDtype``,
                otherwise a Numpy ndarray with ``dtype`` for its dtype.
      :rtype: np.ndarray or pandas.api.extensions.ExtensionArray

      .. rubric:: Examples

      >>> arr = pd.array([1, 2, 3])
      >>> arr
      <IntegerArray>
      [1, 2, 3]
      Length: 3, dtype: Int64

      Casting to another ``ExtensionDtype`` returns an ``ExtensionArray``:

      >>> arr1 = arr.astype('Float64')
      >>> arr1
      <FloatingArray>
      [1.0, 2.0, 3.0]
      Length: 3, dtype: Float64
      >>> arr1.dtype
      Float64Dtype()

      Otherwise, we will get a Numpy ndarray:

      >>> arr2 = arr.astype('float64')
      >>> arr2
      array([1., 2., 3.])
      >>> arr2.dtype
      dtype('float64')



   .. py:method:: copy()

      Return a copy of the array.

      :rtype: ExtensionArray

      .. rubric:: Examples

      >>> arr = pd.array([1, 2, 3])
      >>> arr2 = arr.copy()
      >>> arr[0] = 2
      >>> arr2
      <IntegerArray>
      [1, 2, 3]
      Length: 3, dtype: Int64



   .. py:attribute:: default_fill_value
      :value: ''



   .. py:property:: dtype

      An instance of ExtensionDtype.

      .. rubric:: Examples

      >>> pd.array([1, 2, 3]).dtype
      Int64Dtype()


   .. py:method:: factorize(*, sort=False, use_na_sentinel=True, **kwargs)

      Encode the extension array as an enumerated type.

      :param use_na_sentinel: If True, the sentinel -1 will be used for NaN values. If False,
                              NaN values will be encoded as non-negative integers and will not drop the
                              NaN from the uniques of the values.

                              .. versionadded:: 1.5.0
      :type use_na_sentinel: bool, default True

      :returns: * **codes** (*ndarray*) -- An integer NumPy array that's an indexer into the original
                  ExtensionArray.
                * **uniques** (*ExtensionArray*) -- An ExtensionArray containing the unique values of `self`.

                  .. note::

                     uniques will *not* contain an entry for the NA value of
                     the ExtensionArray if there are any missing values present
                     in `self`.

      .. seealso::

         :py:obj:`factorize`
             Top-level factorize method that dispatches here.

      .. rubric:: Notes

      :meth:`pandas.factorize` offers a `sort` keyword as well.

      .. rubric:: Examples

      >>> idx1 = pd.PeriodIndex(["2014-01", "2014-01", "2014-02", "2014-02",
      ...                       "2014-03", "2014-03"], freq="M")
      >>> arr, idx = idx1.factorize()
      >>> arr
      array([0, 0, 1, 1, 2, 2])
      >>> idx
      PeriodIndex(['2014-01', '2014-02', '2014-03'], dtype='period[M]')



   .. py:method:: isna()

      A 1-D array indicating if each value is missing.

      :returns: In most cases, this should return a NumPy ndarray. For
                exceptional cases like ``SparseArray``, where returning
                an ndarray would be expensive, an ExtensionArray may be
                returned.
      :rtype: numpy.ndarray or pandas.api.extensions.ExtensionArray

      .. rubric:: Notes

      If returning an ExtensionArray, then

      * ``na_values._is_boolean`` should be True
      * `na_values` should implement :func:`ExtensionArray._reduce`
      * ``na_values.any`` and ``na_values.all`` should be implemented

      .. rubric:: Examples

      >>> arr = pd.array([1, 2, np.nan, np.nan])
      >>> arr.isna()
      array([False, False,  True,  True])



.. py:class:: ArkoudaStringDtype

   Bases: :py:obj:`_ArkoudaBaseDtype`


   Arkouda-backed string dtype.

   This dtype integrates Arkouda's distributed ``Strings`` type with the
   pandas ExtensionArray interface via :class:`ArkoudaStringArray`. It
   enables pandas objects (Series, DataFrame) to hold large, server-backed
   string columns without converting to NumPy or Python objects.

   .. method:: construct_array_type()

      Returns the :class:`ArkoudaStringArray` used as the storage class.



   .. py:method:: construct_array_type()
      :classmethod:


      Return the ExtensionArray subclass that handles storage for this dtype.

      :returns: The :class:`ArkoudaStringArray` class associated with this dtype.
      :rtype: type



   .. py:attribute:: kind
      :value: 'O'


      A character code (one of 'biufcmMOSUV'), default 'O'

      This should match the NumPy dtype used when the array is
      converted to an ndarray, which is probably 'O' for object if
      the extension type cannot be represented as a built-in NumPy
      type.

      .. seealso:: :py:obj:`numpy.dtype.kind`


   .. py:attribute:: na_value
      :value: ''


      Default NA value to use for this type.

      This is used in e.g. ExtensionArray.take. This should be the
      user-facing "boxed" version of the NA value, not the physical NA value
      for storage.  e.g. for JSONArray, this is an empty dictionary.


   .. py:attribute:: name
      :value: 'string'


      A string identifying the data type.

      Will be used for display in, e.g. ``Series.dtype``


   .. py:attribute:: type

      The scalar type for the array, e.g. ``int``

      It's expected ``ExtensionArray[item]`` returns an instance
      of ``ExtensionDtype.type`` for scalar ``item``, assuming
      that value is valid (not NA). NA values do not need to be
      instances of `type`.


.. py:class:: ArkoudaUint64Dtype

   Bases: :py:obj:`_ArkoudaBaseDtype`


   Arkouda-backed unsigned 64-bit integer dtype.

   This dtype integrates Arkouda’s ``uint64`` arrays with pandas,
   allowing users to create :class:`pandas.Series` or
   :class:`pandas.DataFrame` objects that store their data on
   the Arkouda server while still conforming to the pandas
   ExtensionArray API.

   .. method:: construct_array_type()

      Return the :class:`ArkoudaArray` class used as the storage
      container for this dtype.


   .. rubric:: Examples

   >>> import arkouda as ak
   >>> import pandas as pd
   >>> from arkouda.pandas.extension import ArkoudaUint64Dtype, ArkoudaArray

   >>> arr = ArkoudaArray(ak.array([1, 2, 3], dtype="uint64"))
   >>> s = pd.Series(arr, dtype=ArkoudaUint64Dtype())
   >>> s
   0    1
   1    2
   2    3
   dtype: uint64


   .. py:method:: construct_array_type()
      :classmethod:


      Return the ExtensionArray class associated with this dtype.

      This is required by the pandas ExtensionDtype API. It tells pandas
      which :class:`~pandas.api.extensions.ExtensionArray` subclass should
      be used to hold data of this dtype inside a :class:`pandas.Series`
      or :class:`pandas.DataFrame`.

      :returns: The :class:`ArkoudaArray` class, which implements the storage
                and operations for Arkouda-backed arrays.
      :rtype: type



   .. py:attribute:: kind
      :value: 'u'


      A character code (one of 'biufcmMOSUV'), default 'O'

      This should match the NumPy dtype used when the array is
      converted to an ndarray, which is probably 'O' for object if
      the extension type cannot be represented as a built-in NumPy
      type.

      .. seealso:: :py:obj:`numpy.dtype.kind`


   .. py:attribute:: na_value
      :value: -1


      Default NA value to use for this type.

      This is used in e.g. ExtensionArray.take. This should be the
      user-facing "boxed" version of the NA value, not the physical NA value
      for storage.  e.g. for JSONArray, this is an empty dictionary.


   .. py:attribute:: name
      :value: 'uint64'


      A string identifying the data type.

      Will be used for display in, e.g. ``Series.dtype``


   .. py:attribute:: type

      The scalar type for the array, e.g. ``int``

      It's expected ``ExtensionArray[item]`` returns an instance
      of ``ExtensionDtype.type`` for scalar ``item``, assuming
      that value is valid (not NA). NA values do not need to be
      instances of `type`.


.. py:class:: ArkoudaUint8Dtype

   Bases: :py:obj:`_ArkoudaBaseDtype`


   Arkouda-backed unsigned 8-bit integer dtype.

   This dtype integrates Arkouda's ``uint8`` arrays with the pandas
   ExtensionArray API, allowing pandas ``Series`` and ``DataFrame``
   objects to store and operate on Arkouda-backed unsigned 8-bit
   integers. The underlying storage is an Arkouda ``pdarray<uint8>``,
   exposed through the :class:`ArkoudaArray` extension array.

   .. method:: construct_array_type()

      Returns the :class:`ArkoudaArray` type that provides the storage
      and behavior for this dtype.



   .. py:method:: construct_array_type()
      :classmethod:


      Return the ExtensionArray subclass that handles storage for this dtype.

      This method is required by the pandas ExtensionDtype interface.
      It tells pandas which ExtensionArray class to use when creating
      arrays of this dtype (for example, when calling
      ``Series(..., dtype="arkouda.uint8")``).

      :returns: The :class:`ArkoudaArray` class associated with this dtype.
      :rtype: type



   .. py:attribute:: kind
      :value: 'u'


      A character code (one of 'biufcmMOSUV'), default 'O'

      This should match the NumPy dtype used when the array is
      converted to an ndarray, which is probably 'O' for object if
      the extension type cannot be represented as a built-in NumPy
      type.

      .. seealso:: :py:obj:`numpy.dtype.kind`


   .. py:attribute:: na_value
      :value: -1


      Default NA value to use for this type.

      This is used in e.g. ExtensionArray.take. This should be the
      user-facing "boxed" version of the NA value, not the physical NA value
      for storage.  e.g. for JSONArray, this is an empty dictionary.


   .. py:attribute:: name
      :value: 'uint8'


      A string identifying the data type.

      Will be used for display in, e.g. ``Series.dtype``


   .. py:attribute:: type

      The scalar type for the array, e.g. ``int``

      It's expected ``ExtensionArray[item]`` returns an instance
      of ``ExtensionDtype.type`` for scalar ``item``, assuming
      that value is valid (not NA). NA values do not need to be
      instances of `type`.


.. py:class:: BoolDType

   Bases: :py:obj:`numpy.dtype`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.


.. py:class:: ByteDType

   Bases: :py:obj:`numpy.dtypes._IntegerAbstractDType`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.


.. py:class:: BytesDType

   Bases: :py:obj:`numpy.dtype`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.


.. py:class:: CLongDoubleDType

   Bases: :py:obj:`numpy.dtypes._ComplexAbstractDType`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.


.. py:class:: CachedAccessor(name: str, accessor)

   Descriptor for caching namespace-based accessors.

   This custom property-like object enables lazy initialization of accessors
   (e.g., `.str`, `.dt`) on Series-like objects, similar to pandas-style extension
   accessors.

   :param name: The name of the namespace to be accessed (e.g., ``df.foo``).
   :type name: str
   :param accessor: A class implementing the accessor logic.
   :type accessor: type

   .. rubric:: Notes

   The `accessor` class's ``__init__`` method must accept a single positional
   argument, which should be one of ``Series``, ``DataFrame``, or ``Index``.


.. py:class:: Complex128DType

   Bases: :py:obj:`numpy.dtypes._ComplexAbstractDType`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.


.. py:class:: Complex64DType

   Bases: :py:obj:`numpy.dtypes._ComplexAbstractDType`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.


.. py:class:: DType

   .. py:method:: BIGINT(*args, **kwargs)


   .. py:method:: BOOL(*args, **kwargs)


   .. py:method:: COMPLEX128(*args, **kwargs)


   .. py:method:: COMPLEX64(*args, **kwargs)


   .. py:method:: FLOAT(*args, **kwargs)


   .. py:method:: FLOAT32(*args, **kwargs)


   .. py:method:: FLOAT64(*args, **kwargs)


   .. py:method:: INT(*args, **kwargs)


   .. py:method:: INT16(*args, **kwargs)


   .. py:method:: INT32(*args, **kwargs)


   .. py:method:: INT64(*args, **kwargs)


   .. py:method:: INT8(*args, **kwargs)


   .. py:method:: STR(*args, **kwargs)


   .. py:method:: UINT(*args, **kwargs)


   .. py:method:: UINT16(*args, **kwargs)


   .. py:method:: UINT32(*args, **kwargs)


   .. py:method:: UINT64(*args, **kwargs)


   .. py:method:: UINT8(*args, **kwargs)


   .. py:method:: name(*args, **kwargs)

      The name of the Enum member.



   .. py:method:: value(*args, **kwargs)

      The value of the Enum member.



.. py:class:: DTypeObjects

   Build an immutable unordered collection of unique elements.


   .. py:method:: copy()

      Return a shallow copy of a set.



   .. py:method:: difference(*others)

      Return a new set with elements in the set that are not in the others.



   .. py:method:: intersection(*others)

      Return a new set with elements common to the set and all others.



   .. py:method:: isdisjoint(other, /)

      Return True if two sets have a null intersection.



   .. py:method:: issubset(other, /)

      Report whether another set contains this set.



   .. py:method:: issuperset(other, /)

      Report whether this set contains another set.



   .. py:method:: symmetric_difference(other, /)

      Return a new set with elements in either the set or other but not both.



   .. py:method:: union(*others)

      Return a new set with elements from the set and all others.



.. py:class:: DTypes

   Build an immutable unordered collection of unique elements.


   .. py:method:: copy()

      Return a shallow copy of a set.



   .. py:method:: difference(*others)

      Return a new set with elements in the set that are not in the others.



   .. py:method:: intersection(*others)

      Return a new set with elements common to the set and all others.



   .. py:method:: isdisjoint(other, /)

      Return True if two sets have a null intersection.



   .. py:method:: issubset(other, /)

      Report whether another set contains this set.



   .. py:method:: issuperset(other, /)

      Report whether this set contains another set.



   .. py:method:: symmetric_difference(other, /)

      Return a new set with elements in either the set or other but not both.



   .. py:method:: union(*others)

      Return a new set with elements from the set and all others.



.. py:class:: DateTime64DType

   Bases: :py:obj:`numpy.dtype`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.


.. py:class:: Datetime(pda, unit: str = _BASE_UNIT)

   Bases: :py:obj:`_AbstractBaseTime`


   Represents a date and/or time.

   Datetime is the Arkouda analog to pandas DatetimeIndex and
   other timeseries data types.

   :param pda:
   :type pda: int64 pdarray, pd.DatetimeIndex, pd.Series, or np.datetime64 array
   :param unit: For int64 pdarray, denotes the unit of the input. Ignored for pandas
                and numpy arrays, which carry their own unit. Not case-sensitive;
                prefixes of full names (like 'sec') are accepted.

                Possible values:

                * 'weeks' or 'w'
                * 'days' or 'd'
                * 'hours' or 'h'
                * 'minutes', 'm', or 't'
                * 'seconds' or 's'
                * 'milliseconds', 'ms', or 'l'
                * 'microseconds', 'us', or 'u'
                * 'nanoseconds', 'ns', or 'n'

                Unlike in pandas, units cannot be combined or mixed with integers
   :type unit: str, default 'ns'

   .. rubric:: Notes

   The ``.values`` attribute is always in nanoseconds with int64 dtype.


   .. py:property:: date


   .. py:property:: day


   .. py:property:: day_of_week


   .. py:property:: day_of_year


   .. py:property:: dayofweek


   .. py:property:: dayofyear


   .. py:property:: hour


   .. py:property:: is_leap_year


   .. py:method:: is_registered() -> numpy.bool_

       Return True iff the object is contained in the registry or is a component of a
       registered object.

      :returns: Indicates if the object is contained in the registry
      :rtype: numpy.bool

      :raises RegistrationError: Raised if there's a server-side error or a mis-match of registered components

      .. seealso:: :py:obj:`register`, :py:obj:`attach`, :py:obj:`unregister`

      .. rubric:: Notes

      Objects registered with the server are immune to deletion until
      they are unregistered.



   .. py:method:: isocalendar()


   .. py:property:: microsecond


   .. py:property:: millisecond


   .. py:property:: minute


   .. py:property:: month


   .. py:property:: nanosecond


   .. py:method:: register(user_defined_name)

      Register this Datetime object and underlying components with the Arkouda server.

      :param user_defined_name: user defined name the Datetime is to be registered under,
                                this will be the root name for underlying components
      :type user_defined_name: str

      :returns: The same Datetime which is now registered with the arkouda server and has an updated name.
                This is an in-place modification, the original is returned to support
                a fluid programming style.
                Please note you cannot register two different Datetimes with the same name.
      :rtype: Datetime

      :raises TypeError: Raised if user_defined_name is not a str
      :raises RegistrationError: If the server was unable to register the Datetimes with the user_defined_name

      .. seealso:: :py:obj:`unregister`, :py:obj:`attach`, :py:obj:`is_registered`

      .. rubric:: Notes

      Objects registered with the server are immune to deletion until
      they are unregistered.



   .. py:property:: second


   .. py:attribute:: special_objType
      :value: 'Datetime'



   .. py:method:: sum()

      Return sum of array elements along the given axis.

      :param axis: The axis or axes along which to do the operation
                   If None, the computation is done across the entire array.
      :type axis: int, Tuple[int, ...], optional, default = None
      :param keepdims: Whether to keep the singleton dimension(s) along `axis` in the result.
      :type keepdims: bool, optional, default = False

      :returns: numeric_scalars if axis is omitted, in which case operation is done over entire array
                pdarray if axis is supplied, in which case the operation is done along that axis
      :rtype: numeric_scalars or pdarray

      :raises TypeError: Raised if pda is not a pdarray instance
      :raises RuntimeError: Raised if there's a server-side error thrown

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> ak.sum(ak.array([1,2,3,4,5]))
      np.int64(15)
      >>> ak.sum(ak.array([5.5,4.5,3.5,2.5,1.5]))
      np.float64(17.5)
      >>> ak.array([[1,2,3],[5,4,3]]).sum(axis=1)
      array([6 12])

      .. rubric:: Notes

      Works as a method of a pdarray (e.g. a.sum()) or a standalone function (e.g. ak.sum(a))



   .. py:attribute:: supported_opeq


   .. py:attribute:: supported_with_datetime


   .. py:attribute:: supported_with_pdarray


   .. py:attribute:: supported_with_r_datetime


   .. py:attribute:: supported_with_r_pdarray


   .. py:attribute:: supported_with_r_timedelta


   .. py:attribute:: supported_with_timedelta


   .. py:method:: to_pandas()

      Convert array to a pandas DatetimeIndex. Note: if the array size
      exceeds client.maxTransferBytes, a RuntimeError is raised.

      .. seealso:: :py:obj:`to_ndarray`



   .. py:method:: unregister()

      Unregister this Datetime object in the arkouda server which was previously
      registered using register() and/or attached to using attach().

      :raises RegistrationError: If the object is already unregistered or if there is a server error
          when attempting to unregister

      .. seealso:: :py:obj:`register`, :py:obj:`attach`, :py:obj:`is_registered`

      .. rubric:: Notes

      Objects registered with the server are immune to deletion until
      they are unregistered.



   .. py:property:: week


   .. py:property:: weekday


   .. py:property:: weekofyear


   .. py:property:: year


.. py:class:: DatetimeAccessor(series)

   Bases: :py:obj:`Properties`


   Accessor for datetime-like operations on Arkouda Series.

   Provides datetime methods such as `.floor()`, `.ceil()`, and `.round()`,
   mirroring the `.dt` accessor in pandas.

   This accessor is automatically attached to Series objects that wrap
   `arkouda.Datetime` values. It should not be instantiated directly.

   :param series: The Series object containing `Datetime` values.
   :type series: arkouda.pandas.Series

   :raises AttributeError: If the underlying Series values are not of type `arkouda.Datetime`.

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> from arkouda import Datetime, Series
   >>> s = Series(Datetime(ak.array([1_000_000_000_000])))
   >>> s.dt.floor("D")
   0   1970-01-01
   dtype: datetime64[ns]


   .. py:attribute:: series


.. py:class:: ErrorMode(*args, **kwds)

   Bases: :py:obj:`enum.Enum`


   Create a collection of name/value pairs.

   Example enumeration:

   >>> class Color(Enum):
   ...     RED = 1
   ...     BLUE = 2
   ...     GREEN = 3

   Access them by:

   - attribute access:

     >>> Color.RED
     <Color.RED: 1>

   - value lookup:

     >>> Color(1)
     <Color.RED: 1>

   - name lookup:

     >>> Color['RED']
     <Color.RED: 1>

   Enumerations can be iterated over, and know how many members they have:

   >>> len(Color)
   3

   >>> list(Color)
   [<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]

   Methods can be added to enumerations, and members can have their own
   attributes -- see the documentation for details.


   .. py:attribute:: ignore
      :value: 'ignore'



   .. py:attribute:: return_validity
      :value: 'return_validity'



   .. py:attribute:: strict
      :value: 'strict'



.. py:class:: False_

   Bases: :py:obj:`numpy.generic`


   Boolean type (True or False), stored as a byte.

       .. warning::

          The :class:`bool` type is not a subclass of the :class:`int_` type
          (the :class:`bool` is not even a number type). This is different
          than Python's default implementation of :class:`bool` as a
          sub-class of :class:`int`.

       :Character code: ``'?'``


.. py:class:: Float16DType

   Bases: :py:obj:`numpy.dtypes._FloatAbstractDType`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.


.. py:class:: Float32DType

   Bases: :py:obj:`numpy.dtypes._FloatAbstractDType`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.


.. py:class:: Float64DType

   Bases: :py:obj:`numpy.dtypes._FloatAbstractDType`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.


.. py:class:: Int16DType

   Bases: :py:obj:`numpy.dtypes._IntegerAbstractDType`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.


.. py:class:: Int32DType

   Bases: :py:obj:`numpy.dtypes._IntegerAbstractDType`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.


.. py:class:: Int64DType

   Bases: :py:obj:`numpy.dtypes._IntegerAbstractDType`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.


.. py:class:: Int8DType

   Bases: :py:obj:`numpy.dtypes._IntegerAbstractDType`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.


.. py:class:: IntDType

   Bases: :py:obj:`numpy.dtypes._IntegerAbstractDType`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.


.. py:class:: LogLevel(*args, **kwds)

   Bases: :py:obj:`enum.Enum`


   Enum for defining valid log levels used by ArkoudaLogger.

   Members
   -------
   INFO : str
       Confirmation that things are working as expected.
   DEBUG : str
       Detailed information, typically of interest only when diagnosing problems.
   WARN : str
       An indication that something unexpected happened, or indicative of some problem.
   ERROR : str
       A more serious problem, the software has not been able to perform some function.
   CRITICAL : str
       An extremely serious error, indicating the program itself may be unable to continue.

   .. rubric:: Notes

   This enum provides a controlled vocabulary for setting log levels on ArkoudaLogger
   instances. These are mapped internally to the standard Python `logging` levels.


   .. py:attribute:: CRITICAL
      :value: 'CRITICAL'



   .. py:attribute:: DEBUG
      :value: 'DEBUG'



   .. py:attribute:: ERROR
      :value: 'ERROR'



   .. py:attribute:: INFO
      :value: 'INFO'



   .. py:attribute:: WARN
      :value: 'WARN'



.. py:class:: LongDType

   Bases: :py:obj:`numpy.dtypes._IntegerAbstractDType`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.


.. py:class:: LongDoubleDType

   Bases: :py:obj:`numpy.dtypes._FloatAbstractDType`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.


.. py:class:: LongLongDType

   Bases: :py:obj:`numpy.dtypes._IntegerAbstractDType`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.


.. py:class:: NUMBER_FORMAT_STRINGS

   dict() -> new empty dictionary
   dict(mapping) -> new dictionary initialized from a mapping object's
       (key, value) pairs
   dict(iterable) -> new dictionary initialized as if via:
       d = {}
       for k, v in iterable:
           d[k] = v
   dict(**kwargs) -> new dictionary initialized with the name=value pairs
       in the keyword argument list.  For example:  dict(one=1, two=2)


   .. py:method:: clear()

      Remove all items from the dict.



   .. py:method:: copy()

      Return a shallow copy of the dict.



   .. py:method:: fromkeys(iterable, value=None, /)

      Create a new dictionary with keys from iterable and values set to value.



   .. py:method:: get(key, default=None, /)

      Return the value for key if key is in the dictionary, else default.



   .. py:method:: items()

      Return a set-like object providing a view on the dict's items.



   .. py:method:: keys()

      Return a set-like object providing a view on the dict's keys.



   .. py:method:: pop(*args, **kwargs)

      D.pop(k[,d]) -> v, remove specified key and return the corresponding value.

      If the key is not found, return the default if given; otherwise,
      raise a KeyError.



   .. py:method:: popitem()

      Remove and return a (key, value) pair as a 2-tuple.

      Pairs are returned in LIFO (last-in, first-out) order.
      Raises KeyError if the dict is empty.



   .. py:method:: setdefault(key, default=None, /)

      Insert key with a value of default if key is not in the dictionary.

      Return the value for key if key is in the dictionary, else default.



   .. py:method:: update(*args, **kwargs)

      D.update([E, ]**F) -> None.  Update D from mapping/iterable E and F.
      If E is present and has a .keys() method, then does:  for k in E.keys(): D[k] = E[k]
      If E is present and lacks a .keys() method, then does:  for k, v in E: D[k] = v
      In either case, this is followed by: for k in F:  D[k] = F[k]



   .. py:method:: values()

      Return an object providing a view on the dict's values.



.. py:exception:: NonUniqueError

   Bases: :py:obj:`ValueError`


   Exception raised when duplicate values are found in a set of keys that are expected to be unique.

   This is typically raised in lookup and alignment operations that assume
   a one-to-one mapping between keys and values.

   .. rubric:: Examples

   >>> from arkouda.alignment import NonUniqueError
   >>> raise NonUniqueError("Duplicate values found in key array.")
   Traceback (most recent call last):
       ...
   arkouda.alignment.NonUniqueError: Duplicate values found in key array.


.. py:class:: NumericDTypes

   Build an immutable unordered collection of unique elements.


   .. py:method:: copy()

      Return a shallow copy of a set.



   .. py:method:: difference(*others)

      Return a new set with elements in the set that are not in the others.



   .. py:method:: intersection(*others)

      Return a new set with elements common to the set and all others.



   .. py:method:: isdisjoint(other, /)

      Return True if two sets have a null intersection.



   .. py:method:: issubset(other, /)

      Report whether another set contains this set.



   .. py:method:: issuperset(other, /)

      Report whether this set contains another set.



   .. py:method:: symmetric_difference(other, /)

      Return a new set with elements in either the set or other but not both.



   .. py:method:: union(*others)

      Return a new set with elements from the set and all others.



.. py:class:: ObjectDType

   Bases: :py:obj:`numpy.dtype`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.


.. py:class:: Power_divergenceResult

   Bases: :py:obj:`Power_divergenceResult`


   The results of a power divergence statistical test.

   .. attribute:: statistic



      :type: float64

   .. attribute:: pvalue



      :type: float64


.. py:class:: Properties

   Base class for accessor implementations in Arkouda.

   Provides the `_make_op` class method to dynamically generate accessor methods
   that wrap underlying `Strings` or `Datetime` operations and return new Series.

   .. rubric:: Notes

   This class is subclassed by `StringAccessor` and `DatetimeAccessor`, and is not
   intended to be used directly.

   .. rubric:: Examples

   Subclasses should define `_make_op("operation_name")`, which will generate
   a method that applies `series.values.operation_name(...)` and returns a new Series.


.. py:data:: RegisteredSymbols
   :value: '__RegisteredSymbols__'


.. py:exception:: RegistrationError

   Bases: :py:obj:`Exception`


   Error/Exception used when the Arkouda Server cannot register an object.


.. py:class:: Row(dict=None, /, **kwargs)

   Bases: :py:obj:`collections.UserDict`


   A dictionary‐like representation of a single row in an Arkouda DataFrame.

   Wraps the column→value mapping for one row and provides convenient ASCII
   and HTML formatting for display.

   :param data: Mapping of column names to their corresponding values for this row.
   :type data: dict

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> from arkouda.row import Row
   >>> df = ak.DataFrame({'x': ak.array([10, 20]), 'y': ak.array(['a', 'b'])})

   Suppose df[0] returns {'x': 10, 'y': 'a'}
   >>> row = Row({'x': 10, 'y': 'a'})
   >>> print(row)
   keys    values
   ------  --------
   x       10
   y       a


.. py:class:: ScalarDTypes

   Build an immutable unordered collection of unique elements.


   .. py:method:: copy()

      Return a shallow copy of a set.



   .. py:method:: difference(*others)

      Return a new set with elements in the set that are not in the others.



   .. py:method:: intersection(*others)

      Return a new set with elements common to the set and all others.



   .. py:method:: isdisjoint(other, /)

      Return True if two sets have a null intersection.



   .. py:method:: issubset(other, /)

      Report whether another set contains this set.



   .. py:method:: issuperset(other, /)

      Report whether this set contains another set.



   .. py:method:: symmetric_difference(other, /)

      Return a new set with elements in either the set or other but not both.



   .. py:method:: union(*others)

      Return a new set with elements from the set and all others.



.. py:class:: ScalarType

   Built-in immutable sequence.

   If no argument is given, the constructor returns an empty tuple.
   If iterable is specified the tuple is initialized from iterable's items.

   If the argument is a tuple, the return value is the same object.


   .. py:method:: count(value, /)

      Return number of occurrences of value.



   .. py:method:: index(value, start=0, stop=9223372036854775807, /)

      Return first index of value.

      Raises ValueError if the value is not present.



.. py:class:: SegArray(segments, values, lengths=None, grouping=None)

   .. py:method:: AND(x=None)


   .. py:method:: OR(x=None)


   .. py:method:: XOR(x=None)


   .. py:method:: aggregate(op, x=None)


   .. py:method:: all(x=None)


   .. py:method:: any(x=None)


   .. py:method:: append(other, axis=0)

      Append other to self, either vertically (axis=0, length of resulting SegArray
      increases), or horizontally (axis=1, each sub-array of other appends to the
      corresponding sub-array of self).

      :param other: Array of sub-arrays to append
      :type other: SegArray
      :param axis: Whether to append vertically (0) or horizontally (1). If axis=1, other
                   must be same size as self.
      :type axis: 0 or 1

      :returns: axis=0: New SegArray containing all sub-arrays
                axis=1: New SegArray of same length, with pairs of sub-arrays concatenated
      :rtype: SegArray



   .. py:method:: append_single(x, prepend=False)

      Append a single value to each sub-array.

      :param x: Single value to append to each sub-array
      :type x: pdarray or scalar

      :returns: Copy of original SegArray with values from x appended to each sub-array
      :rtype: SegArray



   .. py:method:: argmax(x=None)


   .. py:method:: argmin(x=None)


   .. py:method:: concat(x, axis=0, ordered=True)
      :classmethod:


      Concatenate a sequence of SegArrays.

      :param x: The SegArrays to concatenate
      :type x: sequence of SegArray
      :param axis: Select vertical (0) or horizontal (1) concatenation. If axis=1, all
                   SegArrays must have same size.
      :type axis: 0 or 1
      :param ordered: Must be True. This option is present for compatibility only, because unordered
                      concatenation is not yet supported.
      :type ordered: bool

      :returns: The input arrays joined into one SegArray
      :rtype: SegArray



   .. py:method:: copy()

      Return a deep copy.



   .. py:attribute:: dtype


   .. py:method:: filter(filter, discard_empty: bool = False)

      Filter values out of the SegArray object.

      :param filter: The value/s to be filtered out of the SegArray
      :type filter: pdarray, list, or value
      :param discard_empty: Defaults to False. When True, empty segments are removed from
                            the return SegArray
      :type discard_empty: bool

      :rtype: SegArray



   .. py:method:: from_multi_array(m)
      :classmethod:


      Construct a SegArray from a list of columns. This essentially transposes the input,
      resulting in an array of rows.

      :param m: List of columns, the rows of which will form the sub-arrays of the output
      :type m: list of pdarray or Strings

      :returns: Array of rows of input
      :rtype: SegArray



   .. py:method:: from_return_msg(rep_msg) -> SegArray
      :classmethod:



   .. py:method:: get_jth(j, return_origins=True, compressed=False, default=0)

      Select the j-th element of each sub-array, where possible.

      :param j: The index of the value to get from each sub-array. If j is negative,
                it counts backwards from the end of each sub-array.
      :type j: int
      :param return_origins: If True, return a logical index indicating where j is in bounds
      :type return_origins: bool
      :param compressed: If False, return array is same size as self, with default value
                         where j is out of bounds. If True, the return array only contains
                         values where j is in bounds.
      :type compressed: bool
      :param default: When compressed=False, the value to return when j is out of bounds
                      for the sub-array
      :type default: scalar

      :returns:

                val : pdarray
                    compressed=False: The j-th value of each sub-array where j is in
                    bounds and the default value where j is out of bounds.
                    compressed=True: The j-th values of only the sub-arrays where j is
                    in bounds
                origin_indices : pdarray, bool
                    A Boolean array that is True where j is in bounds for the sub-array.
      :rtype: pdarray, pdarray|bool

      .. rubric:: Notes

      If values are Strings, only the compressed format is supported.



   .. py:method:: get_length_n(n, return_origins=True)

      Return all sub-arrays of length n, as a list of columns.

      :param n: Length of sub-arrays to select
      :type n: int
      :param return_origins: Return a logical index indicating which sub-arrays are length n
      :type return_origins: bool

      :returns:

                columns : list of pdarray
                    An n-long list of pdarray, where each row is one of the n-long
                    sub-arrays from the SegArray. The number of rows is the number of
                    True values in the returned mask.
                origin_indices : pdarray, bool
                    Array of bool for each element of the SegArray, True where sub-array
                    has length n.
      :rtype: List of pdarray, pdarray|bool



   .. py:method:: get_ngrams(n, return_origins=True)

      Return all n-grams from all sub-arrays.

      :param n: Length of n-gram
      :type n: int
      :param return_origins: If True, return an int64 array indicating which sub-array
                             each returned n-gram came from.
      :type return_origins: bool

      :returns:

                ngrams : list of pdarray
                    An n-long list of pdarrays, essentially a table where each row is an n-gram.
                origin_indices : pdarray, int
                    The index of the sub-array from which the corresponding n-gram originated
      :rtype: pdarray, pdarray|int



   .. py:method:: get_prefixes(n, return_origins=True, proper=True)

      Return all sub-array prefixes of length n (for sub-arrays that are at least n+1 long).

      :param n: Length of suffix
      :type n: int
      :param return_origins: If True, return a logical index indicating which sub-arrays
                             were long enough to return an n-prefix
      :type return_origins: bool
      :param proper: If True, only return proper prefixes, i.e. from sub-arrays
                     that are at least n+1 long. If False, allow the entire
                     sub-array to be returned as a prefix.
      :type proper: bool

      :returns:

                prefixes : list of pdarray
                    An n-long list of pdarrays, essentially a table where each row is an n-prefix.
                    The number of rows is the number of True values in the returned mask.
                origin_indices : pdarray, bool
                    Boolean array that is True where the sub-array was long enough to return
                    an n-suffix, False otherwise.
      :rtype: List of pdarray, pdarray|bool



   .. py:method:: get_suffixes(n, return_origins=True, proper=True)

      Return the n-long suffix of each sub-array, where possible.

      :param n: Length of suffix
      :type n: int
      :param return_origins: If True, return a logical index indicating which sub-arrays
                             were long enough to return an n-suffix
      :type return_origins: bool
      :param proper: If True, only return proper suffixes, i.e. from sub-arrays
                     that are at least n+1 long. If False, allow the entire
                     sub-array to be returned as a suffix.
      :type proper: bool

      :returns:

                suffixes : list of pdarray
                    An n-long list of pdarrays, essentially a table where each row is an n-suffix.
                    The number of rows is the number of True values in the returned mask.
                origin_indices : pdarray, bool
                    Boolean array that is True where the sub-array was long enough to return
                    an n-suffix, False otherwise.
      :rtype: List of pdarray, pdarray|bool



   .. py:property:: grouping


   .. py:method:: hash() -> Tuple[arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.pdarrayclass.pdarray]

      Compute a 128-bit hash of each segment.

      :returns: A tuple of two int64 pdarrays. The ith hash value is the concatenation
                of the ith values from each array.
      :rtype: Tuple[pdarray,pdarray]



   .. py:method:: intersect(other)

      Computes the intersection of 2 SegArrays.

      :param other: SegArray to compute against
      :type other: SegArray

      :returns: Segments are the 1d intersections of the segments of self and other
      :rtype: SegArray

      .. seealso:: :py:obj:`pdarraysetops.intersect1d`

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> a = [1, 2, 3, 1, 4]
      >>> b = [3, 1, 4, 5]
      >>> c = [1, 3, 3, 5]
      >>> d = [2, 2, 4]
      >>> seg_a = ak.SegArray(ak.array([0, len(a)]), ak.array(a+b))
      >>> seg_b = ak.SegArray(ak.array([0, len(c)]), ak.array(c+d))
      >>> seg_a.intersect(seg_b)
      SegArray([
      [1 3]
      [4]
      ])



   .. py:method:: is_registered() -> bool

      Check if the name of the SegArray object is registered in the Symbol Table.

      :returns: True if SegArray is registered, false if not
      :rtype: bool

      .. seealso:: :py:obj:`register`, :py:obj:`unregister`, :py:obj:`attach`



   .. py:attribute:: logger


   .. py:method:: max(x=None)


   .. py:method:: mean(x=None)


   .. py:method:: min(x=None)


   .. py:property:: nbytes

      The size of the segarray in bytes.

      :returns: The size of the segarray in bytes.
      :rtype: int


   .. py:property:: non_empty


   .. py:method:: nunique(x=None)


   .. py:attribute:: objType
      :value: 'SegArray'



   .. py:method:: prepend_single(x)


   .. py:method:: prod(x=None)


   .. py:method:: read_hdf(prefix_path, dataset='segarray')
      :classmethod:


      Load a saved SegArray from HDF5. All arguments must match what
      was supplied to SegArray.save().

      :param prefix_path: Directory and filename prefix
      :type prefix_path: str
      :param dataset: Name prefix for saved data within the HDF5 files
      :type dataset: str

      :rtype: SegArray



   .. py:method:: register(user_defined_name)

      Register this SegArray object and underlying components with the Arkouda server.

      :param user_defined_name: user defined name which this SegArray object will be registered under
      :type user_defined_name: str

      :returns: The same SegArray which is now registered with the arkouda server and has an updated name.
                This is an in-place modification, the original is returned to support
                a fluid programming style.
                Please note you cannot register two different SegArrays with the same name.
      :rtype: SegArray

      :raises RegistrationError: Raised if the server could not register the SegArray object

      .. rubric:: Notes

      Objects registered with the server are immune to deletion until
      they are unregistered.

      .. seealso:: :py:obj:`unregister`, :py:obj:`attach`, :py:obj:`is_registered`



   .. py:attribute:: registered_name
      :type:  Optional[str]
      :value: None



   .. py:method:: remove_repeats(return_multiplicity=False)

      Condense sequences of repeated values within a sub-array to a single value.

      :param return_multiplicity: If True, also return the number of times each value was repeated.
      :type return_multiplicity: bool

      :returns:

                norepeats : SegArray
                    Sub-arrays with runs of repeated values replaced with single value
                multiplicity : SegArray
                    If return_multiplicity=True, this array contains the number of times
                    each value in the returned SegArray was repeated in the original SegArray.
      :rtype: Segarray, Segarray



   .. py:attribute:: segments


   .. py:method:: set_jth(i, j, v)

      Set the j-th element of each sub-array in a subset.

      :param i: Indices of sub-arrays to set j-th element
      :type i: pdarray, int
      :param j: Index of value to set in each sub-array. If j is negative, it counts
                backwards from the end of the sub-array.
      :type j: int
      :param v: The value(s) to set. If v is a pdarray, it must have same length as i.
      :type v: pdarray or scalar

      :raises ValueError: If j is out of bounds in any of the sub-arrays specified by i.



   .. py:method:: setdiff(other)

      Computes the set difference of 2 SegArrays.

      :param other: SegArray to compute against
      :type other: SegArray

      :returns: Segments are the 1d set difference of the segments of self and other
      :rtype: SegArray

      .. seealso:: :py:obj:`pdarraysetops.setdiff1d`

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> a = [1, 2, 3, 1, 4]
      >>> b = [3, 1, 4, 5]
      >>> c = [1, 3, 3, 5]
      >>> d = [2, 2, 4]
      >>> seg_a = ak.SegArray(ak.array([0, len(a)]), ak.array(a+b))
      >>> seg_b = ak.SegArray(ak.array([0, len(c)]), ak.array(c+d))
      >>> seg_a.setdiff(seg_b)
      SegArray([
      [2 4]
      [1 3 5]
      ])



   .. py:method:: setxor(other)

      Computes the symmetric difference of 2 SegArrays.

      :param other: SegArray to compute against
      :type other: SegArray

      :returns: Segments are the 1d symmetric difference of the segments of self and other
      :rtype: SegArray

      .. seealso:: :py:obj:`pdarraysetops.setxor1d`

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> a = [1, 2, 3, 1, 4]
      >>> b = [3, 1, 4, 5]
      >>> c = [1, 3, 3, 5]
      >>> d = [2, 2, 4]
      >>> seg_a = ak.SegArray(ak.array([0, len(a)]), ak.array(a+b))
      >>> seg_b = ak.SegArray(ak.array([0, len(c)]), ak.array(c+d))
      >>> seg_a.setxor(seg_b)
      SegArray([
      [2 4 5]
      [1 2 3 5]
      ])



   .. py:attribute:: size


   .. py:method:: sum(x=None)


   .. py:method:: to_hdf(prefix_path, dataset='segarray', mode='truncate', file_type='distribute')

      Save the SegArray to HDF5. The result is a collection of HDF5 files, one file
      per locale of the arkouda server, where each filename starts with prefix_path.

      :param prefix_path: Directory and filename prefix that all output files will share
      :type prefix_path: str
      :param dataset: Name prefix for saved data within the HDF5 file
      :type dataset: str
      :param mode: By default, truncate (overwrite) output files, if they exist.
                   If 'append', add data as a new column to existing files.
      :type mode: str {'truncate' | 'append'}
      :param file_type: Default: "distribute"
                        When set to single, dataset is written to a single file.
                        When distribute, dataset is written on a file per locale.
                        This is only supported by HDF5 files and will have no impact of Parquet Files.
      :type file_type: str ("single" | "distribute")

      :rtype: None

      .. seealso:: :py:obj:`load`



   .. py:method:: to_ndarray()

      Convert the array into a numpy.ndarray containing sub-arrays.

      :returns: A numpy ndarray with the same sub-arrays (also numpy.ndarray) as this array
      :rtype: np.ndarray

      .. seealso:: :py:obj:`array`, :py:obj:`tolist`

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> segarr = ak.SegArray(ak.array([0, 4, 7]), ak.arange(12))
      >>> segarr.to_ndarray()
      array([array([0, 1, 2, 3]), array([4, 5, 6]), array([ 7,  8,  9, 10, 11])],
        dtype=object)
      >>> type(segarr.to_ndarray())
      <class 'numpy.ndarray'>



   .. py:method:: to_parquet(prefix_path, dataset='segarray', mode: str = 'truncate', compression: Optional[str] = None)

      Save the SegArray object to Parquet. The result is a collection of files,
      one file per locale of the arkouda server, where each filename starts
      with prefix_path. Each locale saves its chunk of the object to its
      corresponding file.

      :param prefix_path: Directory and filename prefix that all output files share
      :type prefix_path: str
      :param dataset: Name of the dataset to create in files (must not already exist)
      :type dataset: str
      :param mode: Deprecated.
                   Parameter kept to maintain functionality of other calls. Only Truncate
                   supported.
                   By default, truncate (overwrite) output files, if they exist.
                   If 'append', attempt to create new dataset in existing files.
      :type mode: str {'truncate' | 'append'}
      :param compression: (None | "snappy" | "gzip" | "brotli" | "zstd" | "lz4")
                          Sets the compression type used with Parquet files
      :type compression: str (Optional)

      :rtype: string message indicating result of save operation

      :raises RuntimeError: Raised if a server-side error is thrown saving the pdarray
      :raises ValueError: If write mode is not Truncate.

      .. rubric:: Notes

      - Append mode for Parquet has been deprecated. It was not implemented for SegArray.
      - The prefix_path must be visible to the arkouda server and the user must
      have write permission.
      - Output files have names of the form ``<prefix_path>_LOCALE<i>``, where ``<i>``
      ranges from 0 to ``numLocales`` for `file_type='distribute'`.
      - If any of the output files already exist and
      the mode is 'truncate', they will be overwritten. If the mode is 'append'
      and the number of output files is less than the number of locales or a
      dataset with the same name already exists, a ``RuntimeError`` will result.
      - Any file extension can be used.The file I/O does not rely on the extension to
      determine the file format.



   .. py:method:: tolist()

      Convert the segarray into a list containing sub-arrays.

      :returns: A list with the same sub-arrays (also list) as this segarray
      :rtype: list

      .. seealso:: :py:obj:`to_ndarray`

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> segarr = ak.SegArray(ak.array([0, 4, 7]), ak.arange(12))
      >>> segarr.tolist()
      [[0, 1, 2, 3], [4, 5, 6], [7, 8, 9, 10, 11]]
      >>> type(segarr.tolist())
      <class 'list'>



   .. py:method:: transfer(hostname: str, port: arkouda.numpy.dtypes.int_scalars)

      Send a Segmented Array to a different Arkouda server.

      :param hostname: The hostname where the Arkouda server intended to
                       receive the Segmented Array is running.
      :type hostname: str
      :param port: The port to send the array over. This needs to be an
                   open port (i.e., not one that the Arkouda server is
                   running on). This will open up `numLocales` ports,
                   each of which in succession, so will use ports of the
                   range {port..(port+numLocales)} (e.g., running an
                   Arkouda server of 4 nodes, port 1234 is passed as
                   `port`, Arkouda will use ports 1234, 1235, 1236,
                   and 1237 to send the array data).
                   This port much match the port passed to the call to
                   `ak.receive_array()`.
      :type port: int_scalars

      :rtype: A message indicating a complete transfer

      :raises ValueError: Raised if the op is not within the pdarray.BinOps set
      :raises TypeError: Raised if other is not a pdarray or the pdarray.dtype is not
          a supported dtype



   .. py:method:: union(other)

      Computes the union of 2 SegArrays.

      :param other: SegArray to compute against
      :type other: SegArray

      :returns: Segments are the 1d union of the segments of self and other
      :rtype: SegArray

      .. seealso:: :py:obj:`pdarraysetops.union1d`

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> a = [1, 2, 3, 1, 4]
      >>> b = [3, 1, 4, 5]
      >>> c = [1, 3, 3, 5]
      >>> d = [2, 2, 4]
      >>> seg_a = ak.SegArray(ak.array([0, len(a)]), ak.array(a+b))
      >>> seg_b = ak.SegArray(ak.array([0, len(c)]), ak.array(c+d))
      >>> seg_a.union(seg_b)
      SegArray([
      [1 2 3 4 5]
      [1 2 3 4 5]
      ])



   .. py:method:: unique(x=None)

      Return sub-arrays of unique values.

      :param x: The values to unique, per group. By default, the values of this
                SegArray's sub-arrays.
      :type x: pdarray

      :returns: Same number of sub-arrays as original SegArray, but elements in sub-array
                are unique and in sorted order.
      :rtype: SegArray



   .. py:method:: unregister()

      Unregister this SegArray object in the arkouda server which was previously
      registered using register() and/or attached to using attach().

      :raises RuntimeError: Raised if the server could not unregister the SegArray object from the Symbol Table

      .. rubric:: Notes

      Objects registered with the server are immune to deletion until
      they are unregistered.

      .. seealso:: :py:obj:`register`, :py:obj:`attach`, :py:obj:`is_registered`



   .. py:method:: update_hdf(prefix_path: str, dataset: str = 'segarray', repack: bool = True)

      Overwrite the dataset with the name provided with this SegArray object. If
      the dataset does not exist it is added.

      :param prefix_path: Directory and filename prefix that all output files share
      :type prefix_path: str
      :param dataset: Name of the dataset to create in files
      :type dataset: str
      :param repack: Default: True
                     HDF5 does not release memory on delete. When True, the inaccessible
                     data (that was overwritten) is removed. When False, the data remains, but is
                     inaccessible. Setting to false will yield better performance, but will cause
                     file sizes to expand.
      :type repack: bool

      :raises RuntimeError: Raised if a server-side error is thrown saving the SegArray

      .. rubric:: Notes

      - If file does not contain File_Format attribute to indicate how it was saved,
        the file name is checked for _LOCALE#### to determine if it is distributed.
      - If the dataset provided does not exist, it will be added
      - Because HDF5 deletes do not release memory, this will create a copy of the
        file with the new data



   .. py:attribute:: valsize


   .. py:attribute:: values


.. py:class:: Series(data: Union[Tuple, List, arkouda.pandas.groupbyclass.groupable_element_type, Series, arkouda.numpy.segarray.SegArray, pandas.Series, pandas.Categorical], name=None, index: Optional[Union[arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.strings.Strings, Tuple, List, arkouda.pandas.index.Index]] = None)

   One-dimensional arkouda array with axis labels.

   :param index: an array of indices associated with the data array.
                 If empty, it will default to a range of ints whose size match the size of the data.
                 optional
   :type index: pdarray, Strings
   :param data: a 1D array. Must not be None.
   :type data: Tuple, List, groupable_element_type, Series, SegArray

   :raises TypeError: Raised if index is not a pdarray or Strings object
       Raised if data is not a pdarray, Strings, or Categorical object
   :raises ValueError: Raised if the index size does not match data size

   .. rubric:: Notes

   The Series class accepts either positional arguments or keyword arguments.
   If entering positional arguments,
       2 arguments entered:
           argument 1 - data
           argument 2 - index
       1 argument entered:
           argument 1 - data
   If entering 1 positional argument, it is assumed that this is the data argument.
   If only 'data' argument is passed in, Index will automatically be generated.
   If entering keywords,
       'data' (see Parameters)
       'index' (optional) must match size of 'data'


   .. py:method:: add(b: Series) -> Series


   .. py:property:: at
      :type: _LocIndexer


      Accesses entries of a Series by label.

      :returns: An indexer for label-based access to Series entries.
      :rtype: _LocIndexer


   .. py:method:: concat(arrays: List, axis: int = 0, index_labels: Union[List[str], None] = None, value_labels: Union[List[str], None] = None, ordered: bool = False) -> Union[arkouda.pandas.dataframe.DataFrame, Series]
      :staticmethod:


      Concatenate a list of Arkouda Series or grouped arrays horizontally or vertically.

      If a list of grouped Arkouda arrays is passed, they are converted to Series. Each grouping
      is a 2-tuple where the first item is the key(s) and the second is the value. If concatenating
      horizontally (axis=1), all series/groupings must have the same length and the same index.
      The index is converted to a column in the resulting DataFrame; if it's a MultiIndex,
      each level is converted to a separate column.

      :param arrays: A list of Series or groupings (tuples of index and values) to concatenate.
      :type arrays: List
      :param axis: The axis to concatenate along:
                   - 0 = vertical (stack series into one)
                   - 1 = horizontal (align by index and produce a DataFrame)
                   Defaults to 0.
      :type axis: int
      :param index_labels: Column name(s) to label the index when axis=1.
      :type index_labels: List[str] or None, optional
      :param value_labels: Column names to label the values of each Series.
      :type value_labels: List[str] or None, optional
      :param ordered: Unused parameter. Reserved for future support of deterministic
                      vs. performance-optimized concatenation. Defaults to False.
      :type ordered: bool

      :returns:

                - If axis=0: a new Series
                - If axis=1: a new DataFrame
      :rtype: Series or DataFrame



   .. py:method:: diff() -> Series

      Diffs consecutive values of the series.

      Returns a new series with the same index and length.  First value is set to NaN.



   .. py:attribute:: dt


   .. py:property:: dtype
      :type: numpy.dtype



   .. py:method:: fillna(value: Union[supported_scalars, Series, arkouda.numpy.pdarrayclass.pdarray]) -> Series

      Fill NA/NaN values using the specified method.

      :param value: Value to use to fill holes (e.g. 0), alternately a
                    Series of values specifying which value to use for
                    each index.  Values not in the Series will not be filled.
                    This value cannot be a list.
      :type value: supported_scalars, Series, or pdarray

      :returns: Object with missing values filled.
      :rtype: Series

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> from arkouda import Series
      >>> import numpy as np

      >>> data = ak.Series([1, np.nan, 3, np.nan, 5])
      >>> data
      0    1.0
      1    NaN
      2    3.0
      3    NaN
      4    5.0
      dtype: float64

      >>> fill_values1 = ak.ones(5)
      >>> data.fillna(fill_values1)
      0    1.0
      1    1.0
      2    3.0
      3    1.0
      4    5.0
      dtype: float64

      >>> fill_values2 = Series(ak.ones(5))
      >>> data.fillna(fill_values2)
      0    1.0
      1    1.0
      2    3.0
      3    1.0
      4    5.0
      dtype: float64

      >>> fill_values3 = 100.0
      >>> data.fillna(fill_values3)
      0      1.0
      1    100.0
      2      3.0
      3    100.0
      4      5.0
      dtype: float64



   .. py:method:: from_return_msg(repMsg: str) -> Series
      :classmethod:


      Return a Series instance pointing to components created by the arkouda server.

      The user should not call this function directly.

      :param repMsg:
                     + delimited string containing the values and indexes.
      :type repMsg: builtin_str

      :returns: A Series representing a set of pdarray components on the server.
      :rtype: Series

      :raises RuntimeError: Raised if a server-side error is thrown in the process of creating
          the Series instance.



   .. py:method:: has_repeat_labels() -> bool

      Return whether the Series has any labels that appear more than once.



   .. py:method:: hasnans() -> arkouda.numpy.dtypes.bool_scalars

      Return True if there are any NaNs.

      :rtype: bool

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> from arkouda import Series
      >>> import numpy as np

      >>> s = ak.Series(ak.array([1, 2, 3, np.nan]))
      >>> s
      0    1.0
      1    2.0
      2    3.0
      3    NaN
      dtype: float64

      >>> s.hasnans()
      np.True_



   .. py:method:: head(n: int = 10) -> Series

      Return the first n values of the series.



   .. py:property:: iat
      :type: _iLocIndexer


      Accesses entries of a Series by position.

      :returns: An indexer for position-based access to a single element.
      :rtype: _iLocIndexer


   .. py:property:: iloc
      :type: _iLocIndexer


      Accesses entries of a Series by position.

      :returns: An indexer for position-based access to Series entries.
      :rtype: _iLocIndexer


   .. py:method:: is_registered() -> bool

      Return True iff the object is contained in the registry or is a component of a
       registered object.

      :returns: Indicates if the object is contained in the registry
      :rtype: bool

      :raises RegistrationError: Raised if there's a server-side error or a mis-match of registered components

      .. seealso:: :py:obj:`register`, :py:obj:`attach`, :py:obj:`unregister`

      .. rubric:: Notes

      Objects registered with the server are immune to deletion until
      they are unregistered.



   .. py:method:: isin(lst: Union[arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.strings.Strings, List]) -> Series

      Find Series elements whose values are in the specified list.

      :param lst: Either a Python list or an Arkouda array to check membership against.
      :type lst: pdarray, Strings, or List

      :returns: A Series of booleans that is True for elements found in the list,
                and False otherwise.
      :rtype: Series



   .. py:method:: isna() -> Series

      Detect missing values.

      Return a boolean same-sized object indicating if the values are NA. NA values,
      such as numpy.NaN, gets mapped to True values.
      Everything else gets mapped to False values.
      Characters such as empty strings '' are not considered NA values.

      :returns: Mask of bool values for each element in Series
                that indicates whether an element is an NA value.
      :rtype: Series

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> from arkouda import Series
      >>> import numpy as np

      >>> s = Series(ak.array([1, 2, np.nan]), index = ak.array([1, 2, 4]))
      >>> s.isna()
      1    False
      2    False
      4     True
      dtype: bool



   .. py:method:: isnull() -> Series

      Series.isnull is an alias for Series.isna.

      Detect missing values.

      Return a boolean same-sized object indicating if the values are NA. NA values,
      such as numpy.NaN, gets mapped to True values.
      Everything else gets mapped to False values.
      Characters such as empty strings '' are not considered NA values.

      :returns: Mask of bool values for each element in Series
                that indicates whether an element is an NA value.
      :rtype: Series

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> from arkouda import Series
      >>> import numpy as np

      >>> s = Series(ak.array([1, 2, np.nan]), index = ak.array([1, 2, 4]))
      >>> s.isnull()
      1    False
      2    False
      4     True
      dtype: bool



   .. py:property:: loc
      :type: _LocIndexer


      Accesses entries of a Series by label.

      :returns: An indexer for label-based access to Series entries.
      :rtype: _LocIndexer


   .. py:method:: locate(key: Union[int, arkouda.numpy.pdarrayclass.pdarray, arkouda.pandas.index.Index, Series, List, Tuple]) -> Series

      Lookup values by index label.

      :param key: The key or keys to look up. This can be:
                  - A scalar
                  - A list of scalars
                  - A list of lists (for MultiIndex)
                  - A Series (in which case labels are preserved, and its values are used as keys)

                  Keys will be converted to Arkouda arrays as needed.
      :type key: int, pdarray, Index, Series, List, or Tuple

      :returns: A Series containing the values corresponding to the key.
      :rtype: Series



   .. py:method:: map(arg: Union[dict, arkouda.Series]) -> arkouda.Series

      Map values of Series according to an input mapping.

      :param arg: The mapping correspondence.
      :type arg: dict or Series

      :returns: A new series with the same index as the caller.
                When the input Series has Categorical values,
                the return Series will have Strings values.
                Otherwise, the return type will match the input type.
      :rtype: Series

      :raises TypeError: Raised if arg is not of type dict or arkouda.Series.
          Raised if series values not of type pdarray, Categorical, or Strings.

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> s = ak.Series(ak.array([2, 3, 2, 3, 4]))
      >>> s
      0    2
      1    3
      2    2
      3    3
      4    4
      dtype: int64

      >>> s.map({4: 25.0, 2: 30.0, 1: 7.0, 3: 5.0})
      0    30.0
      1     5.0
      2    30.0
      3     5.0
      4    25.0
      dtype: float64

      >>> s2 = ak.Series(ak.array(["a","b","c","d"]), index = ak.array([4,2,1,3]))
      >>> s.map(s2)
      0    b
      1    d
      2    b
      3    d
      4    a
      dtype: object



   .. py:method:: memory_usage(index: bool = True, unit: Literal['B', 'KB', 'MB', 'GB'] = 'B') -> int

      Return the memory usage of the Series.

      The memory usage can optionally include the contribution of
      the index.

      :param index: Specifies whether to include the memory usage of the Series index.
                    Defaults to True.
      :type index: bool
      :param unit: Unit to return. One of {'B', 'KB', 'MB', 'GB'}. Defaults to "B".
      :type unit: {"B", "KB", "MB", "GB"}

      :returns: Bytes of memory consumed.
      :rtype: int

      .. seealso:: :py:obj:`arkouda.numpy.pdarrayclass.nbytes`, :py:obj:`arkouda.Index.memory_usage`, :py:obj:`arkouda.pandas.series.Series.memory_usage`, :py:obj:`arkouda.pandas.datafame.DataFrame.memory_usage`

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> from arkouda.series import Series
      >>> s = ak.Series(ak.arange(3))
      >>> s.memory_usage()
      48

      Not including the index gives the size of the rest of the data, which
      is necessarily smaller:

      >>> s.memory_usage(index=False)
      24

      Select the units:

      >>> s = ak.Series(ak.arange(3000))
      >>> s.memory_usage(unit="KB")
      46.875



   .. py:property:: ndim
      :type: int



   .. py:method:: notna() -> Series

      Detect existing (non-missing) values.

      Return a boolean same-sized object indicating if the values are not NA.
      Non-missing values get mapped to True.
      Characters such as empty strings '' are not considered NA values.
      NA values, such as numpy.NaN, get mapped to False values.

      :returns: Mask of bool values for each element in Series
                that indicates whether an element is not an NA value.
      :rtype: Series

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> from arkouda import Series
      >>> import numpy as np

      >>> s = Series(ak.array([1, 2, np.nan]), index = ak.array([1, 2, 4]))
      >>> s.notna()
      1     True
      2     True
      4    False
      dtype: bool



   .. py:method:: notnull() -> Series

      Series.notnull is an alias for Series.notna.

      Detect existing (non-missing) values.

      Return a boolean same-sized object indicating if the values are not NA.
      Non-missing values get mapped to True.
      Characters such as empty strings '' are not considered NA values.
      NA values, such as numpy.NaN, get mapped to False values.

      :returns: Mask of bool values for each element in Series
                that indicates whether an element is not an NA value.
      :rtype: Series

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> from arkouda import Series
      >>> import numpy as np

      >>> s = Series(ak.array([1, 2, np.nan]), index = ak.array([1, 2, 4]))
      >>> s.notnull()
      1     True
      2     True
      4    False
      dtype: bool



   .. py:attribute:: objType
      :value: 'Series'



   .. py:method:: pdconcat(arrays: List, axis: int = 0, labels: Union[arkouda.numpy.strings.Strings, None] = None) -> Union[pandas.Series, pandas.DataFrame]
      :staticmethod:


      Concatenate a list of Arkouda Series or grouped arrays, returning a local pandas object.

      If a list of grouped Arkouda arrays is passed, they are converted to Series. Each grouping
      is a 2-tuple with the first item being the key(s) and the second the value.

      If `axis=1` (horizontal), each Series or grouping must have the same length and the same index.
      The index is converted to a column in the resulting DataFrame. If it is a MultiIndex,
      each level is converted to a separate column.

      :param arrays: A list of Series or groupings (tuples of index and values) to concatenate.
      :type arrays: List
      :param axis: The axis along which to concatenate:
                   - 0 = vertical (stack into a Series)
                   - 1 = horizontal (align by index into a DataFrame)
                   Defaults to 0.
      :type axis: int
      :param labels: Names to assign to the resulting columns in the DataFrame.
      :type labels: Strings or None, optional

      :returns:

                - If axis=0: a local pandas Series
                - If axis=1: a local pandas DataFrame
      :rtype: Series or DataFrame



   .. py:method:: register(user_defined_name: str)

      Register this Series object and underlying components with the Arkouda server.

      :param user_defined_name: User-defined name the Series is to be registered under.
                                This will be the root name for the underlying components.
      :type user_defined_name: builtin_str

      :returns: The same Series which is now registered with the arkouda server and has an updated name.
                This is an in-place modification, the original is returned to support
                a fluid programming style.
                Please note you cannot register two different Series with the same name.
      :rtype: Series

      :raises TypeError: Raised if user_defined_name is not a str
      :raises RegistrationError: If the server was unable to register the Series with the user_defined_name

      .. seealso:: :py:obj:`unregister`, :py:obj:`attach`, :py:obj:`is_registered`

      .. rubric:: Notes

      Objects registered with the server are immune to deletion until
      they are unregistered.



   .. py:attribute:: registered_name
      :type:  Optional[str]
      :value: None



   .. py:property:: shape
      :type: Tuple[int]



   .. py:attribute:: size


   .. py:method:: sort_index(ascending: bool = True) -> Series

      Sort the Series by its index.

      :param ascending: Whether to sort the index in ascending (default) or descending order.
                        Defaults to True.
      :type ascending: bool

      :returns: A new Series sorted by index.
      :rtype: Series



   .. py:method:: sort_values(ascending: bool = True) -> Series

      Sort the Series by its values.

      :param ascending: Whether to sort values in ascending (default) or descending order.
                        Defaults to True.
      :type ascending: bool

      :returns: A new Series sorted by its values.
      :rtype: Series



   .. py:attribute:: str


   .. py:method:: tail(n: int = 10) -> Series

      Return the last n values of the series.



   .. py:method:: to_dataframe(index_labels: Union[List[str], None] = None, value_label: Union[str, None] = None) -> arkouda.pandas.dataframe.DataFrame

      Convert the Series to an Arkouda DataFrame.

      :param index_labels: Column name(s) to label the index.
      :type index_labels: list of str or None, optional
      :param value_label: Column name to label the values.
      :type value_label: str or None, optional

      :returns: An Arkouda DataFrame representing the Series.
      :rtype: DataFrame



   .. py:method:: to_markdown(mode='wt', index=True, tablefmt='grid', storage_options=None, **kwargs)

      Print Series in Markdown-friendly format.

      :param mode: Mode in which file is opened, "wt" by default.
      :type mode: str, optional
      :param index: Add index (row) labels.
      :type index: bool, optional, default True
      :param tablefmt: Table format to call from tablulate:
                       https://pypi.org/project/tabulate/
      :type tablefmt: str = "grid"
      :param storage_options: Extra options that make sense for a particular storage connection,
                              e.g. host, port, username, password, etc., if using a URL that will be parsed by fsspec,
                              e.g., starting “s3://”, “gcs://”.
                              An error will be raised if providing this argument with a non-fsspec URL.
                              See the fsspec and backend storage implementation docs for the set
                              of allowed keys and values.
      :type storage_options: dict, optional
      :param \*\*kwargs: These parameters will be passed to tabulate.

      .. note::

         This function should only be called on small Series as it calls pandas.Series.to_markdown:
         https://pandas.pydata.org/docs/reference/api/pandas.Series.to_markdown.html

      .. rubric:: Examples

      >>> import arkouda as ak

      >>> s = ak.Series(["elk", "pig", "dog", "quetzal"], name="animal")
      >>> print(s.to_markdown())
      +----+----------+
      |    | animal   |
      +====+==========+
      |  0 | elk      |
      +----+----------+
      |  1 | pig      |
      +----+----------+
      |  2 | dog      |
      +----+----------+
      |  3 | quetzal  |
      +----+----------+

      Output markdown with a tabulate option.

      >>> print(s.to_markdown(tablefmt="grid"))
      +----+----------+
      |    | animal   |
      +====+==========+
      |  0 | elk      |
      +----+----------+
      |  1 | pig      |
      +----+----------+
      |  2 | dog      |
      +----+----------+
      |  3 | quetzal  |
      +----+----------+



   .. py:method:: to_ndarray() -> numpy.ndarray


   .. py:method:: to_pandas() -> pandas.Series

      Convert the series to a local PANDAS series.



   .. py:method:: tolist() -> list


   .. py:method:: topn(n: int = 10) -> Series

      Return the top values of the Series.

      :param n: Number of values to return. Defaults to 10.
      :type n: int

      :returns: A new Series containing the top `n` values.
      :rtype: Series



   .. py:method:: unregister()

      Unregister this Series object in the arkouda server which was previously
      registered using register() and/or attached to using attach().

      :raises RegistrationError: If the object is already unregistered or if there is a server error
          when attempting to unregister

      .. seealso:: :py:obj:`register`, :py:obj:`attach`, :py:obj:`is_registered`

      .. rubric:: Notes

      Objects registered with the server are immune to deletion until
      they are unregistered.



   .. py:method:: validate_key(key: Union[Series, arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.strings.Strings, arkouda.categorical.Categorical, List, supported_scalars, arkouda.numpy.segarray.SegArray]) -> Union[arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.strings.Strings, arkouda.categorical.Categorical, supported_scalars, arkouda.numpy.segarray.SegArray]

      Validate type requirements for keys when reading or writing the Series.

      Also converts list and tuple arguments into pdarrays.

      :param key: The key or container of keys that might be used to index into the Series.
      :type key: Series, pdarray, Strings, Categorical, List, supported_scalars, or SegArray

      :rtype: The validated key(s), with lists and tuples converted to pdarrays

      :raises TypeError: Raised if keys are not boolean values or the type of the labels
          Raised if key is not one of the supported types
      :raises KeyError: Raised if container of keys has keys not present in the Series
      :raises IndexError: Raised if the length of a boolean key array is different
          from the Series



   .. py:method:: validate_val(val: Union[arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.strings.Strings, supported_scalars, List]) -> Union[arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.strings.Strings, supported_scalars]

      Validate type requirements for values being written into the Series.

      Also converts list and tuple arguments into pdarrays.

      :param val: The value or container of values that might be assigned into the Series.
      :type val: pdarray, Strings, supported_scalars, or List

      :rtype: The validated value, with lists converted to pdarrays

      :raises TypeError: Raised if val is not the same type or a container with elements
            of the same time as the Series
          Raised if val is a string or Strings type.
          Raised if val is not one of the supported types



   .. py:method:: value_counts(sort: bool = True) -> Series

      Return a Series containing counts of unique values.

      :param sort: Whether to sort the result by count in descending order. If False,
                   the order of the results is not guaranteed. Defaults to True.
      :type sort: bool

      :returns: A Series where the index contains the unique values and the values are
                their counts in the original Series.
      :rtype: Series



.. py:class:: SeriesDTypes

   dict() -> new empty dictionary
   dict(mapping) -> new dictionary initialized from a mapping object's
       (key, value) pairs
   dict(iterable) -> new dictionary initialized as if via:
       d = {}
       for k, v in iterable:
           d[k] = v
   dict(**kwargs) -> new dictionary initialized with the name=value pairs
       in the keyword argument list.  For example:  dict(one=1, two=2)


   .. py:method:: clear()

      Remove all items from the dict.



   .. py:method:: copy()

      Return a shallow copy of the dict.



   .. py:method:: fromkeys(iterable, value=None, /)

      Create a new dictionary with keys from iterable and values set to value.



   .. py:method:: get(key, default=None, /)

      Return the value for key if key is in the dictionary, else default.



   .. py:method:: items()

      Return a set-like object providing a view on the dict's items.



   .. py:method:: keys()

      Return a set-like object providing a view on the dict's keys.



   .. py:method:: pop(*args, **kwargs)

      D.pop(k[,d]) -> v, remove specified key and return the corresponding value.

      If the key is not found, return the default if given; otherwise,
      raise a KeyError.



   .. py:method:: popitem()

      Remove and return a (key, value) pair as a 2-tuple.

      Pairs are returned in LIFO (last-in, first-out) order.
      Raises KeyError if the dict is empty.



   .. py:method:: setdefault(key, default=None, /)

      Insert key with a value of default if key is not in the dictionary.

      Return the value for key if key is in the dictionary, else default.



   .. py:method:: update(*args, **kwargs)

      D.update([E, ]**F) -> None.  Update D from mapping/iterable E and F.
      If E is present and has a .keys() method, then does:  for k in E.keys(): D[k] = E[k]
      If E is present and lacks a .keys() method, then does:  for k, v in E: D[k] = v
      In either case, this is followed by: for k in F:  D[k] = F[k]



   .. py:method:: values()

      Return an object providing a view on the dict's values.



.. py:class:: ShortDType

   Bases: :py:obj:`numpy.dtypes._IntegerAbstractDType`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.


.. py:data:: SortingAlgorithm

.. py:class:: StrDType

   Bases: :py:obj:`numpy.dtype`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.


.. py:class:: StringAccessor(series)

   Bases: :py:obj:`Properties`


   Accessor for string operations on Arkouda Series.

   Provides string-like methods such as `.contains()`, `.startswith()`, and
   `.endswith()` via the `.str` accessor, similar to pandas.

   This accessor is automatically attached to Series objects that wrap
   `arkouda.Strings` or `arkouda.Categorical` values. It should not be instantiated directly.

   :param series: The Series object containing `Strings` or `Categorical` values.
   :type series: arkouda.pandas.Series

   :raises AttributeError: If the underlying Series values are not `Strings` or `Categorical`.

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> from arkouda import Series
   >>> s = Series(["apple", "banana", "apricot"])
   >>> s.str.startswith("a")
   0     True
   1    False
   2     True
   dtype: bool


   .. py:attribute:: series


.. py:class:: Strings(strings_pdarray: arkouda.numpy.pdarrayclass.pdarray, bytes_size: arkouda.numpy.dtypes.int_scalars)

   Represents an array of strings whose data resides on the
   arkouda server. The user should not call this class directly;
   rather its instances are created by other arkouda functions.

   .. attribute:: entry

      Encapsulation of a Segmented Strings array contained on
      the arkouda server.  This is a composite of
       - offsets array: starting indices for each string
       - bytes array: raw bytes of all strings joined by nulls

      :type: pdarray

   .. attribute:: size

      The number of strings in the array

      :type: int_scalars

   .. attribute:: nbytes

      The total number of bytes in all strings

      :type: int_scalars

   .. attribute:: ndim

      The rank of the array (currently only rank 1 arrays supported)

      :type: int_scalars

   .. attribute:: shape

      The sizes of each dimension of the array

      :type: tuple

   .. attribute:: dtype

      The dtype is ak.str_

      :type: type

   .. attribute:: logger

      Used for all logging operations

      :type: ArkoudaLogger

   .. rubric:: Notes

   Strings is composed of two pdarrays: (1) offsets, which contains the
   starting indices for each string and (2) bytes, which contains the
   raw bytes of all strings, delimited by nulls.


   .. py:attribute:: BinOps


   .. py:method:: argsort(algorithm: arkouda.numpy.sorting.SortingAlgorithm = SortingAlgorithm.RadixSortLSD, ascending: bool = True) -> arkouda.numpy.pdarrayclass.pdarray

      Return the permutation that sorts the Strings.

      :param algorithm: The algorithm to use for sorting.
      :type algorithm: SortingAlgorithm, default SortingAlgorithm.RadixSortLSD
      :param ascending: Whether to sort in ascending order.
      :type ascending: bool, default True

      :returns: The indices that sort the Strings.
      :rtype: pdarray



   .. py:method:: astype(dtype: Union[numpy.dtype, str]) -> arkouda.numpy.pdarrayclass.pdarray

      Cast values of Strings object to provided dtype.

      :param dtype: Dtype to cast to
      :type dtype: np.dtype or str

      :returns: An arkouda pdarray with values converted to the specified data type
      :rtype: pdarray

      .. rubric:: Notes

      This is essentially shorthand for ak.cast(x, '<dtype>') where x is a pdarray.



   .. py:method:: cached_regex_patterns() -> List

      Returns the regex patterns for which Match objects have been cached.



   .. py:method:: capitalize() -> Strings

      Return a new Strings from the original replaced with the first letter capitilzed
      and the remaining letters lowercase.

      :returns: Strings from the original replaced with the capitalized equivalent.
      :rtype: Strings

      :raises RuntimeError: Raised if there is a server-side error thrown.

      .. seealso:: :py:obj:`Strings.lower`, :py:obj:`String.upper`, :py:obj:`String.title`

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> strings = ak.array([f'StrINgS aRe Here {i}' for i in range(5)])
      >>> strings
      array(['StrINgS aRe Here 0', 'StrINgS aRe Here 1', 'StrINgS aRe Here 2', 'StrINgS aRe Here 3', 'StrINgS aRe Here 4'])
      >>> strings.title()
      array(['Strings Are Here 0', 'Strings Are Here 1', 'Strings Are Here 2', 'Strings Are Here 3', 'Strings Are Here 4'])



   .. py:method:: concatenate_uniquely(strings: List[Strings]) -> Strings
      :staticmethod:


      Concatenates a list of Strings into a single Strings object
      containing only unique strings. Order may not be preserved.

      :param strings: List of segmented string objects to concatenate.
      :type strings: List[Strings]

      :returns: A new Strings object containing the unique values.
      :rtype: Strings



   .. py:method:: contains(substr: Union[bytes, arkouda.numpy.dtypes.str_scalars], regex: bool = False) -> arkouda.numpy.pdarrayclass.pdarray

      Check whether each element contains the given substring.

      :param substr: The substring in the form of string or byte array to search for
      :type substr: bytes or str_scalars
      :param regex: Indicates whether substr is a regular expression
                    Note: only handles regular expressions supported by re2
                    (does not support lookaheads/lookbehinds)
      :type regex: bool, default=False

      :returns: True for elements that contain substr, False otherwise
      :rtype: pdarray

      :raises TypeError: Raised if the substr parameter is not bytes or str_scalars
      :raises ValueError: Rasied if substr is not a valid regex
      :raises RuntimeError: Raised if there is a server-side error thrown

      .. seealso:: :py:obj:`Strings.startswith`, :py:obj:`Strings.endswith`

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> strings = ak.array([f'{i} string {i}' for i in range(1, 6)])
      >>> strings
      array(['1 string 1', '2 string 2', '3 string 3', '4 string 4', '5 string 5'])
      >>> strings.contains('string')
      array([True True True True True])
      >>> strings.contains('string \\d', regex=True)
      array([True True True True True])



   .. py:method:: copy() -> Strings

      Return a deep copy of the Strings object.

      :returns: A deep copy of the Strings.
      :rtype: Strings



   .. py:method:: decode(fromEncoding: str, toEncoding: str = 'UTF-8') -> Strings

      Return a new strings object in `fromEncoding`, expecting that the
      current Strings is encoded in `toEncoding`.

      :param fromEncoding: The current encoding of the strings object
      :type fromEncoding: str
      :param toEncoding: The encoding that the strings will be converted to,
                         default to UTF-8
      :type toEncoding: str, default="UTF-8"

      :returns: A new Strings object in `toEncoding`
      :rtype: Strings

      :raises RuntimeError: Raised if there is a server-side error thrown



   .. py:property:: dtype
      :type: numpy.dtype


      Return the dtype object of the underlying data.


   .. py:method:: encode(toEncoding: str, fromEncoding: str = 'UTF-8') -> Strings

      Return a new strings object in `toEncoding`, expecting that the
      current Strings is encoded in `fromEncoding`.

      :param toEncoding: The encoding that the strings will be converted to
      :type toEncoding: str
      :param fromEncoding: The current encoding of the strings object, default to
                           UTF-8
      :type fromEncoding: str, default="UTF-8"

      :returns: A new Strings object in `toEncoding`
      :rtype: Strings

      :raises RuntimeError: Raised if there is a server-side error thrown



   .. py:method:: endswith(substr: Union[bytes, arkouda.numpy.dtypes.str_scalars], regex: bool = False) -> arkouda.numpy.pdarrayclass.pdarray

      Check whether each element ends with the given substring.

      :param substr: The suffix to search for
      :type substr: bytes or str_scalars
      :param regex: Indicates whether substr is a regular expression
                    Note: only handles regular expressions supported by re2
                    (does not support lookaheads/lookbehinds)
      :type regex: bool, default=False

      :returns: True for elements that end with substr, False otherwise
      :rtype: pdarray

      :raises TypeError: Raised if the substr parameter is not bytes or str_scalars
      :raises ValueError: Rasied if substr is not a valid regex
      :raises RuntimeError: Raised if there is a server-side error thrown

      .. seealso:: :py:obj:`Strings.contains`, :py:obj:`Strings.startswith`

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> strings_start = ak.array([f'{i} string' for i in range(1,6)])
      >>> strings_start
      array(['1 string', '2 string', '3 string', '4 string', '5 string'])
      >>> strings_start.endswith('ing')
      array([True True True True True])
      >>> strings_end = ak.array([f'string {i}' for i in range(1, 6)])
      >>> strings_end
      array(['string 1', 'string 2', 'string 3', 'string 4', 'string 5'])
      >>> strings_end.endswith('ing \\d', regex = True)
      array([True True True True True])



   .. py:attribute:: entry
      :type:  arkouda.numpy.pdarrayclass.pdarray


   .. py:method:: equals(other) -> arkouda.numpy.dtypes.bool_scalars

      Whether Strings are the same size and all entries are equal.

      :param other: object to compare.
      :type other: Any

      :returns: True if the Strings are the same, o.w. False.
      :rtype: bool_scalars

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> s = ak.array(["a", "b", "c"])
      >>> s_cpy = ak.array(["a", "b", "c"])
      >>> s.equals(s_cpy)
      np.True_
      >>> s2 = ak.array(["a", "x", "c"])
      >>> s.equals(s2)
      np.False_



   .. py:method:: find_locations(pattern: Union[bytes, arkouda.numpy.dtypes.str_scalars]) -> Tuple[arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.pdarrayclass.pdarray]

      Finds pattern matches and returns pdarrays containing the number, start postitions,
      and lengths of matches.

      :param pattern: The regex pattern used to find matches
      :type pattern: bytes or str_scalars

      :returns:

                pdarray, int64
                    For each original string, the number of pattern matches
                pdarray, int64
                    The start positons of pattern matches
                pdarray, int64
                    The lengths of pattern matches
      :rtype: Tuple[pdarray, pdarray, pdarray]

      :raises TypeError: Raised if the pattern parameter is not bytes or str_scalars
      :raises ValueError: Raised if pattern is not a valid regex
      :raises RuntimeError: Raised if there is a server-side error thrown

      .. seealso:: :py:obj:`Strings.findall`, :py:obj:`Strings.match`

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> strings = ak.array([f'{i} string {i}' for i in range(1, 6)])
      >>> num_matches, starts, lens = strings.find_locations('\\d')
      >>> num_matches
      array([2 2 2 2 2])
      >>> starts
      array([0 9 0 9 0 9 0 9 0 9])
      >>> lens
      array([1 1 1 1 1 1 1 1 1 1])



   .. py:method:: findall(pattern: Union[bytes, arkouda.numpy.dtypes.str_scalars], return_match_origins: bool = False) -> Union[Strings, Tuple]

      Return a new Strings containg all non-overlapping matches of pattern.

      :param pattern: Regex used to find matches
      :type pattern: bytes or str_scalars
      :param return_match_origins: If True, return a pdarray containing the index of the original string each
                                   pattern match is from
      :type return_match_origins: bool, default=False

      :returns:

                Strings
                    Strings object containing only pattern matches
                pdarray, int64 (optional)
                    The index of the original string each pattern match is from
      :rtype: Union[Strings, Tuple]

      :raises TypeError: Raised if the pattern parameter is not bytes or str_scalars
      :raises ValueError: Raised if pattern is not a valid regex
      :raises RuntimeError: Raised if there is a server-side error thrown

      .. seealso:: :py:obj:`Strings.find_locations`

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> strings = ak.array(['1_2___', '____', '3', '__4___5____6___7', ''])
      >>> strings.findall('_+', return_match_origins=True)
      (array(['_', '___', '____', '__', '___', '____', '___']), array([0 0 1 3 3 3 3]))



   .. py:method:: flatten() -> Strings

      Return a copy of the array collapsed into one dimension.

      :rtype: A copy of the input array, flattened to one dimension.

      .. note::

         As multidimensional Strings are currently supported,
         flatten on a Strings object will always return itself.



   .. py:method:: from_parts(offset_attrib: Union[arkouda.numpy.pdarrayclass.pdarray, str], bytes_attrib: Union[arkouda.numpy.pdarrayclass.pdarray, str]) -> Strings
      :staticmethod:


      Assemble a Strings object from separate offset and bytes arrays.

      This factory method constructs a segmented `Strings` array by sending two
      separate components—offsets and values—to the Arkouda server and instructing
      it to assemble them into a single `Strings` object. Use this when offsets
      and byte data are created or transported independently.

      :param offset_attrib: The array of starting positions for each string, or a string
                            expression that can be passed to `create_pdarray` to build it.
      :type offset_attrib: pdarray or str
      :param bytes_attrib: The array of raw byte values (e.g., uint8 character codes), or a string
                           expression that can be passed to `create_pdarray` to build it.
      :type bytes_attrib: pdarray or str

      :returns: A `Strings` object representing the assembled segmented strings array
                on the Arkouda server.
      :rtype: Strings

      :raises RuntimeError: If conversion of `offset_attrib` or `bytes_attrib` to `pdarray` fails,
          or if the server is unable to assemble the parts into a `Strings`.

      .. rubric:: Notes

      - Both inputs can be existing `pdarray` instances or arguments suitable
        for `create_pdarray`.
      - Internally uses the `CMD_ASSEMBLE` command to merge offsets and values.



   .. py:method:: from_return_msg(rep_msg: str) -> Strings
      :staticmethod:


      Create a Strings object from an Arkouda server response message.

      Parse the server’s response descriptor and construct a `Strings` array
      with its underlying pdarray and total byte size.

      :param rep_msg: Server response message of the form:
                      ```
                      created <name> <type> <size> <ndim> <shape> <itemsize>+... bytes.size <total_bytes>
                      ```
                      For example:
                      ```
                      "created foo Strings 3 1 (3,) 8+created bytes.size 24"
                      ```
      :type rep_msg: str

      :returns: A `Strings` object representing the segmented strings array on the server,
                initialized with the returned pdarray and byte-size metadata.
      :rtype: Strings

      :raises RuntimeError: If the response message cannot be parsed or does not match the expected format.

      .. rubric:: Examples

      >>> import arkouda as ak

      # Example response message (typically from `generic_msg`)
      >>> rep_msg = "created foo Strings 3 1 (3,) 8+created bytes.size 24"
      >>> s = ak.Strings.from_return_msg(rep_msg)
      >>> isinstance(s, ak.Strings)
      True



   .. py:method:: fullmatch(pattern: Union[bytes, arkouda.numpy.dtypes.str_scalars]) -> arkouda.pandas.match.Match

      Return a match object where elements match only if the whole string matches the
      regular expression pattern.

      :param pattern: Regex used to find matches
      :type pattern: bytes or str_scalars

      :returns: Match object where elements match only if the whole string matches the
                regular expression pattern
      :rtype: Match

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> strings = ak.array(['1_2___', '____', '3', '__4___5____6___7', ''])
      >>> strings.fullmatch('_+')
      <ak.Match object: matched=False; matched=True, span=(0, 4); matched=False;
      matched=False; matched=False>



   .. py:method:: get_bytes() -> arkouda.numpy.pdarrayclass.pdarray

      Getter for the bytes component (uint8 pdarray) of this Strings.

      :returns: Pdarray of bytes of the string accessed
      :rtype: pdarray

      .. rubric:: Example

      >>> import arkouda as ak
      >>> x = ak.array(['one', 'two', 'three'])
      >>> x.get_bytes()
      array([111 110 101 0 116 119 111 0 116 104 114 101 101 0])



   .. py:method:: get_lengths() -> arkouda.numpy.pdarrayclass.pdarray

      Return the length of each string in the array.

      :returns: The length of each string
      :rtype: pdarray

      :raises RuntimeError: Raised if there is a server-side error thrown



   .. py:method:: get_offsets() -> arkouda.numpy.pdarrayclass.pdarray

      Getter for the offsets component (int64 pdarray) of this Strings.

      :returns: Pdarray of offsets of the string accessed
      :rtype: pdarray

      .. rubric:: Example

      >>> import arkouda as ak
      >>> x = ak.array(['one', 'two', 'three'])
      >>> x.get_offsets()
      array([0 4 8])



   .. py:method:: get_prefixes(n: arkouda.numpy.dtypes.int_scalars, return_origins: bool = True, proper: bool = True) -> Union[Strings, Tuple[Strings, arkouda.numpy.pdarrayclass.pdarray]]

      Return the n-long prefix of each string, where possible.

      :param n: Length of prefix
      :type n: int_scalars
      :param return_origins: If True, return a logical index indicating which strings
                             were long enough to return an n-prefix
      :type return_origins: bool, default=True
      :param proper: If True, only return proper prefixes, i.e. from strings
                     that are at least n+1 long. If False, allow the entire
                     string to be returned as a prefix.
      :type proper: bool, default=True

      :returns:

                prefixes : Strings
                    The array of n-character prefixes; the number of elements is the number of
                    True values in the returned mask.
                origin_indices : pdarray, bool
                    Boolean array that is True where the string was long enough to return
                    an n-character prefix, False otherwise.
      :rtype: Union[Strings, Tuple[Strings, pdarray]]



   .. py:method:: get_suffixes(n: arkouda.numpy.dtypes.int_scalars, return_origins: bool = True, proper: bool = True) -> Union[Strings, Tuple[Strings, arkouda.numpy.pdarrayclass.pdarray]]

      Return the n-long suffix of each string, where possible.

      :param n: Length of suffix
      :type n: int_scalars
      :param return_origins: If True, return a logical index indicating which strings
                             were long enough to return an n-suffix
      :type return_origins: bool, default=True
      :param proper: If True, only return proper suffixes, i.e. from strings
                     that are at least n+1 long. If False, allow the entire
                     string to be returned as a suffix.
      :type proper: bool, default=True

      :returns:

                suffixes : Strings
                    The array of n-character suffixes; the number of elements is the number of
                    True values in the returned mask.
                origin_indices : pdarray, bool
                    Boolean array that is True where the string was long enough to return
                    an n-character suffix, False otherwise.
      :rtype: Union[Strings, Tuple[Strings, pdarray]]



   .. py:method:: group() -> arkouda.numpy.pdarrayclass.pdarray

      Return the permutation that groups the array, placing equivalent
      strings together. All instances of the same string are guaranteed to lie
      in one contiguous block of the permuted array, but the blocks are not
      necessarily ordered.

      :returns: The permutation that groups the array by value
      :rtype: pdarray

      .. seealso:: :py:obj:`GroupBy`, :py:obj:`unique`

      .. rubric:: Notes

      If the arkouda server is compiled with "-sSegmentedString.useHash=true",
      then arkouda uses 128-bit hash values to group strings, rather than sorting
      the strings directly. This method is fast, but the resulting permutation
      merely groups equivalent strings and does not sort them. If the "useHash"
      parameter is false, then a full sort is performed.

      :raises RuntimeError: Raised if there is a server-side error in executing group request or
          creating the pdarray encapsulating the return message



   .. py:method:: hash() -> Tuple[arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.pdarrayclass.pdarray]

      Compute a 128-bit hash of each string.

      :returns: A tuple of two int64 pdarrays. The ith hash value is the concatenation
                of the ith values from each array.
      :rtype: Tuple[pdarray,pdarray]

      .. rubric:: Notes

      The implementation uses SipHash128, a fast and balanced hash function (used
      by Python for dictionaries and sets). For realistic numbers of strings (up
      to about 10**15), the probability of a collision between two 128-bit hash
      values is negligible.



   .. py:property:: inferred_type
      :type: str


      Return a string of the type inferred from the values.


   .. py:method:: info() -> str

      Return a JSON formatted string containing information about all components of self.

      :returns: JSON string containing information about all components of self
      :rtype: str



   .. py:method:: is_registered() -> numpy.bool_

      Return True iff the object is contained in the registry.

      :returns: Indicates if the object is contained in the registry
      :rtype: bool

      :raises RuntimeError: Raised if there's a server-side error thrown



   .. py:method:: isalnum() -> arkouda.numpy.pdarrayclass.pdarray

      Return a boolean pdarray where index i indicates whether string i of the
      Strings is alphanumeric.

      :returns: True for elements that are alphanumeric, False otherwise
      :rtype: pdarray

      :raises RuntimeError: Raised if there is a server-side error thrown

      .. seealso:: :py:obj:`Strings.islower`, :py:obj:`Strings.isupper`, :py:obj:`Strings.istitle`

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> not_alnum = ak.array([f'%Strings {i}' for i in range(3)])
      >>> alnum = ak.array([f'Strings{i}' for i in range(3)])
      >>> strings = ak.concatenate([not_alnum, alnum])
      >>> strings
      array(['%Strings 0', '%Strings 1', '%Strings 2', 'Strings0', 'Strings1', 'Strings2'])
      >>> strings.isalnum()
      array([False False False True True True])



   .. py:method:: isalpha() -> arkouda.numpy.pdarrayclass.pdarray

      Return a boolean pdarray where index i indicates whether string i of the
      Strings is alphabetic.  This means there is at least one character,
      and all the characters are alphabetic.

      :returns: True for elements that are alphabetic, False otherwise
      :rtype: pdarray

      :raises RuntimeError: Raised if there is a server-side error thrown

      .. seealso:: :py:obj:`Strings.islower`, :py:obj:`Strings.isupper`, :py:obj:`Strings.istitle`, :py:obj:`Strings.isalnum`

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> not_alpha = ak.array([f'%Strings {i}' for i in range(3)])
      >>> alpha = ak.array(['StringA','StringB','StringC'])
      >>> strings = ak.concatenate([not_alpha, alpha])
      >>> strings
      array(['%Strings 0', '%Strings 1', '%Strings 2', 'StringA', 'StringB', 'StringC'])
      >>> strings.isalpha()
      array([False False False True True True])



   .. py:method:: isdecimal() -> arkouda.numpy.pdarrayclass.pdarray

      Return a boolean pdarray where index i indicates whether string i of the
      Strings has all decimal characters.

      :returns: True for elements that are decimals, False otherwise
      :rtype: pdarray

      :raises RuntimeError: Raised if there is a server-side error thrown

      .. seealso:: :py:obj:`Strings.isdigit`

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> not_decimal = ak.array([f'Strings {i}' for i in range(3)])
      >>> decimal = ak.array([f'12{i}' for i in range(3)])
      >>> strings = ak.concatenate([not_decimal, decimal])
      >>> strings
      array(['Strings 0', 'Strings 1', 'Strings 2', '120', '121', '122'])
      >>> strings.isdecimal()
      array([False False False True True True])

      Special Character Examples

      >>> special_strings = ak.array(["3.14", "0", "²", "2³₇", "2³x₇"])
      >>> special_strings
      array(['3.14', '0', '²', '2³₇', '2³x₇'])
      >>> special_strings.isdecimal()
      array([False True False False False])



   .. py:method:: isdigit() -> arkouda.numpy.pdarrayclass.pdarray

      Return a boolean pdarray where index i indicates whether string i of the
      Strings has all digit characters.

      :returns: True for elements that are digits, False otherwise
      :rtype: pdarray

      :raises RuntimeError: Raised if there is a server-side error thrown

      .. seealso:: :py:obj:`Strings.islower`, :py:obj:`Strings.isupper`, :py:obj:`Strings.istitle`

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> not_digit = ak.array([f'Strings {i}' for i in range(3)])
      >>> digit = ak.array([f'12{i}' for i in range(3)])
      >>> strings = ak.concatenate([not_digit, digit])
      >>> strings
      array(['Strings 0', 'Strings 1', 'Strings 2', '120', '121', '122'])
      >>> strings.isdigit()
      array([False False False True True True])

      Special Character Examples

      >>> special_strings = ak.array(["3.14", "0", "²", "2³₇", "2³x₇"])
      >>> special_strings
      array(['3.14', '0', '²', '2³₇', '2³x₇'])
      >>> special_strings.isdigit()
      array([False True True True False])



   .. py:method:: isempty() -> arkouda.numpy.pdarrayclass.pdarray

      Return a boolean pdarray where index i indicates whether string i of the
      Strings is empty.


      True for elements that are the empty string, False otherwise

      :returns: True for elements that are digits, False otherwise
      :rtype: pdarray

      :raises RuntimeError: Raised if there is a server-side error thrown

      .. seealso:: :py:obj:`Strings.islower`, :py:obj:`Strings.isupper`, :py:obj:`Strings.istitle`

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> not_empty = ak.array([f'Strings {i}' for i in range(3)])
      >>> empty = ak.array(['' for i in range(3)])
      >>> strings = ak.concatenate([not_empty, empty])
      >>> strings
      array(['Strings 0', 'Strings 1', 'Strings 2', '', '', ''])
      >>> strings.isempty()
      array([False False False True True True])



   .. py:method:: islower() -> arkouda.numpy.pdarrayclass.pdarray

      Return a boolean pdarray where index i indicates whether string i of the
      Strings is entirely lowercase.

      :returns: True for elements that are entirely lowercase, False otherwise
      :rtype: pdarray

      :raises RuntimeError: Raised if there is a server-side error thrown

      .. seealso:: :py:obj:`Strings.isupper`

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> lower = ak.array([f'strings {i}' for i in range(3)])
      >>> upper = ak.array([f'STRINGS {i}' for i in range(3)])
      >>> strings = ak.concatenate([lower, upper])
      >>> strings
      array(['strings 0', 'strings 1', 'strings 2', 'STRINGS 0', 'STRINGS 1', 'STRINGS 2'])
      >>> strings.islower()
      array([True True True False False False])



   .. py:method:: isnumeric() -> arkouda.numpy.pdarrayclass.pdarray

      Return a boolean pdarray where index i indicates whether string i of the
      Strings has all numeric characters. There are 1922 unicode characters that
      qualify as numeric, including the digits 0 through 9, superscripts and
      subscripted digits, special characters with the digits encircled or
      enclosed in parens, "vulgar fractions," and more.

      :returns: True for elements that are numerics, False otherwise
      :rtype: pdarray

      :raises RuntimeError: Raised if there is a server-side error thrown

      .. seealso:: :py:obj:`Strings.isdecimal`

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> not_numeric = ak.array([f'Strings {i}' for i in range(3)])
      >>> numeric = ak.array([f'12{i}' for i in range(3)])
      >>> strings = ak.concatenate([not_numeric, numeric])
      >>> strings
      array(['Strings 0', 'Strings 1', 'Strings 2', '120', '121', '122'])
      >>> strings.isnumeric()
      array([False False False True True True])

      Special Character Examples

      >>> special_strings = ak.array(["3.14", "0", "²", "2³₇", "2³x₇"])
      >>> special_strings
      array(['3.14', '0', '²', '2³₇', '2³x₇'])
      >>> special_strings.isnumeric()
      array([False True True True False])



   .. py:method:: isspace() -> arkouda.numpy.pdarrayclass.pdarray

              Return a boolean pdarray where index i indicates whether string i has all
              whitespace characters (‘ ’, ‘   ’, ‘
      ’, ‘
      ’, ‘
      ’, ‘
      ’).

              Returns
              -------
              pdarray
                  True for elements that are whitespace, False otherwise

              Raises
              ------
              RuntimeError
                  Raised if there is a server-side error thrown

              See Also
              --------
              Strings.islower
              Strings.isupper
              Strings.istitle

              Examples
              --------
              >>> import arkouda as ak
              >>> not_space = ak.array([f'Strings {i}' for i in range(3)])
              >>> space = ak.array([' ', '\t', '\n', '\v', '\f', '\r', ' \t\n\v\f\r'])
              >>> strings = ak.concatenate([not_space, space])
              >>> strings
              array(['Strings 0', 'Strings 1', 'Strings 2', ' ', 'u0009', 'n', 'u000B', 'u000C', 'u000D', ' u0009nu000Bu000Cu000D'])
              >>> strings.isspace()
              array([False False False True True True True True True True])





   .. py:method:: istitle() -> arkouda.numpy.pdarrayclass.pdarray

      Return a boolean pdarray where index i indicates whether string i of the
      Strings is titlecase.

      :returns: True for elements that are titlecase, False otherwise
      :rtype: pdarray

      :raises RuntimeError: Raised if there is a server-side error thrown

      .. seealso:: :py:obj:`Strings.islower`, :py:obj:`Strings.isupper`

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> mixed = ak.array([f'sTrINgs {i}' for i in range(3)])
      >>> title = ak.array([f'Strings {i}' for i in range(3)])
      >>> strings = ak.concatenate([mixed, title])
      >>> strings
      array(['sTrINgs 0', 'sTrINgs 1', 'sTrINgs 2', 'Strings 0', 'Strings 1', 'Strings 2'])
      >>> strings.istitle()
      array([False False False True True True])



   .. py:method:: isupper() -> arkouda.numpy.pdarrayclass.pdarray

      Return a boolean pdarray where index i indicates whether string i of the
      Strings is entirely uppercase.

      :returns: True for elements that are entirely uppercase, False otherwise
      :rtype: pdarray

      :raises RuntimeError: Raised if there is a server-side error thrown

      .. seealso:: :py:obj:`Strings.islower`

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> lower = ak.array([f'strings {i}' for i in range(3)])
      >>> upper = ak.array([f'STRINGS {i}' for i in range(3)])
      >>> strings = ak.concatenate([lower, upper])
      >>> strings
      array(['strings 0', 'strings 1', 'strings 2', 'STRINGS 0', 'STRINGS 1', 'STRINGS 2'])
      >>> strings.isupper()
      array([False False False True True True])



   .. py:attribute:: logger
      :type:  arkouda.logger.ArkoudaLogger


   .. py:method:: lower() -> Strings

      Return a new Strings with all uppercase characters from the original replaced with
      their lowercase equivalent.

      :returns: Strings with all uppercase characters from the original replaced with
                their lowercase equivalent
      :rtype: Strings

      :raises RuntimeError: Raised if there is a server-side error thrown

      .. seealso:: :py:obj:`Strings.upper`

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> strings = ak.array([f'StrINgS {i}' for i in range(5)])
      >>> strings
      array(['StrINgS 0', 'StrINgS 1', 'StrINgS 2', 'StrINgS 3', 'StrINgS 4'])
      >>> strings.lower()
      array(['strings 0', 'strings 1', 'strings 2', 'strings 3', 'strings 4'])



   .. py:method:: lstick(other: Strings, delimiter: Union[bytes, arkouda.numpy.dtypes.str_scalars] = '') -> Strings

      Join the strings from another array onto the left of the strings
      of this array, optionally inserting a delimiter.
      *Warning*: This function is experimental and not guaranteed to work.

      :param other: The strings to join onto self's strings
      :type other: Strings
      :param delimiter: String inserted between self and other
      :type delimiter: bytes or str_scalars, default=""

      :returns: The array of joined strings, as other + self
      :rtype: Strings

      :raises TypeError: Raised if the delimiter parameter is neither bytes nor a str
          or if the other parameter is not a Strings instance
      :raises RuntimeError: Raised if there is a server-side error thrown

      .. seealso:: :py:obj:`stick`, :py:obj:`peel`, :py:obj:`rpeel`

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> s = ak.array(['a', 'c', 'e'])
      >>> t = ak.array(['b', 'd', 'f'])
      >>> s.lstick(t, delimiter='.')
      array(['b.a', 'd.c', 'f.e'])



   .. py:method:: match(pattern: Union[bytes, arkouda.numpy.dtypes.str_scalars]) -> arkouda.pandas.match.Match

      Return a match object where elements match only if the beginning of the string matches the
      regular expression pattern.

      :param pattern: Regex used to find matches
      :type pattern: bytes or str_scalars

      :returns: Match object where elements match only if the beginning of the string matches the
                regular expression pattern
      :rtype: Match

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> strings = ak.array(['1_2___', '____', '3', '__4___5____6___7', ''])
      >>> strings.match('_+')
      <ak.Match object: matched=False; matched=True, span=(0, 4); matched=False;
      matched=True, span=(0, 2); matched=False>



   .. py:attribute:: nbytes
      :type:  arkouda.numpy.dtypes.int_scalars


   .. py:attribute:: ndim
      :type:  arkouda.numpy.dtypes.int_scalars


   .. py:attribute:: objType
      :value: 'Strings'



   .. py:method:: peel(delimiter: Union[bytes, arkouda.numpy.dtypes.str_scalars], times: arkouda.numpy.dtypes.int_scalars = 1, includeDelimiter: bool = False, keepPartial: bool = False, fromRight: bool = False, regex: bool = False) -> Tuple[Strings, Strings]

      Peel off one or more delimited fields from each string (similar
      to string.partition), returning two new arrays of strings.
      *Warning*: This function is experimental and not guaranteed to work.

      :param delimiter: The separator where the split will occur
      :type delimiter: bytes or str_scalars
      :param times: The number of times the delimiter is sought, i.e. skip over
                    the first (times-1) delimiters
      :type times: int_scalars, default=1
      :param includeDelimiter: If true, append the delimiter to the end of the first return
                               array. By default, it is prepended to the beginning of the
                               second return array.
      :type includeDelimiter: bool, default=False
      :param keepPartial: If true, a string that does not contain <times> instances of
                          the delimiter will be returned in the first array. By default,
                          such strings are returned in the second array.
      :type keepPartial: bool, default=False
      :param fromRight: If true, peel from the right instead of the left (see also rpeel)
      :type fromRight: bool, default=False
      :param regex: Indicates whether delimiter is a regular expression
                    Note: only handles regular expressions supported by re2
                    (does not support lookaheads/lookbehinds)
      :type regex: bool, default=False

      :returns:

                left: Strings
                    The field(s) peeled from the end of each string (unless
                    fromRight is true)
                right: Strings
                    The remainder of each string after peeling (unless fromRight
                    is true)
      :rtype: Tuple[Strings, Strings]

      :raises TypeError: Raised if the delimiter parameter is not byte or str_scalars, if
          times is not int64, or if includeDelimiter, keepPartial, or
          fromRight is not bool
      :raises ValueError: Raised if times is < 1 or if delimiter is not a valid regex
      :raises RuntimeError: Raised if there is a server-side error thrown

      .. seealso:: :py:obj:`rpeel`, :py:obj:`stick`, :py:obj:`lstick`

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> s = ak.array(['a.b', 'c.d', 'e.f.g'])
      >>> s.peel('.')
      (array(['a', 'c', 'e']), array(['b', 'd', 'f.g']))
      >>> s.peel('.', includeDelimiter=True)
      (array(['a.', 'c.', 'e.']), array(['b', 'd', 'f.g']))
      >>> s.peel('.', times=2)
      (array(['', '', 'e.f']), array(['a.b', 'c.d', 'g']))
      >>> s.peel('.', times=2, keepPartial=True)
      (array(['a.b', 'c.d', 'e.f']), array(['', '', 'g']))



   .. py:method:: pretty_print_info() -> None

      Print information about all components of self in a human readable format.



   .. py:method:: purge_cached_regex_patterns() -> None

      Purges cached regex patterns.



   .. py:method:: regex_split(pattern: Union[bytes, arkouda.numpy.dtypes.str_scalars], maxsplit: int = 0, return_segments: bool = False) -> Union[Strings, Tuple]

      Return a new Strings split by the occurrences of pattern.

      If maxsplit is nonzero, at most maxsplit splits occur.

      :param pattern: Regex used to split strings into substrings
      :type pattern: bytes or str_scalars
      :param maxsplit: The max number of pattern match occurences in each element to split.
                       The default maxsplit=0 splits on all occurences
      :type maxsplit: int, default=0
      :param return_segments: If True, return mapping of original strings to first substring
                              in return array.
      :type return_segments: bool, default=False

      :returns:

                Strings
                    Substrings with pattern matches removed
                pdarray, int64 (optional)
                    For each original string, the index of first corresponding substring
                    in the return array
      :rtype: Union[Strings, Tuple]

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> strings = ak.array(['1_2___', '____', '3', '__4___5____6___7', ''])
      >>> strings.regex_split('_+', maxsplit=2, return_segments=True)
      (array(['1', '2', '', '', '', '3', '', '4', '5____6___7', '']), array([0 3 5 6 9]))



   .. py:method:: register(user_defined_name: str) -> Strings

      Register this Strings object with a user defined name in the arkouda server
      so it can be attached to later using Strings.attach().

      This is an in-place operation, registering a Strings object more than once will
      update the name in the registry and remove the previously registered name.
      A name can only be registered to one object at a time.

      :param user_defined_name: user defined name which the Strings object is to be registered under
      :type user_defined_name: str

      :returns: The same Strings object which is now registered with the arkouda server and
                has an updated name.
                This is an in-place modification, the original is returned to support a
                fluid programming style.
                Please note you cannot register two different objects with the same name.
      :rtype: Strings

      :raises TypeError: Raised if user_defined_name is not a str
      :raises RegistrationError: If the server was unable to register the Strings object with the user_defined_name
          If the user is attempting to register more than one object with the same name,
          the former should be unregistered first to free up the registration name.

      .. seealso:: :py:obj:`attach`, :py:obj:`unregister`

      .. rubric:: Notes

      Registered names/Strings objects in the server are immune to deletion
      until they are unregistered.



   .. py:attribute:: registered_name
      :type:  Optional[str]
      :value: None



   .. py:method:: rpeel(delimiter: Union[bytes, arkouda.numpy.dtypes.str_scalars], times: arkouda.numpy.dtypes.int_scalars = 1, includeDelimiter: bool = False, keepPartial: bool = False, regex: bool = False) -> Tuple[Strings, Strings]

      Peel off one or more delimited fields from the end of each string
      (similar to string.rpartition), returning two new arrays of strings.
      *Warning*: This function is experimental and not guaranteed to work.

      :param delimiter: The separator where the split will occur
      :type delimiter: bytes or str_scalars
      :param times: The number of times the delimiter is sought, i.e. skip over
                    the last (times-1) delimiters
      :type times: int_scalars, default=1
      :param includeDelimiter: If true, prepend the delimiter to the start of the first return
                               array. By default, it is appended to the end of the
                               second return array.
      :type includeDelimiter: bool, default=False
      :param keepPartial: If true, a string that does not contain <times> instances of
                          the delimiter will be returned in the second array. By default,
                          such strings are returned in the first array.
      :type keepPartial: bool, default=False
      :param regex: Indicates whether delimiter is a regular expression
                    Note: only handles regular expressions supported by re2
                    (does not support lookaheads/lookbehinds)
      :type regex: bool, default=False

      :returns:

                left: Strings
                    The remainder of the string after peeling
                right: Strings
                    The field(s) that were peeled from the right of each string
      :rtype: Tuple[Strings, Strings]

      :raises TypeError: Raised if the delimiter parameter is not bytes or str_scalars or
          if times is not int64
      :raises ValueError: Raised if times is < 1 or if delimiter is not a valid regex
      :raises RuntimeError: Raised if there is a server-side error thrown

      .. seealso:: :py:obj:`peel`, :py:obj:`stick`, :py:obj:`lstick`

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> s = ak.array(['a.b', 'c.d', 'e.f.g'])
      >>> s.rpeel('.')
      (array(['a', 'c', 'e.f']), array(['b', 'd', 'g']))

      Compared against peel

      >>> s.peel('.')
      (array(['a', 'c', 'e']), array(['b', 'd', 'f.g']))



   .. py:method:: search(pattern: Union[bytes, arkouda.numpy.dtypes.str_scalars]) -> arkouda.pandas.match.Match

      Return a match object with the first location in each element where pattern produces a match.
      Elements match if any part of the string matches the regular expression pattern.

      :param pattern: Regex used to find matches
      :type pattern: bytes or str_scalars

      :returns: Match object where elements match if any part of the string matches the
                regular expression pattern
      :rtype: Match

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> strings = ak.array(['1_2___', '____', '3', '__4___5____6___7', ''])
      >>> strings.search('_+')
      <ak.Match object: matched=True, span=(1, 2); matched=True, span=(0, 4);
      matched=False; matched=True, span=(0, 2); matched=False>



   .. py:attribute:: shape
      :type:  Tuple[int]


   .. py:attribute:: size
      :type:  arkouda.numpy.dtypes.int_scalars


   .. py:method:: split(delimiter: str, return_segments: bool = False, regex: bool = False) -> Union[Strings, Tuple]

      Unpack delimiter-joined substrings into a flat array.

      :param delimiter: Characters used to split strings into substrings
      :type delimiter: str
      :param return_segments: If True, also return mapping of original strings to first substring
                              in return array.
      :type return_segments: bool, default=False
      :param regex: Indicates whether delimiter is a regular expression
                    Note: only handles regular expressions supported by re2
                    (does not support lookaheads/lookbehinds)
      :type regex: bool, default=False

      :returns:

                Strings
                    Flattened substrings with delimiters removed
                pdarray, int64 (optional)
                    For each original string, the index of first corresponding substring
                    in the return array
      :rtype: Union[Strings, Tuple]

      .. seealso:: :py:obj:`peel`, :py:obj:`rpeel`

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> orig = ak.array(['one|two', 'three|four|five', 'six'])
      >>> orig.split('|')
      array(['one', 'two', 'three', 'four', 'five', 'six'])
      >>> flat, mapping = orig.split('|', return_segments=True)
      >>> mapping
      array([0 2 5])
      >>> under = ak.array(['one_two', 'three_____four____five', 'six'])
      >>> under_split, under_map = under.split('_+', return_segments=True, regex=True)
      >>> under_split
      array(['one', 'two', 'three', 'four', 'five', 'six'])
      >>> under_map
      array([0 2 5])



   .. py:method:: startswith(substr: Union[bytes, arkouda.numpy.dtypes.str_scalars], regex: bool = False) -> arkouda.numpy.pdarrayclass.pdarray

      Check whether each element starts with the given substring.

      :param substr: The prefix to search for
      :type substr: bytes or str_scalars
      :param regex: Indicates whether substr is a regular expression
                    Note: only handles regular expressions supported by re2
                    (does not support lookaheads/lookbehinds)
      :type regex: bool, default=False

      :returns: True for elements that start with substr, False otherwise
      :rtype: pdarray

      :raises TypeError: Raised if the substr parameter is not a bytes ior str_scalars
      :raises ValueError: Rasied if substr is not a valid regex
      :raises RuntimeError: Raised if there is a server-side error thrown

      .. seealso:: :py:obj:`Strings.contains`, :py:obj:`Strings.endswith`

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> strings_end = ak.array([f'string {i}' for i in range(1, 6)])
      >>> strings_end
      array(['string 1', 'string 2', 'string 3', 'string 4', 'string 5'])
      >>> strings_end.startswith('string')
      array([True True True True True])
      >>> strings_start = ak.array([f'{i} string' for i in range(1,6)])
      >>> strings_start
      array(['1 string', '2 string', '3 string', '4 string', '5 string'])
      >>> strings_start.startswith('\\d str', regex = True)
      array([True True True True True])



   .. py:method:: stick(other: Strings, delimiter: Union[bytes, arkouda.numpy.dtypes.str_scalars] = '', toLeft: bool = False) -> Strings

      Join the strings from another array onto one end of the strings
      of this array, optionally inserting a delimiter.
      *Warning*: This function is experimental and not guaranteed to work.

      :param other: The strings to join onto self's strings
      :type other: Strings
      :param delimiter: String inserted between self and other
      :type delimiter: bytes or str_scalars, default=""
      :param toLeft: If true, join other strings to the left of self. By default,
                     other is joined to the right of self.
      :type toLeft: bool, default=False

      :returns: The array of joined strings
      :rtype: Strings

      :raises TypeError: Raised if the delimiter parameter is not bytes or str_scalars
          or if the other parameter is not a Strings instance
      :raises ValueError: Raised if times is < 1
      :raises RuntimeError: Raised if there is a server-side error thrown

      .. seealso:: :py:obj:`lstick`, :py:obj:`peel`, :py:obj:`rpeel`

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> s = ak.array(['a', 'c', 'e'])
      >>> t = ak.array(['b', 'd', 'f'])
      >>> s.stick(t, delimiter='.')
      array(['a.b', 'c.d', 'e.f'])



   .. py:method:: strip(chars: Optional[Union[bytes, arkouda.numpy.dtypes.str_scalars]] = '') -> Strings

      Return a new Strings object with all leading and trailing occurrences of characters contained
      in chars removed. The chars argument is a string specifying the set of characters to be removed.
      If omitted, the chars argument defaults to removing whitespace. The chars argument is not a
      prefix or suffix; rather, all combinations of its values are stripped.

      :param chars: the set of characters to be removed
      :type chars: bytes or str_scalars, optional

      :returns: Strings object with the leading and trailing characters matching the set of characters in
                the chars argument removed
      :rtype: Strings

      :raises RuntimeError: Raised if there is a server-side error thrown

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> strings = ak.array(['Strings ', '  StringS  ', 'StringS   '])
      >>> s = strings.strip()
      >>> s
      array(['Strings', 'StringS', 'StringS'])

      >>> strings = ak.array(['Strings 1', '1 StringS  ', '  1StringS  12 '])
      >>> s = strings.strip(' 12')
      >>> s
      array(['Strings', 'StringS', 'StringS'])



   .. py:method:: sub(pattern: Union[bytes, arkouda.numpy.dtypes.str_scalars], repl: Union[bytes, arkouda.numpy.dtypes.str_scalars], count: int = 0) -> Strings

      Return new Strings obtained by replacing non-overlapping occurrences of pattern with the
      replacement repl.

      If count is nonzero, at most count substitutions occur.

      :param pattern: The regex to substitue
      :type pattern: bytes or str_scalars
      :param repl: The substring to replace pattern matches with
      :type repl: bytes or str_scalars
      :param count: The max number of pattern match occurences in each element to replace.
                    The default count=0 replaces all occurences of pattern with repl
      :type count: int, default=0

      :returns: Strings with pattern matches replaced
      :rtype: Strings

      :raises TypeError: Raised if pattern or repl are not bytes or str_scalars
      :raises ValueError: Raised if pattern is not a valid regex
      :raises RuntimeError: Raised if there is a server-side error thrown

      .. seealso:: :py:obj:`Strings.subn`

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> strings = ak.array(['1_2___', '____', '3', '__4___5____6___7', ''])
      >>> strings.sub(pattern='_+', repl='-', count=2)
      array(['1-2-', '-', '3', '-4-5____6___7', ''])



   .. py:method:: subn(pattern: Union[bytes, arkouda.numpy.dtypes.str_scalars], repl: Union[bytes, arkouda.numpy.dtypes.str_scalars], count: int = 0) -> Tuple[Strings, arkouda.numpy.pdarrayclass.pdarray]

      Perform the same operation as sub(), but return a tuple (new_Strings, number_of_substitions).

      :param pattern: The regex to substitue
      :type pattern: bytes or str_scalars
      :param repl: The substring to replace pattern matches with
      :type repl: bytes or str_scalars
      :param count: The max number of pattern match occurences in each element to replace.
                    The default count=0 replaces all occurences of pattern with repl
      :type count: int, default=0

      :returns:

                Strings
                    Strings with pattern matches replaced
                pdarray, int64
                    The number of substitutions made for each element of Strings
      :rtype: Tuple[Strings, pdarray]

      :raises TypeError: Raised if pattern or repl are not bytes or str_scalars
      :raises ValueError: Raised if pattern is not a valid regex
      :raises RuntimeError: Raised if there is a server-side error thrown

      .. seealso:: :py:obj:`Strings.sub`

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> strings = ak.array(['1_2___', '____', '3', '__4___5____6___7', ''])
      >>> strings.subn(pattern='_+', repl='-', count=2)
      (array(['1-2-', '-', '3', '-4-5____6___7', '']), array([2 1 0 2 0]))



   .. py:method:: take(indices: Union[arkouda.numpy.dtypes.numeric_scalars, arkouda.numpy.pdarrayclass.pdarray], axis: Optional[int] = None) -> arkouda.numpy.pdarrayclass.pdarray

      Take elements from the array along an axis.

      When axis is not None, this function does the same thing as “fancy” indexing (indexing arrays
      using arrays); however, it can be easier to use if you need elements along a given axis.
      A call such as ``np.take(arr, indices, axis=3)`` is equivalent to ``arr[:,:,:,indices,...]``.

      :param indices: The indices of the values to extract. Also allow scalars for indices.
      :type indices: numeric_scalars or pdarray
      :param axis: The axis over which to select values. By default, the flattened input array is used.
      :type axis: int, optional

      :returns: The returned array has the same type as `a`.
      :rtype: pdarray

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> a = ak.array(["a","b","c"])
      >>> indices = [0, 1]
      >>> a.take(indices)
      array(['a', 'b'])



   .. py:method:: title() -> Strings

      Return a new Strings from the original replaced with their titlecase equivalent.

      :returns: Strings from the original replaced with their titlecase equivalent.
      :rtype: Strings

      :raises RuntimeError: Raised if there is a server-side error thrown.

      .. seealso:: :py:obj:`Strings.lower`, :py:obj:`String.upper`

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> strings = ak.array([f'StrINgS {i}' for i in range(5)])
      >>> strings
      array(['StrINgS 0', 'StrINgS 1', 'StrINgS 2', 'StrINgS 3', 'StrINgS 4'])
      >>> strings.title()
      array(['Strings 0', 'Strings 1', 'Strings 2', 'Strings 3', 'Strings 4'])



   .. py:method:: to_csv(prefix_path: str, dataset: str = 'strings_array', col_delim: str = ',', overwrite: bool = False) -> str

      Write Strings to CSV file(s). File will contain a single column with the Strings data.
      All CSV Files written by Arkouda include a header denoting data types of the columns.
      Unlike other file formats, CSV files store Strings as their UTF-8 format instead of storing
      bytes as uint(8).

      :param prefix_path: The filename prefix to be used for saving files. Files will have _LOCALE#### appended
                          when they are written to disk.
      :type prefix_path: str
      :param dataset: Column name to save the Strings under. Defaults to "strings_array".
      :type dataset: str, default="strings_array"
      :param col_delim: Defaults to ",". Value to be used to separate columns within the file.
                        Please be sure that the value used DOES NOT appear in your dataset.
      :type col_delim: str, default=","
      :param overwrite: Defaults to False. If True, any existing files matching your provided prefix_path will
                        be overwritten. If False, an error will be returned if existing files are found.
      :type overwrite: bool, default=False

      :returns: response message
      :rtype: str

      :raises ValueError: Raised if all datasets are not present in all parquet files or if one or
          more of the specified files do not exist
      :raises RuntimeError: Raised if one or more of the specified files cannot be opened.
          If `allow_errors` is true this may be raised if no values are returned
          from the server.
      :raises TypeError: Raised if we receive an unknown arkouda_type returned from the server

      .. rubric:: Notes

      - CSV format is not currently supported by load/load_all operations
      - The column delimiter is expected to be the same for column names and data
      - Be sure that column delimiters are not found within your data.
      - All CSV files must delimit rows using newline (``\\n``) at this time.



   .. py:method:: to_hdf(prefix_path: str, dataset: str = 'strings_array', mode: Literal['truncate', 'append'] = 'truncate', save_offsets: bool = True, file_type: Literal['single', 'distribute'] = 'distribute') -> str

      Save the Strings object to HDF5.
      The object can be saved to a collection of files or single file.

      :param prefix_path: Directory and filename prefix that all output files share
      :type prefix_path: str
      :param dataset: The name of the Strings dataset to be written, defaults to strings_array
      :type dataset: str, default="strings_array"
      :param mode: By default, truncate (overwrite) output files, if they exist.
                   If 'append', create a new Strings dataset within existing files.
      :type mode: {"truncate", "append"}, default = "truncate"
      :param save_offsets: Defaults to True which will instruct the server to save the offsets array to HDF5
                           If False the offsets array will not be save and will be derived from the string values
                           upon load/read.
      :type save_offsets: bool, default=True
      :param file_type: Default: Distribute
                        Distribute the dataset over a file per locale.
                        Single file will save the dataset to one file
      :type file_type: {"single", "distribute"}, default = "distribute"

      :returns: String message indicating result of save operation
      :rtype: str

      :raises RuntimeError: Raised if a server-side error is thrown saving the pdarray

      .. rubric:: Notes

      - Parquet files do not store the segments, only the values.
      - Strings state is saved as two datasets within an hdf5 group:
        one for the string characters and one for the
        segments corresponding to the start of each string
      - the hdf5 group is named via the dataset parameter.
      - The prefix_path must be visible to the arkouda server and the user must
        have write permission.
      - Output files have names of the form ``<prefix_path>_LOCALE<i>``, where ``<i>``
        ranges from 0 to ``numLocales`` for `file_type='distribute'`. Otherwise,
        the file name will be `prefix_path`.
      - If any of the output files already exist and
        the mode is 'truncate', they will be overwritten. If the mode is 'append'
        and the number of output files is less than the number of locales or a
        dataset with the same name already exists, a ``RuntimeError`` will result.
      - Any file extension can be used.The file I/O does not rely on the extension to
        determine the file format.

      .. seealso:: :py:obj:`to_hdf`



   .. py:method:: to_ndarray() -> numpy.ndarray

      Convert the array to a np.ndarray, transferring array data from the
      arkouda server to Python. If the array exceeds a built-in size limit,
      a RuntimeError is raised.

      :returns: A numpy ndarray with the same strings as this array
      :rtype: np.ndarray

      .. rubric:: Notes

      The number of bytes in the array cannot exceed ``ak.client.maxTransferBytes``,
      otherwise a ``RuntimeError`` will be raised. This is to protect the user
      from overflowing the memory of the system on which the Python client
      is running, under the assumption that the server is running on a
      distributed system with much more memory than the client. The user
      may override this limit by setting ak.client.maxTransferBytes to a larger
      value, but proceed with caution.

      .. seealso:: :py:obj:`array`, :py:obj:`tolist`

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> a = ak.array(["hello", "my", "world"])
      >>> a.to_ndarray()
      array(['hello', 'my', 'world'], dtype='<U5')
      >>> type(a.to_ndarray())
      <class 'numpy.ndarray'>



   .. py:method:: to_parquet(prefix_path: str, dataset: str = 'strings_array', mode: Literal['truncate', 'append'] = 'truncate', compression: Optional[Literal['snappy', 'gzip', 'brotli', 'zstd', 'lz4']] = None) -> str

      Save the Strings object to Parquet. The result is a collection of files,
      one file per locale of the arkouda server, where each filename starts
      with prefix_path. Each locale saves its chunk of the array to its
      corresponding file.

      :param prefix_path: Directory and filename prefix that all output files share
      :type prefix_path: str
      :param dataset: Name of the dataset to create in files (must not already exist)
      :type dataset: str, default="strings_array"
      :param mode: By default, truncate (overwrite) output files, if they exist.
                   If 'append', attempt to create new dataset in existing files.
      :type mode: {"truncate", "append"}, default = "truncate"
      :param compression: Sets the compression type used with Parquet files
      :type compression: {"snappy", "gzip", "brotli", "zstd", "lz4"}, optional

      :returns: string message indicating result of save operation
      :rtype: str

      :raises RuntimeError: Raised if a server-side error is thrown saving the pdarray

      .. rubric:: Notes

      - The prefix_path must be visible to the arkouda server and the user must
      have write permission.
      - Output files have names of the form ``<prefix_path>_LOCALE<i>``, where ``<i>``
      ranges from 0 to ``numLocales`` for `file_type='distribute'`.
      - 'append' write mode is supported, but is not efficient.
      - If any of the output files already exist and
      the mode is 'truncate', they will be overwritten. If the mode is 'append'
      and the number of output files is less than the number of locales or a
      dataset with the same name already exists, a ``RuntimeError`` will result.
      - Any file extension can be used.The file I/O does not rely on the extension to
      determine the file format.



   .. py:method:: tolist() -> List[str]

      Convert the SegString to a list, transferring data from the
      arkouda server to Python. If the SegString exceeds a built-in size limit,
      a RuntimeError is raised.

      :returns: A list with the same strings as this SegString
      :rtype: List[str]

      .. rubric:: Notes

      The number of bytes in the array cannot exceed ``ak.client.maxTransferBytes``,
      otherwise a ``RuntimeError`` will be raised. This is to protect the user
      from overflowing the memory of the system on which the Python client
      is running, under the assumption that the server is running on a
      distributed system with much more memory than the client. The user
      may override this limit by setting ak.client.maxTransferBytes to a larger
      value, but proceed with caution.

      .. seealso:: :py:obj:`to_ndarray`

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> a = ak.array(["hello", "my", "world"])
      >>> a.tolist()
      ['hello', 'my', 'world']
      >>> type(a.tolist())
      <class 'list'>



   .. py:method:: transfer(hostname: str, port: arkouda.numpy.dtypes.int_scalars) -> Union[str, memoryview]

      Send a Strings object to a different Arkouda server.

      :param hostname: The hostname where the Arkouda server intended to
                       receive the Strings object is running.
      :type hostname: str
      :param port: The port to send the array over. This needs to be an
                   open port (i.e., not one that the Arkouda server is
                   running on). This will open up `numLocales` ports,
                   each of which in succession, so will use ports of the
                   range {port..(port+numLocales)} (e.g., running an
                   Arkouda server of 4 nodes, port 1234 is passed as
                   `port`, Arkouda will use ports 1234, 1235, 1236,
                   and 1237 to send the array data).
                   This port much match the port passed to the call to
                   `ak.receive_array()`.
      :type port: int_scalars

      :returns: A message indicating a complete transfer
      :rtype: str

      :raises ValueError: Raised if the op is not within the pdarray.BinOps set
      :raises TypeError: Raised if other is not a pdarray or the pdarray.dtype is not
          a supported dtype



   .. py:method:: unregister() -> None

      Unregister a Strings object in the arkouda server which was previously
      registered using register() and/or attached to using attach().

      :raises RuntimeError: Raised if the server could not find the internal name/symbol to remove

      .. seealso:: :py:obj:`register`, :py:obj:`attach`

      .. rubric:: Notes

      Registered names/Strings objects in the server are immune to deletion until
      they are unregistered.



   .. py:method:: update_hdf(prefix_path: str, dataset: str = 'strings_array', save_offsets: bool = True, repack: bool = True) -> str

      Overwrite the dataset with the name provided with this Strings object.

      If the dataset does not exist it is added.

      :param prefix_path: Directory and filename prefix that all output files share
      :type prefix_path: str
      :param dataset: Name of the dataset to create in files
      :type dataset: str, default="strings_array"
      :param save_offsets: Defaults to True which will instruct the server to save the offsets array to HDF5
                           If False the offsets array will not be save and will be derived from the string values
                           upon load/read.
      :type save_offsets: bool, default=True
      :param repack: Default: True
                     HDF5 does not release memory on delete. When True, the inaccessible
                     data (that was overwritten) is removed. When False, the data remains, but is
                     inaccessible. Setting to false will yield better performance, but will cause
                     file sizes to expand.
      :type repack: bool, default=True

      :returns: success message if successful
      :rtype: str

      :raises RuntimeError: Raised if a server-side error is thrown saving the Strings object

      .. rubric:: Notes

      - If file does not contain File_Format attribute to indicate how it was saved,
        the file name is checked for _LOCALE#### to determine if it is distributed.
      - If the dataset provided does not exist, it will be added



   .. py:method:: upper() -> Strings

      Return a new Strings with all lowercase characters from the original replaced with
      their uppercase equivalent.

      :returns: Strings with all lowercase characters from the original replaced with
                their uppercase equivalent
      :rtype: Strings

      :raises RuntimeError: Raised if there is a server-side error thrown

      .. seealso:: :py:obj:`Strings.lower`

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> strings = ak.array([f'StrINgS {i}' for i in range(5)])
      >>> strings
      array(['StrINgS 0', 'StrINgS 1', 'StrINgS 2', 'StrINgS 3', 'StrINgS 4'])
      >>> strings.upper()
      array(['STRINGS 0', 'STRINGS 1', 'STRINGS 2', 'STRINGS 3', 'STRINGS 4'])



.. py:class:: TimeDelta64DType

   Bases: :py:obj:`numpy.dtype`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.


.. py:class:: Timedelta(pda, unit: str = _BASE_UNIT)

   Bases: :py:obj:`_AbstractBaseTime`


   Represents a duration, the difference between two dates or times.

   Timedelta is the Arkouda equivalent of pandas.TimedeltaIndex.

   :param pda:
   :type pda: int64 pdarray, pd.TimedeltaIndex, pd.Series, or np.timedelta64 array
   :param unit: For int64 pdarray, denotes the unit of the input. Ignored for pandas
                and numpy arrays, which carry their own unit. Not case-sensitive;
                prefixes of full names (like 'sec') are accepted.

                Possible values:

                * 'weeks' or 'w'
                * 'days' or 'd'
                * 'hours' or 'h'
                * 'minutes', 'm', or 't'
                * 'seconds' or 's'
                * 'milliseconds', 'ms', or 'l'
                * 'microseconds', 'us', or 'u'
                * 'nanoseconds', 'ns', or 'n'

                Unlike in pandas, units cannot be combined or mixed with integers
   :type unit: str, default 'ns'

   .. rubric:: Notes

   The ``.values`` attribute is always in nanoseconds with int64 dtype.


   .. py:method:: abs()

      Absolute value of time interval.



   .. py:property:: components


   .. py:property:: days


   .. py:method:: is_registered() -> numpy.bool_

       Return True iff the object is contained in the registry or is a component of a
       registered object.

      :returns: Indicates if the object is contained in the registry
      :rtype: numpy.bool

      :raises RegistrationError: Raised if there's a server-side error or a mis-match of registered components

      .. seealso:: :py:obj:`register`, :py:obj:`attach`, :py:obj:`unregister`

      .. rubric:: Notes

      Objects registered with the server are immune to deletion until
      they are unregistered.



   .. py:property:: microseconds


   .. py:property:: nanoseconds


   .. py:method:: register(user_defined_name)

      Register this Timedelta object and underlying components with the Arkouda server.

      :param user_defined_name: user defined name the timedelta is to be registered under,
                                this will be the root name for underlying components
      :type user_defined_name: str

      :returns: The same Timedelta which is now registered with the arkouda server and has an updated name.
                This is an in-place modification, the original is returned to support
                a fluid programming style.
                Please note you cannot register two different Timedeltas with the same name.
      :rtype: Timedelta

      :raises TypeError: Raised if user_defined_name is not a str
      :raises RegistrationError: If the server was unable to register the timedelta with the user_defined_name

      .. seealso:: :py:obj:`unregister`, :py:obj:`attach`, :py:obj:`is_registered`

      .. rubric:: Notes

      Objects registered with the server are immune to deletion until
      they are unregistered.



   .. py:property:: seconds


   .. py:attribute:: special_objType
      :value: 'Timedelta'



   .. py:method:: std(ddof: arkouda.numpy.dtypes.int_scalars = 0, axis: Optional[Union[None, int, tuple]] = None, keepdims: Optional[bool] = False)

      Returns the standard deviation as a pd.Timedelta object, with args compatible with ak.std.



   .. py:method:: sum()

      Return sum of array elements along the given axis.

      :param axis: The axis or axes along which to do the operation
                   If None, the computation is done across the entire array.
      :type axis: int, Tuple[int, ...], optional, default = None
      :param keepdims: Whether to keep the singleton dimension(s) along `axis` in the result.
      :type keepdims: bool, optional, default = False

      :returns: numeric_scalars if axis is omitted, in which case operation is done over entire array
                pdarray if axis is supplied, in which case the operation is done along that axis
      :rtype: numeric_scalars or pdarray

      :raises TypeError: Raised if pda is not a pdarray instance
      :raises RuntimeError: Raised if there's a server-side error thrown

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> ak.sum(ak.array([1,2,3,4,5]))
      np.int64(15)
      >>> ak.sum(ak.array([5.5,4.5,3.5,2.5,1.5]))
      np.float64(17.5)
      >>> ak.array([[1,2,3],[5,4,3]]).sum(axis=1)
      array([6 12])

      .. rubric:: Notes

      Works as a method of a pdarray (e.g. a.sum()) or a standalone function (e.g. ak.sum(a))



   .. py:attribute:: supported_opeq


   .. py:attribute:: supported_with_datetime


   .. py:attribute:: supported_with_pdarray


   .. py:attribute:: supported_with_r_datetime


   .. py:attribute:: supported_with_r_pdarray


   .. py:attribute:: supported_with_r_timedelta


   .. py:attribute:: supported_with_timedelta


   .. py:method:: to_pandas()

      Convert array to a pandas TimedeltaIndex. Note: if the array size
      exceeds client.maxTransferBytes, a RuntimeError is raised.

      .. seealso:: :py:obj:`to_ndarray`



   .. py:method:: total_seconds()


   .. py:method:: unregister()

      Unregister this timedelta object in the arkouda server which was previously
      registered using register() and/or attached to using attach().

      :raises RegistrationError: If the object is already unregistered or if there is a server error
          when attempting to unregister

      .. seealso:: :py:obj:`register`, :py:obj:`attach`, :py:obj:`is_registered`

      .. rubric:: Notes

      Objects registered with the server are immune to deletion until
      they are unregistered.



.. py:class:: True_

   Bases: :py:obj:`numpy.generic`


   Boolean type (True or False), stored as a byte.

       .. warning::

          The :class:`bool` type is not a subclass of the :class:`int_` type
          (the :class:`bool` is not even a number type). This is different
          than Python's default implementation of :class:`bool` as a
          sub-class of :class:`int`.

       :Character code: ``'?'``


.. py:class:: UByteDType

   Bases: :py:obj:`numpy.dtypes._IntegerAbstractDType`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.


.. py:class:: UInt16DType

   Bases: :py:obj:`numpy.dtypes._IntegerAbstractDType`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.


.. py:class:: UInt32DType

   Bases: :py:obj:`numpy.dtypes._IntegerAbstractDType`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.


.. py:class:: UInt64DType

   Bases: :py:obj:`numpy.dtypes._IntegerAbstractDType`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.


.. py:class:: UInt8DType

   Bases: :py:obj:`numpy.dtypes._IntegerAbstractDType`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.


.. py:class:: UIntDType

   Bases: :py:obj:`numpy.dtypes._IntegerAbstractDType`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.


.. py:class:: ULongDType

   Bases: :py:obj:`numpy.dtypes._IntegerAbstractDType`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.


.. py:class:: ULongLongDType

   Bases: :py:obj:`numpy.dtypes._IntegerAbstractDType`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.


.. py:class:: UShortDType

   Bases: :py:obj:`numpy.dtypes._IntegerAbstractDType`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.


.. py:class:: VoidDType

   Bases: :py:obj:`numpy.dtype`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.


.. py:function:: abs(pda: arkouda.numpy.pdarrayclass.pdarray) -> arkouda.numpy.pdarrayclass.pdarray

   Return the element-wise absolute value of the array.

   :param pda:
   :type pda: pdarray

   :returns: A pdarray containing absolute values of the input array elements
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.abs(ak.arange(-5,-1))
   array([5 4 3 2])

   >>> ak.abs(ak.linspace(-5,-1,5))
   array([5.00000000... 4.00000000... 3.00000000...
   2.00000000... 1.00000000...])


.. py:function:: align(*args)

   Map multiple arrays of sparse identifiers to a common 0-up index.

   :param \*args: Arrays to map to dense index
   :type \*args: pdarrays or sequences of pdarrays

   :returns: **aligned** -- Arrays with values replaced by 0-up indices
   :rtype: list of pdarrays


.. py:class:: all_scalars

   Bases: :py:obj:`_NotIterable`


   Mixin to prevent iteration, without being compatible with Iterable.

   That is, we could do::

       def __iter__(self): raise TypeError()

   But this would make users of this mixin duck type-compatible with
   collections.abc.Iterable - isinstance(foo, Iterable) would be True.

   Luckily, we can instead prevent iteration by setting __iter__ to None, which
   is treated specially.


   .. py:method:: copy_with(params)


.. py:function:: append(arr: arkouda.numpy.pdarrayclass.pdarray, values: arkouda.numpy.pdarrayclass.pdarray, axis: Optional[int] = None) -> arkouda.numpy.pdarrayclass.pdarray

   Append values to the end of an array.

   :param arr: Values are appended to a copy of this array.
   :type arr: pdarray
   :param values: These values are appended to a copy of arr.
                  It must be of the correct shape (the same shape as arr, excluding axis).
                  If axis is not specified, values can be any shape and will be flattened before use.
   :type values: pdarray
   :param axis: The axis along which values are appended.
                If axis is not given, both arr and values are flattened before use.
   :type axis: Optional[int], default=None

   :returns: A copy of arr with values appended to axis.
             Note that append does not occur in-place: a new array is allocated and filled.
             If axis is None, out is a flattened array.
   :rtype: pdarray

   .. seealso:: :py:obj:`delete`

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.array([1, 2, 3])
   >>> b = ak.array([[4, 5, 6], [7, 8, 9]])
   >>> ak.append(a, b)
   array([1 2 3 4 5 6 7 8 9])
   >>> ak.append(b, b, axis = 0)
   array([array([4 5 6]) array([7 8 9]) array([4 5 6]) array([7 8 9])])


.. py:function:: apply(arr: arkouda.numpy.pdarrayclass.pdarray, func: Union[Callable, str], result_dtype: Optional[Union[numpy.dtype, str]] = None) -> arkouda.numpy.pdarrayclass.pdarray

   Apply a python function to a pdarray.

   The function should take one argument
   and return a new value. The function will then be called on each element in
   the pdarray.



   Warning: This function is experimental and may not work as expected.
   Known limitations:
   - Any python modules used inside of the function must be installed on the server.

   :param arr: The pdarray to which the function is applied
   :type arr: pdarray
   :param func: The function to apply to the array. This can be a callable function or
                a string, but either way it should take a single argument and return a
                single value. If a string, it should be a lambda function that takes a
                single argument, e.g. "lambda x,: x+1". Note the dangling comma after
                the argument, this is required for string functions.
   :type func: Union[Callable, str]
   :param result_dtype: The dtype of the resulting pdarray. If None, the dtype of the resulting
                        pdarray will be the same as the input pdarray. If a string, it should be
                        a valid numpy dtype string, e.g. "float64". If a numpy dtype, it should
                        be a valid numpy dtype object, e.g. np.float64. This is not supported
                        for functions passed as strings.
   :type result_dtype: Optional[Union[np.dtype, str]]

   :returns: The pdarray resulting from applying the function to the input array
   :rtype: pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> arr = ak.apply(ak.array([1, 2, 3]), lambda x: x+1)
   >>> arr
   array([2 3 4])

   Or,
   >>> import math
   >>> arr = ak.randint(0, 10, 4, seed=1)
   >>> def times_pi(x):
   ...        return x*math.pi
   >>> arr = ak.apply(arr, times_pi, "float64")
   >>> arr
   array([21.991148575128552 28.274333882308138 15.707963267948966 3.1415926535897931])


.. py:function:: arange(__arg1: arkouda.numpy.dtypes.int_scalars, *, dtype: Optional[Union[numpy.dtype, type, arkouda.numpy.dtypes.bigint]] = None, max_bits: Optional[int] = None) -> arkouda.numpy.pdarrayclass.pdarray
                 arange(__arg1: arkouda.numpy.dtypes.int_scalars, __arg2: arkouda.numpy.dtypes.int_scalars, *, dtype: Optional[Union[numpy.dtype, type, arkouda.numpy.dtypes.bigint]] = None, max_bits: Optional[int] = None) -> arkouda.numpy.pdarrayclass.pdarray
                 arange(__arg1: arkouda.numpy.dtypes.int_scalars, __arg2: arkouda.numpy.dtypes.int_scalars, __arg3: arkouda.numpy.dtypes.int_scalars, *, dtype: Optional[Union[numpy.dtype, type, arkouda.numpy.dtypes.bigint]] = None, max_bits: Optional[int] = None) -> arkouda.numpy.pdarrayclass.pdarray

   Create a pdarray of consecutive integers within the interval [start, stop).

   Called as: arange([start,] stop[, step,] dtype=int64).

   If only one arg is given then arg is the stop parameter. If two args are
   given, then the first arg is start and second is stop. If three args are
   given, then the first arg is start, second is stop, third is step.

   The return value is cast to type dtype

   :param start:
   :type start: int_scalars, optional
   :param stop:
   :type stop: int_scalars, optional
   :param step: if one of these three is supplied, it's used as stop, and start = 0, step = 1
                if two of them are supplied, start = start, stop = stop, step = 1
                if all three are supplied, start = start, stop = stop, step = step
   :type step: int_scalars, optional
   :param dtype: The target dtype to cast values to
   :type dtype: np.dtype, type, or str
   :param max_bits: Specifies the maximum number of bits; only used for bigint pdarrays
   :type max_bits: int

   :returns: Integers from start (inclusive) to stop (exclusive) by step
   :rtype: pdarray

   :raises ValueError: Raised if none of start, stop, step was supplied
   :raises TypeError: Raised if start, stop, or step is not an int object
   :raises ZeroDivisionError: Raised if step == 0

   .. seealso:: :py:obj:`linspace`, :py:obj:`zeros`, :py:obj:`ones`, :py:obj:`randint`

   .. rubric:: Notes

   Negative steps result in decreasing values. Currently, only int64
   pdarrays can be created with this method. For float64 arrays, use
   the linspace method.

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.arange(0, 5, 1)
   array([0 1 2 3 4])

   >>> ak.arange(5, 0, -1)
   array([5 4 3 2 1])

   >>> ak.arange(0, 10, 2)
   array([0 2 4 6 8])

   >>> ak.arange(-5, -10, -1)
   array([-5 -6 -7 -8 -9])


.. py:function:: arccos(pda: arkouda.numpy.pdarrayclass.pdarray, where: Union[bool, arkouda.numpy.pdarrayclass.pdarray] = True) -> arkouda.numpy.pdarrayclass.pdarray

   Return the element-wise inverse cosine of the array. The result is between 0 and pi.

   :param pda:
   :type pda: pdarray
   :param where: This condition is broadcast over the input. At locations where the condition is True,
                 the inverse cosine will be applied to the corresponding value. Elsewhere, it will retain
                 its original value. Default set to True.
   :type where: bool or pdarray, default=True

   :returns: A pdarray containing inverse cosine for each element
             of the original pdarray
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.linspace(-0.7,0.5,4)
   >>> ak.arccos(a)
   array([2.34619382... 1.87548898... 1.47062890... 1.04719755...])


.. py:function:: arccosh(pda: arkouda.numpy.pdarrayclass.pdarray, where: Union[bool, arkouda.numpy.pdarrayclass.pdarray] = True) -> arkouda.numpy.pdarrayclass.pdarray

   Return the element-wise inverse hyperbolic cosine of the array.

   :param pda:
   :type pda: pdarray
   :param where: This condition is broadcast over the input. At locations where the condition is True,
                 the inverse hyperbolic cosine will be applied to the corresponding value. Elsewhere, it will
                 retain its original value. Default set to True.
   :type where: bool or pdarray, default=True

   :returns: A pdarray containing inverse hyperbolic cosine for each element
             of the original pdarray
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.linspace(1,500,4)
   >>> ak.arccosh(a)
   array([0.00000000... 5.81312608... 6.50328742... 6.90775427...])


.. py:function:: arcsin(pda: arkouda.numpy.pdarrayclass.pdarray, where: Union[bool, arkouda.numpy.pdarrayclass.pdarray] = True) -> arkouda.numpy.pdarrayclass.pdarray

   Return the element-wise inverse sine of the array. The result is between -pi/2 and pi/2.

   :param pda:
   :type pda: pdarray
   :param where: This condition is broadcast over the input. At locations where the condition is True,
                 the inverse sine will be applied to the corresponding value. Elsewhere, it will retain
                 its original value. Default set to True.
   :type where: bool or pdarray, default=True

   :returns: A pdarray containing inverse sine for each element
             of the original pdarray
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.linspace(-0.7,0.5,4)
   >>> ak.arcsin(a)
   array([-0.77539749... -0.30469265... 0.10016742... 0.52359877...])


.. py:function:: arcsinh(pda: arkouda.numpy.pdarrayclass.pdarray, where: Union[bool, arkouda.numpy.pdarrayclass.pdarray] = True) -> arkouda.numpy.pdarrayclass.pdarray

   Return the element-wise inverse hyperbolic sine of the array.

   :param pda:
   :type pda: pdarray
   :param where: This condition is broadcast over the input. At locations where the condition is True,
                 the inverse hyperbolic sine will be applied to the corresponding value. Elsewhere, it will retain
                 its original value. Default set to True.
   :type where: bool or pdarray, default=True

   :returns: A pdarray containing inverse hyperbolic sine for each element
             of the original pdarray
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.linspace(-500,500,4)
   >>> ak.arcsinh(a)
   array([-6.90775627... -5.80915199... 5.80915199... 6.90775627...])


.. py:function:: arctan(pda: arkouda.numpy.pdarrayclass.pdarray, where: Union[bool, arkouda.numpy.pdarrayclass.pdarray] = True) -> arkouda.numpy.pdarrayclass.pdarray

   Return the element-wise inverse tangent of the array. The result is between -pi/2 and pi/2.

   :param pda:
   :type pda: pdarray
   :param where: This condition is broadcast over the input. At locations where the condition is True,
                 the inverse tangent will be applied to the corresponding value. Elsewhere, it will retain
                 its original value. Default set to True.
   :type where: bool or pdarray, default=True

   :returns: A pdarray containing inverse tangent for each element
             of the original pdarray
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.linspace(-10.7,10.5,4)
   >>> ak.arctan(a)
   array([-1.47760906... -1.30221689... 1.28737507... 1.47584462...])


.. py:function:: arctan2(num: Union[arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.dtypes.numeric_scalars], denom: Union[arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.dtypes.numeric_scalars], where: Union[bool, arkouda.numpy.pdarrayclass.pdarray] = True) -> arkouda.numpy.pdarrayclass.pdarray

   Return the element-wise inverse tangent of the array pair. The result chosen is the
   signed angle in radians between the ray ending at the origin and passing through the
   point (1,0), and the ray ending at the origin and passing through the point (denom, num).
   The result is between -pi and pi.

   :param num: Numerator of the arctan2 argument.
   :type num: pdarray or numeric_scalars
   :param denom: Denominator of the arctan2 argument.
   :type denom: pdarray or numeric_scalars
   :param where: This condition is broadcast over the input. At locations where the condition is True,
                 the inverse tangent will be applied to the corresponding values. Elsewhere, it will retain
                 its original value. Default set to True.
   :type where: bool or pdarray, default=True

   :returns: A pdarray containing inverse tangent for each corresponding element pair
             of the original pdarray, using the signed values or the numerator and
             denominator to get proper placement on unit circle.
   :rtype: pdarray

   :raises TypeError: | Raised if any parameter fails the typechecking
       | Raised if any element of pdarrays num and denom is not a supported type
       | Raised if both num and denom are scalars
       | Raised if where is neither boolean nor a pdarray of boolean

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> x = ak.array([1,-1,-1,1])
   >>> y = ak.array([1,1,-1,-1])
   >>> ak.arctan2(y,x)
   array([0.78539816... 2.35619449... -2.35619449... -0.78539816...])


.. py:function:: arctanh(pda: arkouda.numpy.pdarrayclass.pdarray, where: Union[bool, arkouda.numpy.pdarrayclass.pdarray] = True) -> arkouda.numpy.pdarrayclass.pdarray

   Return the element-wise inverse hyperbolic tangent of the array.

   :param pda:
   :type pda: pdarray
   :param where: This condition is broadcast over the input. At locations where the condition is True,
                 the inverse hyperbolic tangent will be applied to the corresponding value. Elsewhere,
                 it will retain its original value. Default set to True.
   :type where: bool or pdarray, default=True

   :returns: A pdarray containing inverse hyperbolic tangent for each element
             of the original pdarray
   :rtype: pdarray

   :raises TypeError: Raised if the parameters are not a pdarray or numeric scalar.

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.linspace(-.999,.999,4)
   >>> ak.arctanh(a)
   array([-3.80020116... -0.34619863... 0.34619863... 3.80020116...])


.. py:function:: argmaxk(pda: pdarray, k: arkouda.numpy.dtypes.int_scalars) -> pdarray

   Find the indices corresponding to the `k` maximum values of an array.

   Returns the largest `k` values of an array, sorted

   :param pda: Input array.
   :type pda: pdarray
   :param k: The desired count of indices corresponding to maxmum array values
   :type k: int_scalars

   :returns: The indices of the maximum `k` values from the pda, sorted
   :rtype: pdarray

   :raises TypeError: Raised if pda is not a pdarray or k is not an integer
   :raises ValueError: Raised if the pda is empty, or pda.ndim > 1, or k < 1

   .. rubric:: Notes

   This call is equivalent in value to ak.argsort(a)[k:]
   and generally outperforms this operation.

   This reduction will see a significant drop in performance as `k` grows
   beyond a certain value. This value is system dependent, but generally
   about a `k` of 5 million is where performance degradation has been observed.

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> A = ak.array([10,5,1,3,7,2,9,0])
   >>> ak.argmaxk(A, 3)
   array([4 6 0])
   >>> ak.argmaxk(A, 4)
   array([1 4 6 0])


.. py:function:: argmink(pda: pdarray, k: arkouda.numpy.dtypes.int_scalars) -> pdarray

   Finds the indices corresponding to the `k` minimum values of an array.

   :param pda: Input array.
   :type pda: pdarray
   :param k: The desired count of indices corresponding to minimum array values
   :type k: int_scalars

   :returns: The indices of the minimum `k` values from the pda, sorted
   :rtype: pdarray

   :raises TypeError: Raised if pda is not a pdarray or k is not an integer
   :raises ValueError: Raised if the pda is empty, or pda.ndim > 1, or k < 1

   .. rubric:: Notes

   This call is equivalent in value to ak.argsort(a)[:k]
   and generally outperforms this operation.

   This reduction will see a significant drop in performance as `k` grows
   beyond a certain value. This value is system dependent, but generally
   about a `k` of 5 million is where performance degradation has been observed.

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> A = ak.array([10,5,1,3,7,2,9,0])
   >>> ak.argmink(A, 3)
   array([7 2 5])
   >>> ak.argmink(A, 4)
   array([7 2 5 3])


.. py:function:: argsort(pda: Union[arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.strings.Strings, arkouda.pandas.categorical.Categorical], algorithm: SortingAlgorithm = SortingAlgorithm.RadixSortLSD, axis: arkouda.numpy.dtypes.int_scalars = 0, ascending: bool = True) -> arkouda.numpy.pdarrayclass.pdarray

   Return the permutation (indices) that sorts the array.

   :param pda: The array to sort (supported: int64, uint64, float64 for pdarray).
   :type pda: pdarray, Strings, or Categorical
   :param algorithm: The algorithm to use for sorting.
   :type algorithm: SortingAlgorithm, default SortingAlgorithm.RadixSortLSD
   :param axis: Axis to sort along. Negative values are normalized against the array rank.
                For 1D types (Strings, Categorical), must be 0.
   :type axis: int, default 0
   :param ascending: Sort order.
   :type ascending: bool, default True

   :returns: Indices such that ``pda[indices]`` is sorted.
   :rtype: pdarray

   :raises TypeError: If `pda` is not a pdarray, Strings, or Categorical.
   :raises ValueError: If `axis` is out of bounds.

   .. seealso:: :py:obj:`coargsort`

   .. rubric:: Notes

   Uses a least-significant-digit radix sort, which is stable and
   resilient to non-uniformity in data but communication intensive.

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.randint(0, 10, 10, seed=1)
   >>> a
   array([7 9 5 1 4 1 8 5 5 0])
   >>> perm = ak.argsort(a)
   >>> a[perm]
   array([0 1 1 4 5 5 5 7 8 9])
   >>> ak.argsort(a, ak.sorting.SortingAlgorithm["RadixSortLSD"])
   array([9 3 5 4 2 7 8 0 6 1])
   >>> ak.argsort(a, ak.sorting.SortingAlgorithm["TwoArrayRadixSort"])
   array([9 3 5 4 2 7 8 0 6 1])
   >>> ak.argsort(a, ascending=False)
   array([1 6 0 8 7 2 4 5 3 9])


.. py:function:: array(a: Union[arkouda.numpy.pdarrayclass.pdarray, numpy.ndarray, Iterable, arkouda.numpy.strings.Strings], dtype: Union[numpy.dtype, type, str, None] = None, copy: bool = False, max_bits: int = -1) -> Union[arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.strings.Strings]

   Convert a Python, NumPy, or Arkouda array-like into a `pdarray` or `Strings` object,
   transferring data to the Arkouda server.

   :param a: The array-like input to convert. Supported types include Arkouda `Strings`, `pdarray`,
             NumPy `ndarray`, or Python iterables such as list, tuple, range, or deque.
   :type a: Union[pdarray, np.ndarray, Iterable, Strings]
   :param dtype: The target dtype to cast values to. This may be a NumPy dtype object,
                 a NumPy scalar type (e.g. `np.int64`), or a string (e.g. `'int64'`, `'str'`).
   :type dtype: Union[np.dtype, type, str], optional
   :param copy: If True, a deep copy of the array is made. If False, no copy is made if the input
                is already a `pdarray`. **Note**: Arkouda does not currently support views or shallow copies.
                This differs from NumPy. Also, the default (`False`) is chosen to reduce performance overhead.
   :type copy: bool, default=False
   :param max_bits: The maximum number of bits for bigint arrays. Ignored for other dtypes.
   :type max_bits: int, optional

   :returns: A `pdarray` stored on the Arkouda server, or a `Strings` object.
   :rtype: Union[pdarray, Strings]

   :raises TypeError: - If `a` is not a `pdarray`, `np.ndarray`, or Python iterable.
       - If `a` is of string type and `dtype` is not `ak.str_`.
   :raises RuntimeError: - If input size exceeds `ak.client.maxTransferBytes`.
       - If `a.dtype` is unsupported or incompatible with Arkouda.
       - If `a.size * a.itemsize > maxTransferBytes`.
   :raises ValueError: - If `a`'s rank is not supported (see `get_array_ranks()`).
       - If the server response is malformed or missing required fields.

   .. seealso::

      :py:obj:`pdarray.to_ndarray`
          Convert back from Arkouda to NumPy.

   .. rubric:: Notes

   - Arkouda does not currently support shallow copies or views; all copies are deep.
   - The number of bytes transferred to the server is limited by `ak.client.maxTransferBytes`.
     This prevents saturating the network during large transfers. To increase this limit,
     set `ak.client.maxTransferBytes` to a larger value manually.
   - If the input is a Unicode string array (`dtype.kind == 'U'` or `dtype='str'`),
     this function recursively creates a `Strings` object from two internal `pdarray`s
     (one for offsets and one for concatenated string bytes).

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.array(np.arange(1, 10))
   array([1 2 3 4 5 6 7 8 9])

   >>> ak.array(range(1, 10))
   array([1 2 3 4 5 6 7 8 9])

   >>> strings = ak.array([f'string {i}' for i in range(5)])
   >>> type(strings)
   <class 'arkouda.numpy.strings.Strings'>


.. py:function:: array_equal(pda_a: arkouda.numpy.pdarrayclass.pdarray, pda_b: arkouda.numpy.pdarrayclass.pdarray, equal_nan: bool = False) -> bool

   Compares two pdarrays for equality.
   If neither array has any nan elements, then if all elements are pairwise equal,
   it returns True.
   If equal_Nan is False, then any nan element in either array gives a False return.
   If equal_Nan is True, then pairwise-corresponding nans are considered equal.

   :param pda_a:
   :type pda_a: pdarray
   :param pda_b:
   :type pda_b: pdarray
   :param equal_nan: Determines how to handle nans
   :type equal_nan: bool, default=False

   :returns:

             With string data:
                False if one array is type ak.str_ & the other isn't, True if both are ak.str_ & they match.

             With numeric data:
                True if neither array has any nan elements, and all elements pairwise equal.

                True if equal_Nan True, all non-nans pairwise equal & nans in pda_a correspond to nans in pda_b

                False if equal_Nan False, & either array has any nan element.
   :rtype: boolean

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.randint(0,10,10,dtype=ak.float64)
   >>> b = a
   >>> ak.array_equal(a,b)
   True
   >>> b[9] = np.nan
   >>> ak.array_equal(a,b)
   False
   >>> a[9] = np.nan
   >>> ak.array_equal(a,b)
   False
   >>> ak.array_equal(a,b,True)
   True


.. py:function:: assert_almost_equal(left, right, rtol: float = 1e-05, atol: float = 1e-08, **kwargs) -> None

   Check that the left and right objects are approximately equal.

   By approximately equal, we refer to objects that are numbers or that
   contain numbers which may be equivalent to specific levels of precision.

   :param left:
   :type left: object
   :param right:
   :type right: object
   :param rtol: Relative tolerance.
   :type rtol: float, default 1e-5
   :param atol: Absolute tolerance.
   :type atol: float, default 1e-8

   .. warning::

      This function cannot be used on pdarray of size > ak.client.maxTransferBytes
      because it converts pdarrays to numpy arrays and calls np.allclose.


.. py:function:: assert_almost_equivalent(left, right, rtol: float = 1e-05, atol: float = 1e-08) -> None

   Check that two objects are approximately equal.

   By approximately equal, we refer to objects that are numbers or that
   contain numbers which may be equivalent to specific levels of precision.

   If the objects are pandas or numpy objects, they are converted to Arkouda objects.
   Then assert_almost_equal is applied to the result.

   :param left: First object to compare.
   :type left: object
   :param right: Second object to compare.
   :type right: object
   :param rtol: Relative tolerance. Default is 1e-5.
   :type rtol: float
   :param atol: Absolute tolerance. Default is 1e-8.
   :type atol: float

   :raises TypeError: If either input is not a supported numeric-like type.

   .. warning::

      This function cannot be used on pdarrays of size > ak.client.maxTransferBytes
      because it converts pdarrays to numpy arrays and calls np.allclose.

   .. seealso:: :py:obj:`assert_almost_equal`

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> from arkouda.testing import assert_almost_equivalent
   >>> assert_almost_equivalent(0.123456, 0.123457, rtol=1e-4)


.. py:function:: assert_arkouda_array_equal(left: arkouda.pdarray | arkouda.Strings | arkouda.Categorical | arkouda.SegArray, right: arkouda.pdarray | arkouda.Strings | arkouda.Categorical | arkouda.SegArray, check_dtype: bool = True, err_msg=None, check_same=None, obj: str = 'pdarray', index_values=None) -> None

   Check that two Arkouda arrays are equivalent. Supports pdarray, Strings,
   Categorical, and SegArray.

   :param left: The first array to compare.
   :type left: pdarray or Strings or Categorical or SegArray
   :param right: The second array to compare.
   :type right: pdarray or Strings or Categorical or SegArray
   :param check_dtype: Whether to check dtype if both `left` and `right` are ak.pdarray.
                       Defaults to True.
   :type check_dtype: bool
   :param err_msg: Custom assertion message, if provided. Defaults to None.
   :type err_msg: str or None
   :param check_same: If not None, assert whether `left` and `right` share the same memory.
                      - `'copy'`: assert that they do **not** share memory.
                      - `'same'`: assert that they **do** share memory.
                      Defaults to None.
   :type check_same: {'copy', 'same'} or None
   :param obj: Object name used in assertion error messages. Defaults to 'pdarray'.
   :type obj: str
   :param index_values: Optional index shared by both `left` and `right`, used to enhance
                        output in error messages. Defaults to None.
   :type index_values: Index or pdarray or None


.. py:function:: assert_arkouda_array_equivalent(left: arkouda.pdarray | arkouda.Strings | arkouda.Categorical | arkouda.SegArray | numpy.ndarray | pandas.Categorical, right: arkouda.pdarray | arkouda.Strings | arkouda.Categorical | arkouda.SegArray | numpy.ndarray | pandas.Categorical, check_dtype: bool = True, err_msg=None, check_same=None, obj: str = 'pdarray', index_values=None) -> None

    Check that two Arkouda-compatible arrays are equal.

   Supported types include numpy arrays, pandas Categorical, and Arkouda arrays.

   :param left: First array to compare.
   :type left: pdarray, Strings, Categorical, SegArray, np.ndarray, or pd.Categorical
   :param right: Second array to compare.
   :type right: pdarray, Strings, Categorical, SegArray, np.ndarray, or pd.Categorical
   :param check_dtype: Whether to verify that dtypes match. Default is True.
   :type check_dtype: bool
   :param err_msg: Optional message to display on failure.
   :type err_msg: str or None
   :param check_same: Whether to ensure identity or separation in memory. Default is None.
   :type check_same: None or {"copy", "same"}
   :param obj: Object label for error messages. Default is "pdarray".
   :type obj: str
   :param index_values: Shared index used in error output. Default is None.
   :type index_values: Index or pdarray, optional

   :raises TypeError: If either input is not a supported array type.

   .. seealso:: :py:obj:`assert_arkouda_array_equal`

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> from arkouda import Strings
   >>> from arkouda.testing import assert_arkouda_array_equivalent
   >>> a = ak.array([1, 2, 3])
   >>> b = ak.array([1, 2, 3])
   >>> assert_arkouda_array_equivalent(a, b)
   >>> s1 = ak.array(['x', 'y'])
   >>> s2 = ak.array(['x', 'y'])
   >>> assert_arkouda_array_equivalent(s1, s2)


.. py:function:: assert_arkouda_pdarray_equal(left: arkouda.pdarray, right: arkouda.pdarray, check_dtype: bool = True, err_msg=None, check_same=None, obj: str = 'pdarray', index_values=None) -> None

   Check that two Arkouda pdarray objects are equivalent.

   :param left: The first array to compare.
   :type left: pdarray
   :param right: The second array to compare.
   :type right: pdarray
   :param check_dtype: Whether to check dtype if both arrays are pdarrays. Defaults to True.
   :type check_dtype: bool
   :param err_msg: Custom assertion message to display on failure. Defaults to None.
   :type err_msg: str or None
   :param check_same: If not None, asserts whether `left` and `right` share the same memory:
                      - 'copy': assert they do **not** share memory
                      - 'same': assert they **do** share memory
                      Defaults to None.
   :type check_same: {'copy', 'same'} or None
   :param obj: A name for the object being compared, used in assertion messages.
               Defaults to 'pdarray'.
   :type obj: str
   :param index_values: Optional index shared by both arrays, used to enhance output on failure.
                        Defaults to None.
   :type index_values: Index or pdarray or None


.. py:function:: assert_arkouda_segarray_equal(left: arkouda.SegArray, right: arkouda.SegArray, check_dtype: bool = True, err_msg=None, check_same=None, obj: str = 'segarray') -> None

   Check that two Arkouda SegArray objects are equivalent.

   :param left: The first SegArray to compare.
   :type left: SegArray
   :param right: The second SegArray to compare.
   :type right: SegArray
   :param check_dtype: Whether to check dtype if both arrays contain pdarrays. Defaults to True.
   :type check_dtype: bool
   :param err_msg: Custom assertion message. Defaults to None.
   :type err_msg: str or None
   :param check_same: If not None, asserts whether `left` and `right` share the same memory.
                      - 'copy': assert that they do **not** share memory.
                      - 'same': assert that they **do** share memory.
                      Defaults to None.
   :type check_same: {'copy', 'same'} or None
   :param obj: Name of the object being compared (used in assertion messages).
               Defaults to 'segarray'.
   :type obj: str


.. py:function:: assert_arkouda_strings_equal(left, right, err_msg=None, check_same=None, obj: str = 'Strings', index_values=None) -> None

   Check that two `ak.Strings` arrays are equivalent.

   :param left: The first Strings object to compare.
   :type left: Strings
   :param right: The second Strings object to compare.
   :type right: Strings
   :param err_msg: Custom assertion message. Defaults to None.
   :type err_msg: str or None
   :param check_same: If not None, assert whether `left` and `right` share the same memory.
                      - 'copy': assert that they do **not** share memory
                      - 'same': assert that they **do** share memory
                      Defaults to None.
   :type check_same: {'copy', 'same'} or None
   :param obj: A name for the object being compared, used in assertion messages.
               Defaults to 'Strings'.
   :type obj: str
   :param index_values: Optional index shared by both arrays, used in output. Defaults to None.
   :type index_values: Index or pdarray or None


.. py:function:: assert_attr_equal(attr: str, left, right, obj: str = 'Attributes') -> None

   Check that attributes are equal. Both objects must have the given attribute.

   :param attr: The name of the attribute being compared.
   :type attr: str
   :param left: The first object to compare.
   :type left: object
   :param right: The second object to compare.
   :type right: object
   :param obj: A name for the object being compared, used in assertion messages.
               Defaults to 'Attributes'.
   :type obj: str


.. py:function:: assert_categorical_equal(left, right, check_dtype: bool = True, check_category_order: bool = True, obj: str = 'Categorical') -> None

   Test that Categoricals are equivalent.

   :param left: The first Categorical to compare.
   :type left: Categorical
   :param right: The second Categorical to compare.
   :type right: Categorical
   :param check_dtype: Whether to check that the integer dtype of the codes is the same.
                       Defaults to True.
   :type check_dtype: bool
   :param check_category_order: Whether to compare the order of the categories (which implies identical integer codes).
                                If False, only the resulting values are compared. The `ordered` attribute is
                                always checked. Defaults to True.
   :type check_category_order: bool
   :param obj: A name for the object being compared, used in assertion messages.
               Defaults to 'Categorical'.
   :type obj: str


.. py:function:: assert_class_equal(left, right, exact: bool = True, obj: str = 'Input') -> None

   Check classes are equal.


.. py:function:: assert_contains_all(iterable, dic) -> None

   Assert that a dictionary contains all the elements of an iterable.

   :param iterable:
   :type iterable: iterable
   :param dic:
   :type dic: dict


.. py:function:: assert_copy(iter1, iter2, **eql_kwargs) -> None

   Check that the elements are equal, but not the same object.

   Does not check that items in sequences are also not the same object.

   :param iter1: Iterables that produce elements comparable with assert_almost_equal.
   :type iter1: iterable
   :param iter2: Iterables that produce elements comparable with assert_almost_equal.
   :type iter2: iterable


.. py:function:: assert_dict_equal(left, right, compare_keys: bool = True) -> None

   Assert that two dictionaries are equal.

   Values must be arkouda objects.

   :param left: The dictionaries to be compared.
   :type left: dict
   :param right: The dictionaries to be compared.
   :type right: dict
   :param compare_keys: Whether to compare the keys. Defaults to True.
                        If False, only the values are compared.
   :type compare_keys: bool


.. py:function:: assert_equal(left, right, **kwargs) -> None

   Wrap tm.assert_*_equal to dispatch to the appropriate test function.

   :param left: The two items to be compared.
   :type left: Index, Series, DataFrame, or pdarray
   :param right: The two items to be compared.
   :type right: Index, Series, DataFrame, or pdarray
   :param \*\*kwargs: All keyword arguments are passed through to the underlying assert method.


.. py:function:: assert_equivalent(left, right, **kwargs) -> None

   Dispatch to the appropriate assertion function depending on object types.

   :param left: First object to compare. Type determines which assertion function is used.
   :type left: Any
   :param right: Second object to compare.
   :type right: Any
   :param \*\*kwargs: Keyword arguments passed to the specific assertion function.
   :type \*\*kwargs: dict

   :raises AssertionError: If values are not equivalent.

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> import pandas as pd
   >>> from arkouda.testing import assert_equivalent
   >>> ak_series = ak.Series([1, 2, 3])
   >>> pd_series = pd.Series([1, 2, 3])
   >>> assert_equivalent(ak_series, pd_series)


.. py:function:: assert_frame_equal(left: arkouda.DataFrame, right: arkouda.DataFrame, check_dtype: bool = True, check_index_type: bool = True, check_column_type: bool | Literal['equiv'] = 'equiv', check_frame_type: bool = True, check_names: bool = True, check_exact: bool = True, check_categorical: bool = True, check_like: bool = False, rtol: float = 1e-05, atol: float = 1e-08, obj: str = 'DataFrame') -> None

   Check that left and right DataFrame are equal.

   This function is intended to compare two DataFrames and output any
   differences. It is mostly intended for use in unit tests.
   Additional parameters allow varying the strictness of the
   equality checks performed.

   :param left: First DataFrame to compare.
   :type left: DataFrame
   :param right: Second DataFrame to compare.
   :type right: DataFrame
   :param check_dtype: Whether to check the DataFrame dtype is identical. Defaults to True.
   :type check_dtype: bool
   :param check_index_type: Whether to check the Index class, dtype, and inferred_type are identical.
                            Defaults to True.
   :type check_index_type: bool
   :param check_column_type: Whether to check the column class, dtype, and inferred_type are identical.
                             Passed as the ``exact`` argument of :func:`assert_index_equal`.
                             Defaults to 'equiv'.
   :type check_column_type: bool or {'equiv'}
   :param check_frame_type: Whether to check the DataFrame class is identical. Defaults to True.
   :type check_frame_type: bool
   :param check_names: Whether to check that the `names` attribute for both the `index`
                       and `column` attributes of the DataFrame is identical. Defaults to True.
   :type check_names: bool
   :param check_exact: Whether to compare numbers exactly. Defaults to False.
   :type check_exact: bool
   :param check_categorical: Whether to compare internal Categoricals exactly. Defaults to True.
   :type check_categorical: bool
   :param check_like: If True, ignore the order of index and columns.
                      Note: index labels must match their respective rows (as in columns);
                      same labels must be with the same data. Defaults to False.
   :type check_like: bool
   :param rtol: Relative tolerance. Only used when `check_exact` is False. Defaults to 1e-5.
   :type rtol: float
   :param atol: Absolute tolerance. Only used when `check_exact` is False. Defaults to 1e-8.
   :type atol: float
   :param obj: A name for the object being compared, used in assertion messages.
               Defaults to 'DataFrame'.
   :type obj: str

   .. seealso::

      :py:obj:`assert_series_equal`
          Equivalent method for asserting Series equality.

   .. rubric:: Examples

   >>> import arkouda as ak

   This example shows comparing two DataFrames that are equal
   but with columns of differing dtypes.

   >>> from arkouda.testing import assert_frame_equal
   >>> df1 = ak.DataFrame({'a': [1, 2], 'b': [3, 4]})
   >>> df2 = ak.DataFrame({'a': [1, 2], 'b': [3.0, 4.0]})

   df1 equals itself.
   >>> assert_frame_equal(df1, df1)

   df1 differs from df2 as column 'b' is of a different type.
   >>> assert_frame_equal(df1, df2) # doctest: +SKIP
   Traceback (most recent call last):
   ...
   AssertionError: Attributes of DataFrame.iloc[:, 1] (column name="b") are different

   Attribute "dtype" are different
   [left]:  int64
   [right]: float64

   Ignore differing dtypes in columns with check_dtype.

   >>> assert_frame_equal(df1, df2, check_dtype=False)


.. py:function:: assert_frame_equivalent(left: arkouda.DataFrame | pandas.DataFrame, right: arkouda.DataFrame | pandas.DataFrame, check_dtype: bool = True, check_index_type: bool = True, check_column_type: bool = True, check_frame_type: bool = True, check_names: bool = True, check_exact: bool = True, check_categorical: bool = True, check_like: bool = False, rtol: float = 1e-05, atol: float = 1e-08, obj: str = 'DataFrame') -> None

   Check that two DataFrames are equal.

   This function compares two DataFrames and raises an assertion if they differ.
   It is intended primarily for use in unit tests. pandas DataFrames are converted to
   Arkouda equivalents before comparison.

   :param left: First DataFrame to compare.
   :type left: DataFrame or pd.DataFrame
   :param right: Second DataFrame to compare.
   :type right: DataFrame or pd.DataFrame
   :param check_dtype: Whether to check that dtypes are identical. Default is True.
   :type check_dtype: bool
   :param check_index_type: Whether to check that index class, dtype, and inferred type are identical. Default is True.
   :type check_index_type: bool
   :param check_column_type: Whether to check that column class, dtype, and inferred type are identical. Default is True.
   :type check_column_type: bool
   :param check_frame_type: Whether to check that the DataFrame class is identical. Default is True.
   :type check_frame_type: bool
   :param check_names: Whether to check that the index and column names are identical. Default is True.
   :type check_names: bool
   :param check_exact: Whether to compare values exactly. Default is True.
   :type check_exact: bool
   :param check_categorical: Whether to compare internal categoricals exactly. Default is True.
   :type check_categorical: bool
   :param check_like: Whether to ignore the order of index and columns. Labels must still match their data. /
                      Default is False.
   :type check_like: bool
   :param rtol: Relative tolerance used when check_exact is False. Default is 1e-5.
   :type rtol: float
   :param atol: Absolute tolerance used when check_exact is False. Default is 1e-8.
   :type atol: float
   :param obj: Object name used in error messages. Default is "DataFrame".
   :type obj: str

   :raises TypeError: If either input is not a DataFrame or pd.DataFrame.

   .. seealso:: :py:obj:`assert_frame_equal`

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> import pandas as pd
   >>> from arkouda.testing import assert_frame_equivalent
   >>> df1 = ak.DataFrame({'a': [1, 2], 'b': [3, 4]})
   >>> df2 = pd.DataFrame({'a': [1, 2], 'b': [3.0, 4.0]})

   Fails because dtypes are different:
   >>> assert_frame_equivalent(df1, df2)  # doctest: +SKIP


.. py:function:: assert_index_equal(left: arkouda.Index, right: arkouda.Index, exact: bool = True, check_names: bool = True, check_exact: bool = True, check_categorical: bool = True, check_order: bool = True, rtol: float = 1e-05, atol: float = 1e-08, obj: str = 'Index') -> None

   Check that left and right Index are equal.

   :param left: The first Index to compare.
   :type left: Index
   :param right: The second Index to compare.
   :type right: Index
   :param exact: Whether to check that the Index class, dtype, and inferred_type
                 are identical. Defaults to True.
   :type exact: bool
   :param check_names: Whether to check the `name` attribute. Defaults to True.
   :type check_names: bool
   :param check_exact: Whether to compare numbers exactly. Defaults to True.
   :type check_exact: bool
   :param check_categorical: Whether to compare internal Categorical values exactly. Defaults to True.
   :type check_categorical: bool
   :param check_order: Whether to compare the order of index entries as well as their values.
                       If True, both indexes must contain the same elements, in the same order.
                       If False, both indexes must contain the same elements, but in any order.
                       Defaults to True.
   :type check_order: bool
   :param rtol: Relative tolerance. Only used when `check_exact` is False.
                Defaults to 1e-5.
   :type rtol: float
   :param atol: Absolute tolerance. Only used when `check_exact` is False.
                Defaults to 1e-8.
   :type atol: float
   :param obj: A name for the object being compared, used in assertion messages.
               Defaults to 'Index'.
   :type obj: str

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> from arkouda import testing as tm
   >>> a = ak.Index([1, 2, 3])
   >>> b = ak.Index([1, 2, 3])
   >>> tm.assert_index_equal(a, b)


.. py:function:: assert_index_equivalent(left: arkouda.Index | pandas.Index, right: arkouda.Index | pandas.Index, exact: bool = True, check_names: bool = True, check_exact: bool = True, check_categorical: bool = True, check_order: bool = True, rtol: float = 1e-05, atol: float = 1e-08, obj: str = 'Index') -> None

   Check that two Index objects are equal.

   If the objects are pandas Index, they are converted to Arkouda Index.
   Then assert_index_equal is applied to the result.

   :param left: First Index to compare.
   :type left: Index or pd.Index
   :param right: Second Index to compare.
   :type right: Index or pd.Index
   :param exact: Whether to check that class, dtype, and inferred type are identical. Default is True.
   :type exact: bool
   :param check_names: Whether to check the names attribute. Default is True.
   :type check_names: bool
   :param check_exact: Whether to compare values exactly. Default is True.
   :type check_exact: bool
   :param check_categorical: Whether to compare internal Categoricals exactly. Default is True.
   :type check_categorical: bool
   :param check_order: Whether to require identical order in index values. Default is True.
   :type check_order: bool
   :param rtol: Relative tolerance used when check_exact is False. Default is 1e-5.
   :type rtol: float
   :param atol: Absolute tolerance used when check_exact is False. Default is 1e-8.
   :type atol: float
   :param obj: Object name used in error messages. Default is "Index".
   :type obj: str

   :raises TypeError: If either input is not an Index or pd.Index.

   .. seealso:: :py:obj:`assert_index_equal`

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> from arkouda import testing as tm
   >>> import pandas as pd
   >>> a = ak.Index([1, 2, 3])
   >>> b = pd.Index([1, 2, 3])
   >>> tm.assert_index_equivalent(a, b)


.. py:function:: assert_is_sorted(seq) -> None

   Assert that the sequence is sorted.


.. py:function:: assert_series_equal(left, right, check_dtype: bool = True, check_index_type: bool = True, check_series_type: bool = True, check_names: bool = True, check_exact: bool = False, check_categorical: bool = True, check_category_order: bool = True, rtol: float = 1e-05, atol: float = 1e-08, obj: str = 'Series', *, check_index: bool = True, check_like: bool = False) -> None

   Check that left and right Series are equal.

   :param left: First Series to compare.
   :type left: Series
   :param right: Second Series to compare.
   :type right: Series
   :param check_dtype: Whether to check the Series dtype is identical. Defaults to True.
   :type check_dtype: bool
   :param check_index_type: Whether to check the Index class, dtype, and inferred_type are identical. Defaults to True.
   :type check_index_type: bool
   :param check_series_type: Whether to check that the Series class is identical. Defaults to True.
   :type check_series_type: bool
   :param check_names: Whether to check the Series and Index `name` attribute. Defaults to True.
   :type check_names: bool
   :param check_exact: Whether to compare numbers exactly. Defaults to False.
   :type check_exact: bool
   :param check_categorical: Whether to compare internal Categoricals exactly. Defaults to True.
   :type check_categorical: bool
   :param check_category_order: Whether to compare the category order of internal Categoricals. Defaults to True.
   :type check_category_order: bool
   :param rtol: Relative tolerance. Only used when `check_exact` is False. Defaults to 1e-5.
   :type rtol: float
   :param atol: Absolute tolerance. Only used when `check_exact` is False. Defaults to 1e-8.
   :type atol: float
   :param obj: Name of the object being compared, used in assertion messages. Defaults to 'Series'.
   :type obj: str
   :param check_index: Whether to check index equivalence. If False, only the values are compared. Defaults to True.
   :type check_index: bool
   :param check_like: If True, ignore the order of the index.
                      Must be False if `check_index` is False.
                      Note: same labels must be with the same data. Defaults to False.
   :type check_like: bool

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> from arkouda import testing as tm
   >>> a = ak.Series([1, 2, 3, 4])
   >>> b = ak.Series([1, 2, 3, 4])
   >>> tm.assert_series_equal(a, b)


.. py:function:: assert_series_equivalent(left: arkouda.Series | pandas.Series, right: arkouda.Series | pandas.Series, check_dtype: bool = True, check_index_type: bool = True, check_series_type: bool = True, check_names: bool = True, check_exact: bool = False, check_categorical: bool = True, check_category_order: bool = True, rtol: float = 1e-05, atol: float = 1e-08, obj: str = 'Series', *, check_index: bool = True, check_like: bool = False) -> None

   Check that two Series are equal.

   This function compares two Series and raises an assertion if they differ.
   pandas Series are converted to Arkouda equivalents before comparison.
   The comparison can be customized using the provided keyword arguments.

   :param left: First Series to compare.
   :type left: Series or pd.Series
   :param right: Second Series to compare.
   :type right: Series or pd.Series
   :param check_dtype: Whether to check that dtypes are identical. Default is True.
   :type check_dtype: bool
   :param check_index_type: Whether to check that index class, dtype, and inferred type are identical. Default is True.
   :type check_index_type: bool
   :param check_series_type: Whether to check that the Series class is identical. Default is True.
   :type check_series_type: bool
   :param check_names: Whether to check that the Series and Index name attributes are identical. Default is True.
   :type check_names: bool
   :param check_exact: Whether to compare numbers exactly. Default is False.
   :type check_exact: bool
   :param check_categorical: Whether to compare internal Categoricals exactly. Default is True.
   :type check_categorical: bool
   :param check_category_order: Whether to compare category order in internal Categoricals. Default is True.
   :type check_category_order: bool
   :param rtol: Relative tolerance used when check_exact is False. Default is 1e-5.
   :type rtol: float
   :param atol: Absolute tolerance used when check_exact is False. Default is 1e-8.
   :type atol: float
   :param obj: Object name used in error messages. Default is "Series".
   :type obj: str
   :param check_index: Whether to check index equivalence. If False, only values are compared. Default is True.
   :type check_index: bool
   :param check_like: If True, ignore the order of the index. Must be False if check_index is False.
                      Note: identical labels must still correspond to the same data. Default is False.
   :type check_like: bool

   :raises TypeError: If either input is not a Series or pd.Series.

   .. seealso:: :py:obj:`assert_series_equal`

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> from arkouda import testing as tm
   >>> import pandas as pd
   >>> a = ak.Series([1, 2, 3, 4])
   >>> b = pd.Series([1, 2, 3, 4])
   >>> tm.assert_series_equivalent(a, b)


.. py:function:: attach(name: str)

   Attach a previously created Arkouda object by its registered name.

   This function retrieves an Arkouda object (e.g., `pdarray`, `DataFrame`,
   `Series`, etc.) associated with a given `name`. It returns the corresponding
   object based on the type of object stored under that name.

   :param name: The name of the object to attach.
   :type name: str

   :returns: The Arkouda object associated with the given `name`. The returned object
             could be of any supported type, such as `pdarray`, `DataFrame`, `Series`,
             etc.
   :rtype: object

   :raises ValueError: If the object type in the response message does not match any known types.

   .. rubric:: Examples

   >>> import arkouda as ak

   Attach an existing pdarray
   >>> obj = ak.array([1, 2, 3])
   >>> registered_obj = obj.register("my_array")
   >>> arr = ak.attach("my_array")
   >>> print(arr)
   [1 2 3]
   >>> registered_obj.unregister()


.. py:function:: attach_all(names: list)

   Attach to all objects registered with the provided names.

   This function returns a dictionary mapping each name in the input list
   to the corresponding Arkouda object retrieved using `attach`.

   :param names: A list of names corresponding to registered Arkouda objects.
   :type names: List of str

   :returns: A dictionary mapping each name to the attached Arkouda object.
   :rtype: dict

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> data = { "arr1": ak.array([0, 1, 2]), "arr2": ak.array([3, 4, 5]) }
   >>> ak.register_all(data)

   Assuming "arr1" and "arr2" were previously registered
   >>> attached_objs = ak.attach_all(["arr1", "arr2"])
   >>> print(attached_objs["arr1"])
   [0 1 2]
   >>> print(type(attached_objs["arr2"]))
   <class 'arkouda.numpy.pdarrayclass.pdarray'>
   >>> ak.unregister_all(["arr1", "arr2"])


.. py:function:: base_repr(number, base=2, padding=0)

   Return a string representation of a number in the given base system.

   :param number: The value to convert. Positive and negative values are handled.
   :type number: int
   :param base: Convert `number` to the `base` number system. The valid range is 2-36,
                the default value is 2.
   :type base: int, optional
   :param padding: Number of zeros padded on the left. Default is 0 (no padding).
   :type padding: int, optional

   :returns: **out** -- String representation of `number` in `base` system.
   :rtype: str

   .. seealso::

      :py:obj:`binary_repr`
          Faster version of `base_repr` for base 2.

   .. rubric:: Examples

   >>> import numpy as np
   >>> np.base_repr(5)
   '101'
   >>> np.base_repr(6, 5)
   '11'
   >>> np.base_repr(7, base=5, padding=3)
   '00012'

   >>> np.base_repr(10, base=16)
   'A'
   >>> np.base_repr(32, base=16)
   '20'


.. py:class:: bigint

   Datatype for representing integers of variable size.

   May be used for integers that exceed 64 bits.



   .. py:method:: itemsize(*args, **kwargs)

      int([x]) -> integer
      int(x, base=10) -> integer

      Convert a number or string to an integer, or return 0 if no arguments
      are given.  If x is a number, return x.__int__().  For floating-point
      numbers, this truncates towards zero.

      If x is not a number or if base is given, then x must be a string,
      bytes, or bytearray instance representing an integer literal in the
      given base.  The literal can be preceded by '+' or '-' and be surrounded
      by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
      Base 0 means to interpret the base from the string as an integer literal.
      >>> int('0b100', base=0)
      4



   .. py:method:: name(*args, **kwargs)

      str(object='') -> str
      str(bytes_or_buffer[, encoding[, errors]]) -> str

      Create a new string object from the given object. If encoding or
      errors is specified, then the object must expose a data buffer
      that will be decoded using the given encoding and error handler.
      Otherwise, returns the result of object.__str__() (if defined)
      or repr(object).
      encoding defaults to 'utf-8'.
      errors defaults to 'strict'.



   .. py:method:: ndim(*args, **kwargs)

      int([x]) -> integer
      int(x, base=10) -> integer

      Convert a number or string to an integer, or return 0 if no arguments
      are given.  If x is a number, return x.__int__().  For floating-point
      numbers, this truncates towards zero.

      If x is not a number or if base is given, then x must be a string,
      bytes, or bytearray instance representing an integer literal in the
      given base.  The literal can be preceded by '+' or '-' and be surrounded
      by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
      Base 0 means to interpret the base from the string as an integer literal.
      >>> int('0b100', base=0)
      4



   .. py:method:: shape(*args, **kwargs)

      Built-in immutable sequence.

      If no argument is given, the constructor returns an empty tuple.
      If iterable is specified the tuple is initialized from iterable's items.

      If the argument is a tuple, the return value is the same object.



   .. py:method:: type(x)


.. py:function:: bigint_from_uint_arrays(arrays, max_bits=-1)

   Create a bigint pdarray from an iterable of uint pdarrays.
   The first item in arrays will be the highest 64 bits and
   the last item will be the lowest 64 bits.

   :param arrays: An iterable of uint pdarrays used to construct the bigint pdarray.
                  The first item in arrays will be the highest 64 bits and
                  the last item will be the lowest 64 bits.
   :type arrays: Sequence[pdarray]
   :param max_bits: Specifies the maximum number of bits; only used for bigint pdarrays
   :type max_bits: int

   :returns: bigint pdarray constructed from uint arrays
   :rtype: pdarray

   :raises TypeError: Raised if any pdarray in arrays has a dtype other than uint or
       if the pdarrays are not the same size.
   :raises RuntimeError: Raised if there is a server-side error thrown

   .. seealso:: :py:obj:`pdarray.bigint_to_uint_arrays`

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.bigint_from_uint_arrays([ak.ones(5, dtype=ak.uint64), ak.arange(5, dtype=ak.uint64)])
   >>> a
   array([18446744073709551616 18446744073709551617 18446744073709551618
   18446744073709551619 18446744073709551620])

   >>> a.dtype
   dtype(bigint)

   >>> all(a[i] == 2**64 + i for i in range(5))
   True


.. py:function:: binary_repr(num, width=None)

   Return the binary representation of the input number as a string.

   For negative numbers, if width is not given, a minus sign is added to the
   front. If width is given, the two's complement of the number is
   returned, with respect to that width.

   In a two's-complement system negative numbers are represented by the two's
   complement of the absolute value. This is the most common method of
   representing signed integers on computers [1]_. A N-bit two's-complement
   system can represent every integer in the range
   :math:`-2^{N-1}` to :math:`+2^{N-1}-1`.

   :param num: Only an integer decimal number can be used.
   :type num: int
   :param width: The length of the returned string if `num` is positive, or the length
                 of the two's complement if `num` is negative, provided that `width` is
                 at least a sufficient number of bits for `num` to be represented in
                 the designated form. If the `width` value is insufficient, an error is
                 raised.
   :type width: int, optional

   :returns: **bin** -- Binary representation of `num` or two's complement of `num`.
   :rtype: str

   .. seealso::

      :py:obj:`base_repr`
          Return a string representation of a number in the given base system.

      :py:obj:`bin`
          Python's built-in binary representation generator of an integer.

   .. rubric:: Notes

   `binary_repr` is equivalent to using `base_repr` with base 2, but about 25x
   faster.

   .. rubric:: References

   .. [1] Wikipedia, "Two's complement",
       https://en.wikipedia.org/wiki/Two's_complement

   .. rubric:: Examples

   >>> import numpy as np
   >>> np.binary_repr(3)
   '11'
   >>> np.binary_repr(-3)
   '-11'
   >>> np.binary_repr(3, width=4)
   '0011'

   The two's complement is returned when the input number is negative and
   width is specified:

   >>> np.binary_repr(-3, width=3)
   '101'
   >>> np.binary_repr(-3, width=5)
   '11101'


.. py:class:: bitType

   Bases: :py:obj:`numpy.unsignedinteger`


   Unsigned signed integer type, 64bit on 64bit systems and 32bit on 32bit
       systems.

       :Character code: ``'L'``
       :Canonical name: `numpy.uint`
       :Alias on this platform (Linux x86_64): `numpy.uint64`: 64-bit unsigned integer (``0`` to ``18_446_744_073_709_551_615``).
       :Alias on this platform (Linux x86_64): `numpy.uintp`: Unsigned integer large enough to fit pointer, compatible with C ``uintptr_t``.


   .. py:method:: bit_count(/)

      uint64.bit_count() -> int

              Computes the number of 1-bits in the absolute value of the input.
              Analogous to the builtin `int.bit_count` or ``popcount`` in C++.

              Examples
              --------
              >>> np.uint64(127).bit_count()
              7



.. py:class:: bool

   Bases: :py:obj:`numpy.generic`


   Boolean type (True or False), stored as a byte.

       .. warning::

          The :class:`bool` type is not a subclass of the :class:`int_` type
          (the :class:`bool` is not even a number type). This is different
          than Python's default implementation of :class:`bool` as a
          sub-class of :class:`int`.

       :Character code: ``'?'``


.. py:class:: bool_scalars

   Bases: :py:obj:`_NotIterable`


   Mixin to prevent iteration, without being compatible with Iterable.

   That is, we could do::

       def __iter__(self): raise TypeError()

   But this would make users of this mixin duck type-compatible with
   collections.abc.Iterable - isinstance(foo, Iterable) would be True.

   Luckily, we can instead prevent iteration by setting __iter__ to None, which
   is treated specially.


   .. py:method:: copy_with(params)


.. py:function:: broadcast_arrays(*arrays: arkouda.numpy.pdarrayclass.pdarray) -> List[arkouda.numpy.pdarrayclass.pdarray]

   Broadcast arrays to a common shape.

   :param arrays: The arrays to broadcast. Must be broadcastable to a common shape.
   :type arrays: pdarray

   :returns: A list whose elements are the given Arrays broadcasted to the common shape.
   :rtype: List

   :raises ValueError: Raised by broadcast_to if a common shape cannot be determined.

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.arange(10).reshape(1,2,5)
   >>> b = ak.arange(20).reshape(4,1,5)
   >>> c = ak.broadcast_arrays(a,b)
   >>> c[0][0,:,:]
   array([array([0 1 2 3 4]) array([5 6 7 8 9])])
   >>> c[1][:,0,0]
   array([0 5 10 15])


.. py:function:: broadcast_dims(sa: Sequence[int], sb: Sequence[int]) -> Tuple[int, Ellipsis]

   Determine the broadcasted shape of two arrays given their shapes.

   This function implements the broadcasting rules from the Array API standard
   to compute the shape resulting from broadcasting two arrays together.

   See: https://data-apis.org/array-api/latest/API_specification/broadcasting.html#algorithm

   :param sa: The shape of the first array.
   :type sa: Sequence[int]
   :param sb: The shape of the second array.
   :type sb: Sequence[int]

   :returns: The broadcasted shape resulting from combining `sa` and `sb`.
   :rtype: Tuple[int, ...]

   :raises ValueError: If the shapes are not compatible for broadcasting.

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> from arkouda.util import broadcast_dims
   >>> broadcast_dims((5, 1), (1, 3))
   (5, 3)

   >>> broadcast_dims((4,), (3, 1))
   (3, 4)


.. py:function:: broadcast_shapes(*shapes: Tuple[int, Ellipsis]) -> Tuple[int, Ellipsis]

   Determine a broadcasted shape, given an arbitary number of shapes.

   This function implements the broadcasting rules from the Array API standard
   to compute the shape resulting from broadcasting two arrays together.

   See: https://data-apis.org/array-api/latest/API_specification/broadcasting.html#algorithm

   :param shapes: a list or tuple of the shapes to be broadcast
   :type shapes: Tuple[int, ...]

   :returns: The broadcasted shape
   :rtype: Tuple[int, ...]

   :raises ValueError: If the shapes are not compatible for broadcasting.

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.broadcast_shapes((1,2,3),(4,1,3),(4,2,1))
   (4, 2, 3)


.. py:function:: broadcast_to(x: arkouda.numpy.pdarrayclass.pdarray, shape: Tuple[int, Ellipsis]) -> arkouda.numpy.pdarrayclass.pdarray

   Broadcast the array to the specified shape.

   :param x: The array to be broadcast.
   :type x: pdarray
   :param shape: The shape to which the array is to be broadcast.
   :type shape: Tuple[int, ...]

   :returns: A new array which is x broadcast to the provided shape.
   :rtype: pdarray

   :raises ValueError: Raised server-side if the broadcast fails.

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.arange(5)
   >>> ak.broadcast_to(a,(2,5))
   array([array([0 1 2 3 4]) array([0 1 2 3 4])])


.. py:class:: byte

   Bases: :py:obj:`numpy.signedinteger`


   Signed integer type, compatible with C ``char``.

       :Character code: ``'b'``
       :Canonical name: `numpy.byte`
       :Alias on this platform (Linux x86_64): `numpy.int8`: 8-bit signed integer (``-128`` to ``127``).


   .. py:method:: bit_count(/)

      int8.bit_count() -> int

              Computes the number of 1-bits in the absolute value of the input.
              Analogous to the builtin `int.bit_count` or ``popcount`` in C++.

              Examples
              --------
              >>> np.int8(127).bit_count()
              7
              >>> np.int8(-127).bit_count()
              7



.. py:class:: bytes_

   A byte string.

       When used in arrays, this type strips trailing null bytes.

       :Character code: ``'S'``


   .. py:method:: T(*args, **kwargs)

      Scalar attribute identical to the corresponding array attribute.

          Please see `ndarray.T`.



   .. py:method:: all(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.all`.



   .. py:method:: any(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.any`.



   .. py:method:: argmax(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.argmax`.



   .. py:method:: argmin(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.argmin`.



   .. py:method:: argsort(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.argsort`.



   .. py:method:: astype(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.astype`.



   .. py:method:: base(*args, **kwargs)

      Scalar attribute identical to the corresponding array attribute.

          Please see `ndarray.base`.



   .. py:method:: byteswap(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.byteswap`.



   .. py:method:: choose(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.choose`.



   .. py:method:: clip(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.clip`.



   .. py:method:: compress(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.compress`.



   .. py:method:: conj(*args, **kwargs)


   .. py:method:: conjugate(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.conjugate`.



   .. py:method:: copy(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.copy`.



   .. py:method:: cumprod(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.cumprod`.



   .. py:method:: cumsum(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.cumsum`.



   .. py:method:: data(*args, **kwargs)

      Pointer to start of data.



   .. py:method:: device(*args, **kwargs)


   .. py:method:: diagonal(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.diagonal`.



   .. py:method:: dtype(*args, **kwargs)

      Get array data-descriptor.



   .. py:method:: dump(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.dump`.



   .. py:method:: dumps(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.dumps`.



   .. py:method:: fill(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.fill`.



   .. py:method:: flags(*args, **kwargs)

      The integer value of flags.



   .. py:method:: flat(*args, **kwargs)

      A 1-D view of the scalar.



   .. py:method:: flatten(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.flatten`.



   .. py:method:: getfield(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.getfield`.



   .. py:method:: imag(*args, **kwargs)

      The imaginary part of the scalar.



   .. py:method:: item(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.item`.



   .. py:method:: itemset(*args, **kwargs)


   .. py:method:: itemsize(*args, **kwargs)

      The length of one element in bytes.



   .. py:method:: max(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.max`.



   .. py:method:: mean(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.mean`.



   .. py:method:: min(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.min`.



   .. py:method:: nbytes(*args, **kwargs)


   .. py:method:: ndim(*args, **kwargs)

      The number of array dimensions.



   .. py:method:: newbyteorder(*args, **kwargs)


   .. py:method:: nonzero(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.nonzero`.



   .. py:method:: prod(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.prod`.



   .. py:method:: ptp(*args, **kwargs)


   .. py:method:: put(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.put`.



   .. py:method:: ravel(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.ravel`.



   .. py:method:: real(*args, **kwargs)

      The real part of the scalar.



   .. py:method:: repeat(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.repeat`.



   .. py:method:: reshape(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.reshape`.



   .. py:method:: resize(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.resize`.



   .. py:method:: round(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.round`.



   .. py:method:: searchsorted(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.searchsorted`.



   .. py:method:: setfield(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.setfield`.



   .. py:method:: setflags(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.setflags`.



   .. py:method:: shape(*args, **kwargs)

      Tuple of array dimensions.



   .. py:method:: size(*args, **kwargs)

      The number of elements in the gentype.



   .. py:method:: sort(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.sort`.



   .. py:method:: squeeze(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.squeeze`.



   .. py:method:: std(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.std`.



   .. py:method:: strides(*args, **kwargs)

      Tuple of bytes steps in each dimension.



   .. py:method:: sum(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.sum`.



   .. py:method:: swapaxes(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.swapaxes`.



   .. py:method:: take(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.take`.



   .. py:method:: to_device(*args, **kwargs)


   .. py:method:: tobytes(*args, **kwargs)


   .. py:method:: tofile(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.tofile`.



   .. py:method:: tolist(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.tolist`.



   .. py:method:: tostring(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.tostring`.



   .. py:method:: trace(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.trace`.



   .. py:method:: transpose(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.transpose`.



   .. py:method:: var(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.var`.



   .. py:method:: view(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.view`.



.. py:function:: can_cast(from_, to) -> bool

   Returns True if cast between data types can occur according to the casting rule.

   :param from_: Data type, NumPy scalar, or array to cast from.
   :type from_: dtype, dtype specifier, NumPy scalar, or pdarray
   :param to: Data type to cast to.
   :type to: dtype or dtype specifier

   :returns: True if cast can occur according to the casting rule.
   :rtype: builtins.bool


.. py:function:: cast(pda: Union[arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.strings.Strings, arkouda.pandas.categorical.Categorical], dt: Union[numpy.dtype, type, str, arkouda.numpy.dtypes.bigint], errors: ErrorMode = ErrorMode.strict) -> Union[Union[arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.strings.Strings, arkouda.pandas.categorical.Categorical], Tuple[arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.pdarrayclass.pdarray]]

   Cast an array to another dtype.

   :param pda: The array of values to cast
   :type pda: pdarray, Strings, or Categorical
   :param dt: The target dtype to cast values to
   :type dt: np.dtype, type, str, or bigint
   :param errors: Controls how errors are handled when casting strings to a numeric type
                  (ignored for casts from numeric types).
                      - strict: raise RuntimeError if *any* string cannot be converted
                      - ignore: never raise an error. Uninterpretable strings get
                          converted to NaN (float64), -2**63 (int64), zero (uint64 and
                          uint8), or False (bool)
                      - return_validity: in addition to returning the same output as
                        "ignore", also return a bool array indicating where the cast
                        was successful.
                  Default set to strict.
   :type errors: {strict, ignore, return_validity}, default=ErrorMode.strict

   :returns:

             pdarray or Strings
                 Array of values cast to desired dtype
             [validity : pdarray(bool)]
                 If errors="return_validity" and input is Strings, a second array is
                 returned with True where the cast succeeded and False where it failed.
   :rtype: Union[Union[pdarray, Strings, Categorical], Tuple[pdarray, pdarray]]

   .. rubric:: Notes

   The cast is performed according to Chapel's casting rules and is NOT safe
   from overflows or underflows. The user must ensure that the target dtype
   has the precision and capacity to hold the desired result.

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.cast(ak.linspace(1.0,5.0,5), dt=ak.int64)
   array([1 2 3 4 5])

   >>> ak.cast(ak.arange(0,5), dt=ak.float64).dtype
   dtype('float64')

   >>> ak.cast(ak.arange(0,5), dt=ak.bool_)
   array([False True True True True])

   >>> ak.cast(ak.linspace(0,4,5), dt=ak.bool_)
   array([False True True True True])


.. py:class:: cdouble

   Bases: :py:obj:`numpy.complexfloating`


   Complex number type composed of two double-precision floating-point
       numbers, compatible with Python :class:`complex`.

       :Character code: ``'D'``
       :Canonical name: `numpy.cdouble`
       :Alias on this platform (Linux x86_64): `numpy.complex128`: Complex number type composed of 2 64-bit-precision floating-point numbers.


.. py:function:: ceil(pda: arkouda.numpy.pdarrayclass.pdarray, where: Union[bool, arkouda.numpy.pdarrayclass.pdarray] = True) -> arkouda.numpy.pdarrayclass.pdarray

   Return the element-wise ceiling of the array.

   :param pda:
   :type pda: pdarray
   :param where: This condition is applied over the input. At locations where the condition is True, the
                 corresponding value will be acted on by the function. Elsewhere, it will retain its
                 original value. Default set to True.
   :type where: bool or pdarray, default=True

   :returns: A pdarray containing ceiling values of the input array elements
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.ceil(ak.linspace(1.1,5.5,5))
   array([2.00000000... 3.00000000... 4.00000000... 5.00000000... 6.00000000...])


.. py:function:: chisquare(f_obs, f_exp=None, ddof=0)

   Computes the chi square statistic and p-value.

   :param f_obs: The observed frequency.
   :type f_obs: pdarray
   :param f_exp: The expected frequency.
   :type f_exp: pdarray, default = None
   :param ddof: The delta degrees of freedom.
   :type ddof: int

   :rtype: arkouda.akstats.Power_divergenceResult

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> from arkouda.scipy import chisquare
   >>> chisquare(ak.array([10, 20, 30, 10]), ak.array([10, 30, 20, 10]))
   Power_divergenceResult(statistic=np.float64(8.333333333333334),
       pvalue=np.float64(0.03960235520756414))

   .. seealso:: :py:obj:`scipy.stats.chisquare`, :py:obj:`arkouda.akstats.power_divergence`

   .. rubric:: References

   [1] “Chi-squared test”, https://en.wikipedia.org/wiki/Chi-squared_test

   [2] "scipy.stats.chisquare",
   https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.chisquare.html


.. py:function:: clear() -> None

   Send a clear message to clear all unregistered data from the server symbol table.

   :raises RuntimeError: Raised if there is a server-side error in executing clear request


.. py:function:: clip(pda: arkouda.numpy.pdarrayclass.pdarray, lo: Union[arkouda.numpy.dtypes.numeric_scalars, arkouda.numpy.pdarrayclass.pdarray], hi: Union[arkouda.numpy.dtypes.numeric_scalars, arkouda.numpy.pdarrayclass.pdarray]) -> arkouda.numpy.pdarrayclass.pdarray

   Clip (limit) the values in an array to a given range [lo,hi].

   Given an array a, values outside the range are clipped to the
   range edges, such that all elements lie in the range.

   There is no check to enforce that lo < hi.  If lo > hi, the corresponding
   value of the array will be set to hi.

   If lo or hi (or both) are pdarrays, the check is by pairwise elements.
   See examples.

   :param pda: the array of values to clip
   :type pda: pdarray
   :param lo: the lower value of the clipping range
   :type lo: numeric_scalars or pdarray
   :param hi: the higher value of the clipping range
              If lo or hi (or both) are pdarrays, the check is by pairwise elements.
              See examples.
   :type hi: numeric_scalars or pdarray

   :returns:

             A pdarray matching pda, except that element x remains x if lo <= x <= hi,
                                                     or becomes lo if x < lo,
                                                     or becomes hi if x > hi.
   :rtype: pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.array([1,2,3,4,5,6,7,8,9,10])
   >>> ak.clip(a,3,8)
   array([3 3 3 4 5 6 7 8 8 8])
   >>> ak.clip(a,3,8.0)
   array([3.00000000... 3.00000000... 3.00000000... 4.00000000...
          5.00000000... 6.00000000... 7.00000000... 8.00000000...
          8.00000000... 8.00000000...])
   >>> ak.clip(a,None,7)
   array([1 2 3 4 5 6 7 7 7 7])
   >>> ak.clip(a,5,None)
   array([5 5 5 5 5 6 7 8 9 10])
   >>> ak.clip(a,None,None) # doctest: +SKIP
   ValueError: Either min or max must be supplied.
   >>> ak.clip(a,ak.array([2,2,3,3,8,8,5,5,6,6]),8)
   array([2 2 3 4 8 8 7 8 8 8])
   >>> ak.clip(a,4,ak.array([10,9,8,7,6,5,5,5,5,5]))
   array([4 4 4 4 5 5 5 5 5 5])

   .. rubric:: Notes

   Either lo or hi may be None, but not both.
   If lo > hi, all x = hi.
   If all inputs are int64, output is int64, but if any input is float64, output is float64.

   :raises ValueError: Raised if both lo and hi are None


.. py:class:: clongdouble

   Bases: :py:obj:`numpy.complexfloating`


   Complex number type composed of two extended-precision floating-point
       numbers.

       :Character code: ``'G'``
       :Alias on this platform (Linux x86_64): `numpy.complex256`: Complex number type composed of 2 128-bit extended-precision floating-point numbers.


.. py:function:: clz(pda: pdarray) -> pdarray

   Count leading zeros for each integer in an array.

   :param pda: Input array (must be integral).
   :type pda: pdarray, int64, uint64, bigint

   :returns: The number of leading zeros of each element.
   :rtype: pdarray

   :raises TypeError: If input array is not int64, uint64, or bigint

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> A = ak.arange(10)
   >>> ak.clz(A)
   array([64 63 62 62 61 61 61 61 60 60])


.. py:function:: coargsort(arrays: Sequence[Union[arkouda.numpy.strings.Strings, arkouda.numpy.pdarrayclass.pdarray, arkouda.pandas.categorical.Categorical]], algorithm: SortingAlgorithm = SortingAlgorithm.RadixSortLSD, ascending: bool = True) -> arkouda.numpy.pdarrayclass.pdarray

   Return the permutation that groups the rows (left-to-right), if the
   input arrays are treated as columns. The permutation sorts numeric
   columns, but not Strings or Categoricals — those are grouped, not ordered.

   :param arrays: The columns (int64, uint64, float64, Strings, or Categorical) to sort by row.
   :type arrays: Sequence of Strings, pdarray, or Categorical
   :param algorithm: The algorithm to be used for sorting the arrays.
   :type algorithm: SortingAlgorithm, default=SortingAlgorithm.RadixSortLSD
   :param ascending: Whether to sort in ascending order. Ignored when arrays have ndim > 1.
   :type ascending: bool, default=True

   :returns: The indices that permute the rows into grouped order.
   :rtype: pdarray

   :raises ValueError: If the inputs are not all the same size or not valid array types.

   .. seealso:: :py:obj:`argsort`

   .. rubric:: Notes

   Uses a least-significant-digit radix sort, which is stable and resilient
   to non-uniformity in data but communication intensive. Starts with the
   last array and moves forward.

   For Strings, sorting is based on a hash. This ensures grouping of identical strings,
   but not lexicographic order. For Categoricals, sorting is based on the internal codes.

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.array([0, 1, 0, 1])
   >>> b = ak.array([1, 1, 0, 0])
   >>> perm = ak.coargsort([a, b])
   >>> perm
   array([2 0 3 1])
   >>> a[perm]
   array([0 0 1 1])
   >>> b[perm]
   array([0 1 0 1])


.. py:class:: complex128

   Bases: :py:obj:`numpy.complexfloating`


   Complex number type composed of two double-precision floating-point
       numbers, compatible with Python :class:`complex`.

       :Character code: ``'D'``
       :Canonical name: `numpy.cdouble`
       :Alias on this platform (Linux x86_64): `numpy.complex128`: Complex number type composed of 2 64-bit-precision floating-point numbers.


.. py:class:: complex64

   Bases: :py:obj:`numpy.complexfloating`


   Complex number type composed of two single-precision floating-point
       numbers.

       :Character code: ``'F'``
       :Canonical name: `numpy.csingle`
       :Alias on this platform (Linux x86_64): `numpy.complex64`: Complex number type composed of 2 32-bit-precision floating-point numbers.


.. py:function:: compute_join_size(a: arkouda.numpy.pdarrayclass.pdarray, b: arkouda.numpy.pdarrayclass.pdarray) -> Tuple[int, int]

   Compute the internal size of a hypothetical join between a and b. Returns
   both the number of elements and number of bytes required for the join.


.. py:function:: concatenate(arrays: Sequence[Union[arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.strings.Strings, arkouda.pandas.categorical.Categorical]], axis: int = 0, ordered: bool = True) -> Union[arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.strings.Strings, arkouda.pandas.categorical.Categorical, Sequence[arkouda.pandas.categorical.Categorical]]

   Concatenate a list or tuple of ``pdarray`` or ``Strings`` objects into
   one ``pdarray`` or ``Strings`` object, respectively.

   :param arrays: The arrays to concatenate. Must all have same dtype.
   :type arrays: Sequence[Union[pdarray,Strings,Categorical]]
   :param axis: The axis along which the arrays will be joined.
                If axis is None, arrays are flattened before use. Only for use with pdarray, and when
                ordered is True. Default is 0.
   :type axis: int, default = 0
   :param ordered: If True (default), the arrays will be appended in the
                   order given. If False, array data may be interleaved
                   in blocks, which can greatly improve performance but
                   results in non-deterministic ordering of elements.
   :type ordered: bool

   :returns: Single pdarray or Strings object containing all values, returned in
             the original order
   :rtype: Union[pdarray,Strings,Categorical]

   :raises ValueError: Raised if arrays is empty or if pdarrays have differing dtypes
   :raises TypeError: Raised if arrays is not a pdarrays or Strings python Sequence such as a
       list or tuple
   :raises RuntimeError: Raised if any array elements are dtypes for which
       concatenate has not been implemented.

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.concatenate([ak.array([1, 2, 3]), ak.array([4, 5, 6])])
   array([1 2 3 4 5 6])

   >>> ak.concatenate([ak.array([True,False,True]),ak.array([False,True,True])])
   array([True False True False True True])

   >>> ak.concatenate([ak.array(['one','two']),ak.array(['three','four','five'])])
   array(['one', 'two', 'three', 'four', 'five'])


.. py:function:: copy(a: Union[arkouda.numpy.strings.Strings, arkouda.numpy.pdarrayclass.pdarray]) -> Union[arkouda.numpy.strings.Strings, arkouda.numpy.pdarrayclass.pdarray]

   Return a deep copy of the given Arkouda object.

   :param a: The object to copy.
   :type a: Union[Strings, pdarray]

   :returns: A deep copy of the pdarray or Strings object.
   :rtype: Union[Strings, pdarray]

   :raises TypeError: If the input is not a Strings or pdarray instance.


.. py:function:: corr(x: pdarray, y: pdarray) -> numpy.float64

   Return the correlation between x and y.

   :param x: One of the pdarrays used to calculate correlation
   :type x: pdarray
   :param y: One of the pdarrays used to calculate correlation
   :type y: pdarray

   :returns: The scalar correlation of the two pdarrays
   :rtype: np.float64

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.arange(10)
   >>> b = a + 1
   >>> ak.corr(a,b)
   np.float64(0.9999999999999998)
   >>> a.corr(b)
   np.float64(0.9999999999999998)

   :raises TypeError: Raised if x or y is not a pdarray instance
   :raises RuntimeError: Raised if there's a server-side error thrown

   .. seealso:: :py:obj:`std`, :py:obj:`cov`

   .. rubric:: Notes

   The correlation is calculated by
   cov(x, y) / (x.std(ddof=1) * y.std(ddof=1))


.. py:function:: cos(pda: arkouda.numpy.pdarrayclass.pdarray, where: Union[bool, arkouda.numpy.pdarrayclass.pdarray] = True) -> arkouda.numpy.pdarrayclass.pdarray

   Return the element-wise cosine of the array.

   :param pda:
   :type pda: pdarray
   :param where: This condition is broadcast over the input. At locations where the condition is True,
                 the cosine will be applied to the corresponding value. Elsewhere, it will retain
                 its original value. Default set to True.
   :type where: bool or pdarray, default=True

   :returns: A pdarray containing cosine for each element
             of the original pdarray
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.linspace(-1.5,0.75,4)
   >>> ak.cos(a)
   array([0.07073720... 0.73168886... 1.00000000... 0.73168886...])


.. py:function:: cosh(pda: arkouda.numpy.pdarrayclass.pdarray, where: Union[bool, arkouda.numpy.pdarrayclass.pdarray] = True) -> arkouda.numpy.pdarrayclass.pdarray

   Return the element-wise hyperbolic cosine of the array.

   :param pda:
   :type pda: pdarray
   :param where: This condition is broadcast over the input. At locations where the condition is True,
                 the hyperbolic cosine will be applied to the corresponding value. Elsewhere, it will retain
                 its original value. Default set to True.
   :type where: bool or pdarray, default=True

   :returns: A pdarray containing hyperbolic cosine for each element
             of the original pdarray
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.linspace(-0.9,0.7,4)
   >>> ak.cosh(a)
   array([1.43308638... 1.06797874... 1.01392106... 1.25516900...])


.. py:function:: count_nonzero(pda: arkouda.numpy.pdarrayclass.pdarray) -> arkouda.numpy.dtypes.int_scalars

   Compute the nonzero count of a given array. 1D case only, for now.

   :param pda: The input data, in pdarray form, numeric, bool, or str
   :type pda: pdarray

   :returns: The nonzero count of the entire pdarray
   :rtype: int_scalars

   :raises TypeError: Raised if the parameter is not a pdarray with numeric, bool, or str datatype
   :raises ValueError: Raised if sum applied to the pdarray doesn't come back with a scalar

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> pda = ak.array([0,4,7,8,1,3,5,2,-1])
   >>> ak.count_nonzero(pda)
   np.int64(8)
   >>> pda = ak.array([False,True,False,True,False])
   >>> ak.count_nonzero(pda)
   np.int64(2)
   >>> pda = ak.array(["hello","","there"])
   >>> ak.count_nonzero(pda)
   np.int64(2)


.. py:function:: cov(x: pdarray, y: pdarray) -> numpy.float64

   Return the covariance of x and y.

   :param x: One of the pdarrays used to calculate covariance
   :type x: pdarray
   :param y: One of the pdarrays used to calculate covariance
   :type y: pdarray

   :returns: The scalar covariance of the two pdarrays
   :rtype: np.float64

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.arange(10)
   >>> b = a + 1
   >>> ak.cov(a,b)
   np.float64(9.166666666666666)
   >>> a.cov(b)
   np.float64(9.166666666666666)

   :raises TypeError: Raised if x or y is not a pdarray instance
   :raises RuntimeError: Raised if there's a server-side error thrown

   .. seealso:: :py:obj:`mean`, :py:obj:`var`

   .. rubric:: Notes

   The covariance is calculated by
   ``cov = ((x - x.mean()) * (y - y.mean())).sum() / (x.size - 1)``.


.. py:class:: csingle

   Bases: :py:obj:`numpy.complexfloating`


   Complex number type composed of two single-precision floating-point
       numbers.

       :Character code: ``'F'``
       :Canonical name: `numpy.csingle`
       :Alias on this platform (Linux x86_64): `numpy.complex64`: Complex number type composed of 2 32-bit-precision floating-point numbers.


.. py:function:: ctz(pda: pdarray) -> pdarray

   Count trailing zeros for each integer in an array.

   :param pda: Input array (must be integral).
   :type pda: pdarray, int64, uint64, bigint

   :returns: The number of trailing zeros of each element.
   :rtype: pdarray

   .. rubric:: Notes

   ctz(0) is defined to be zero.

   :raises TypeError: If input array is not int64, uint64, or bigint

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> A = ak.arange(10)
   >>> ak.ctz(A)
   array([0 0 1 0 2 0 1 0 3 0])


.. py:function:: cumprod(pda: arkouda.numpy.pdarrayclass.pdarray, axis: Optional[Union[int, None]] = None) -> arkouda.numpy.pdarrayclass.pdarray

   Return the cumulative product over the array.

   The product is inclusive, such that the ``i`` th element of the
   result is the product of elements up to and including ``i``.

   :param pda:
   :type pda: pdarray
   :param axis: the axis along which to compute the product
   :type axis: int, optional

   :returns: A pdarray containing cumulative products for each element
             of the original pdarray
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray
   :raises ValueError: Raised if an invalid axis is given

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.cumprod(ak.arange(1,5))
   array([1 2 6 24])

   >>> ak.cumprod(ak.uniform(5,1.0,5.0, seed=1))
   array([4.14859379... 5.54704379... 22.20109135... 79.7021268... 298.2655159...])

   >>> ak.cumprod(ak.randint(0, 2, 5, dtype=ak.bool_, seed=1))
   array([1 0 0 0 0])


.. py:function:: cumsum(pda: arkouda.numpy.pdarrayclass.pdarray, axis: Optional[Union[int, None]] = None) -> arkouda.numpy.pdarrayclass.pdarray

   Return the cumulative sum over the array.

   The sum is inclusive, such that the ``i`` th element of the
   result is the sum of elements up to and including ``i``.

   :param pda:
   :type pda: pdarray
   :param axis: the axis along which to compute the sum
   :type axis: int, optional

   :returns: A pdarray containing cumulative sums for each element of the original pdarray
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray
   :raises ValueError: Raised if an invalid axis is given

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.cumsum(ak.arange(1,5))
   array([1 3 6 10])

   >>> ak.cumsum(ak.uniform(5,1.0,5.0, seed=1))
   array([4.14859379... 5.48568392... 9.48801240... 13.0780218... 16.8202747...])

   >>> ak.cumsum(ak.randint(0, 2, 5, dtype=ak.bool_, seed=1))
   array([1 1 2 3 4])


.. py:function:: date_operators(cls)

   Add common datetime operation methods to a DatetimeAccessor class.

   This class decorator dynamically attaches datetime operations (`floor`,
   `ceil`, `round`) to the given class using the `_make_op` helper.

   :param cls: The accessor class to decorate.
   :type cls: type

   :returns: The accessor class with datetime methods added.
   :rtype: type

   .. rubric:: Notes

   Used internally to implement the `.dt` accessor API.


.. py:function:: date_range(start=None, end=None, periods=None, freq=None, tz=None, normalize=False, name=None, inclusive='both', **kwargs)

   Create a fixed frequency Datetime range. Alias for
   ``ak.Datetime(pd.date_range(args))``. Subject to size limit
   imposed by client.maxTransferBytes.

   :param start: Left bound for generating dates.
   :type start: str or datetime-like, optional
   :param end: Right bound for generating dates.
   :type end: str or datetime-like, optional
   :param periods: Number of periods to generate.
   :type periods: int, optional
   :param freq: Frequency strings can have multiples, e.g. '5H'. See
                timeseries.offset_aliases for a list of
                frequency aliases.
   :type freq: str or DateOffset, default 'D'
   :param tz: Time zone name for returning localized DatetimeIndex, for example
              'Asia/Hong_Kong'. By default, the resulting DatetimeIndex is
              timezone-naive.
   :type tz: str or tzinfo, optional
   :param normalize: Normalize start/end dates to midnight before generating date range.
   :type normalize: bool, default False
   :param name: Name of the resulting DatetimeIndex.
   :type name: str, default None
   :param inclusive: Include boundaries. Whether to set each bound as closed or open.
   :type inclusive: {"both", "neither", "left", "right"}, default "both"
   :param \*\*kwargs: For compatibility. Has no effect on the result.

   :returns: **rng**
   :rtype: DatetimeIndex

   .. rubric:: Notes

   Of the four parameters ``start``, ``end``, ``periods``, and ``freq``,
   exactly three must be specified. If ``freq`` is omitted, the resulting
   ``DatetimeIndex`` will have ``periods`` linearly spaced elements between
   ``start`` and ``end`` (closed on both sides).

   To learn more about the frequency strings, please see `this link
   <https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases>`__.


.. py:class:: datetime64

   Bases: :py:obj:`numpy.generic`


   If created from a 64-bit integer, it represents an offset from
       ``1970-01-01T00:00:00``.
       If created from string, the string can be in ISO 8601 date
       or datetime format.

       When parsing a string to create a datetime object, if the string contains
       a trailing timezone (A 'Z' or a timezone offset), the timezone will be
       dropped and a User Warning is given.

       Datetime64 objects should be considered to be UTC and therefore have an
       offset of +0000.

       >>> np.datetime64(10, 'Y')
       np.datetime64('1980')
       >>> np.datetime64('1980', 'Y')
       np.datetime64('1980')
       >>> np.datetime64(10, 'D')
       np.datetime64('1970-01-11')

       See :ref:`arrays.datetime` for more information.

       :Character code: ``'M'``


.. py:function:: deg2rad(pda: arkouda.numpy.pdarrayclass.pdarray, where: Union[bool, arkouda.numpy.pdarrayclass.pdarray] = True) -> arkouda.numpy.pdarrayclass.pdarray

   Converts angles element-wise from degrees to radians.

   :param pda:
   :type pda: pdarray
   :param where: This condition is broadcast over the input. At locations where the condition is True, the
                 corresponding value will be converted from degrees to radians. Elsewhere, it will retain its
                 original value. Default set to True.
   :type where: bool or pdarray, default=True

   :returns: A pdarray containing an angle converted to radians, from degrees, for each element
             of the original pdarray
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.linspace(0,359,4)
   >>> ak.deg2rad(a)
   array([0.00000000... 2.08857733... 4.17715467... 6.26573201...])


.. py:function:: delete(arr: arkouda.numpy.pdarrayclass.pdarray, obj: Union[slice, int, Sequence[int], Sequence[bool], arkouda.numpy.pdarrayclass.pdarray], axis: Optional[int] = None) -> arkouda.numpy.pdarrayclass.pdarray

   Return a copy of 'arr' with elements along the specified axis removed.

   :param arr: The array to remove elements from
   :type arr: pdarray
   :param obj: The indices to remove from 'arr'. If obj is a pdarray, it must
               have an integer or bool dtype.
   :type obj: slice, int, Sequence of int, Sequence of bool, or pdarray
   :param axis: The axis along which to remove elements. If None, the array will
                be flattened before removing elements. Defaults to None.
   :type axis: Optional[int], optional

   :returns: A copy of 'arr' with elements removed
   :rtype: pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> arr = ak.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])
   >>> arr
   array([array([1 2 3 4]) array([5 6 7 8]) array([9 10 11 12])])
   >>> ak.delete(arr, 1, 0)
   array([array([1 2 3 4]) array([9 10 11 12])])

   >>> ak.delete(arr, slice(0, 4, 2), 1)
   array([array([2 4]) array([6 8]) array([10 12])])
   >>> ak.delete(arr, [1, 3, 5], None)
   array([1 3 5 7 8 9 10 11 12])


.. py:function:: diff(a: pdarray, n: int = 1, axis: int = -1, prepend=None, append=None) -> pdarray

   Calculate the n-th discrete difference along the given axis.

   The first difference is given by ``out[i] = a[i+1] - a[i]`` along the given axis,
   higher differences are calculated by using diff iteratively.

   :param a: The array to calculate the difference
   :type a: pdarray
   :param n: The order of the finite difference. Default is 1.
   :type n: int, optional
   :param axis: The axis along which to calculate the difference. Default is the last axis.
   :type axis: int, optional
   :param prepend: The pdarray to prepend to `a` along `axis` before calculating the difference.
   :type prepend: pdarray, optional
   :param append: The pdarray to append to `a` along `axis` before calculating the difference.
   :type append: pdarray, optional

   :returns: The n-th differences. The shape of the output is the same as `a`
             except along `axis` where the dimension is smaller by `n`. The
             type of the output is the same as the type of the difference
             between any two elements of `a`. This is the same as the type of
             `a` in most cases. A notable exception is `datetime64`, which
             results in a `timedelta64` output array.
   :rtype: pdarray

   .. rubric:: Notes

   Type is preserved for boolean arrays, so the result will contain
   `False` when consecutive elements are the same and `True` when they
   differ.

   For unsigned integer arrays, the results will also be unsigned. This
   should not be surprising, as the result is consistent with
   calculating the difference directly.

   If this is not desirable, then the array should be cast to a larger
   integer type first:

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.array([1, 2, 4, 7, 0])
   >>> ak.diff(a)
   array([1 2 3 -7])
   >>> ak.diff(a, n=2)
   array([1 1 -10])

   >>> a = ak.array([[1, 3, 6, 10], [0, 5, 6, 8]])
   >>> ak.diff(a)
   array([array([2 3 4]) array([5 1 2])])
   >>> ak.diff(a, axis=0)
   array([array([-1 2 0 -2])])


.. py:function:: disableVerbose(logLevel: LogLevel = LogLevel.INFO) -> None

   Disables verbose logging.

   Disables verbose logging (DEBUG log level) for all ArkoudaLoggers, setting
   the log level for each to the logLevel parameter.

   :param logLevel: The new log level, defaultts to LogLevel.INFO
   :type logLevel: LogLevel

   :raises TypeError: Raised if logLevel is not a LogLevel enum


.. py:function:: divmod(x: Union[arkouda.numpy.dtypes.numeric_scalars, pdarray], y: Union[arkouda.numpy.dtypes.numeric_scalars, pdarray], where: Union[arkouda.numpy.dtypes.bool_scalars, pdarray] = True) -> Tuple[pdarray, pdarray]

   :param x: The dividend array, the values that will be the numerator of the floordivision and will be
             acted on by the bases for modular division.
   :type x: numeric_scalars(float_scalars, int_scalars) or pdarray
   :param y: The divisor array, the values that will be the denominator of the division and will be the
             bases for the modular division.
   :type y: numeric_scalars(float_scalars, int_scalars) or pdarray
   :param where: This condition is broadcast over the input. At locations where the condition is True, the
                 corresponding value will be divided using floor and modular division. Elsewhere, it will retain
                 its original value. Default set to True.
   :type where: Boolean or pdarray

   :returns: Returns a tuple that contains quotient and remainder of the division
   :rtype: (pdarray, pdarray)

   :raises TypeError: At least one entry must be a pdarray
   :raises ValueError: If both inputs are both pdarrays, their size must match
   :raises ZeroDivisionError: No entry in y is allowed to be 0, to prevent division by zero

   .. rubric:: Notes

   The div is calculated by x // y
   The mod is calculated by x % y

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> x = ak.arange(5, 10)
   >>> y = ak.array([2, 1, 4, 5, 8])
   >>> ak.divmod(x,y)
   (array([2 6 1 1 1]), array([1 0 3 3 1]))
   >>> ak.divmod(x,y, x % 2 == 0)
   (array([5 6 7 1 9]), array([5 0 7 3 9]))


.. py:function:: dot(pda1: Union[int, numpy.int64, numpy.float64, numpy.uint64, pdarray], pda2: Union[int, numpy.int64, numpy.float64, numpy.uint64, pdarray]) -> Union[arkouda.numpy.dtypes.numeric_scalars, numpy.bool, pdarray]

   Computes dot product of two arrays.

   If pda1 and pda2 are 1-D vectors of identical length, returns the conventional dot product.

   If both pda1 and pda2 are scalars, returns their product.

   If one of pda1, pda2 is a scalar, and the other a pdarray, returns the pdarray multiplied
   by the scalar.

   If both pda1 and pda2 are 2-D arrays, returns the matrix multiplication.

   If pda1 is M-D and pda2 is 1-D, returns a sum product over the last axis of pda1 and pda2.

   If pda1 is M-D and pda2 is N-D, returns a sum product over the last axis of pda1 and the
   next-to-last axis of pda2, e.g.:

   For example, If pda1 has rank (3,3,4) and pda2 has rank (4,2), then the result of
   ak.dot(pda1,pda2) has rank (3,3,2), and

   result[i,j,k] = sum( pda1[i, j, :] * pda2[:, k] )

   :param pda1:
   :type pda1: Union[np.int64, np.float64, np.uint64, pdarray],
   :param pda2:
   :type pda2: Union[np.int64, np.float64, np.uint64, pdarray],

   :returns: as described above
   :rtype: Union[numeric_scalars, pdarray]

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.dot(ak.array([1, 2, 3]),ak.array([4,5,6]))
   np.int64(32)
   >>> ak.dot(ak.array([1, 2, 3]),5)
   array([5 10 15])
   >>> ak.dot(5,ak.array([2, 3, 4]))
   array([10 15 20])
   >>> ak.dot(ak.arange(9).reshape(3,3),ak.arange(6).reshape(3,2))
   array([array([10 13]) array([28 40]) array([46 67])])
   >>> ak.dot(ak.arange(27).reshape(3,3,3),ak.array([2,3,4]))
   array([array([11 38 65]) array([92 119 146]) array([173 200 227])])
   >>> ak.dot(ak.arange(36).reshape(3,3,4),ak.arange(8).reshape(4,2))
   array([array([array([28 34]) array([76 98]) array([124 162])]) array([array([172 226])
       array([220 290]) array([268 354])]) array([array([316 418]) array([364 482]) array([412 546])])])

   :raises ValueError: Raised if either pdda1 or pda2 is not an allowed type, or if shapes are incompatible.


.. py:class:: double

   Bases: :py:obj:`numpy.floating`


   Double-precision floating-point number type, compatible with Python
       :class:`float` and C ``double``.

       :Character code: ``'d'``
       :Canonical name: `numpy.double`
       :Alias on this platform (Linux x86_64): `numpy.float64`: 64-bit precision floating-point number type: sign bit, 11 bits exponent, 52 bits mantissa.


   .. py:method:: as_integer_ratio(/)

      double.as_integer_ratio() -> (int, int)

              Return a pair of integers, whose ratio is exactly equal to the original
              floating point number, and with a positive denominator.
              Raise `OverflowError` on infinities and a `ValueError` on NaNs.

              >>> np.double(10.0).as_integer_ratio()
              (10, 1)
              >>> np.double(0.0).as_integer_ratio()
              (0, 1)
              >>> np.double(-.25).as_integer_ratio()
              (-1, 4)



   .. py:method:: fromhex(string, /)

      Create a floating-point number from a hexadecimal string.

      >>> float.fromhex('0x1.ffffp10')
      2047.984375
      >>> float.fromhex('-0x1p-1074')
      -5e-324



   .. py:method:: hex(/)

      Return a hexadecimal representation of a floating-point number.

      >>> (-0.1).hex()
      '-0x1.999999999999ap-4'
      >>> 3.14159.hex()
      '0x1.921f9f01b866ep+1'



   .. py:method:: is_integer(/)

      double.is_integer() -> bool

              Return ``True`` if the floating point number is finite with integral
              value, and ``False`` otherwise.

              .. versionadded:: 1.22

              Examples
              --------
              >>> np.double(-2.0).is_integer()
              True
              >>> np.double(3.2).is_integer()
              False



.. py:function:: dtype(dtype)

   Create a data type object.

   :param dtype: Object to be converted to a data type object.
   :type dtype: object

   :rtype: type


.. py:data:: e
   :type:  float

.. py:function:: enableVerbose() -> None

   Enable verbose logging (DEBUG log level) for all ArkoudaLoggers.


.. py:function:: errstate(*, divide: Optional[_ErrorMode] = None, over: Optional[_ErrorMode] = None, under: Optional[_ErrorMode] = None, invalid: Optional[_ErrorMode] = None, call: Optional[Callable[[str, str], None]] = None) -> Iterator[None]

   Context manager to temporarily set floating-point error handling.

   :param divide: Temporary behavior within the context.
   :type divide: {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional
   :param over: Temporary behavior within the context.
   :type over: {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional
   :param under: Temporary behavior within the context.
   :type under: {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional
   :param invalid: Temporary behavior within the context.
   :type invalid: {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional
   :param call: Temporary callable used if any category is set to 'call'.
                Signature: (errtype: str, message: str) -> None.
   :type call: callable or None, optional

   :Yields: *None* -- This context manager does not return a value. Code inside the ``with``
            block will be executed with the temporary error handling settings.

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.geterr()
   {'divide': 'call', 'over': 'ignore', 'under': 'ignore', 'invalid': 'ignore'}
   >>> with ak.errstate(divide='warn'):
   ...     _ = ak.array([1.0]) / 0  # gives a warning
   >>> ak.geterr()['divide']   # doctest: +SKIP
   'ignore'

   .. rubric:: Notes

   This affects only stored policy; it does not add runtime checks by itself.


.. py:data:: euler_gamma
   :type:  float

.. py:function:: exp(pda: arkouda.numpy.pdarrayclass.pdarray) -> arkouda.numpy.pdarrayclass.pdarray

   Return the element-wise exponential of the array.

   :param pda:
   :type pda: pdarray

   :returns: A pdarray containing exponential values of the input
             array elements
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.exp(ak.arange(1,5))
   array([2.71828182... 7.38905609... 20.0855369... 54.5981500...])

   >>> ak.exp(ak.uniform(4, 1.0, 5.0, seed=1))
   array([63.3448620... 3.80794671... 54.7254287... 36.2344168...])


.. py:function:: expm1(pda: arkouda.numpy.pdarrayclass.pdarray) -> arkouda.numpy.pdarrayclass.pdarray

   Return the element-wise exponential of the array minus one.

   :param pda:
   :type pda: pdarray

   :returns: A pdarray containing e raised to each of the inputs,
             then subtracting one.
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.expm1(ak.arange(1,5))
   array([1.71828182... 6.38905609... 19.0855369... 53.5981500...])

   >>> ak.expm1(ak.uniform(5,1.0,5.0, seed=1))
   array([62.3448620... 2.80794671... 53.7254287...
       35.2344168... 41.1929399...])


.. py:function:: eye(N: arkouda.numpy.dtypes.int_scalars, M: arkouda.numpy.dtypes.int_scalars, k: arkouda.numpy.dtypes.int_scalars = 0, dt: type = ak_float64) -> arkouda.numpy.pdarrayclass.pdarray

   Return a pdarray with zeros everywhere except along a diagonal, which is all ones.
   The matrix need not be square.

   :param N:
   :type N: int_scalars
   :param M:
   :type M: int_scalars
   :param k: | if k = 0, zeros start at element [0,0] and proceed along diagonal
             | if k > 0, zeros start at element [0,k] and proceed along diagonal
             | if k < 0, zeros start at element [k,0] and proceed along diagonal
   :type k: int_scalars, default=0
   :param dt: The data type of the elements in the matrix being returned. Default set to ak_float64
   :type dt: type, default=ak_float64

   :returns: an array of zeros with ones along the specified diagonal
   :rtype: pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.eye(N=4,M=4,k=0,dt=ak.int64)
   array([array([1 0 0 0]) array([0 1 0 0]) array([0 0 1 0]) array([0 0 0 1])])
   >>> ak.eye(N=3,M=3,k=1,dt=ak.float64)
   array([array([0.00000000... 1.00000000... 0.00000000...])
   array([0.00000000... 0.00000000... 1.00000000...])
   array([0.00000000... 0.00000000... 0.00000000...])])
   >>> ak.eye(N=4,M=4,k=-1,dt=ak.bool_)
   array([array([False False False False]) array([True False False False])
   array([False True False False]) array([False False True False])])

   .. rubric:: Notes

   if N = M and k = 0, the result is an identity matrix
   Server returns an error if rank of pda < 2


.. py:function:: fabs(pda: arkouda.numpy.pdarrayclass.pdarray) -> arkouda.numpy.pdarrayclass.pdarray

   Compute the absolute values element-wise, casting to a float beforehand.

   :param pda:
   :type pda: pdarray

   :returns: A pdarray containing absolute values of the input array elements, casted to float type
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.fabs(ak.arange(-5,-1))
   array([5.00000000000000000 4.00000000000000000 3.00000000000000000 2.00000000000000000])

   >>> ak.fabs(ak.linspace(-5,-1,5))
   array([5.00000000... 4.00000000... 3.00000000...
   2.00000000... 1.00000000...])


.. py:function:: find(query, space, all_occurrences=False, remove_missing=False)

   Return indices of query items in a search list of items.

   :param query: The items to search for. If multiple arrays, each "row" is an item.
   :type query: (sequence of) array-like
   :param space: The set of items in which to search. Must have same shape/dtype as query.
   :type space: (sequence of) array-like
   :param all_occurrences: When duplicate terms are present in search space, if all_occurrences is True,
                           return all occurrences found as a SegArray, otherwise return only the first
                           occurrences as a pdarray. Defaults to only finding the first occurrence.
                           Finding all occurrences is not yet supported on sequences of arrays
   :type all_occurrences: bool
   :param remove_missing: If all_occurrences is True, remove_missing is automatically enabled.
                          If False, return -1 for any items in query not found in space. If True,
                          remove these and only return indices of items that are found.
   :type remove_missing: bool

   :returns: **indices** -- For each item in query, its index in space. If all_occurrences is False,
             the return will be a pdarray of the first index where each value in the
             query appears in the space. If all_occurrences is True, the return will be
             a SegArray containing every index where each value in the query appears in
             the space. If all_occurrences is True, remove_missing is automatically enabled.
             If remove_missing is True, exclude missing values, otherwise return -1.
   :rtype: pdarray or SegArray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> select_from = ak.arange(10)
   >>> arr1 = select_from[ak.randint(0, select_from.size, 20, seed=10)]
   >>> arr2 = select_from[ak.randint(0, select_from.size, 20, seed=11)]

   Remove some values to ensure we have some values
   which don't appear in the search space

   >>> arr2 = arr2[arr2 != 9]
   >>> arr2 = arr2[arr2 != 3]

   Find with defaults (all_occurrences and remove_missing both False)

   >>> ak.find(arr1, arr2)
   array([-1 -1 -1 0 1 -1 -1 -1 2 -1 5 -1 8 -1 5 -1 -1 11 5 0])

   Set remove_missing to True, only difference from default
   is missing values are excluded

   >>> ak.find(arr1, arr2, remove_missing=True)
   array([0 1 2 5 8 5 11 5 0])

   Set both remove_missing and all_occurrences to True, missing values
   will be empty segments

   >>> ak.find(arr1, arr2, remove_missing=True, all_occurrences=True).tolist()
   [[],
    [],
    [],
    [0, 4],
    [1, 3, 10],
    [],
    [],
    [],
    [2, 6, 12, 13],
    [],
    [5, 7],
    [],
    [8, 9, 14],
    [],
    [5, 7],
    [],
    [],
    [11, 15],
    [5, 7],
    [0, 4]]


.. py:class:: finfo

   finfo(dtype)

   Machine limits for floating point types.

   .. attribute:: bits

      The number of bits occupied by the type.

      :type: int

   .. attribute:: dtype

      Returns the dtype for which `finfo` returns information. For complex
      input, the returned dtype is the associated ``float*`` dtype for its
      real and complex components.

      :type: dtype

   .. attribute:: eps

      The difference between 1.0 and the next smallest representable float
      larger than 1.0. For example, for 64-bit binary floats in the IEEE-754
      standard, ``eps = 2**-52``, approximately 2.22e-16.

      :type: float

   .. attribute:: epsneg

      The difference between 1.0 and the next smallest representable float
      less than 1.0. For example, for 64-bit binary floats in the IEEE-754
      standard, ``epsneg = 2**-53``, approximately 1.11e-16.

      :type: float

   .. attribute:: iexp

      The number of bits in the exponent portion of the floating point
      representation.

      :type: int

   .. attribute:: machep

      The exponent that yields `eps`.

      :type: int

   .. attribute:: max

      The largest representable number.

      :type: floating point number of the appropriate type

   .. attribute:: maxexp

      The smallest positive power of the base (2) that causes overflow.

      :type: int

   .. attribute:: min

      The smallest representable number, typically ``-max``.

      :type: floating point number of the appropriate type

   .. attribute:: minexp

      The most negative power of the base (2) consistent with there
      being no leading 0's in the mantissa.

      :type: int

   .. attribute:: negep

      The exponent that yields `epsneg`.

      :type: int

   .. attribute:: nexp

      The number of bits in the exponent including its sign and bias.

      :type: int

   .. attribute:: nmant

      The number of bits in the mantissa.

      :type: int

   .. attribute:: precision

      The approximate number of decimal digits to which this kind of
      float is precise.

      :type: int

   .. attribute:: resolution

      The approximate decimal resolution of this type, i.e.,
      ``10**-precision``.

      :type: floating point number of the appropriate type

   .. attribute:: tiny

      An alias for `smallest_normal`, kept for backwards compatibility.

      :type: float

   .. attribute:: smallest_normal

      The smallest positive floating point number with 1 as leading bit in
      the mantissa following IEEE-754 (see Notes).

      :type: float

   .. attribute:: smallest_subnormal

      The smallest positive floating point number with 0 as leading bit in
      the mantissa following IEEE-754.

      :type: float

   :param dtype: Kind of floating point or complex floating point
                 data-type about which to get information.
   :type dtype: float, dtype, or instance

   .. seealso::

      :py:obj:`iinfo`
          The equivalent for integer data types.

      :py:obj:`spacing`
          The distance between a value and the nearest adjacent number

      :py:obj:`nextafter`
          The next floating point value after x1 towards x2

   .. rubric:: Notes

   For developers of NumPy: do not instantiate this at the module level.
   The initial calculation of these parameters is expensive and negatively
   impacts import times.  These objects are cached, so calling ``finfo()``
   repeatedly inside your functions is not a problem.

   Note that ``smallest_normal`` is not actually the smallest positive
   representable value in a NumPy floating point type. As in the IEEE-754
   standard [1]_, NumPy floating point types make use of subnormal numbers to
   fill the gap between 0 and ``smallest_normal``. However, subnormal numbers
   may have significantly reduced precision [2]_.

   This function can also be used for complex data types as well. If used,
   the output will be the same as the corresponding real float type
   (e.g. numpy.finfo(numpy.csingle) is the same as numpy.finfo(numpy.single)).
   However, the output is true for the real and imaginary components.

   .. rubric:: References

   .. [1] IEEE Standard for Floating-Point Arithmetic, IEEE Std 754-2008,
          pp.1-70, 2008, https://doi.org/10.1109/IEEESTD.2008.4610935
   .. [2] Wikipedia, "Denormal Numbers",
          https://en.wikipedia.org/wiki/Denormal_number

   .. rubric:: Examples

   >>> import numpy as np
   >>> np.finfo(np.float64).dtype
   dtype('float64')
   >>> np.finfo(np.complex64).dtype
   dtype('float32')


   .. py:property:: smallest_normal

      Return the value for the smallest normal.

      :returns: **smallest_normal** -- Value for the smallest normal.
      :rtype: float

      :Warns: **UserWarning** -- If the calculated value for the smallest normal is requested for
              double-double.


   .. py:property:: tiny

      Return the value for tiny, alias of smallest_normal.

      :returns: **tiny** -- Value for the smallest normal, alias of smallest_normal.
      :rtype: float

      :Warns: **UserWarning** -- If the calculated value for the smallest normal is requested for
              double-double.


.. py:class:: flexible

   Bases: :py:obj:`numpy.generic`


   Abstract base class of all scalar types without predefined length.
       The actual size of these types depends on the specific `numpy.dtype`
       instantiation.


.. py:function:: flip(x: arkouda.numpy.pdarrayclass.pdarray, /, *, axis: Optional[Union[arkouda.numpy.dtypes.int_scalars, Tuple[arkouda.numpy.dtypes.int_scalars, Ellipsis]]] = None) -> arkouda.numpy.pdarrayclass.pdarray
                 flip(x: arkouda.numpy.strings.Strings, /, *, axis: Optional[Union[arkouda.numpy.dtypes.int_scalars, Tuple[arkouda.numpy.dtypes.int_scalars, Ellipsis]]] = None) -> arkouda.numpy.strings.Strings
                 flip(x: arkouda.pandas.categorical.Categorical, /, *, axis: Optional[Union[arkouda.numpy.dtypes.int_scalars, Tuple[arkouda.numpy.dtypes.int_scalars, Ellipsis]]] = None) -> arkouda.pandas.categorical.Categorical

   Reverse an array's values along a particular axis or axes.

   :param x: Reverse the order of elements in an array along the given axis.

             The shape of the array is preserved, but the elements are reordered.
   :type x: pdarray, Strings, or Categorical
   :param axis: The axis or axes along which to flip the array. If None, flip the array along all axes.
   :type axis: int or Tuple[int, ...], optional

   :returns: An array with the entries of axis reversed.
   :rtype: pdarray, Strings, or Categorical

   :raises IndexError: Raised if operation fails server-side.

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.arange(12)
   >>> ak.flip(a)
   array([11 10 9 8 7 6 5 4 3 2 1 0])

   .. note:: This differs from numpy as it actually reverses the data, rather than presenting a view.


.. py:class:: float16

   Bases: :py:obj:`numpy.floating`


   Half-precision floating-point number type.

       :Character code: ``'e'``
       :Canonical name: `numpy.half`
       :Alias on this platform (Linux x86_64): `numpy.float16`: 16-bit-precision floating-point number type: sign bit, 5 bits exponent, 10 bits mantissa.


   .. py:method:: as_integer_ratio(/)

      half.as_integer_ratio() -> (int, int)

              Return a pair of integers, whose ratio is exactly equal to the original
              floating point number, and with a positive denominator.
              Raise `OverflowError` on infinities and a `ValueError` on NaNs.

              >>> np.half(10.0).as_integer_ratio()
              (10, 1)
              >>> np.half(0.0).as_integer_ratio()
              (0, 1)
              >>> np.half(-.25).as_integer_ratio()
              (-1, 4)



   .. py:method:: is_integer(/)

      half.is_integer() -> bool

              Return ``True`` if the floating point number is finite with integral
              value, and ``False`` otherwise.

              .. versionadded:: 1.22

              Examples
              --------
              >>> np.half(-2.0).is_integer()
              True
              >>> np.half(3.2).is_integer()
              False



.. py:class:: float32

   Bases: :py:obj:`numpy.floating`


   Single-precision floating-point number type, compatible with C ``float``.

       :Character code: ``'f'``
       :Canonical name: `numpy.single`
       :Alias on this platform (Linux x86_64): `numpy.float32`: 32-bit-precision floating-point number type: sign bit, 8 bits exponent, 23 bits mantissa.


   .. py:method:: as_integer_ratio(/)

      single.as_integer_ratio() -> (int, int)

              Return a pair of integers, whose ratio is exactly equal to the original
              floating point number, and with a positive denominator.
              Raise `OverflowError` on infinities and a `ValueError` on NaNs.

              >>> np.single(10.0).as_integer_ratio()
              (10, 1)
              >>> np.single(0.0).as_integer_ratio()
              (0, 1)
              >>> np.single(-.25).as_integer_ratio()
              (-1, 4)



   .. py:method:: is_integer(/)

      single.is_integer() -> bool

              Return ``True`` if the floating point number is finite with integral
              value, and ``False`` otherwise.

              .. versionadded:: 1.22

              Examples
              --------
              >>> np.single(-2.0).is_integer()
              True
              >>> np.single(3.2).is_integer()
              False



.. py:class:: float64

   Bases: :py:obj:`numpy.floating`


   Double-precision floating-point number type, compatible with Python
       :class:`float` and C ``double``.

       :Character code: ``'d'``
       :Canonical name: `numpy.double`
       :Alias on this platform (Linux x86_64): `numpy.float64`: 64-bit precision floating-point number type: sign bit, 11 bits exponent, 52 bits mantissa.


   .. py:method:: as_integer_ratio(/)

      double.as_integer_ratio() -> (int, int)

              Return a pair of integers, whose ratio is exactly equal to the original
              floating point number, and with a positive denominator.
              Raise `OverflowError` on infinities and a `ValueError` on NaNs.

              >>> np.double(10.0).as_integer_ratio()
              (10, 1)
              >>> np.double(0.0).as_integer_ratio()
              (0, 1)
              >>> np.double(-.25).as_integer_ratio()
              (-1, 4)



   .. py:method:: fromhex(string, /)

      Create a floating-point number from a hexadecimal string.

      >>> float.fromhex('0x1.ffffp10')
      2047.984375
      >>> float.fromhex('-0x1p-1074')
      -5e-324



   .. py:method:: hex(/)

      Return a hexadecimal representation of a floating-point number.

      >>> (-0.1).hex()
      '-0x1.999999999999ap-4'
      >>> 3.14159.hex()
      '0x1.921f9f01b866ep+1'



   .. py:method:: is_integer(/)

      double.is_integer() -> bool

              Return ``True`` if the floating point number is finite with integral
              value, and ``False`` otherwise.

              .. versionadded:: 1.22

              Examples
              --------
              >>> np.double(-2.0).is_integer()
              True
              >>> np.double(3.2).is_integer()
              False



.. py:class:: float_scalars

   Bases: :py:obj:`_NotIterable`


   Mixin to prevent iteration, without being compatible with Iterable.

   That is, we could do::

       def __iter__(self): raise TypeError()

   But this would make users of this mixin duck type-compatible with
   collections.abc.Iterable - isinstance(foo, Iterable) would be True.

   Luckily, we can instead prevent iteration by setting __iter__ to None, which
   is treated specially.


   .. py:method:: copy_with(params)


.. py:class:: floating

   Bases: :py:obj:`numpy.inexact`


   Abstract base class of all floating-point scalar types.


.. py:function:: floor(pda: arkouda.numpy.pdarrayclass.pdarray, where: Union[bool, arkouda.numpy.pdarrayclass.pdarray] = True) -> arkouda.numpy.pdarrayclass.pdarray

   Return the element-wise floor of the array.

   :param pda:
   :type pda: pdarray
   :param where: This condition is applied over the input. At locations where the condition is True, the
                 corresponding value will be acted on by the function. Elsewhere, it will retain its
                 original value. Default set to True.
   :type where: bool or pdarray, default=True

   :returns: A pdarray containing floor values of the input array elements
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.floor(ak.linspace(1.1,5.5,5))
   array([1.00000000... 2.00000000... 3.00000000...
   4.00000000... 5.00000000...])


.. py:function:: fmod(dividend: Union[pdarray, arkouda.numpy.dtypes.numeric_scalars], divisor: Union[pdarray, arkouda.numpy.dtypes.numeric_scalars]) -> pdarray

   Returns the element-wise remainder of division.

   It is equivalent to np.fmod, the remainder has the same sign as the dividend.

   :param dividend: The array being acted on by the bases for the modular division.
   :type dividend: numeric scalars or pdarray
   :param divisor: The array that will be the bases for the modular division.
   :type divisor: numeric scalars or pdarray

   :returns: an array that contains the element-wise remainder of division.
   :rtype: pdarray

   :raises TypeError: Raised if neither dividend nor divisor is a pdarray (at least one must be)
       or if any scalar or pdarray element is not one of int, uint, float, bigint


.. py:function:: format_float_positional(x, precision=None, unique=True, fractional=True, trim='k', sign=False, pad_left=None, pad_right=None, min_digits=None)

   Format a floating-point scalar as a decimal string in positional notation.

   Provides control over rounding, trimming and padding. Uses and assumes
   IEEE unbiased rounding. Uses the "Dragon4" algorithm.

   :param x: Value to format.
   :type x: python float or numpy floating scalar
   :param precision: Maximum number of digits to print. May be None if `unique` is
                     `True`, but must be an integer if unique is `False`.
   :type precision: non-negative integer or None, optional
   :param unique: If `True`, use a digit-generation strategy which gives the shortest
                  representation which uniquely identifies the floating-point number from
                  other values of the same type, by judicious rounding. If `precision`
                  is given fewer digits than necessary can be printed, or if `min_digits`
                  is given more can be printed, in which cases the last digit is rounded
                  with unbiased rounding.
                  If `False`, digits are generated as if printing an infinite-precision
                  value and stopping after `precision` digits, rounding the remaining
                  value with unbiased rounding
   :type unique: boolean, optional
   :param fractional: If `True`, the cutoffs of `precision` and `min_digits` refer to the
                      total number of digits after the decimal point, including leading
                      zeros.
                      If `False`, `precision` and `min_digits` refer to the total number of
                      significant digits, before or after the decimal point, ignoring leading
                      zeros.
   :type fractional: boolean, optional
   :param trim: Controls post-processing trimming of trailing digits, as follows:

                * 'k' : keep trailing zeros, keep decimal point (no trimming)
                * '.' : trim all trailing zeros, leave decimal point
                * '0' : trim all but the zero before the decimal point. Insert the
                  zero if it is missing.
                * '-' : trim trailing zeros and any trailing decimal point
   :type trim: one of 'k', '.', '0', '-', optional
   :param sign: Whether to show the sign for positive values.
   :type sign: boolean, optional
   :param pad_left: Pad the left side of the string with whitespace until at least that
                    many characters are to the left of the decimal point.
   :type pad_left: non-negative integer, optional
   :param pad_right: Pad the right side of the string with whitespace until at least that
                     many characters are to the right of the decimal point.
   :type pad_right: non-negative integer, optional
   :param min_digits: Minimum number of digits to print. Only has an effect if `unique=True`
                      in which case additional digits past those necessary to uniquely
                      identify the value may be printed, rounding the last additional digit.

                      .. versionadded:: 1.21.0
   :type min_digits: non-negative integer or None, optional

   :returns: **rep** -- The string representation of the floating point value
   :rtype: string

   .. seealso:: :py:obj:`format_float_scientific`

   .. rubric:: Examples

   >>> import numpy as np
   >>> np.format_float_positional(np.float32(np.pi))
   '3.1415927'
   >>> np.format_float_positional(np.float16(np.pi))
   '3.14'
   >>> np.format_float_positional(np.float16(0.3))
   '0.3'
   >>> np.format_float_positional(np.float16(0.3), unique=False, precision=10)
   '0.3000488281'


.. py:function:: format_float_scientific(x, precision=None, unique=True, trim='k', sign=False, pad_left=None, exp_digits=None, min_digits=None)

   Format a floating-point scalar as a decimal string in scientific notation.

   Provides control over rounding, trimming and padding. Uses and assumes
   IEEE unbiased rounding. Uses the "Dragon4" algorithm.

   :param x: Value to format.
   :type x: python float or numpy floating scalar
   :param precision: Maximum number of digits to print. May be None if `unique` is
                     `True`, but must be an integer if unique is `False`.
   :type precision: non-negative integer or None, optional
   :param unique: If `True`, use a digit-generation strategy which gives the shortest
                  representation which uniquely identifies the floating-point number from
                  other values of the same type, by judicious rounding. If `precision`
                  is given fewer digits than necessary can be printed. If `min_digits`
                  is given more can be printed, in which cases the last digit is rounded
                  with unbiased rounding.
                  If `False`, digits are generated as if printing an infinite-precision
                  value and stopping after `precision` digits, rounding the remaining
                  value with unbiased rounding
   :type unique: boolean, optional
   :param trim: Controls post-processing trimming of trailing digits, as follows:

                * 'k' : keep trailing zeros, keep decimal point (no trimming)
                * '.' : trim all trailing zeros, leave decimal point
                * '0' : trim all but the zero before the decimal point. Insert the
                  zero if it is missing.
                * '-' : trim trailing zeros and any trailing decimal point
   :type trim: one of 'k', '.', '0', '-', optional
   :param sign: Whether to show the sign for positive values.
   :type sign: boolean, optional
   :param pad_left: Pad the left side of the string with whitespace until at least that
                    many characters are to the left of the decimal point.
   :type pad_left: non-negative integer, optional
   :param exp_digits: Pad the exponent with zeros until it contains at least this
                      many digits. If omitted, the exponent will be at least 2 digits.
   :type exp_digits: non-negative integer, optional
   :param min_digits: Minimum number of digits to print. This only has an effect for
                      `unique=True`. In that case more digits than necessary to uniquely
                      identify the value may be printed and rounded unbiased.

                      .. versionadded:: 1.21.0
   :type min_digits: non-negative integer or None, optional

   :returns: **rep** -- The string representation of the floating point value
   :rtype: string

   .. seealso:: :py:obj:`format_float_positional`

   .. rubric:: Examples

   >>> import numpy as np
   >>> np.format_float_scientific(np.float32(np.pi))
   '3.1415927e+00'
   >>> s = np.float32(1.23e24)
   >>> np.format_float_scientific(s, unique=False, precision=15)
   '1.230000071797338e+24'
   >>> np.format_float_scientific(s, exp_digits=4)
   '1.23e+0024'


.. py:function:: from_series(series: pandas.Series, dtype: Optional[Union[type, str]] = None) -> Union[arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.strings.Strings]

   Converts a Pandas Series to an Arkouda pdarray or Strings object. If
   dtype is None, the dtype is inferred from the Pandas Series. Otherwise,
   the dtype parameter is set if the dtype of the Pandas Series is to be
   overridden or is  unknown (for example, in situations where the Series
   dtype is object).

   :param series: The Pandas Series with a dtype of bool, float64, int64, or string
   :type series: Pandas Series
   :param dtype: The valid dtype types are np.bool, np.float64, np.int64, and np.str
   :type dtype: Optional[type]

   :rtype: Union[pdarray,Strings]

   :raises TypeError: Raised if series is not a Pandas Series object
   :raises ValueError: Raised if the Series dtype is not bool, float64, int64, string, datetime, or timedelta

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> np.random.seed(1701)
   >>> ak.from_series(pd.Series(np.random.randint(0,10,5)))
   array([4 3 3 5 0])

   >>> ak.from_series(pd.Series(['1', '2', '3', '4', '5']),dtype=np.int64)
   array([1 2 3 4 5])

   >>> np.random.seed(1701)
   >>> ak.from_series(pd.Series(np.random.uniform(low=0.0,high=1.0,size=3)))
   array([0.089433234324597599 0.1153776854774361 0.51874393620990389])

   >>> ak.from_series(
   ...     pd.Series([
   ...         '0.57600036956445599',
   ...         '0.41619265571741659',
   ...         '0.6615356693784662',
   ...     ]),
   ...     dtype=np.float64,
   ... )
   array([0.57600036956445599 0.41619265571741659 0.6615356693784662])

   >>> np.random.seed(1864)
   >>> ak.from_series(pd.Series(np.random.choice([True, False],size=5)))
   array([True True True False False])

   >>> ak.from_series(pd.Series(['True', 'False', 'False', 'True', 'True']), dtype=bool)
   array([True True True True True])

   >>> ak.from_series(pd.Series(['a', 'b', 'c', 'd', 'e'], dtype="string"))
   array(['a', 'b', 'c', 'd', 'e'])

   >>> ak.from_series(pd.Series(pd.to_datetime(['1/1/2018', np.datetime64('2018-01-01')])))
   array([1514764800000000000 1514764800000000000])

   .. rubric:: Notes

   The supported datatypes are bool, float64, int64, string, and datetime64[ns]. The
   data type is either inferred from the the Series or is set via the dtype parameter.

   Series of datetime or timedelta are converted to Arkouda arrays of dtype int64 (nanoseconds)

   A Pandas Series containing strings has a dtype of object. Arkouda assumes the Series
   contains strings and sets the dtype to str


.. py:function:: full(size: Union[arkouda.numpy.dtypes.int_scalars, Tuple[arkouda.numpy.dtypes.int_scalars, Ellipsis], str], fill_value: Union[arkouda.numpy.dtypes.numeric_scalars, numpy.bool, str], dtype: Union[numpy.dtype, type, str, arkouda.numpy.dtypes.bigint] = float64, max_bits: Optional[int] = None) -> Union[arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.strings.Strings]

   Create a pdarray filled with fill_value.

   :param size: Size or shape of the array
   :type size: int_scalars or tuple of int_scalars
   :param fill_value: Value with which the array will be filled
   :type fill_value: int_scalars or str
   :param dtype: Resulting array type, default float64
   :type dtype: all_scalars
   :param max_bits: Specifies the maximum number of bits; only used for bigint pdarrays
   :type max_bits: int

   :returns: array of the requested size and dtype filled with fill_value
   :rtype: pdarray or Strings

   :raises TypeError: Raised if the supplied dtype is not supported
   :raises RuntimeError: Raised if the size parameter is neither an int nor a str that is parseable to an int.
   :raises ValueError: Raised if the rank of the given shape is not in get_array_ranks() or is empty
       Raised if max_bits is not NONE and ndim does not equal 1

   .. seealso:: :py:obj:`zeros`, :py:obj:`ones`

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.full(5, 7, dtype=ak.int64)
   array([7 7 7 7 7])

   >>> ak.full(5, 9, dtype=ak.float64)
   array([9.00000000000000000 9.00000000000000000 9.00000000000000000
          9.00000000000000000 9.00000000000000000])

   >>> ak.full(5, 5, dtype=ak.bool_)
   array([True True True True True])


.. py:function:: full_like(pda: arkouda.numpy.pdarrayclass.pdarray, fill_value: arkouda.numpy.dtypes.numeric_scalars) -> Union[arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.strings.Strings]

   Create a pdarray filled with fill_value of the same size and dtype as an existing
   pdarray.

   :param pda: Array to use for size and dtype
   :type pda: pdarray
   :param fill_value: Value with which the array will be filled
   :type fill_value: int_scalars

   :returns: Equivalent to ak.full(pda.size, fill_value, pda.dtype)
   :rtype: pdarray

   :raises TypeError: Raised if the pda parameter is not a pdarray.

   .. seealso:: :py:obj:`ones_like`, :py:obj:`zeros_like`

   .. rubric:: Notes

   Logic for generating the pdarray is delegated to the ak.full method.
   Accordingly, the supported dtypes match are defined by the ak.full method.

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.full_like(ak.full(5,7,dtype=ak.int64),6)
   array([6 6 6 6 6])

   >>> ak.full_like(ak.full(7,9,dtype=ak.float64),10)
   array([10.00000000000000000 10.00000000000000000 10.00000000000000000
          10.00000000000000000 10.00000000000000000 10.00000000000000000 10.00000000000000000])

   >>> ak.full_like(ak.full(5,True,dtype=ak.bool_),False)
   array([False False False False False])


.. py:function:: gen_ranges(starts, ends, stride=1, return_lengths=False)

   Generate a segmented array of variable-length, contiguous ranges between pairs of
   start- and end-points.

   :param starts: The start value of each range
   :type starts: pdarray, int64
   :param ends: The end value (exclusive) of each range
   :type ends: pdarray, int64
   :param stride: Difference between successive elements of each range
   :type stride: int
   :param return_lengths: Whether or not to return the lengths of each segment. Default False.
   :type return_lengths: bool, optional

   :returns:

             segments : pdarray, int64
                 The starting index of each range in the resulting array
             ranges : pdarray, int64
                 The actual ranges, flattened into a single array
             lengths : pdarray, int64
                 The lengths of each segment. Only returned if return_lengths=True.
   :rtype: pdarray|int64, pdarray|int64, pdarray|int64


.. py:function:: get_byteorder(dt: np.dtype) -> str

   Get a concrete byteorder (turns '=' into '<' or '>') on the client.

   :param dt: The numpy dtype to determine the byteorder of.
   :type dt: np.dtype

   :returns: Returns "<" for little endian and ">" for big endian.
   :rtype: str

   :raises ValueError: Returned if sys.byteorder is not "little" or "big"

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.get_byteorder(ak.dtype(ak.int64))
   '<'


.. py:function:: get_server_byteorder() -> str

   Get the server's byteorder.

   :returns: Returns "little" for little endian and "big" for big endian.
   :rtype: str

   :raises ValueError: Raised if Server byteorder is not 'little' or 'big'

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.get_server_byteorder()
   'little'


.. py:function:: geterr() -> Dict[str, _ErrorMode]

   Get the current Arkouda floating-point error handling settings.

   :returns: Mapping of {'divide', 'over', 'under', 'invalid'} to one of
             {'ignore', 'warn', 'raise', 'call', 'print', 'log'}.
   :rtype: dict


.. py:function:: geterrcall() -> Optional[Callable[[str, str], None]]

   Get the current callable used when error mode is 'call'.

   :returns: A function of signature (errtype: str, message: str) -> None, or None.
   :rtype: callable or None


.. py:class:: half

   Bases: :py:obj:`numpy.floating`


   Half-precision floating-point number type.

       :Character code: ``'e'``
       :Canonical name: `numpy.half`
       :Alias on this platform (Linux x86_64): `numpy.float16`: 16-bit-precision floating-point number type: sign bit, 5 bits exponent, 10 bits mantissa.


   .. py:method:: as_integer_ratio(/)

      half.as_integer_ratio() -> (int, int)

              Return a pair of integers, whose ratio is exactly equal to the original
              floating point number, and with a positive denominator.
              Raise `OverflowError` on infinities and a `ValueError` on NaNs.

              >>> np.half(10.0).as_integer_ratio()
              (10, 1)
              >>> np.half(0.0).as_integer_ratio()
              (0, 1)
              >>> np.half(-.25).as_integer_ratio()
              (-1, 4)



   .. py:method:: is_integer(/)

      half.is_integer() -> bool

              Return ``True`` if the floating point number is finite with integral
              value, and ``False`` otherwise.

              .. versionadded:: 1.22

              Examples
              --------
              >>> np.half(-2.0).is_integer()
              True
              >>> np.half(3.2).is_integer()
              False



.. py:function:: hash(pda: Union[Union[arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.strings.Strings, arkouda.numpy.segarray.SegArray, arkouda.pandas.categorical.Categorical], List[Union[arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.strings.Strings, arkouda.numpy.segarray.SegArray, arkouda.pandas.categorical.Categorical]]], full: bool = True) -> Union[Tuple[arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.pdarrayclass.pdarray], arkouda.numpy.pdarrayclass.pdarray]

   Return an element-wise hash of the array or list of arrays.

   :param pda:
   :type pda: pdarray, Strings, SegArray, or Categorical     or List of pdarray, Strings, SegArray, or Categorical
   :param full: This is only used when a single pdarray is passed into hash
                By default, a 128-bit hash is computed and returned as
                two int64 arrays. If full=False, then a 64-bit hash
                is computed and returned as a single int64 array.
   :type full: bool, default=True

   :returns: If full=True or a list of pdarrays is passed,
             a 2-tuple of pdarrays containing the high
             and low 64 bits of each hash, respectively.
             If full=False and a single pdarray is passed,
             a single pdarray containing a 64-bit hash
   :rtype: hashes

   :raises TypeError: Raised if the parameter is not a pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.randint(0,65536,3,seed=8675309)
   >>> ak.hash(a,full=False)
   array([6132219720275344925 189443193828113335 14797568559700425150])
   >>> ak.hash(a)
   (array([12228890592923494910 17773622519799422780 16661993598191972647]),
       array([2936052102410048944 15730675498625067356 4746877828134486787]))

   .. rubric:: Notes

   In the case of a single pdarray being passed, this function
   uses the SIPhash algorithm, which can output either a 64-bit
   or 128-bit hash. However, the 64-bit hash runs a significant
   risk of collisions when applied to more than a few million
   unique values. Unless the number of unique values is known to
   be small, the 128-bit hash is strongly recommended.

   Note that this hash should not be used for security, or for
   any cryptographic application. Not only is SIPhash not
   intended for such uses, but this implementation employs a
   fixed key for the hash, which makes it possible for an
   adversary with control over input to engineer collisions.

   In the case of a list of pdrrays, Strings, Categoricals, or Segarrays
   being passed, a non-linear function must be applied to each
   array since hashes of subsequent arrays cannot be simply XORed
   because equivalent values will cancel each other out, hence we
   do a rotation by the ordinal of the array.


.. py:function:: hist_all(ak_df: arkouda.dataframe.DataFrame, cols: Optional[list[str]] = None)

   Create a grid of histograms for numeric columns in an Arkouda DataFrame.

   :param ak_df: An Arkouda DataFrame containing the data to visualize.
   :type ak_df: DataFrame
   :param cols: A list of column names to plot. If empty or not provided, all
                columns in the DataFrame are considered.
   :type cols: list, optional

   :returns: A tuple containing the matplotlib Figure and an array of Axes objects.
   :rtype: tuple[matplotlib.figure.Figure, numpy.ndarray]

   .. rubric:: Notes

   This function uses matplotlib to display a grid of histograms. It attempts to
   select a suitable number of bins using Doane's formula. Columns with
   non-numeric types will be grouped and encoded before plotting.

   .. rubric:: Examples

   Basic usage with all columns:
   >>> import arkouda as ak
   >>> import numpy as np
   >>> from arkouda.plotting import hist_all
   >>> ak_df = ak.DataFrame({
   ...     "a": ak.array(np.random.randn(100)),
   ...     "b": ak.array(np.random.randn(100)),
   ...     "c": ak.array(np.random.randn(100)),
   ...     "d": ak.array(np.random.randn(100))
   ... })
   >>> fig, axes = hist_all(ak_df)

   Save the figure to disk:
   >>> fig, axes = hist_all(ak_df, cols=["a", "b"])
   >>> fig.savefig("hist_all.png")


.. py:function:: histogram(pda: arkouda.numpy.pdarrayclass.pdarray, bins: arkouda.numpy.dtypes.int_scalars = 10, range: Optional[Tuple[arkouda.numpy.dtypes.numeric_scalars, arkouda.numpy.dtypes.numeric_scalars]] = None) -> Tuple[arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.pdarrayclass.pdarray]

   Compute a histogram of evenly spaced bins over the range of an array.

   :param pda: The values to histogram
   :type pda: pdarray
   :param bins: The number of equal-size bins to use (default: 10)
   :type bins: int_scalars, default=10
   :param range: The range of the values to count.
                 Values outside of this range are dropped.
                 By default, all values are counted.
   :type range: (minVal, maxVal), optional

   :returns: The number of values present in each bin and the bin edges
   :rtype: (pdarray, Union[pdarray, int64 or float64])

   :raises TypeError: Raised if the parameter is not a pdarray or if bins is
       not an int.
   :raises ValueError: Raised if bins < 1
   :raises NotImplementedError: Raised if pdarray dtype is bool or uint8

   .. seealso:: :py:obj:`value_counts`, :py:obj:`histogram2d`

   .. rubric:: Notes

   The bins are evenly spaced in the interval [pda.min(), pda.max()].
   If range parameter is provided, the interval is [range[0], range[1]].

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> import matplotlib.pyplot as plt
   >>> A = ak.arange(0, 10, 1)
   >>> nbins = 3
   >>> h, b = ak.histogram(A, bins=nbins)
   >>> h
   array([3 3 4])
   >>> b
   array([0.00000000... 3.00000000... 6.00000000... 9.00000000...])

   To plot, export the left edges and the histogram to NumPy
   >>> b_np = b.to_ndarray()
   >>> import numpy as np
   >>> b_widths = np.diff(b_np)
   >>> plt.bar(b_np[:-1], h.to_ndarray(), width=b_widths, align='edge', edgecolor='black')
   <BarContainer object of 3 artists>
   >>> plt.show() # doctest: +SKIP


.. py:function:: histogram2d(x: arkouda.numpy.pdarrayclass.pdarray, y: arkouda.numpy.pdarrayclass.pdarray, bins: Union[arkouda.numpy.dtypes.int_scalars, Sequence[arkouda.numpy.dtypes.int_scalars]] = 10, range: Optional[Tuple[Tuple[arkouda.numpy.dtypes.numeric_scalars, arkouda.numpy.dtypes.numeric_scalars], Tuple[arkouda.numpy.dtypes.numeric_scalars, arkouda.numpy.dtypes.numeric_scalars]]] = None) -> Tuple[arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.pdarrayclass.pdarray]

   Compute the bi-dimensional histogram of two data samples with evenly spaced bins.

   :param x: A pdarray containing the x coordinates of the points to be histogrammed.
   :type x: pdarray
   :param y: A pdarray containing the y coordinates of the points to be histogrammed.
   :type y: pdarray
   :param bins: The number of equal-size bins to use.
                If int, the number of bins for the two dimensions (nx=ny=bins).
                If [int, int], the number of bins in each dimension (nx, ny = bins).
                Defaults to 10
   :type bins: int_scalars or [int, int], default=10
   :param range: The ranges of the values in x and y to count.
                 Values outside of these ranges are dropped.
                 By default, all values are counted.
   :type range: ((xMin, xMax), (yMin, yMax)), optional

   :returns:

             hist : pdarray
                 shape(nx, ny)
                 The bi-dimensional histogram of samples x and y.
                 Values in x are histogrammed along the first dimension and
                 values in y are histogrammed along the second dimension.

             x_edges : pdarray
                 The bin edges along the first dimension.

             y_edges : pdarray
                 The bin edges along the second dimension.
   :rtype: Tuple[pdarray, pdarray, pdarray]

   :raises TypeError: Raised if x or y parameters are not pdarrays or if bins is
       not an int or (int, int).
   :raises ValueError: Raised if bins < 1
   :raises NotImplementedError: Raised if pdarray dtype is bool or uint8

   .. seealso:: :py:obj:`histogram`

   .. rubric:: Notes

   The x bins are evenly spaced in the interval [x.min(), x.max()]
   and y bins are evenly spaced in the interval [y.min(), y.max()].
   If range parameter is provided, the intervals are given
   by range[0] for x and range[1] for y..

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> x = ak.arange(0, 10, 1)
   >>> y = ak.arange(9, -1, -1)
   >>> nbins = 3
   >>> h, x_edges, y_edges = ak.histogram2d(x, y, bins=nbins)
   >>> h
   array([array([0.00000000... 0.00000000... 3.00000000...])
          array([0.00000000... 2.00000000... 1.00000000...])
          array([3.00000000... 1.00000000... 0.00000000...])])
   >>> x_edges
   array([0.00000000... 3.00000000... 6.00000000... 9.00000000...])
   >>> y_edges
   array([0.00000000... 3.00000000... 6.00000000... 9.00000000...])


.. py:function:: histogramdd(sample: Sequence[arkouda.numpy.pdarrayclass.pdarray], bins: Union[arkouda.numpy.dtypes.int_scalars, Sequence[arkouda.numpy.dtypes.int_scalars]] = 10, range: Optional[Sequence[Optional[Tuple[arkouda.numpy.dtypes.numeric_scalars, arkouda.numpy.dtypes.numeric_scalars]]]] = None) -> Tuple[arkouda.numpy.pdarrayclass.pdarray, Sequence[arkouda.numpy.pdarrayclass.pdarray]]

   Compute the multidimensional histogram of data in sample with evenly spaced bins.

   :param sample: A sequence of pdarrays containing the coordinates of the points to be histogrammed.
   :type sample: Sequence of pdarray
   :param bins: The number of equal-size bins to use.
                If int, the number of bins for all dimensions (nx=ny=...=bins).
                If [int, int, ...], the number of bins in each dimension (nx, ny, ... = bins).
                Defaults to 10
   :type bins: int_scalars or Sequence of int_scalars, default=10
   :param range: The ranges of the values to count for each array in sample.
                 Values outside of these ranges are dropped.
                 By default, all values are counted.
   :type range: Sequence[optional (minVal, maxVal)], optional

   :returns:

             hist : pdarray
                 shape(nx, ny, ..., nd)
                 The multidimensional histogram of pdarrays in sample.
                 Values in first pdarray are histogrammed along the first dimension.
                 Values in second pdarray are histogrammed along the second dimension and so on.

             edges : List[pdarray]
                 A list of pdarrays containing the bin edges for each dimension.
   :rtype: Tuple[pdarray, Sequence[pdarray]]

   :raises ValueError: Raised if bins < 1
   :raises NotImplementedError: Raised if pdarray dtype is bool or uint8

   .. seealso:: :py:obj:`histogram`

   .. rubric:: Notes

   The bins for each dimension, m, are evenly spaced in the interval [m.min(), m.max()]
   or in the inverval determined by range[dimension], if provided.

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> x = ak.arange(0, 10, 1)
   >>> y = ak.arange(9, -1, -1)
   >>> z = ak.where(x % 2 == 0, x, y)
   >>> h, edges = ak.histogramdd((x, y,z), bins=(2,2,3))
   >>> h
   array([array([array([0.00000000... 0.00000000... 0.00000000...])
       array([2.00000000... 1.00000000... 2.00000000...])])
       array([array([2.00000000... 1.00000000... 2.00000000...])
       array([0.00000000... 0.00000000... 0.00000000...])])])
   >>> edges
   [array([0.00000000... 4.5 9.00000000...]),
       array([0.00000000... 4.5 9.00000000...]),
       array([0.00000000... 2.66666666... 5.33333333... 8.00000000...])]


.. py:function:: hstack(tup: Sequence[arkouda.numpy.pdarrayclass.pdarray], *, dtype: Optional[Union[str, type]] = None, casting: Literal['no', 'equiv', 'safe', 'same_kind', 'unsafe'] = 'same_kind') -> arkouda.numpy.pdarrayclass.pdarray

   Stack arrays in sequence horizontally (column wise).

   This is equivalent to concatenation along the second axis, except for 1-D arrays
   where it concatenates along the first axis. Rebuilds arrays divided by ``hsplit``.

   This function makes most sense for arrays with up to 3 dimensions. For instance, for pixel-data
   with a height (first axis), width (second axis), and r/g/b channels (third axis). The functions
   ``concatenate``, ``stack`` and ``block`` provide more general stacking and concatenation operations.

   :param tup: The arrays must have the same shape along all but the second axis, except 1-D arrays which
               can be any length. In the case of a single array_like input, it will be treated as a sequence of
               arrays; i.e., each element along the zeroth axis is treated as a separate array.
   :type tup: sequence of pdarray
   :param dtype: If provided, the destination array will have this type.
   :type dtype: str or type, optional
   :param casting: Controls what kind of data casting may occur. Defaults to ‘same_kind’. Currently unused.
   :type casting: {‘no’, ‘equiv’, ‘safe’, ‘same_kind’, ‘unsafe’}, optional

   :returns: The array formed by stacking the given arrays.
   :rtype: pdarray

   .. seealso:: :py:obj:`concatenate`, :py:obj:`stack`, :py:obj:`block`, :py:obj:`vstack`, :py:obj:`dstack`, :py:obj:`column_stack`, :py:obj:`hsplit`, :py:obj:`unstack`

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.array([1, 2, 3])
   >>> b = ak.array([4, 5, 6])
   >>> ak.hstack((a, b))
   array([1 2 3 4 5 6])
   >>> a = ak.array([[1],[2],[3]])
   >>> b = ak.array([[4],[5],[6]])
   >>> ak.hstack((a, b))
   array([array([1 4]) array([2 5]) array([3 6])])


.. py:class:: iinfo

   iinfo(type)

   Machine limits for integer types.

   .. attribute:: bits

      The number of bits occupied by the type.

      :type: int

   .. attribute:: dtype

      Returns the dtype for which `iinfo` returns information.

      :type: dtype

   .. attribute:: min

      The smallest integer expressible by the type.

      :type: int

   .. attribute:: max

      The largest integer expressible by the type.

      :type: int

   :param int_type: The kind of integer data type to get information about.
   :type int_type: integer type, dtype, or instance

   .. seealso::

      :py:obj:`finfo`
          The equivalent for floating point data types.

   .. rubric:: Examples

   With types:

   >>> import numpy as np
   >>> ii16 = np.iinfo(np.int16)
   >>> ii16.min
   -32768
   >>> ii16.max
   32767
   >>> ii32 = np.iinfo(np.int32)
   >>> ii32.min
   -2147483648
   >>> ii32.max
   2147483647

   With instances:

   >>> ii32 = np.iinfo(np.int32(10))
   >>> ii32.min
   -2147483648
   >>> ii32.max
   2147483647


   .. py:property:: max

      Maximum value of given dtype.


   .. py:property:: min

      Minimum value of given dtype.


.. py:function:: in1d(A: arkouda.pandas.groupbyclass.groupable, B: arkouda.pandas.groupbyclass.groupable, assume_unique: bool = False, symmetric: bool = False, invert: bool = False) -> arkouda.pandas.groupbyclass.groupable

   Test whether each element of a 1-D array is also present in a second array.

   Returns a boolean array the same length as `A` that is True
   where an element of `A` is in `B` and False otherwise.

   Supports multi-level, i.e. test if rows of a are in the set of rows of b.
   But note that multi-dimensional pdarrays are not supported.

   :param A: Entries will be tested for membership in B
   :type A: list of pdarrays, pdarray, Strings, or Categorical
   :param B: The set of elements in which to test membership
   :type B: list of pdarrays, pdarray, Strings, or Categorical
   :param assume_unique: If true, assume rows of a and b are each unique and sorted.
                         By default, sort and unique them explicitly.
   :type assume_unique: bool, optional, defaults to False
   :param symmetric: Return in1d(A, B), in1d(B, A) when A and B are single items.
   :type symmetric: bool, optional, defaults to False
   :param invert: If True, the values in the returned array are inverted (that is,
                  False where an element of `A` is in `B` and True otherwise).
                  Default is False. ``ak.in1d(a, b, invert=True)`` is equivalent
                  to (but is faster than) ``~ak.in1d(a, b)``.
   :type invert: bool, optional, defaults to False

   :returns: True for each row in a that is contained in b
   :rtype: groupable

   :raises TypeError: Raised if either A or B is not a pdarray, Strings, or Categorical
       object, or if both are pdarrays and either has rank > 1,
       or if invert is not a bool
   :raises RuntimeError: Raised if the dtype of either array is not supported

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.in1d(ak.array([-1, 0, 1]), ak.array([-2, 0, 2]))
   array([False True False])

   >>> ak.in1d(ak.array(['one','two']),ak.array(['two', 'three','four','five']))
   array([False True])

   .. seealso:: :py:obj:`arkouda.pandas.groupbyclass.unique`, :py:obj:`intersect1d`, :py:obj:`union1d`

   .. rubric:: Notes

   `in1d` can be considered as an element-wise function version of the
   python keyword `in`, for 1-D sequences. ``in1d(a, b)`` is logically
   equivalent to ``ak.array([item in b for item in a])``, but is much
   faster and scales to arbitrarily large ``a``.

   ak.in1d is not supported for bool or float64 pdarrays


.. py:function:: in1d_intervals(vals, intervals, symmetric=False)

   Test each value for membership in *any* of a set of half-open (pythonic) intervals.

   :param vals: Values to test for membership in intervals
   :type vals: pdarray(int, float)
   :param intervals: Non-overlapping, half-open intervals, as a tuple of
                     (lower_bounds_inclusive, upper_bounds_exclusive)
   :type intervals: 2-tuple of pdarrays
   :param symmetric: If True, also return boolean pdarray indicating which intervals
                     contained one or more query values.
   :type symmetric: bool

   :returns: * *pdarray(bool)* -- Array of same length as <vals>, True if corresponding value is
               included in any of the ranges defined by (low[i], high[i]) inclusive.
             * *pdarray(bool) (if symmetric=True)* -- Array of same length as number of intervals, True if corresponding
               interval contains any of the values in <vals>.

   .. rubric:: Notes

   First return array is equivalent to the following:
       ((vals >= intervals[0][0]) & (vals < intervals[1][0])) |
       ((vals >= intervals[0][1]) & (vals < intervals[1][1])) |
       ...
       ((vals >= intervals[0][-1]) & (vals < intervals[1][-1]))
   But much faster when testing many ranges.

   Second (optional) return array is equivalent to:
       ((intervals[0] <= vals[0]) & (intervals[1] > vals[0])) |
       ((intervals[0] <= vals[1]) & (intervals[1] > vals[1])) |
       ...
       ((intervals[0] <= vals[-1]) & (intervals[1] > vals[-1]))
   But much faster when vals is non-trivial size.


.. py:function:: indexof1d(query: arkouda.pandas.groupbyclass.groupable, space: arkouda.pandas.groupbyclass.groupable) -> arkouda.numpy.pdarrayclass.pdarray

   Return indices of query items in a search list of items. Items not found will be excluded.
   When duplicate terms are present in search space return indices of all occurrences.

   :param query: The items to search for. If multiple arrays, each "row" is an item.
   :type query: (sequence of) pdarray or Strings or Categorical
   :param space: The set of items in which to search. Must have same shape/dtype as query.
   :type space: (sequence of) pdarray or Strings or Categorical

   :returns: For each item in query that is found in space, its index in space.
   :rtype: pdarray

   .. rubric:: Notes

   This is an alias of
   `ak.find(query, space, all_occurrences=True, remove_missing=True).values`

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> select_from = ak.arange(10)
   >>> query = select_from[ak.randint(0, select_from.size, 20, seed=10)]
   >>> space = select_from[ak.randint(0, select_from.size, 20, seed=11)]

   remove some values to ensure that query has entries
   which don't appear in space

   >>> space = space[space != 9]
   >>> space = space[space != 3]

   >>> ak.indexof1d(query, space)
   array([0 4 1 3 10 2 6 12 13 5 7 8 9 14 5 7 11 15 5 7 0 4])

   :raises TypeError: Raised if either `query` or `space` is not a pdarray, Strings, or
       Categorical object
   :raises RuntimeError: Raised if the dtype of either array is not supported


.. py:class:: inexact

   Bases: :py:obj:`numpy.number`


   Abstract base class of all numeric scalar types with a (potentially)
       inexact representation of the values in its range, such as
       floating-point numbers.


.. py:data:: inf
   :type:  float

.. py:function:: information(names: Union[List[str], str] = RegisteredSymbols) -> str

   Return a JSON formatted string containing information about the objects in names.

   :param names: names is either the name of an object or list of names of objects to retrieve info
                 if names is ak.AllSymbols, retrieves info for all symbols in the symbol table
                 if names is ak.RegisteredSymbols, retrieves info for all symbols in the registry
   :type names: Union[List[str], str]

   :returns: JSON formatted string containing a list of information for each object in names
   :rtype: str

   :raises RuntimeError: Raised if a server-side error is thrown in the process of
       retrieving information about the objects in names


.. py:class:: int16

   Bases: :py:obj:`numpy.signedinteger`


   Signed integer type, compatible with C ``short``.

       :Character code: ``'h'``
       :Canonical name: `numpy.short`
       :Alias on this platform (Linux x86_64): `numpy.int16`: 16-bit signed integer (``-32_768`` to ``32_767``).


   .. py:method:: bit_count(/)

      int16.bit_count() -> int

              Computes the number of 1-bits in the absolute value of the input.
              Analogous to the builtin `int.bit_count` or ``popcount`` in C++.

              Examples
              --------
              >>> np.int16(127).bit_count()
              7
              >>> np.int16(-127).bit_count()
              7



.. py:class:: int32

   Bases: :py:obj:`numpy.signedinteger`


   Signed integer type, compatible with C ``int``.

       :Character code: ``'i'``
       :Canonical name: `numpy.intc`
       :Alias on this platform (Linux x86_64): `numpy.int32`: 32-bit signed integer (``-2_147_483_648`` to ``2_147_483_647``).


   .. py:method:: bit_count(/)

      int32.bit_count() -> int

              Computes the number of 1-bits in the absolute value of the input.
              Analogous to the builtin `int.bit_count` or ``popcount`` in C++.

              Examples
              --------
              >>> np.int32(127).bit_count()
              7
              >>> np.int32(-127).bit_count()
              7



.. py:class:: int64

   Bases: :py:obj:`numpy.signedinteger`


   Default signed integer type, 64bit on 64bit systems and 32bit on 32bit
       systems.

       :Character code: ``'l'``
       :Canonical name: `numpy.int_`
       :Alias on this platform (Linux x86_64): `numpy.int64`: 64-bit signed integer (``-9_223_372_036_854_775_808`` to ``9_223_372_036_854_775_807``).
       :Alias on this platform (Linux x86_64): `numpy.intp`: Signed integer large enough to fit pointer, compatible with C ``intptr_t``.


   .. py:method:: bit_count(/)

      int64.bit_count() -> int

              Computes the number of 1-bits in the absolute value of the input.
              Analogous to the builtin `int.bit_count` or ``popcount`` in C++.

              Examples
              --------
              >>> np.int64(127).bit_count()
              7
              >>> np.int64(-127).bit_count()
              7



.. py:class:: int8

   Bases: :py:obj:`numpy.signedinteger`


   Signed integer type, compatible with C ``char``.

       :Character code: ``'b'``
       :Canonical name: `numpy.byte`
       :Alias on this platform (Linux x86_64): `numpy.int8`: 8-bit signed integer (``-128`` to ``127``).


   .. py:method:: bit_count(/)

      int8.bit_count() -> int

              Computes the number of 1-bits in the absolute value of the input.
              Analogous to the builtin `int.bit_count` or ``popcount`` in C++.

              Examples
              --------
              >>> np.int8(127).bit_count()
              7
              >>> np.int8(-127).bit_count()
              7



.. py:class:: intTypes

   Build an immutable unordered collection of unique elements.


   .. py:method:: copy()

      Return a shallow copy of a set.



   .. py:method:: difference(*others)

      Return a new set with elements in the set that are not in the others.



   .. py:method:: intersection(*others)

      Return a new set with elements common to the set and all others.



   .. py:method:: isdisjoint(other, /)

      Return True if two sets have a null intersection.



   .. py:method:: issubset(other, /)

      Report whether another set contains this set.



   .. py:method:: issuperset(other, /)

      Report whether this set contains another set.



   .. py:method:: symmetric_difference(other, /)

      Return a new set with elements in either the set or other but not both.



   .. py:method:: union(*others)

      Return a new set with elements from the set and all others.



.. py:class:: int_scalars

   Bases: :py:obj:`_NotIterable`


   Mixin to prevent iteration, without being compatible with Iterable.

   That is, we could do::

       def __iter__(self): raise TypeError()

   But this would make users of this mixin duck type-compatible with
   collections.abc.Iterable - isinstance(foo, Iterable) would be True.

   Luckily, we can instead prevent iteration by setting __iter__ to None, which
   is treated specially.


   .. py:method:: copy_with(params)


.. py:class:: intc

   Bases: :py:obj:`numpy.signedinteger`


   Signed integer type, compatible with C ``int``.

       :Character code: ``'i'``
       :Canonical name: `numpy.intc`
       :Alias on this platform (Linux x86_64): `numpy.int32`: 32-bit signed integer (``-2_147_483_648`` to ``2_147_483_647``).


   .. py:method:: bit_count(/)

      int32.bit_count() -> int

              Computes the number of 1-bits in the absolute value of the input.
              Analogous to the builtin `int.bit_count` or ``popcount`` in C++.

              Examples
              --------
              >>> np.int32(127).bit_count()
              7
              >>> np.int32(-127).bit_count()
              7



.. py:function:: intersect1d(A: arkouda.pandas.groupbyclass.groupable, B: arkouda.pandas.groupbyclass.groupable, assume_unique: bool = False) -> Union[arkouda.numpy.pdarrayclass.pdarray, arkouda.pandas.groupbyclass.groupable]

   Find the intersection of two arrays.

   Return the sorted, unique values that are in both of the input arrays.

   :param A:
   :type A: list of pdarrays, pdarray, Strings, or Categorical
   :param B:
   :type B: list of pdarrays, pdarray, Strings, or Categorical
   :param assume_unique: If True, the input arrays are both assumed to be unique, which
                         can speed up the calculation.  Default is False.
   :type assume_unique: bool

   :returns: Sorted 1D array/List of sorted pdarrays of common and unique elements.
   :rtype: pdarray/groupable

   :raises TypeError: Raised if either A or B is not a groupable
   :raises RuntimeError: Raised if the dtype of either pdarray is not supported

   .. seealso:: :py:obj:`arkouda.pandas.groupbyclass.unique`, :py:obj:`union1d`

   .. rubric:: Examples

   >>> import arkouda as ak

   1D Example
   >>> ak.intersect1d(ak.array([1, 3, 4, 3]), ak.array([3, 1, 2, 1]))
   array([1 3])

   Multi-Array Example
   >>> a = ak.arange(5)
   >>> b = ak.array([1, 5, 3, 4, 2])
   >>> c = ak.array([1, 4, 3, 2, 5])
   >>> d = ak.array([1, 2, 3, 5, 4])
   >>> multia = [a, a, a]
   >>> multib = [b, c, d]
   >>> ak.intersect1d(multia, multib)
   [array([1 3]), array([1 3]), array([1 3])]


.. py:function:: interval_lookup(keys, values, arguments, fillvalue=-1, tiebreak=None, hierarchical=False)

   Apply a function defined over intervals to an array of arguments.

   :param keys: Tuple of closed intervals expressed as (lower_bounds_inclusive, upper_bounds_inclusive).
                Must have same dtype(s) as vals.
   :type keys: 2-tuple of (sequences of) pdarrays
   :param values: Function value to return for each entry in keys.
   :type values: pdarray
   :param arguments: Values to search for in intervals. If multiple arrays, each "row" is an item.
   :type arguments: (sequences of) pdarray
   :param fillvalue: Default value to return when argument is not in any interval.
   :type fillvalue: scalar
   :param tiebreak: When an argument is present in more than one key interval, the interval with the
                    lowest tiebreak value will be chosen. If no tiebreak is given, the
                    first valid key interval will be chosen.
   :type tiebreak: (optional) pdarray, numeric

   :returns: Value of function corresponding to the keys interval
             containing each argument, or fillvalue if argument not
             in any interval.
   :rtype: pdarray


.. py:class:: intp

   Bases: :py:obj:`numpy.signedinteger`


   Default signed integer type, 64bit on 64bit systems and 32bit on 32bit
       systems.

       :Character code: ``'l'``
       :Canonical name: `numpy.int_`
       :Alias on this platform (Linux x86_64): `numpy.int64`: 64-bit signed integer (``-9_223_372_036_854_775_808`` to ``9_223_372_036_854_775_807``).
       :Alias on this platform (Linux x86_64): `numpy.intp`: Signed integer large enough to fit pointer, compatible with C ``intptr_t``.


   .. py:method:: bit_count(/)

      int64.bit_count() -> int

              Computes the number of 1-bits in the absolute value of the input.
              Analogous to the builtin `int.bit_count` or ``popcount`` in C++.

              Examples
              --------
              >>> np.int64(127).bit_count()
              7
              >>> np.int64(-127).bit_count()
              7



.. py:function:: isSupportedBool(num)

   Whether a scalar is an arkouda supported boolean dtype.

   :param num: A scalar.
   :type num: object

   :returns: True if scalar is an instance of an arkouda supported boolean dtype, else False.
   :rtype: bool

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.isSupportedBool("True")
   False
   >>> ak.isSupportedBool(True)
   True


.. py:function:: isSupportedDType(scalar: object) -> bool

   Whether a scalar is an arkouda supported dtype.

   :param scalar:
   :type scalar: object

   :returns: True if scalar is an instance of an arkouda supported dtype, else False.
   :rtype: builtins.bool

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.isSupportedDType(ak.int64(64))
   True
   >>> ak.isSupportedDType(np.complex128(1+2j))
   False


.. py:function:: isSupportedFloat(num)

   Whether a scalar is an arkouda supported float dtype.

   :param num: A scalar.
   :type num: object

   :returns: True if scalar is an instance of an arkouda supported float dtype, else False.
   :rtype: bool

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.isSupportedFloat(56)
   False
   >>> ak.isSupportedFloat(56.7)
   True


.. py:function:: isSupportedInt(num)

   Whether a scalar is an arkouda supported integer dtype.

   :param num: A scalar.
   :type num: object

   :returns: True if scalar is an instance of an arkouda supported integer dtype, else False.
   :rtype: bool

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.isSupportedInt(79)
   True
   >>> ak.isSupportedInt(54.9)
   False


.. py:function:: isSupportedNumber(num)

   Whether a scalar is an arkouda supported numeric dtype.

   :param num: A scalar.
   :type num: object

   :returns: True if scalar is an instance of an arkouda supported numeric dtype, else False.
   :rtype: bool

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.isSupportedNumber(45.9)
   True
   >>> ak.isSupportedNumber("string")
   False


.. py:function:: is_cosorted(arrays)

   Return True iff the arrays are cosorted.

   Return True iff the arrays are cosorted, i.e., if the arrays were columns in a table
   then the rows are sorted.

   :param arrays: Arrays to check for cosortedness
   :type arrays: list-like of pdarrays

   :returns: True iff arrays are cosorted.
   :rtype: bool

   :raises ValueError: Raised if arrays are not the same length
   :raises TypeError: Raised if arrays is not a list-like of pdarrays


.. py:function:: is_registered(name: str, as_component: bool = False) -> bool

   Determine if the provided name is associated with a registered Arkouda object.

   This function checks if the `name` is found in the registry of objects,
   and optionally checks if it is registered as a component of a registered object.

   :param name: The name to check for in the registry.
   :type name: str
   :param as_component: When True, the function checks if the name is registered as a component
                        of a registered object (rather than as a standalone object).
   :type as_component: bool, default=False

   :returns: `True` if the name is found in the registry, `False` otherwise.
   :rtype: bool

   :raises KeyError: If the registry query encounters an issue (e.g., invalid registry data or access issues).

   .. rubric:: Examples

   >>> import arkouda as ak

   Check if a name is registered as an object
   >>> obj = ak.array([1, 2, 3])
   >>> registered_obj = obj.register("my_array")
   >>> result = ak.is_registered("my_array")
   >>> print(result)
   True
   >>> registered_obj.unregister()

   Check if a name is registered as a component
   >>> result = ak.is_registered("my_component", as_component=True)
   >>> print(result)
   False


.. py:function:: isfinite(pda: arkouda.numpy.pdarrayclass.pdarray) -> arkouda.numpy.pdarrayclass.pdarray

   Return the element-wise isfinite check applied to the array.

   :param pda:
   :type pda: pdarray

   :returns: A pdarray containing boolean values indicating whether the
             input array elements are finite
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray
   :raises RuntimeError: if the underlying pdarray is not float-based

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.isfinite(ak.array([1.0, 2.0, ak.inf]))
   array([True True False])


.. py:function:: isinf(pda: arkouda.numpy.pdarrayclass.pdarray) -> arkouda.numpy.pdarrayclass.pdarray

   Return the element-wise isinf check applied to the array.

   :param pda:
   :type pda: pdarray

   :returns: A pdarray containing boolean values indicating whether the
             input array elements are infinite (positive or negative)
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray
   :raises RuntimeError: if the underlying pdarray is not float-based

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.isinf(ak.array([1.0, 2.0, ak.inf]))
   array([False False True])


.. py:function:: isnan(pda: arkouda.numpy.pdarrayclass.pdarray) -> arkouda.numpy.pdarrayclass.pdarray

   Return the element-wise isnan check applied to the array.

   :param pda:
   :type pda: pdarray

   :returns: A pdarray containing boolean values indicating whether the
             input array elements are NaN
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray
   :raises RuntimeError: if the underlying pdarray is not float-based

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.isnan(ak.array([1.0, 2.0, np.log(-1)]))
   array([False False True])


.. py:function:: isnumeric(pda) -> arkouda.numpy.pdarrayclass.pdarray

   Return a boolean pdarray where index i indicates whether string i of the
   Strings has all numeric characters. There are 1922 unicode characters that
   qualify as numeric, including the digits 0 through 9, superscripts and
   subscripted digits, special characters with the digits encircled or
   enclosed in parens, "vulgar fractions," and more.

   :returns: True for elements that are numerics, False otherwise
   :rtype: pdarray

   :raises RuntimeError: Raised if there is a server-side error thrown
   :raises TypeError: Raised if the input is not a Strings type

   .. seealso:: :py:obj:`Strings.isdecimal`

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> not_numeric = ak.array([f'Strings {i}' for i in range(3)])
   >>> numeric = ak.array([f'12{i}' for i in range(3)])
   >>> strings = ak.concatenate([not_numeric, numeric])
   >>> strings
   array(['Strings 0', 'Strings 1', 'Strings 2', '120', '121', '122'])
   >>> ak.isnumeric(strings)
   array([False False False True True True])

   Special Character Examples

   >>> special_strings = ak.array(["3.14", "0", "²", "2³₇", "2³x₇"])
   >>> special_strings
   array(['3.14', '0', '²', '2³₇', '2³x₇'])
   >>> ak.isnumeric(special_strings)
   array([False True True True False])


.. py:function:: isscalar(element)

   Returns True if the type of `element` is a scalar type.

   :param element: Input argument, can be of any type and shape.
   :type element: any

   :returns: **val** -- True if `element` is a scalar type, False if it is not.
   :rtype: bool

   .. seealso::

      :py:obj:`ndim`
          Get the number of dimensions of an array

   .. rubric:: Notes

   If you need a stricter way to identify a *numerical* scalar, use
   ``isinstance(x, numbers.Number)``, as that returns ``False`` for most
   non-numerical elements such as strings.

   In most cases ``np.ndim(x) == 0`` should be used instead of this function,
   as that will also return true for 0d arrays. This is how numpy overloads
   functions in the style of the ``dx`` arguments to `gradient` and
   the ``bins`` argument to `histogram`. Some key differences:

   +------------------------------------+---------------+-------------------+
   | x                                  |``isscalar(x)``|``np.ndim(x) == 0``|
   +====================================+===============+===================+
   | PEP 3141 numeric objects           | ``True``      | ``True``          |
   | (including builtins)               |               |                   |
   +------------------------------------+---------------+-------------------+
   | builtin string and buffer objects  | ``True``      | ``True``          |
   +------------------------------------+---------------+-------------------+
   | other builtin objects, like        | ``False``     | ``True``          |
   | `pathlib.Path`, `Exception`,       |               |                   |
   | the result of `re.compile`         |               |                   |
   +------------------------------------+---------------+-------------------+
   | third-party objects like           | ``False``     | ``True``          |
   | `matplotlib.figure.Figure`         |               |                   |
   +------------------------------------+---------------+-------------------+
   | zero-dimensional numpy arrays      | ``False``     | ``True``          |
   +------------------------------------+---------------+-------------------+
   | other numpy arrays                 | ``False``     | ``False``         |
   +------------------------------------+---------------+-------------------+
   | `list`, `tuple`, and other         | ``False``     | ``False``         |
   | sequence objects                   |               |                   |
   +------------------------------------+---------------+-------------------+

   .. rubric:: Examples

   >>> import numpy as np

   >>> np.isscalar(3.1)
   True

   >>> np.isscalar(np.array(3.1))
   False

   >>> np.isscalar([3.1])
   False

   >>> np.isscalar(False)
   True

   >>> np.isscalar('numpy')
   True

   NumPy supports PEP 3141 numbers:

   >>> from fractions import Fraction
   >>> np.isscalar(Fraction(5, 17))
   True
   >>> from numbers import Number
   >>> np.isscalar(Number())
   True


.. py:function:: issubdtype(arg1, arg2)

   Returns True if first argument is a typecode lower/equal in type hierarchy.

   This is like the builtin :func:`issubclass`, but for `dtype`\ s.

   :param arg1: `dtype` or object coercible to one
   :type arg1: dtype_like
   :param arg2: `dtype` or object coercible to one
   :type arg2: dtype_like

   :returns: **out**
   :rtype: bool

   .. seealso::

      :ref:`arrays.scalars`
          Overview of the numpy type hierarchy.

   .. rubric:: Examples

   `issubdtype` can be used to check the type of arrays:

   >>> ints = np.array([1, 2, 3], dtype=np.int32)
   >>> np.issubdtype(ints.dtype, np.integer)
   True
   >>> np.issubdtype(ints.dtype, np.floating)
   False

   >>> floats = np.array([1, 2, 3], dtype=np.float32)
   >>> np.issubdtype(floats.dtype, np.integer)
   False
   >>> np.issubdtype(floats.dtype, np.floating)
   True

   Similar types of different sizes are not subdtypes of each other:

   >>> np.issubdtype(np.float64, np.float32)
   False
   >>> np.issubdtype(np.float32, np.float64)
   False

   but both are subtypes of `floating`:

   >>> np.issubdtype(np.float64, np.floating)
   True
   >>> np.issubdtype(np.float32, np.floating)
   True

   For convenience, dtype-like objects are allowed too:

   >>> np.issubdtype('S1', np.bytes_)
   True
   >>> np.issubdtype('i4', np.signedinteger)
   True


.. py:function:: join_on_eq_with_dt(a1: arkouda.numpy.pdarrayclass.pdarray, a2: arkouda.numpy.pdarrayclass.pdarray, t1: arkouda.numpy.pdarrayclass.pdarray, t2: arkouda.numpy.pdarrayclass.pdarray, dt: Union[int, numpy.int64], pred: str, result_limit: Union[int, numpy.int64] = 1000) -> Tuple[arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.pdarrayclass.pdarray]

   Inner-join on equality between two integer arrays where the time-window predicate is also true.

   :param a1: Values to join (must be int64 dtype).
   :type a1: pdarray
   :param a2: Values to join (must be int64 dtype).
   :type a2: pdarray
   :param t1: timestamps in millis corresponding to the a1 pdarray
   :type t1: pdarray
   :param t2: timestamps in millis corresponding to the a2 pdarray
   :type t2: pdarray
   :param dt: time delta
   :type dt: Union[int,np.int64]
   :param pred: time window predicate
   :type pred: str
   :param result_limit: size limit for returned result
   :type result_limit: Union[int,np.int64]

   :returns:

             result_array_one : pdarray, int64
                 a1 indices where a1 == a2
             result_array_one : pdarray, int64
                 a2 indices where a2 == a1
   :rtype: Tuple[pdarray, pdarray]

   :raises TypeError: Raised if a1, a2, t1, or t2 is not a pdarray, or if dt or
       result_limit is not an int
   :raises ValueError: if a1, a2, t1, or t2 dtype is not int64, pred is not
       'true_dt', 'abs_dt', or 'pos_dt', or result_limit is < 0


.. py:function:: left_align(left, right)

   Map two arrays of sparse identifiers to the 0-up index.

   Map two arrays of sparse identifiers to the 0-up index set implied by the left array,
   discarding values from right that do not appear in left.


.. py:function:: linspace(start: Union[arkouda.numpy.dtypes.numeric_scalars, arkouda.numpy.pdarrayclass.pdarray], stop: Union[arkouda.numpy.dtypes.numeric_scalars, arkouda.numpy.pdarrayclass.pdarray], num: arkouda.numpy.dtypes.int_scalars = 50, endpoint: Union[None, bool] = True, dtype: Optional[type] = float64, axis: arkouda.numpy.dtypes.int_scalars = 0) -> arkouda.numpy.pdarrayclass.pdarray

   Return evenly spaced numbers over a specified interval.

   Returns `num` evenly spaced samples, calculated over the
   interval [`start`, `stop`].

   The endpoint of the interval can optionally be excluded.

   :param start: The starting value of the sequence.
   :type start: Union[numeric_scalars, pdarray]
   :param stop: The end value of the sequence, unless `endpoint` is set to False.
                In that case, the sequence consists of all but the last of ``num + 1``
                evenly spaced samples, so that `stop` is excluded.  Note that the step
                size changes when `endpoint` is False.
   :type stop: Union[numeric_scalars, pdarray]
   :param num: Number of samples to generate. Default is 50. Must be non-negative.
   :type num: int, optional
   :param endpoint: If True, `stop` is the last sample. Otherwise, it is not included.
                    Default is True.
   :type endpoint: bool, optional
   :param dtype: Allowed for compatibility with numpy linspace, but anything entered
                 is ignored.  The output is always ak.float64.
   :type dtype: dtype, optional
   :param axis: The axis in the result to store the samples.  Relevant only if start
                or stop are array-like.  By default (0), the samples will be along a
                new axis inserted at the beginning. Use -1 to get an axis at the end.
   :type axis: int, optional

   :returns: There are `num` equally spaced samples in the closed interval
             ``[start, stop]`` or the half-open interval ``[start, stop)``
             (depending on whether `endpoint` is True or False).
   :rtype: pdarray

   :raises TypeError: Raised if start or stop is not a float or a pdarray, or if num
       is not an int, or if endpoint is not a bool, or if dtype is anything
       other than None or float64, or axis is not an integer.
   :raises ValueError: Raised if axis is not a valid axis for the given data.

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.linspace(0,1,3)
   array([0.00000000000000000 0.5 1.00000000000000000])
   >>> ak.linspace(1,0,3)
   array([1.00000000000000000 0.5 0.00000000000000000])
   >>> ak.linspace(0,1,3,endpoint=False)
   array([0.00000000000000000 0.33333333333333331 0.66666666666666663])
   >>> ak.linspace(0,ak.array([2,3]),3)
   array([array([0.00000000000000000 0.00000000000000000])
       array([1.00000000000000000 1.5]) array([2.00000000000000000 3.00000000000000000])])
   >>> ak.linspace(ak.array([0,1]),3,3)
   array([array([0.00000000000000000 1.00000000000000000])
       array([1.5 2.00000000000000000]) array([3.00000000000000000 3.00000000000000000])])
   >>> ak.linspace(ak.array([0,1]),ak.array([2,3]),3)
   array([array([0.00000000000000000 1.00000000000000000])
       array([1.00000000000000000 2.00000000000000000])
       array([2.00000000000000000 3.00000000000000000])])


.. py:function:: list_registry(detailed: bool = False)

   Return a list containing the names of all registered objects.

   :param detailed: Default = False
                    Return details of registry objects. Currently includes object type for any objects
   :type detailed: bool

   :returns: Dict containing keys "Components" and "Objects".
   :rtype: dict

   :raises RuntimeError: Raised if there's a server-side error thrown


.. py:function:: list_symbol_table() -> List[str]

   Return a list containing the names of all objects in the symbol table.

   :returns: List of all object names in the symbol table
   :rtype: list

   :raises RuntimeError: Raised if there's a server-side error thrown


.. py:function:: log(pda: arkouda.numpy.pdarrayclass.pdarray) -> arkouda.numpy.pdarrayclass.pdarray

   Return the element-wise natural log of the array.

   :param pda:
   :type pda: pdarray

   :returns: A pdarray containing natural log values of the input
             array elements
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray

   .. rubric:: Notes

   Logarithms with other bases can be computed as follows:

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> A = ak.array([1, 10, 100])

   Natural log
   >>> ak.log(A)
   array([0.00000000... 2.30258509... 4.60517018...])

   Log base 10
   >>> ak.log(A) / np.log(10)
   array([0.00000000... 1.00000000... 2.00000000...])

   Log base 2
   >>> ak.log(A) / np.log(2)
   array([0.00000000... 3.32192809... 6.64385618...])


.. py:function:: log10(pda: arkouda.numpy.pdarrayclass.pdarray) -> arkouda.numpy.pdarrayclass.pdarray

   Return the element-wise base 10 log of the array.

   :param pda: array to compute on
   :type pda: pdarray

   :returns: pdarray containing base 10 log values of the input array elements
   :rtype: pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.arange(1,5)
   >>> ak.log10(a)
   array([0.00000000... 0.30102999... 0.47712125... 0.60205999...])


.. py:function:: log1p(pda: arkouda.numpy.pdarrayclass.pdarray) -> arkouda.numpy.pdarrayclass.pdarray

   Return the element-wise natural log of one plus the array.

   :param pda: array to compute on
   :type pda: pdarray

   :returns: pdarray containing natural log values of the input array elements,
             adding one before taking the log
   :rtype: pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.log1p(ak.arange(1,5))
   array([0.69314718... 1.09861228... 1.38629436... 1.60943791...])


.. py:function:: log2(pda: arkouda.numpy.pdarrayclass.pdarray) -> arkouda.numpy.pdarrayclass.pdarray

   Return the element-wise base 2 log of the array.

   :param pda: array to compute on
   :type pda: pdarray

   :returns: pdarray containing base 2 log values of the input array elements
   :rtype: pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.arange(1,5)
   >>> ak.log2(a)
   array([0.00000000... 1.00000000... 1.58496250... 2.00000000...])


.. py:function:: logspace(start: Union[arkouda.numpy.dtypes.numeric_scalars, arkouda.numpy.pdarrayclass.pdarray], stop: Union[arkouda.numpy.dtypes.numeric_scalars, arkouda.numpy.pdarrayclass.pdarray], num: arkouda.numpy.dtypes.int_scalars = 50, base: arkouda.numpy.dtypes.numeric_scalars = 10.0, endpoint: Union[None, bool] = True, dtype: Optional[type] = float64, axis: Union[None, arkouda.numpy.dtypes.int_scalars] = 0) -> arkouda.numpy.pdarrayclass.pdarray

   Create a pdarray of numbers evenly spaced on a log scale.

   :param start: The starting value of the sequence.
   :type start: Union[numeric_scalars, pdarray]
   :param stop: The end value of the sequence, unless `endpoint` is set to False.
                In that case, the sequence consists of all but the last of ``num + 1``
                evenly spaced samples, so that `stop` is excluded.  Note that the step
                size changes when `endpoint` is False.
   :type stop: Union[numeric_scalars, pdarray]
   :param num: Number of samples to generate. Default is 50. Must be non-negative.
   :type num: int, optional
   :param base: the base of the log space, defaults to 10.0.
   :type base: numeric_scalars, optional
   :param endpoint: If True, `stop` is the last sample. Otherwise, it is not included.
                    Default is True.
   :type endpoint: bool, optional
   :param dtype: allowed for compatibility with numpy, but ignored.  Outputs are always float
   :type dtype: Union[None, float64]
   :param axis: The axis in the result to store the samples.  Relevant only if start
                or stop are array-like.  By default (0), the samples will be along a
                new axis inserted at the beginning. Use -1 to get an axis at the end.
   :type axis: int, optional

   :returns: There are `num` equally spaced (logarithmically) samples in the closed interval
             base**``[start, stop]`` or the half-open interval base**``[start, stop)``
             (depending on whether `endpoint` is True or False).
   :rtype: pdarray

   :raises TypeError: Raised if start or stop is not a float or a pdarray, or if num
       is not an int, or if endpoint is not a bool, or if dtype is anything
       other than None or float64, or axis is not an integer.
   :raises ValueError: Raised if axis is not a valid axis for the given data, or if base < 0.

   .. seealso:: :py:obj:`linspace`

   .. rubric:: Notes

   If start is greater than stop, the pdarray values are generated
   in descending order.

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.logspace(2,3,3,4)
   array([16.00000000000000000 32.00000000000000000 64.00000000000000000])
   >>> ak.logspace(2,3,3,4,endpoint=False)
   array([16.00000000000000000 25.398416831491197 40.317473596635935])
   >>> ak.logspace(0,1,3,4)
   array([1.00000000000000000 2.00000000000000000 4.00000000000000000])
   >>> ak.logspace(1,0,3,4)
   array([4.00000000000000000 2.00000000000000000 1.00000000000000000])
   >>> ak.logspace(0,1,3,endpoint=False)
   array([1.00000000000000000 2.1544346900318838 4.6415888336127784])
   >>> ak.logspace(0,ak.array([2,3]),3,base=2)
   array([array([1.00000000000000000 1.00000000000000000])
       array([2.00000000000000000 2.8284271247461903])
       array([4.00000000000000000 8.00000000000000000])])
   >>> ak.logspace(ak.array([0,1]),3,3,base=3)
   array([array([1.00000000000000000 3.00000000000000000])
       array([5.196152422706632 9.00000000000000000])
       array([27.00000000000000000 27.00000000000000000])])
   >>> ak.logspace(ak.array([0,1]),ak.array([2,3]),3,base=4)
   array([array([1.00000000000000000 4.00000000000000000])
       array([4.00000000000000000 16.00000000000000000])
       array([16.00000000000000000 64.00000000000000000])])


.. py:class:: longdouble

   Bases: :py:obj:`numpy.floating`


   Extended-precision floating-point number type, compatible with C
       ``long double`` but not necessarily with IEEE 754 quadruple-precision.

       :Character code: ``'g'``
       :Alias on this platform (Linux x86_64): `numpy.float128`: 128-bit extended-precision floating-point number type.


   .. py:method:: as_integer_ratio(/)

      longdouble.as_integer_ratio() -> (int, int)

              Return a pair of integers, whose ratio is exactly equal to the original
              floating point number, and with a positive denominator.
              Raise `OverflowError` on infinities and a `ValueError` on NaNs.

              >>> np.longdouble(10.0).as_integer_ratio()
              (10, 1)
              >>> np.longdouble(0.0).as_integer_ratio()
              (0, 1)
              >>> np.longdouble(-.25).as_integer_ratio()
              (-1, 4)



   .. py:method:: is_integer(/)

      longdouble.is_integer() -> bool

              Return ``True`` if the floating point number is finite with integral
              value, and ``False`` otherwise.

              .. versionadded:: 1.22

              Examples
              --------
              >>> np.longdouble(-2.0).is_integer()
              True
              >>> np.longdouble(3.2).is_integer()
              False



.. py:class:: longlong

   Bases: :py:obj:`numpy.signedinteger`


   Signed integer type, compatible with C ``long long``.

       :Character code: ``'q'``


   .. py:method:: bit_count(/)


.. py:function:: lookup(keys, values, arguments, fillvalue=-1)

   Apply the function defined by the mapping keys --> values to arguments.

   :param keys: The domain of the function. Entries must be unique (if a sequence of
                arrays is given, each row is treated as a tuple-valued entry).
   :type keys: (sequence of) array-like
   :param values: The range of the function. Must be same length as keys.
   :type values: pdarray
   :param arguments: The arguments on which to evaluate the function. Must have same dtype
                     (or tuple of dtypes, for a sequence) as keys.
   :type arguments: (sequence of) array-like
   :param fillvalue: The default value to return for arguments not in keys.
   :type fillvalue: scalar

   :returns: **evaluated** -- The result of evaluating the function over arguments.
   :rtype: pdarray

   .. rubric:: Notes

   While the values cannot be Strings (or other complex objects), the same
   result can be achieved by passing an arange as the values, then using
   the return as indices into the desired object.

   .. rubric:: Examples

   >>> import arkouda as ak

   Lookup numbers by two-word name
   >>> keys1 = ak.array(['twenty' for _ in range(5)])
   >>> keys2 = ak.array(['one', 'two', 'three', 'four', 'five'])
   >>> values = ak.array([21, 22, 23, 24, 25])
   >>> args1 = ak.array(['twenty', 'thirty', 'twenty'])
   >>> args2 = ak.array(['four', 'two', 'two'])
   >>> ak.lookup([keys1, keys2], values, [args1, args2])
   array([24 -1 22])

   Other direction requires an intermediate index
   >>> revkeys = values
   >>> revindices = ak.arange(values.size)
   >>> revargs = ak.array([24, 21, 22])
   >>> indx = ak.lookup(revkeys, revindices, revargs)
   >>> keys1[indx], keys2[indx]
   (array(['twenty', 'twenty', 'twenty']),
   array(['four', 'one', 'two']))


.. py:function:: matmul(pdaLeft: arkouda.numpy.pdarrayclass.pdarray, pdaRight: arkouda.numpy.pdarrayclass.pdarray) -> arkouda.numpy.pdarrayclass.pdarray

   Compute the product of two matrices.

   :param pdaLeft:
   :type pdaLeft: pdarray
   :param pdaRight:
   :type pdaRight: pdarray

   :returns: the matrix product pdaLeft x pdaRight
   :rtype: pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.array([[1,2,3,4,5],[1,2,3,4,5]])
   >>> b = ak.array([[1,1],[2,2],[3,3],[4,4],[5,5]])
   >>> ak.matmul(a,b)
   array([array([55 55]) array([55 55])])

   >>> x = ak.array([[1,2,3],[1.1,2.1,3.1]])
   >>> y = ak.array([[1,1,1],[0,2,2],[0,0,3]])
   >>> ak.matmul(x,y)
   array([array([1.00000000... 5.00000000... 14.0000000...])
   array([1.10000000... 5.30000000... 14.6000000...])])

   .. rubric:: Notes

   Server returns an error if shapes of pdaLeft and pdaRight
   are incompatible with matrix multiplication.


.. py:function:: maxk(pda: pdarray, k: arkouda.numpy.dtypes.int_scalars) -> pdarray

   Find the `k` maximum values of an array.

   Returns the largest `k` values of an array, sorted

   :param pda: Input array.
   :type pda: pdarray
   :param k: The desired count of maximum values to be returned by the output.
   :type k: int_scalars

   :returns: The maximum `k` values from pda, sorted
   :rtype: pdarray

   :raises TypeError: Raised if pda is not a pdarray or k is not an integer
   :raises ValueError: Raised if the pda is empty, or pda.ndim > 1, or k < 1

   .. rubric:: Notes

   This call is equivalent in value to a[ak.argsort(a)[k:]]

   and generally outperforms this operation.

   This reduction will see a significant drop in performance as `k` grows
   beyond a certain value. This value is system dependent, but generally
   about a `k` of 5 million is where performance degredation has been observed.

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> A = ak.array([10,5,1,3,7,2,9,0])
   >>> ak.maxk(A, 3)
   array([7 9 10])
   >>> ak.maxk(A, 4)
   array([5 7 9 10])


.. py:function:: may_share_memory(a, b)

   Conservative version akin to numpy.may_share_memory.

   For now it just defers to shares_memory.



.. py:function:: median(pda: arkouda.numpy.pdarrayclass.pdarray) -> numpy.float64

   Compute the median of a given array.  1d case only, for now.

   :param pda: The input data, in pdarray form, numeric type or boolean
   :type pda: pdarray

   :returns: | The median of the entire pdarray
             | The array is sorted, and then if the number of elements is odd,
                 the return value is the middle element.  If even, then the
                 mean of the two middle elements.
   :rtype: np.float64

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> pda = ak.array([0,4,7,8,1,3,5,2,-1])
   >>> ak.median(pda)
   np.float64(3.0)
   >>> pda = ak.array([0,1,3,3,1,2,3,4,2,3])
   >>> ak.median(pda)
   np.float64(2.5)


.. py:function:: mink(pda: pdarray, k: arkouda.numpy.dtypes.int_scalars) -> pdarray

   Find the `k` minimum values of an array.

   Returns the smallest `k` values of an array, sorted

   :param pda: Input array.
   :type pda: pdarray
   :param k: The desired count of minimum values to be returned by the output.
   :type k: int_scalars

   :returns: The minimum `k` values from pda, sorted
   :rtype: pdarray

   :raises TypeError: Raised if pda is not a pdarray
   :raises ValueError: Raised if the pda is empty, or pda.ndim > 1, or k < 1

   .. rubric:: Notes

   This call is equivalent in value to a[ak.argsort(a)[:k]]
   and generally outperforms this operation.

   This reduction will see a significant drop in performance as `k` grows
   beyond a certain value. This value is system dependent, but generally
   about a `k` of 5 million is where performance degredation has been observed.

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> A = ak.array([10,5,1,3,7,2,9,0])
   >>> ak.mink(A, 3)
   array([0 1 2])
   >>> ak.mink(A, 4)
   array([0 1 2 3])


.. py:function:: mod(dividend, divisor) -> pdarray

   Returns the element-wise remainder of division.

   Computes the remainder complementary to the floor_divide function.
   It is equivalent to np.mod, the remainder has the same sign as the divisor.

   :param dividend: pdarray : The numeric scalar or pdarray being acted on by the bases for the modular division.
   :param divisor: pdarray : The numeric scalar or pdarray that will be the bases for the modular division.

   :returns: an array that contains the element-wise remainder of division.
   :rtype: pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.array([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20])
   >>> b = ak.array([2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7,8,8])
   >>> ak.mod(a,b)
   array([1 0 1 1 2 0 3 0 1 0 1 2 1 2 3 2 3 4 3 4])

   :raises ValueError: raised if shapes of dividend and divisor are incompatible


.. py:data:: nan
   :type:  float

.. py:data:: newaxis
   :type:  None

.. py:function:: nextafter(x1: Union[arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.dtypes.numeric_scalars, arkouda.numpy.dtypes.bigint], x2: Union[arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.dtypes.numeric_scalars, arkouda.numpy.dtypes.bigint]) -> Union[arkouda.numpy.pdarrayclass.pdarray, float]

   Return the next floating-point value after `x1` towards `x2`, element-wise.
   Accuracy only guaranteed for 64 bit values.

   :param x1: Values to find the next representable value of.
   :type x1: pdarray, numeric_scalars, or bigint
   :param x2: The direction where to look for the next representable value of `x1`.
              If `x1.shape != x2.shape`, they must be broadcastable to a common shape
              (which becomes the shape of the output).
   :type x2: pdarray, numeric_scalars, or bigint

   :returns: The next representable values of `x1` in the direction of `x2`.
             This is a scalar if both `x1` and `x2` are scalars.
   :rtype: pdarray or float

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> eps = np.finfo(np.float64).eps
   >>> ak.nextafter(1, 2) == 1 + eps
    np.True_
   >>> a = ak.array([1, 2])
   >>> b = ak.array([2, 1])
   >>> ak.nextafter(a, b) == ak.array([eps + 1, 2 - eps])
   array([True True])


.. py:class:: number

   Bases: :py:obj:`numpy.generic`


   Abstract base class of all numeric scalar types.


.. py:class:: numeric_and_bool_scalars

   Bases: :py:obj:`_NotIterable`


   Mixin to prevent iteration, without being compatible with Iterable.

   That is, we could do::

       def __iter__(self): raise TypeError()

   But this would make users of this mixin duck type-compatible with
   collections.abc.Iterable - isinstance(foo, Iterable) would be True.

   Luckily, we can instead prevent iteration by setting __iter__ to None, which
   is treated specially.


   .. py:method:: copy_with(params)


.. py:class:: numeric_scalars

   Bases: :py:obj:`_NotIterable`


   Mixin to prevent iteration, without being compatible with Iterable.

   That is, we could do::

       def __iter__(self): raise TypeError()

   But this would make users of this mixin duck type-compatible with
   collections.abc.Iterable - isinstance(foo, Iterable) would be True.

   Luckily, we can instead prevent iteration by setting __iter__ to None, which
   is treated specially.


   .. py:method:: copy_with(params)


.. py:class:: numpy_scalars

   Bases: :py:obj:`_NotIterable`


   Mixin to prevent iteration, without being compatible with Iterable.

   That is, we could do::

       def __iter__(self): raise TypeError()

   But this would make users of this mixin duck type-compatible with
   collections.abc.Iterable - isinstance(foo, Iterable) would be True.

   Luckily, we can instead prevent iteration by setting __iter__ to None, which
   is treated specially.


   .. py:method:: copy_with(params)


.. py:function:: ones(size: Union[arkouda.numpy.dtypes.int_scalars, Tuple[arkouda.numpy.dtypes.int_scalars, Ellipsis], str], dtype: Union[numpy.dtype, type, str, arkouda.numpy.dtypes.bigint] = float64, max_bits: Optional[int] = None) -> arkouda.numpy.pdarrayclass.pdarray

   Create a pdarray filled with ones.

   :param size: Size or shape of the array
   :type size: int_scalars or tuple of int_scalars
   :param dtype: Resulting array type, default ak.float64
   :type dtype: Union[float64, int64, bool]
   :param max_bits: Specifies the maximum number of bits; only used for bigint pdarrays
                    Included for consistency, as ones are all zeros ending on a one, regardless
                    of max_bits
   :type max_bits: int

   :returns: Ones of the requested size or shape and dtype
   :rtype: pdarray

   :raises TypeError: Raised if the supplied dtype is not supported
   :raises RuntimeError: Raised if the size parameter is neither an int nor a str that is parseable to an int.
   :raises ValueError: Raised if the rank of the given shape is not in get_array_ranks() or is empty

   .. seealso:: :py:obj:`zeros`, :py:obj:`ones_like`

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.ones(5, dtype=ak.int64)
   array([1 1 1 1 1])

   >>> ak.ones(5, dtype=ak.float64)
   array([1.00000000000000000 1.00000000000000000 1.00000000000000000
          1.00000000000000000 1.00000000000000000])

   >>> ak.ones(5, dtype=ak.bool_)
   array([True True True True True])

   .. rubric:: Notes

   Logic for generating the pdarray is delegated to the ak.full method.


.. py:function:: ones_like(pda: arkouda.numpy.pdarrayclass.pdarray) -> arkouda.numpy.pdarrayclass.pdarray

   Create a one-filled pdarray of the same size and dtype as an existing
   pdarray.

   :param pda: Array to use for size and dtype
   :type pda: pdarray

   :returns: Equivalent to ak.ones(pda.size, pda.dtype)
   :rtype: pdarray

   :raises TypeError: Raised if the pda parameter is not a pdarray.

   .. seealso:: :py:obj:`ones`, :py:obj:`zeros_like`

   .. rubric:: Notes

   Logic for generating the pdarray is delegated to the ak.ones method.
   Accordingly, the supported dtypes match are defined by the ak.ones method.

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.ones_like(ak.zeros(5,dtype=ak.int64))
   array([1 1 1 1 1])

   >>> ak.ones_like(ak.zeros(5,dtype=ak.float64))
   array([1.00000000000000000 1.00000000000000000 1.00000000000000000
          1.00000000000000000 1.00000000000000000])

   >>> ak.ones_like(ak.zeros(5,dtype=ak.bool_))
   array([True True True True True])


.. py:function:: parity(pda: pdarray) -> pdarray

   Find the bit parity (XOR of all bits) for each integer in an array.

   :param pda: Input array (must be integral).
   :type pda: pdarray, int64, uint64, bigint

   :returns: The parity of each element: 0 if even number of bits set, 1 if odd.
   :rtype: pdarray

   :raises TypeError: If input array is not int64, uint64, or bigint

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> A = ak.arange(10)
   >>> ak.parity(A)
   array([0 1 1 0 1 0 0 1 1 0])


.. py:class:: pdarray(name: str, mydtype: numpy.dtype, size: arkouda.numpy.dtypes.int_scalars, ndim: arkouda.numpy.dtypes.int_scalars, shape: Tuple[int, Ellipsis], itemsize: arkouda.numpy.dtypes.int_scalars, max_bits: Optional[int] = None)

   The basic arkouda array class. This class contains only the
   attributes of the array; the data resides on the arkouda
   server. When a server operation results in a new array, arkouda
   will create a pdarray instance that points to the array data on
   the server. As such, the user should not initialize pdarray
   instances directly.

   .. attribute:: name

      The server-side identifier for the array

      :type: str

   .. attribute:: dtype

      The element dtype of the array

      :type: type

   .. attribute:: size

      The number of elements in the array

      :type: int_scalars

   .. attribute:: ndim

      The rank of the array

      :type: int_scalars

   .. attribute:: shape

      A tuple containing the sizes of each dimension of the array

      :type: Tuple[int, ...]

   .. attribute:: itemsize

      The size in bytes of each element

      :type: int_scalars


   .. py:attribute:: BinOps


   .. py:attribute:: OpEqOps


   .. py:method:: all(axis: Optional[Union[int, Tuple[int, Ellipsis]]] = None, keepdims: bool = False) -> Union[arkouda.numpy.dtypes.bool_scalars, pdarray]

      Return True iff all elements of the array along the given axis evaluate to True.

      :param axis: The axis or axes along which to do the operation
                   If None, the computation is done across the entire array.
      :type axis: int, Tuple[int, ...], optional, default = None
      :param keepdims: Whether to keep the singleton dimension(s) along `axis` in the result.
      :type keepdims: bool, optional, default = False

      :returns: boolean if axis is omitted, pdarray if axis is supplied
      :rtype: boolean or pdarray

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> ak.all(ak.array([True,False,False]))
      np.False_
      >>> ak.all(ak.array([[True,True,False],[False,True,True]]),axis=0)
      array([False True False])
      >>> ak.all(ak.array([[True,True,True],[False,False,False]]),axis=0,keepdims=True)
      array([array([False False False])])
      >>> ak.all(ak.array([[True,True,True],[False,False,False]]),axis=1,keepdims=True)
      array([array([True]) array([False])])
      >>> ak.array([True,False,False]).all()
      np.False_

      :raises TypeError: Raised if pda is not a pdarray instance
      :raises RuntimeError: Raised if there's a server-side error thrown

      .. rubric:: Notes

      Works as a method of a pdarray (e.g. a.any()) or a standalone function (e.g. ak.all(a))



   .. py:method:: any(axis: Optional[Union[int, Tuple[int, Ellipsis]]] = None, keepdims: bool = False) -> Union[arkouda.numpy.dtypes.bool_scalars, pdarray]

      Return True iff any element of the array along the given axis evaluates to True.

      :param axis: The axis or axes along which to do the operation
                   If None, the computation is done across the entire array.
      :type axis: int, Tuple[int, ...], optional, default = None
      :param keepdims: Whether to keep the singleton dimension(s) along `axis` in the result.
      :type keepdims: bool, optional, default = False

      :returns: boolean if axis is omitted, else pdarray if axis is supplied
      :rtype: boolean or pdarray

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> ak.any(ak.array([True,False,False]))
      np.True_
      >>> ak.any(ak.array([[True,True,False],[False,True,True]]),axis=0)
      array([True True True])
      >>> ak.any(ak.array([[True,True,True],[False,False,False]]),axis=0,keepdims=True)
      array([array([True True True])])
      >>> ak.any(ak.array([[True,True,True],[False,False,False]]),axis=1,keepdims=True)
      array([array([True]) array([False])])
      >>> ak.array([True,False,False]).any()
      np.True_

      :raises TypeError: Raised if pda is not a pdarray instance
      :raises RuntimeError: Raised if there's a server-side error thrown

      .. rubric:: Notes

      Works as a method of a pdarray (e.g. a.any()) or a standalone function (e.g. ak.any(a))



   .. py:method:: argmax(axis: Optional[Union[int, None]] = None, keepdims: bool = False) -> Union[numpy.int64, numpy.uint64, pdarray]

      Return index of the first occurrence of the maximum along the given axis.

      :param axis: The axis or axes along which to do the operation
                   If None, the computation is done across the entire array.
      :type axis: int, Tuple[int, ...], optional, default = None
      :param keepdims: Whether to keep the singleton dimension(s) along `axis` in the result.
      :type keepdims: bool, optional, default = False

      :returns: int64 or uint64 if axis is omitted, in which case operation is done over entire array
                pdarray if axis is supplied, in which case the operation is done along that axis
      :rtype: int64, uint64 or pdarray

      :raises TypeError: Raised if pda is not a pdarray instance
      :raises RuntimeError: Raised if there's a server-side error thrown

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> ak.argmax(ak.array([1,2,3,4,5]))
      np.int64(4)
      >>> ak.argmax(ak.array([5.5,4.5,3.5,2.5,1.5]))
      np.int64(0)
      >>> ak.array([[1,2,3],[5,4,3]]).argmax(axis=1)
      array([2 0])

      .. rubric:: Notes

      Works as a method of a pdarray (e.g. a.argmax()) or a standalone function (e.g. ak.argmax(a))



   .. py:method:: argmaxk(k: arkouda.numpy.dtypes.int_scalars) -> pdarray

      Finds the indices corresponding to the `k` maximum values of an array.

      See ``arkouda.argmaxk`` for details.



   .. py:method:: argmin(axis: Optional[Union[int, None]] = None, keepdims: bool = False) -> Union[numpy.int64, numpy.uint64, pdarray]

      Return index of the first occurrence of the minimum along the given axis.

      :param axis: The axis or axes along which to do the operation
                   If None, the computation is done across the entire array.
      :type axis: int, Tuple[int, ...], optional, default = None
      :param keepdims: Whether to keep the singleton dimension(s) along `axis` in the result.
      :type keepdims: bool, optional, default = False

      :returns: int64 or uint64 if axis is omitted, in which case operation is done over entire array
                pdarray if axis is supplied, in which case the operation is done along that axis
      :rtype: int64, uint64 or pdarray

      :raises TypeError: Raised if pda is not a pdarray instance
      :raises RuntimeError: Raised if there's a server-side error thrown

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> ak.argmin(ak.array([1,2,3,4,5]))
      np.int64(0)
      >>> ak.argmin(ak.array([5.5,4.5,3.5,2.5,1.5]))
      np.int64(4)
      >>> ak.array([[1,2,3],[5,4,3]]).argmin(axis=1)
      array([0 2])

      .. rubric:: Notes

      Works as a method of a pdarray (e.g. a.argmin()) or a standalone function (e.g. ak.argmin(a))



   .. py:method:: argmink(k: arkouda.numpy.dtypes.int_scalars) -> pdarray

      Finds the indices corresponding to the `k` minimum values of an array.

      See ``arkouda.argmink`` for details.



   .. py:method:: argsort(algorithm: arkouda.numpy.sorting.SortingAlgorithm = SortingAlgorithm.RadixSortLSD, axis: arkouda.numpy.dtypes.int_scalars = 0, ascending: bool = True) -> pdarray

      Return the permutation that sorts the pdarray.

      :param algorithm: The algorithm to use for sorting.
      :type algorithm: SortingAlgorithm, default SortingAlgorithm.RadixSortLSD
      :param axis: The axis to sort along. Must be between -1 and the array rank.
      :type axis: int_scalars, default 0
      :param ascending: Whether to sort in ascending order. If False, returns a reversed permutation.
                        Note: ascending=False is only supported for 1D arrays.
      :type ascending: bool, default True

      :returns: The indices that would sort the array.
      :rtype: pdarray

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> a = ak.array([42, 7, 19])
      >>> a.argsort()
      array([1 2 0])
      >>> a[a.argsort()]
      array([7 19 42])
      >>> a.argsort(ascending=False)
      array([0 2 1])



   .. py:method:: astype(dtype) -> pdarray

      Cast values of pdarray to provided dtype.

      :param dtype: Dtype to cast to
      :type dtype: np.dtype or str

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> ak.array([1,2,3]).astype(ak.float64)
      array([1.00000000000000000 2.00000000000000000 3.00000000000000000])
      >>> ak.array([1.5,2.5]).astype(ak.int64)
      array([1 2])
      >>> ak.array([True,False]).astype(ak.int64)
      array([1 0])

      :returns: An arkouda pdarray with values converted to the specified data type
      :rtype: pdarray

      .. rubric:: Notes

      This is essentially shorthand for ak.cast(x, '<dtype>') where x is a pdarray.



   .. py:method:: bigint_to_uint_arrays() -> List[pdarray]

      Create a list of uint pdarrays from a bigint pdarray.
      The first item in return will be the highest 64 bits of the
      bigint pdarray and the last item will be the lowest 64 bits.

      :returns: A list of uint pdarrays where:
                The first item in return will be the highest 64 bits of the
                bigint pdarray and the last item will be the lowest 64 bits.
      :rtype: List[pdarrays]

      :raises RuntimeError: Raised if there is a server-side error thrown

      .. seealso:: :py:obj:`pdarraycreation.bigint_from_uint_arrays`

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> a = ak.arange(2**64, 2**64 + 5)
      >>> a
      array([18446744073709551616 18446744073709551617 18446744073709551618
      18446744073709551619 18446744073709551620])
      >>> a.bigint_to_uint_arrays()
      [array([1 1 1 1 1]), array([0 1 2 3 4])]



   .. py:method:: clz() -> pdarray

      Count the number of leading zeros in each element.

      See `ak.clz`.



   .. py:method:: copy() -> pdarray

      Return an array copy of the given object.

      :returns: A deep copy of the pdarray.
      :rtype: pdarray



   .. py:method:: corr(y: pdarray) -> numpy.float64

      Compute the correlation between self and y using pearson correlation coefficient.

      See ``arkouda.corr`` for details.



   .. py:method:: cov(y: pdarray) -> numpy.float64

      Compute the covariance between self and y.



   .. py:method:: ctz() -> pdarray

      Count the number of trailing zeros in each element.

      See `ak.ctz`.



   .. py:attribute:: dtype
      :type:  numpy.dtype


   .. py:method:: equals(other) -> arkouda.numpy.dtypes.bool_scalars

      Whether pdarrays are the same size and all entries are equal.

      :param other: object to compare.
      :type other: object

      :returns: True if the pdarrays are the same, o.w. False.
      :rtype: bool_scalars

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> a = ak.array([1, 2, 3])
      >>> a_cpy = ak.array([1, 2, 3])
      >>> a.equals(a_cpy)
      np.True_
      >>> a2 = ak.array([1, 2, 5])
      >>> a.equals(a2)
      np.False_



   .. py:method:: fill(value: Union[arkouda.numpy.dtypes.numeric_scalars, arkouda.numpy.dtypes.bool_scalars]) -> None

      Fill the array (in place) with a constant value.

      :param value:
      :type value: numeric_scalars

      :raises TypeError: Raised if value is not an int, int64, float, or float64



   .. py:method:: flatten()

      Return a copy of the array collapsed into one dimension.

      :rtype: A copy of the input array, flattened to one dimension.

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> a = ak.array([[3,2,1],[2,3,1]])
      >>> a.flatten()
      array([3 2 1 2 3 1])



   .. py:method:: format_other(other) -> str

      Attempt to cast scalar other to the element dtype of this pdarray,
      and print the resulting value to a string (e.g. for sending to a
      server command). The user should not call this function directly.

      :param other: The scalar to be cast to the pdarray.dtype
      :type other: object

      :rtype: string representation of np.dtype corresponding to the other parameter

      :raises TypeError: Raised if the other parameter cannot be converted to
          Numpy dtype



   .. py:property:: inferred_type
      :type: Union[str, None]


      Return a string of the type inferred from the values.


   .. py:method:: info() -> str

      Return a JSON formatted string containing information about all components of self.

      :returns: JSON string containing information about all components of self
      :rtype: str



   .. py:method:: is_registered() -> numpy.bool_

      Return True iff the object is contained in the registry.

      :returns: Indicates if the object is contained in the registry
      :rtype: bool

      :raises RuntimeError: Raised if there's a server-side error thrown

      .. note::

         This will return True if the object is registered itself or as a component
         of another object



   .. py:method:: is_sorted(axis: Optional[Union[int, Tuple[int, Ellipsis]]] = None, keepdims: bool = False) -> Union[arkouda.numpy.dtypes.bool_scalars, pdarray]

      Return True iff the array (or given axis of the array) is monotonically non-decreasing.

      :param axis: The axis or axes along which to do the operation
                   If None, the computation is done across the entire array.
      :type axis: int, Tuple[int, ...], optional, default = None
      :param keepdims: Whether to keep the singleton dimension(s) along `axis` in the result.
      :type keepdims: bool, optional, default = False

      :returns: boolean if axis is omitted, else pdarray if axis is supplied
      :rtype: boolean or pdarray

      :raises TypeError: Raised if pda is not a pdarray instance
      :raises RuntimeError: Raised if there's a server-side error thrown

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> ak.is_sorted(ak.array([1,2,3,4,5]))
      np.True_
      >>> ak.is_sorted(ak.array([5,4,3,2,1]))
      np.False_
      >>> ak.array([[1,2,3],[5,4,3]]).is_sorted(axis=1)
      array([True False])

      .. rubric:: Notes

      Works as a method of a pdarray (e.g. a.is_sorted()) or a
      standalone function (e.g. ak.is_sorted(a))



   .. py:attribute:: itemsize
      :type:  arkouda.numpy.dtypes.int_scalars


   .. py:method:: max(axis: Optional[Union[int, Tuple[int, Ellipsis]]] = None, keepdims: bool = False) -> Union[arkouda.numpy.dtypes.numeric_scalars, pdarray]

      Return max of array elements along the given axis.

      :param axis: The axis or axes along which to do the operation
                   If None, the computation is done across the entire array.
      :type axis: int, Tuple[int, ...], optional, default = None
      :param keepdims: Whether to keep the singleton dimension(s) along `axis` in the result.
      :type keepdims: bool, optional, default = False

      :returns: numeric_scalar if axis is omitted, in which case operation is done over entire array
                pdarray if axis is supplied, in which case the operation is done along that axis
      :rtype: numeric_scalar or pdarray

      :raises TypeError: Raised if pda is not a pdarray instance
      :raises RuntimeError: Raised if there's a server-side error thrown

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> ak.max(ak.array([1,2,3,4,5]))
      np.int64(5)
      >>> ak.max(ak.array([5.5,4.5,3.5,2.5,1.5]))
      np.float64(5.5)
      >>> ak.array([[1,2,3],[5,4,3]]).max(axis=1)
      array([3 5])

      .. rubric:: Notes

      Works as a method of a pdarray (e.g. a.max()) or a standalone function (e.g. ak.max(a))



   .. py:property:: max_bits


   .. py:method:: maxk(k: arkouda.numpy.dtypes.int_scalars) -> pdarray

      Compute the maximum "k" values.

      See ``arkouda.maxk`` for details.



   .. py:method:: mean(axis: Optional[Union[int, Tuple[int, Ellipsis]]] = None, keepdims: bool = False) -> Union[arkouda.numpy.dtypes.numeric_scalars, pdarray]

      Return the mean of the array.

      :param axis: The axis or axes along which to do the operation
                   If None, the computation is done across the entire array.
      :type axis: int, Tuple[int, ...], optional, default = None
      :param keepdims: Whether to keep the singleton dimension(s) along `axis` in the result.
      :type keepdims: bool, optional, default = False

      :returns: The mean calculated from the pda sum and size, along the axis/axes if
                those are given.
      :rtype: Union[np.float64, pdarray]

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> a = ak.arange(10)
      >>> ak.mean(a)
      np.float64(4.5)
      >>> a.mean()
      np.float64(4.5)
      >>> a = ak.arange(10).reshape(2,5)
      >>> a.mean(axis=0)
      array([2.5 3.5 4.5 5.5 6.5])
      >>> ak.mean(a,axis=0)
      array([2.5 3.5 4.5 5.5 6.5])
      >>> a.mean(axis=1)
      array([2.00000000000000000 7.00000000000000000])
      >>> ak.mean(a,axis=1)
      array([2.00000000000000000 7.00000000000000000])

      :raises Raised if pda is not a pdarray instance:

      RuntimeError
          Raised if there's a server-side error thrown



   .. py:method:: min(axis: Optional[Union[int, Tuple[int, Ellipsis]]] = None, keepdims: bool = False) -> Union[arkouda.numpy.dtypes.numeric_scalars, pdarray]

      Return min of array elements along the given axis.

      :param axis: The axis or axes along which to do the operation
                   If None, the computation is done across the entire array.
      :type axis: int, Tuple[int, ...], optional, default = None
      :param keepdims: Whether to keep the singleton dimension(s) along `axis` in the result.
      :type keepdims: bool, optional, default = False

      :returns: numeric_scalar if axis is omitted, in which case operation is done over entire array
                pdarray if axis is supplied, in which case the operation is done along that axis
      :rtype: numeric_scalar or pdarray

      :raises TypeError: Raised if pda is not a pdarray instance
      :raises RuntimeError: Raised if there's a server-side error thrown

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> ak.min(ak.array([1,2,3,4,5]))
      np.int64(1)
      >>> ak.min(ak.array([5.5,4.5,3.5,2.5,1.5]))
      np.float64(1.5)
      >>> ak.array([[1,2,3],[5,4,3]]).min(axis=1)
      array([1 3])

      .. rubric:: Notes

      Works as a method of a pdarray (e.g. a.min()) or a standalone function (e.g. ak.min(a))



   .. py:method:: mink(k: arkouda.numpy.dtypes.int_scalars) -> pdarray

      Compute the minimum "k" values.

      See ``arkouda.mink`` for details.



   .. py:attribute:: name
      :type:  str


   .. py:property:: nbytes

      The size of the pdarray in bytes.

      :returns: The size of the pdarray in bytes.
      :rtype: int


   .. py:attribute:: ndim
      :type:  arkouda.numpy.dtypes.int_scalars


   .. py:attribute:: objType
      :value: 'pdarray'



   .. py:method:: opeq(other, op)


   .. py:method:: parity() -> pdarray

      Find the parity (XOR of all bits) in each element.

      See `ak.parity`.



   .. py:method:: popcount() -> pdarray

      Find the population (number of bits set) in each element.

      See `ak.popcount`.



   .. py:method:: pretty_print_info() -> None

      Print information about all components of self in a human-readable format.



   .. py:method:: prod(axis: Optional[Union[int, Tuple[int, Ellipsis]]] = None, keepdims: bool = False) -> Union[arkouda.numpy.dtypes.numeric_scalars, pdarray]

      Return prod of array elements along the given axis.

      :param axis: The axis or axes along which to do the operation
                   If None, the computation is done across the entire array.
      :type axis: int, Tuple[int, ...], optional, defalt = None
      :param keepdims: Whether to keep the singleton dimension(s) along `axis` in the result.
      :type keepdims: bool, optional, default = False

      :returns: numeric_scalars if axis is omitted, in which case operation is done over entire array
                pdarray if axis is supplied, in which case the operation is done along that axis
      :rtype: numeric_scalars or pdarray

      :raises TypeError: Raised if pda is not a pdarray instance
      :raises RuntimeError: Raised if there's a server-side error thrown

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> ak.prod(ak.array([1,2,3,4,5]))
      np.int64(120)
      >>> ak.prod(ak.array([5.5,4.5,3.5,2.5,1.5]))
      np.float64(324.84375)
      >>> ak.array([[1,2,3],[5,4,3]]).prod(axis=1)
      array([6 60])

      .. rubric:: Notes

      Works as a method of a pdarray (e.g. a.prod()) or a standalone function (e.g. ak.prod(a))



   .. py:method:: register(user_defined_name: str) -> pdarray

      Register this pdarray with a user defined name in the arkouda server
      so it can be attached to later using pdarray.attach().

      This is an in-place operation, registering a pdarray more than once will
      update the name in the registry and remove the previously registered name.
      A name can only be registered to one pdarray at a time.

      :param user_defined_name: user defined name array is to be registered under
      :type user_defined_name: str

      :returns: The same pdarray which is now registered with the arkouda server and has an updated name.
                This is an in-place modification, the original is returned to support a
                fluid programming style.
                Please note you cannot register two different pdarrays with the same name.
      :rtype: pdarray

      :raises TypeError: Raised if user_defined_name is not a str
      :raises RegistrationError: If the server was unable to register the pdarray with the user_defined_name
          If the user is attempting to register more than one pdarray with the same name,
          the former should be unregistered first to free up the registration name.

      .. seealso:: :py:obj:`attach`, :py:obj:`unregister`, :py:obj:`is_registered`, :py:obj:`list_registry`, :py:obj:`unregister_pdarray_by_name`

      .. rubric:: Notes

      Registered names/pdarrays in the server are immune to deletion
      until they are unregistered.

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> a = ak.zeros(3)
      >>> a.register("my_zeros")
      array([0.00000000000000000 0.00000000000000000 0.00000000000000000])

      potentially disconnect from server and reconnect to server
      >>> b = ak.attach("my_zeros")
      >>> b.unregister()



   .. py:attribute:: registered_name
      :type:  Optional[str]
      :value: None



   .. py:method:: reshape(*shape)

      Gives a new shape to an array without changing its data.

      :param shape: The new shape should be compatible with the original shape.
      :type shape: int, tuple of ints, or pdarray

      :returns: a pdarray with the same data, reshaped to the new shape
      :rtype: pdarray

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> a = ak.array([[3,2,1],[2,3,1]])
      >>> a.reshape((3,2))
      array([array([3 2]) array([1 2]) array([3 1])])
      >>> a.reshape(3,2)
      array([array([3 2]) array([1 2]) array([3 1])])
      >>> a.reshape((6,1))
      array([array([3]) array([2]) array([1]) array([2]) array([3]) array([1])])

      .. rubric:: Notes

      only available as a method, not as a standalone function, i.e.,
      a.reshape(compatibleShape) is valid, but ak.reshape(a,compatibleShape) is not.



   .. py:method:: rotl(other) -> pdarray

      Rotate bits left by <other>.



   .. py:method:: rotr(other) -> pdarray

      Rotate bits right by <other>.



   .. py:property:: shape

      Return the shape of an array.

      :returns: The elements of the shape tuple give the lengths of the corresponding array dimensions.
      :rtype: tuple of int


   .. py:attribute:: size
      :type:  arkouda.numpy.dtypes.int_scalars


   .. py:method:: slice_bits(low, high) -> pdarray

      Return a pdarray containing only bits from low to high of self.

      This is zero indexed and inclusive on both ends, so slicing the bottom 64 bits is
      pda.slice_bits(0, 63)

      :param low: The lowest bit included in the slice (inclusive)
                  zero indexed, so the first bit is 0
      :type low: int
      :param high: The highest bit included in the slice (inclusive)
      :type high: int

      :returns: A new pdarray containing the bits of self from low to high
      :rtype: pdarray

      :raises RuntimeError: Raised if there is a server-side error thrown

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> p = ak.array([2**65 + (2**64 - 1)])
      >>> bin(p[0])
      '0b101111111111111111111111111111111111111111111111111111111111111111'
      >>> bin(p.slice_bits(64, 65)[0])
      '0b10'
      >>> a = ak.array([143,15])
      >>> a.slice_bits(1,3)
      array([7 7])
      >>> a.slice_bits(4,9)
      array([8 0])
      >>> a.slice_bits(1,9)
      array([71 7])



   .. py:method:: std(ddof: arkouda.numpy.dtypes.int_scalars = 0, axis: Optional[Union[int, Tuple[int, Ellipsis]]] = None, keepdims: Optional[bool] = False) -> Union[numpy.float64, pdarray]

      Return the standard deviation of values in the array. The standard
      deviation is implemented as the square root of the variance.

      :param ddof: "Delta Degrees of Freedom" used in calculating std
      :type ddof: int_scalars
      :param axis: The axis or axes along which to do the operation
                   If None, the computation is done across the entire array.
      :type axis: int, Tuple[int, ...], optional, default = None
      :param keepdims: Whether to keep the singleton dimension(s) along `axis` in the result.
      :type keepdims: bool, optional, default = False

      :returns:

                The scalar standard deviation of the array, or the standard deviation
                 along the axis/axes if supplied
      :rtype: Union[np.float64, pdarray]

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> a = ak.arange(10)
      >>> ak.std(a)
      np.float64(2.8722813232690143)
      >>> a.std()
      np.float64(2.8722813232690143)
      >>> a = ak.arange(10).reshape(2,5)
      >>> a.std(axis=0)
      array([2.5 2.5 2.5 2.5 2.5])
      >>> ak.std(a,axis=0)
      array([2.5 2.5 2.5 2.5 2.5])
      >>> a.std(axis=1)
      array([1.4142135623730951 1.4142135623730951])
      >>> ak.std(a,axis=1)
      array([1.4142135623730951 1.4142135623730951])

      :raises TypeError: Raised if pda is not a pdarray instance or ddof is not an integer
      :raises ValueError: Raised if ddof is an integer < 0
      :raises RuntimeError: Raised if there's a server-side error thrown

      .. seealso:: :py:obj:`mean`, :py:obj:`var`

      .. rubric:: Notes

      The standard deviation is the square root of the average of the squared
      deviations from the mean, i.e., ``std = sqrt(mean((x - x.mean())**2))``.

      The average squared deviation is normally calculated as
      ``x.sum() / N``, where ``N = len(x)``.  If, however, `ddof` is specified,
      the divisor ``N - ddof`` is used instead. In standard statistical
      practice, ``ddof=1`` provides an unbiased estimator of the variance
      of the infinite population. ``ddof=0`` provides a maximum likelihood
      estimate of the variance for normally distributed variables. The
      standard deviation computed in this function is the square root of
      the estimated variance, so even with ``ddof=1``, it will not be an
      unbiased estimate of the standard deviation per se.



   .. py:method:: sum(axis: Optional[Union[int, Tuple[int, Ellipsis]]] = None, keepdims: bool = False) -> Union[arkouda.numpy.dtypes.numeric_scalars, pdarray]

      Return sum of array elements along the given axis.

      :param axis: The axis or axes along which to do the operation
                   If None, the computation is done across the entire array.
      :type axis: int, Tuple[int, ...], optional, default = None
      :param keepdims: Whether to keep the singleton dimension(s) along `axis` in the result.
      :type keepdims: bool, optional, default = False

      :returns: numeric_scalars if axis is omitted, in which case operation is done over entire array
                pdarray if axis is supplied, in which case the operation is done along that axis
      :rtype: numeric_scalars or pdarray

      :raises TypeError: Raised if pda is not a pdarray instance
      :raises RuntimeError: Raised if there's a server-side error thrown

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> ak.sum(ak.array([1,2,3,4,5]))
      np.int64(15)
      >>> ak.sum(ak.array([5.5,4.5,3.5,2.5,1.5]))
      np.float64(17.5)
      >>> ak.array([[1,2,3],[5,4,3]]).sum(axis=1)
      array([6 12])

      .. rubric:: Notes

      Works as a method of a pdarray (e.g. a.sum()) or a standalone function (e.g. ak.sum(a))



   .. py:method:: take(indices: Union[arkouda.numpy.dtypes.numeric_scalars, pdarray], axis: Optional[int] = None) -> pdarray

      Take elements from the array along an axis.

      When axis is not None, this function does the same thing as “fancy” indexing (indexing arrays
      using arrays); however, it can be easier to use if you need elements along a given axis.
      A call such as ``np.take(arr, indices, axis=3)`` is equivalent to ``arr[:,:,:,indices,...]``.

      :param indices: The indices of the values to extract. Also allow scalars for indices.
      :type indices: numeric_scalars or pdarray
      :param axis: The axis over which to select values. By default, the flattened input array is used.
      :type axis: int, optional

      :returns: The returned array has the same type as `a`.
      :rtype: pdarray

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> a = ak.array([4, 3, 5, 7, 6, 8])
      >>> indices = [0, 1, 4]
      >>> a.take(indices)
      array([4 3 6])



   .. py:method:: to_csv(prefix_path: str, dataset: str = 'array', col_delim: str = ',', overwrite: bool = False)

      Write pdarry to CSV file(s).  File will contain a single column
      with the pdarray data.  All CSV files written by Arkouda include
      a header denoting data types of the columns.

      :param prefix_path: filename prefix to be used for saving files.  Files will have
                          _LOCALE#### appended when they are written to disk.
      :type prefix_path: str
      :param dataset: column name to save the pdarray under.
      :type dataset: str, defaults to "array"
      :param col_delim: value to be used to separate columns within the file.  Please
                        be sure that the value used DOES NOT appear in your dataset.
      :type col_delim: str, defaults to ","
      :param overwrite: If True, existing files matching the provided path will be overwritten.
                        if False and existing files are found, an error will be returned.
      :type overwrite: bool, defaults to False

      :returns: **response message**
      :rtype: str

      :raises ValueError: Raised if all datasets are not present in all parquet files or if one
          or more of the specified files do not exist
      :raises RuntimeError: Raised if one or more of the specified files cannot be opened.
          if 'allow_errors' is true, this may be raised if no values are returned
          from the server.
      :raises TypeError: Raise if the server returns an unknown arkouda_type

      .. rubric:: Notes

      - CSV format is not currently supported by load/load_all operations
      - The column delimiter is expected to be the same for all column names and data
      - Be sure that column delimiters are not found within your data.
      - All CSV files must delimit rows using newline ("\\n") at this time.



   .. py:method:: to_cuda()

      Convert the array to a Numba DeviceND array, transferring array data from the
      arkouda server to Python via ndarray. If the array exceeds a builtin size limit,
      a RuntimeError is raised.

      :returns: A Numba ndarray with the same attributes and data as the pdarray; on GPU
      :rtype: numba.DeviceNDArray

      :raises ImportError: Raised if CUDA is not available
      :raises ModuleNotFoundError: Raised if Numba is either not installed or not enabled
      :raises RuntimeError: Raised if there is a server-side error thrown in the course of retrieving
          the pdarray.

      .. rubric:: Notes

      The number of bytes in the array cannot exceed ``client.maxTransferBytes``,
      otherwise a ``RuntimeError`` will be raised. This is to protect the user
      from overflowing the memory of the system on which the Python client
      is running, under the assumption that the server is running on a
      distributed system with much more memory than the client. The user
      may override this limit by setting client.maxTransferBytes to a larger
      value, but proceed with caution.

      .. seealso:: :py:obj:`array`

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> a = ak.arange(0, 5, 1)
      >>> a.to_cuda() # doctest: +SKIP
      array([0, 1, 2, 3, 4])
      >>> type(a.to_cuda()) # doctest: +SKIP
      numpy.devicendarray



   .. py:method:: to_hdf(prefix_path: str, dataset: str = 'array', mode: str = 'truncate', file_type: str = 'distribute') -> str

      Save the pdarray to HDF5.
      The object can be saved to a collection of files or single file.

      :param prefix_path: Directory and filename prefix that all output files share
      :type prefix_path: str
      :param dataset: Name of the dataset to create in files (must not already exist)
      :type dataset: str
      :param mode: By default, truncate (overwrite) output files, if they exist.
                   If 'append', attempt to create new dataset in existing files.
      :type mode: str {'truncate' | 'append'}
      :param file_type: Default: "distribute"
                        When set to single, dataset is written to a single file.
                        When distribute, dataset is written on a file per locale.
                        This is only supported by HDF5 files and will have no impact of Parquet Files.
      :type file_type: str ("single" | "distribute")

      :rtype: string message indicating result of save operation

      :raises RuntimeError: Raised if a server-side error is thrown saving the pdarray

      .. rubric:: Notes

      - The prefix_path must be visible to the arkouda server and the user must
      have write permission.
      - Output files have names of the form ``<prefix_path>_LOCALE<i>``, where ``<i>``
      ranges from 0 to ``numLocales`` for `file_type='distribute'`. Otherwise,
      the file name will be `prefix_path`.
      - If any of the output files already exist and
      the mode is 'truncate', they will be overwritten. If the mode is 'append'
      and the number of output files is less than the number of locales or a
      dataset with the same name already exists, a ``RuntimeError`` will result.
      - Any file extension can be used.The file I/O does not rely on the extension to
      determine the file format.

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> a = ak.arange(25)

      Saving without an extension
      >>> a.to_hdf('path/prefix', dataset='array') # doctest: +SKIP
      Saves the array to numLocales HDF5 files with the name ``cwd/path/name_prefix_LOCALE####``

      Saving with an extension (HDF5)
      >>> a.to_hdf('path/prefix.h5', dataset='array') # doctest: +SKIP
      Saves the array to numLocales HDF5 files with the name
      ``cwd/path/name_prefix_LOCALE####.h5`` where #### is replaced by each locale number

      Saving to a single file
      >>> a.to_hdf('path/prefix.hdf5', dataset='array', file_type='single') # doctest: +SKIP
      Saves the array in to single hdf5 file on the root node.
      ``cwd/path/name_prefix.hdf5``



   .. py:method:: to_ndarray() -> numpy.ndarray

      Convert the array to a np.ndarray, transferring array data from the
      Arkouda server to client-side Python. Note: if the pdarray size exceeds
      client.maxTransferBytes, a RuntimeError is raised.

      :returns: A numpy ndarray with the same attributes and data as the pdarray
      :rtype: np.ndarray

      :raises RuntimeError: Raised if there is a server-side error thrown, if the pdarray size
          exceeds the built-in client.maxTransferBytes size limit, or if the bytes
          received does not match expected number of bytes

      .. rubric:: Notes

      The number of bytes in the array cannot exceed ``client.maxTransferBytes``,
      otherwise a ``RuntimeError`` will be raised. This is to protect the user
      from overflowing the memory of the system on which the Python client
      is running, under the assumption that the server is running on a
      distributed system with much more memory than the client. The user
      may override this limit by setting client.maxTransferBytes to a larger
      value, but proceed with caution.

      .. seealso:: :py:obj:`array`, :py:obj:`tolist`

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> a = ak.arange(0, 5, 1)
      >>> a.to_ndarray()
      array([0, 1, 2, 3, 4])
      >>> type(a.to_ndarray())
      <class 'numpy.ndarray'>



   .. py:method:: to_parquet(prefix_path: str, dataset: str = 'array', mode: str = 'truncate', compression: Optional[str] = None) -> str

      Save the pdarray to Parquet. The result is a collection of files,
      one file per locale of the arkouda server, where each filename starts
      with prefix_path. Each locale saves its chunk of the array to its
      corresponding file.

      :param prefix_path: Directory and filename prefix that all output files share
      :type prefix_path: str
      :param dataset: Name of the dataset to create in files (must not already exist)
      :type dataset: str
      :param mode: By default, truncate (overwrite) output files, if they exist.
                   If 'append', attempt to create new dataset in existing files.
      :type mode: str {'truncate' | 'append'}
      :param compression: (None | "snappy" | "gzip" | "brotli" | "zstd" | "lz4")
                          Sets the compression type used with Parquet files
      :type compression: str (Optional)

      :rtype: string message indicating result of save operation

      :raises RuntimeError: Raised if a server-side error is thrown saving the pdarray

      .. rubric:: Notes

      - The prefix_path must be visible to the arkouda server and the user must
      have write permission.
      - Output files have names of the form ``<prefix_path>_LOCALE<i>``, where ``<i>``
      ranges from 0 to ``numLocales`` for `file_type='distribute'`.
      - 'append' write mode is supported, but is not efficient.
      - If any of the output files already exist and
      the mode is 'truncate', they will be overwritten. If the mode is 'append'
      and the number of output files is less than the number of locales or a
      dataset with the same name already exists, a ``RuntimeError`` will result.
      - Any file extension can be used.The file I/O does not rely on the extension to
      determine the file format.

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> a = ak.arange(25)

      Saving without an extension
      >>> a.to_parquet('path/prefix', dataset='array') # doctest: +SKIP
      Saves the array to numLocales HDF5 files with the name ``cwd/path/name_prefix_LOCALE####``

      Saving with an extension (HDF5)
      >>> a.to_parqet('path/prefix.parquet', dataset='array') # doctest: +SKIP
      Saves the array to numLocales HDF5 files with the name
      ``cwd/path/name_prefix_LOCALE####.parquet`` where #### is replaced by each locale number



   .. py:method:: tolist() -> List[arkouda.numpy.dtypes.numeric_scalars]

      Convert the array to a list, transferring array data from the
      Arkouda server to client-side Python. Note: if the pdarray size exceeds
      client.maxTransferBytes, a RuntimeError is raised.

      :returns: A list with the same data as the pdarray
      :rtype: List[numeric_scalars]

      :raises RuntimeError: Raised if there is a server-side error thrown, if the pdarray size
          exceeds the built-in client.maxTransferBytes size limit, or if the bytes
          received does not match expected number of bytes

      .. rubric:: Notes

      The number of bytes in the array cannot exceed ``client.maxTransferBytes``,
      otherwise a ``RuntimeError`` will be raised. This is to protect the user
      from overflowing the memory of the system on which the Python client
      is running, under the assumption that the server is running on a
      distributed system with much more memory than the client. The user
      may override this limit by setting client.maxTransferBytes to a larger
      value, but proceed with caution.

      .. seealso:: :py:obj:`to_ndarray`

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> a = ak.arange(0, 5, 1)
      >>> a.tolist()
      [0, 1, 2, 3, 4]
      >>> type(a.tolist())
      <class 'list'>



   .. py:method:: transfer(hostname: str, port: arkouda.numpy.dtypes.int_scalars)

      Send a pdarray to a different Arkouda server.

      :param hostname: The hostname where the Arkouda server intended to
                       receive the pdarray is running.
      :type hostname: str
      :param port: The port to send the array over. This needs to be an
                   open port (i.e., not one that the Arkouda server is
                   running on). This will open up `numLocales` ports,
                   each of which in succession, so will use ports of the
                   range {port..(port+numLocales)} (e.g., running an
                   Arkouda server of 4 nodes, port 1234 is passed as
                   `port`, Arkouda will use ports 1234, 1235, 1236,
                   and 1237 to send the array data).
                   This port much match the port passed to the call to
                   `ak.receive_array()`.
      :type port: int_scalars

      :rtype: A message indicating a complete transfer

      :raises ValueError: Raised if the op is not within the pdarray.BinOps set
      :raises TypeError: Raised if other is not a pdarray or the pdarray.dtype is not
          a supported dtype



   .. py:method:: unregister() -> None

      Unregister a pdarray in the arkouda server which was previously
      registered using register() and/or attahced to using attach().

      :raises RuntimeError: Raised if the server could not find the internal name/symbol to remove

      .. seealso:: :py:obj:`register`, :py:obj:`unregister`, :py:obj:`is_registered`, :py:obj:`unregister_pdarray_by_name`, :py:obj:`list_registry`

      .. rubric:: Notes

      Registered names/pdarrays in the server are immune to deletion until
      they are unregistered.

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> a = ak.zeros(3)
      >>> a.register("my_zeros")
      array([0.00000000000000000 0.00000000000000000 0.00000000000000000])

      potentially disconnect from server and reconnect to server
      >>> b = ak.attach("my_zeros")
      >>> b.unregister()



   .. py:method:: update_hdf(prefix_path: str, dataset: str = 'array', repack: bool = True)

      Overwrite the dataset with the name provided with this pdarray. If
      the dataset does not exist it is added.

      :param prefix_path: Directory and filename prefix that all output files share
      :type prefix_path: str
      :param dataset: Name of the dataset to create in files
      :type dataset: str
      :param repack: Default: True
                     HDF5 does not release memory on delete. When True, the inaccessible
                     data (that was overwritten) is removed. When False, the data remains, but is
                     inaccessible. Setting to false will yield better performance, but will cause
                     file sizes to expand.
      :type repack: bool

      :rtype: str - success message if successful

      :raises RuntimeError: Raised if a server-side error is thrown saving the pdarray

      .. rubric:: Notes

      - If file does not contain File_Format attribute to indicate how it was saved,
        the file name is checked for _LOCALE#### to determine if it is distributed.
      - If the dataset provided does not exist, it will be added



   .. py:method:: value_counts()

      Count the occurrences of the unique values of self.

      :returns:

                unique_values : pdarray
                    The unique values, sorted in ascending order

                counts : pdarray, int64
                    The number of times the corresponding unique value occurs
      :rtype: pdarray, pdarray|int64

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> ak.array([2, 0, 2, 4, 0, 0]).value_counts()
      (array([0 2 4]), array([3 2 1]))



   .. py:method:: var(ddof: arkouda.numpy.dtypes.int_scalars = 0, axis: Optional[Union[int, Tuple[int, Ellipsis]]] = None, keepdims: Optional[bool] = False) -> Union[numpy.float64, pdarray]

      Return the variance of values in the array.

      :param ddof: "Delta Degrees of Freedom" used in calculating var
      :type ddof: int_scalars
      :param axis: The axis or axes along which to do the operation
                   If None, the computation is done across the entire array.
      :type axis: int, Tuple[int, ...], optional, default = None
      :param keepdims: Whether to keep the singleton dimension(s) along `axis` in the result.
      :type keepdims: bool, optional, default = False

      :returns: The scalar variance of the array, or the variance along the axis/axes
                if supplied
      :rtype: Union[np.float64, pdarray]

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> a = ak.arange(10)
      >>> ak.var(a)
      np.float64(8.25)
      >>> a.var()
      np.float64(8.25)
      >>> a = ak.arange(10).reshape(2,5)
      >>> a.var(axis=0)
      array([6.25 6.25 6.25 6.25 6.25])
      >>> ak.var(a,axis=0)
      array([6.25 6.25 6.25 6.25 6.25])
      >>> a.var(axis=1)
      array([2.00000000000000000 2.00000000000000000])
      >>> ak.var(a,axis=1)
      array([2.00000000000000000 2.00000000000000000])

      :raises TypeError: Raised if pda is not a pdarray instance
      :raises ValueError: Raised if the ddof >= pdarray size
      :raises RuntimeError: Raised if there's a server-side error thrown

      .. seealso:: :py:obj:`mean`, :py:obj:`std`

      .. rubric:: Notes

      The variance is the average of the squared deviations from the mean,
      i.e.,  ``var = mean((x - x.mean())**2)``.

      The mean is normally calculated as ``x.sum() / N``, where ``N = len(x)``.
      If, however, `ddof` is specified, the divisor ``N - ddof`` is used
      instead.  In standard statistical practice, ``ddof=1`` provides an
      unbiased estimator of the variance of a hypothetical infinite population.
      ``ddof=0`` provides a maximum likelihood estimate of the variance for
      normally distributed variables.



.. py:function:: percentile(a: arkouda.numpy.pdarrayclass.pdarray, q: Optional[Union[arkouda.numpy.dtypes.numeric_scalars, Tuple[arkouda.numpy.dtypes.numeric_scalars], numpy.ndarray]] = 0.5, axis: Optional[Union[arkouda.numpy.dtypes.int_scalars, Tuple[arkouda.numpy.dtypes.int_scalars, Ellipsis], None]] = None, method: Optional[str] = 'linear', keepdims: bool = False) -> Union[arkouda.numpy.dtypes.numeric_scalars, arkouda.numpy.pdarrayclass.pdarray]

   Compute the q-th percentile of the data along the specified axis.

   :param a: data whose percentile will be computed
   :type a: pdarray
   :param q: a scalar, tuple, or np.ndarray of q values for the computation.  All values
             must be in the range 0 <= q <= 100
   :type q: pdarray, Tuple, or np.ndarray
   :param axis: the axis or axes along which the percentiles are computed.  The default is None,
                which computes the percenntile along a flattened version of the array.
   :type axis: None, int scalar, or tuple of int scalars
   :param method: one of "inverted_cdf," "averaged_inverted_cdf", "closest_observation",
                  "interpolated_inverted_cdf", "hazen", "weibull", "linear", 'median_unbiased",
                  "normal_unbiased", "lower"," higher", "midpoint"
   :type method: string
   :param keepdims: True if the degenerate axes are to be retained after slicing, False if not
   :type keepdims: bool

   :returns: If q is a scalar and axis is None, the result is a scalar.
             If q is a scalar and axis is supplied, the result is a pdarray of rank len(axis)
             less than the rank of a.
             If q is an array and axis is None, the result is a pdarray of shape q.shape
             If q is an array and axis is None, the result is a pdarray of rank q.ndim +
             pda.ndim - len(axis).  However, there is an intermediate result which is of rank
             q.ndim + pda.ndim.  If this is not in the compiled ranks, an error will be thrown
             even if the final result would be in the compiled ranks.
   :rtype: pdarray or scalar

   .. rubric:: Notes

   np.percentile also supports the method "nearest," however its behavior does not match
   the numpy documentation, so it's not supported here.
   np.percentile also allows for weighted inputs, but only for the method "inverted_cdf."
   That also is not supported here.

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.array([[1,2,3,4,5],[1,2,3,4,5]])
   >>> q = 70
   >>> ak.percentile(a,q,axis=None,method="linear")
   np.float64(4.0)
   >>> ak.percentile(a,q,axis=1,method="lower")
   array([3.00000000... 3.00000000...])
   >>> q = np.array([40,60])
   >>> ak.percentile(a,q,axis=None,method="weibull")
   array([2.40000000... 3.59999999...])
   >>> a = ak.array([[1,2],[5,3]])
   >>> ak.percentile(a,q,axis=0,method="hazen")
   array([array([2.20000000... 2.29999999...])
       array([3.79999999... 2.69999999...])])

   :raises ValueError: Raised if scalar q or any value of array q is outside the range [0,100]
       Raised if the method is not one of the 12 supported methods.
       Raised if the result would have a rank not in the compiled ranks.


.. py:data:: pi
   :type:  float

.. py:function:: plot_dist(b: arkouda.pdarrayclass.pdarray | numpy.typing.NDArray[numpy.floating], h: arkouda.pdarrayclass.pdarray | numpy.typing.NDArray[numpy.floating], *, log: bool = True, xlabel: Optional[str] = None, newfig: bool = True, show: bool = False) -> Tuple[matplotlib.figure.Figure, numpy.ndarray]

   Plot the distribution and cumulative distribution of histogram data.

   :param b: Histogram bin edges (length N+1) or bin centers (length N).
   :type b: arkouda.pdarray or numpy.ndarray
   :param h: Histogram counts. Accepts length N or N+1 (Arkouda-like extra last bin).
   :type h: arkouda.pdarray or numpy.ndarray
   :param log: If True, use a log scale for the y-axis of the distribution plot.
   :type log: bool, default True
   :param xlabel: Label for the x-axis.
   :type xlabel: str, optional
   :param newfig: If True, create a new figure; otherwise draw into the current figure.
   :type newfig: bool, default True
   :param show: If True, call ``plt.show()`` before returning.
   :type show: bool, default False

   :returns: (fig, axes) where axes[0] is the distribution, axes[1] the cumulative.
   :rtype: tuple[matplotlib.figure.Figure, numpy.ndarray]

   .. rubric:: Notes

   If ``h`` is one element longer than expected (as with ``ak.histogram``),
   the final element is dropped automatically.

   .. rubric:: Examples

   Using Arkouda's histogram:
   >>> import arkouda as ak
   >>> import numpy as np
   >>> from matplotlib import pyplot as plt
   >>> from arkouda.plotting import plot_dist
   >>> edges, counts = ak.histogram(ak.arange(10), 3)
   >>> fig, axes = plot_dist(edges, counts)
   >>> fig.savefig("dist.png")

   Using NumPy's histogram:
   >>> data = np.random.randn(1000)
   >>> counts, edges = np.histogram(data, bins=20)
   >>> fig, axes = plot_dist(edges, counts, xlabel="Value")
   >>> plt.show()


.. py:function:: popcount(pda: pdarray) -> pdarray

   Find the population (number of bits set) for each integer in an array.

   :param pda: Input array (must be integral).
   :type pda: pdarray, int64, uint64, bigint

   :returns: The number of bits set (1) in each element
   :rtype: pdarray

   :raises TypeError: If input array is not int64, uint64, or bigint

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> A = ak.arange(10)
   >>> ak.popcount(A)
   array([0 1 1 2 1 2 2 3 1 2])


.. py:function:: power(pda: pdarray, pwr: Union[int, float, pdarray], where: Union[arkouda.numpy.dtypes.bool_scalars, pdarray] = True) -> pdarray

   Raises an array to a power. If where is given, the operation will only take place in the positions
   where the where condition is True.

   Note:
   Our implementation of the where argument deviates from numpy. The difference in behavior occurs
   at positions where the where argument contains a False. In numpy, these position will have
   uninitialized memory (which can contain anything and will vary between runs). We have chosen to
   instead return the value of the original array in these positions.

   :param pda: A pdarray of values that will be raised to a power (pwr)
   :type pda: pdarray
   :param pwr: The power(s) that pda is raised to
   :type pwr: integer, float, or pdarray
   :param where: This condition is broadcast over the input. At locations where the condition is True, the
                 corresponding value will be raised to the respective power. Elsewhere, it will retain its
                 original value. Default set to True.
   :type where: Boolean or pdarray

   :returns: a pdarray of values raised to a power, under the boolean where condition.
   :rtype: pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.arange(5)
   >>> ak.power(a, 3)
   array([0 1 8 27 64])
   >>> ak.power(a, 3, a % 2 == 0)
   array([0 1 8 3 64])

   :raises TypeError: raised if pda is not a pdarray, or if pwe is not an int, float, or pdarray
   :raises ValueError: raised if pda and power are of incompatible dimensions


.. py:function:: power_divergence(f_obs, f_exp=None, ddof=0, lambda_=None)

   Computes the power divergence statistic and p-value.

   :param f_obs: The observed frequency.
   :type f_obs: pdarray
   :param f_exp: The expected frequency.
   :type f_exp: pdarray, default = None
   :param ddof: The delta degrees of freedom.
   :type ddof: int
   :param lambda_: The power in the Cressie-Read power divergence statistic.
                   Allowed values: "pearson", "log-likelihood", "freeman-tukey", "mod-log-likelihood",
                   "neyman", "cressie-read"

                   Powers correspond as follows:

                   "pearson": 1

                   "log-likelihood": 0

                   "freeman-tukey": -0.5

                   "mod-log-likelihood": -1

                   "neyman": -2

                   "cressie-read": 2 / 3
   :type lambda_: string, default = "pearson"

   :rtype: arkouda.akstats.Power_divergenceResult

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> from arkouda.scipy import power_divergence
   >>> x = ak.array([10, 20, 30, 10])
   >>> y = ak.array([10, 30, 20, 10])
   >>> power_divergence(x, y, lambda_="pearson")
   Power_divergenceResult(statistic=np.float64(8.333333333333334),
       pvalue=np.float64(0.03960235520756414))
   >>> power_divergence(x, y, lambda_="log-likelihood")
   Power_divergenceResult(statistic=np.float64(8.109302162163285),
       pvalue=np.float64(0.04380595350226197))

   .. seealso:: :py:obj:`scipy.stats.power_divergence`, :py:obj:`arkouda.akstats.chisquare`

   .. rubric:: Notes

   This is a modified version of scipy.stats.power_divergence [2]
   in order to scale using arkouda pdarrays.

   .. rubric:: References

   [1] "scipy.stats.power_divergence",
   https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.power_divergence.html

   [2] Scipy contributors (2024) scipy (Version v1.12.0) [Source code].
   https://github.com/scipy/scipy


.. py:function:: pretty_print_information(names: Union[List[str], str] = RegisteredSymbols) -> None

   Print verbose information for each object in names in a human readable format.

   :param names: names is either the name of an object or list of names of objects to retrieve info
                 if names is ak.AllSymbols, retrieves info for all symbols in the symbol table
                 if names is ak.RegisteredSymbols, retrieves info for all symbols in the registry
   :type names: Union[List[str], str]

   :raises RuntimeError: Raised if a server-side error is thrown in the process of
       retrieving information about the objects in names


.. py:function:: promote_to_common_dtype(arrays: List[arkouda.numpy.pdarrayclass.pdarray]) -> Tuple[Any, List[arkouda.numpy.pdarrayclass.pdarray]]

   Promote a list of pdarrays to a common dtype.

   :param arrays: List of pdarrays to promote
   :type arrays: List[pdarray]

   :returns: The common dtype of the pdarrays and the list of pdarrays promoted to that dtype
   :rtype: dtype, List[pdarray]

   :raises TypeError: Raised if any pdarray is a non-numeric type

   .. seealso:: :py:obj:`pdarray.promote_dtype`

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.arange(5)
   >>> b = ak.ones(5, dtype=ak.float64)
   >>> dtype, promoted = ak.promote_to_common_dtype([a, b])
   >>> dtype
   dtype('float64')
   >>> all(isinstance(p, ak.pdarray) and p.dtype == dtype for p in promoted)
   True


.. py:function:: putmask(A: arkouda.numpy.pdarrayclass.pdarray, mask: arkouda.numpy.pdarrayclass.pdarray, Values: arkouda.numpy.pdarrayclass.pdarray) -> None

   Overwrite elements of A with elements from B based upon a mask array.
   Similar to numpy.putmask, where mask = False, A retains its original value,
   but where mask = True, A is overwritten with the corresponding entry from Values.

   This is similar to ak.where, except that (1) no new pdarray is created, and
   (2) Values does not have to be the same size as A and mask.

   :param A: Value(s) used when mask is False (see Notes for allowed dtypes)
   :type A: pdarray
   :param mask: Used to choose values from A or B, must be same size as A, and of type ak.bool_
   :type mask: pdarray
   :param Values: Value(s) used when mask is False (see Notes for allowed dtypes)
   :type Values: pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.array(np.arange(10))
   >>> ak.putmask (a,a>2,a**2)
   >>> a
   array([0 1 2 9 16 25 36 49 64 81])

   >>> a = ak.array(np.arange(10))
   >>> values = ak.array([3,2])
   >>> ak.putmask (a,a>2,values)
   >>> a
   array([0 1 2 2 3 2 3 2 3 2])

   :raises RuntimeError: Raised if mask is not same size as A, or if A.dtype and Values.dtype are not
       an allowed pair (see Notes for details).

   .. rubric:: Notes

   | A and mask must be the same size.  Values can be any size.
   | Allowed dtypes for A and Values conform to types accepted by numpy putmask.
   | If A is ak.float64, Values can be ak.float64, ak.int64, ak.uint64, ak.bool_.
   | If A is ak.int64, Values can be ak.int64 or ak.bool_.
   | If A is ak.uint64, Values can be ak.uint64, or ak.bool_.
   | If A is ak.bool_, Values must be ak.bool_.

   Only one conditional clause is supported e.g., n < 5, n > 1.

   multi-dim pdarrays are now implemented.


.. py:function:: quantile(a: arkouda.numpy.pdarrayclass.pdarray, q: Optional[Union[arkouda.numpy.dtypes.numeric_scalars, Tuple[arkouda.numpy.dtypes.numeric_scalars], numpy.ndarray, arkouda.numpy.pdarrayclass.pdarray]] = 0.5, axis: Optional[Union[arkouda.numpy.dtypes.int_scalars, Tuple[arkouda.numpy.dtypes.int_scalars, Ellipsis], None]] = None, method: Optional[str] = 'linear', keepdims: bool = False) -> Union[arkouda.numpy.dtypes.numeric_scalars, arkouda.numpy.pdarrayclass.pdarray]

   Compute the q-th quantile of the data along the specified axis.

   :param a: data whose quantile will be computed
   :type a: pdarray
   :param q: a scalar, tuple, or np.ndarray of q values for the computation.  All values
             must be in the range 0 <= q <= 1
   :type q: pdarray, Tuple, or np.ndarray
   :param axis: the axis or axes along which the quantiles are computed.  The default is None,
                which computes the quantile along a flattened version of the array.
   :type axis: None, int scalar, or tuple of int scalars
   :param method: one of "inverted_cdf," "averaged_inverted_cdf", "closest_observation",
                  "interpolated_inverted_cdf", "hazen", "weibull", "linear", 'median_unbiased",
                  "normal_unbiased", "lower"," higher", "midpoint"
   :type method: string
   :param keepdims: True if the degenerate axes are to be retained after slicing, False if not
   :type keepdims: bool

   :returns: If q is a scalar and axis is None, the result is a scalar.
             If q is a scalar and axis is supplied, the result is a pdarray of rank len(axis)
             less than the rank of a.
             If q is an array and axis is None, the result is a pdarray of shape q.shape
             If q is an array and axis is None, the result is a pdarray of rank q.ndim +
             pda.ndim - len(axis).  However, there is an intermediate result which is of rank
             q.ndim + pda.ndim.  If this is not in the compiled ranks, an error will be thrown
             even if the final result would be in the compiled ranks.
   :rtype: pdarray or scalar

   .. rubric:: Notes

   np.quantile also supports the method "nearest," however its behavior does not match
   the numpy documentation, so it's not supported here.
   np.quantile also allows for weighted inputs, but only for the method "inverted_cdf."
   That also is not supported here.

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.array([[1,2,3,4,5],[1,2,3,4,5]])
   >>> q = 0.7
   >>> ak.quantile(a,q,axis=None,method="linear")
   np.float64(4.0)
   >>> ak.quantile(a,q,axis=1,method="lower")
   array([3.00000000... 3.00000000...])
   >>> q = np.array([0.4,0.6])
   >>> ak.quantile(a,q,axis=None,method="weibull")
   array([2.40000000... 3.59999999...])
   >>> a = ak.array([[1,2],[5,3]])
   >>> ak.quantile(a,q,axis=0,method="hazen")
   array([array([2.20000000... 2.29999999...])
       array([3.79999999... 2.69999999...])])

   :raises ValueError: Raised if scalar q or any value of array q is outside the range [0,1]
       Raised if the method is not one of the 12 supported methods.
       Raised if the result would have a rank not in the compiled ranks.


.. py:function:: rad2deg(pda: arkouda.numpy.pdarrayclass.pdarray, where: Union[bool, arkouda.numpy.pdarrayclass.pdarray] = True) -> arkouda.numpy.pdarrayclass.pdarray

   Converts angles element-wise from radians to degrees.

   :param pda:
   :type pda: pdarray
   :param where: This condition is broadcast over the input. At locations where the condition is True, the
                 corresponding value will be converted from radians to degrees. Elsewhere, it will retain its
                 original value. Default set to True.
   :type where: bool or pdarray, default=True

   :returns: A pdarray containing an angle converted to degrees, from radians, for each element
             of the original pdarray
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.linspace(0,6.28,4)
   >>> ak.rad2deg(a)
   array([0.00000000... 119.939165... 239.878330... 359.817495...])


.. py:function:: randint(low: arkouda.numpy.dtypes.numeric_scalars, high: arkouda.numpy.dtypes.numeric_scalars, size: Union[arkouda.numpy.dtypes.int_scalars, Tuple[arkouda.numpy.dtypes.int_scalars, Ellipsis]] = 1, dtype=akint64, seed: Optional[arkouda.numpy.dtypes.int_scalars] = None) -> arkouda.numpy.pdarrayclass.pdarray

   Generate a pdarray of randomized int, float, or bool values in a
   specified range bounded by the low and high parameters.

   :param low: The low value (inclusive) of the range
   :type low: numeric_scalars
   :param high: The high value (exclusive for int, inclusive for float) of the range
   :type high: numeric_scalars
   :param size: The size or shape of the returned array
   :type size: int_scalars or tuple of int_scalars
   :param dtype: The dtype of the array
   :type dtype: Union[int64, float64, bool]
   :param seed: Index for where to pull the first returned value
   :type seed: int_scalars, optional

   :returns: Values drawn uniformly from the specified range having the desired dtype
   :rtype: pdarray

   :raises TypeError: Raised if dtype.name not in DTypes, size is not an int, low or high is
       not an int or float, or seed is not an int
   :raises ValueError: Raised if size < 0 or if high < low

   .. rubric:: Notes

   Calling randint with dtype=float64 will result in uniform non-integral
   floating point values.

   Ranges >= 2**64 in size is undefined behavior because
   it exceeds the maximum value that can be stored on the server (uint64)

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.randint(0, 10, 5, seed=1701)
   array([6 5 1 6 3])

   >>> ak.randint(0, 1, 3, seed=1701, dtype=ak.float64)
   array([0.011410423448327005 0.73618171558685619 0.12367222192448891])

   >>> ak.randint(0, 2, 5, seed=1701, dtype=ak.bool_)
   array([False True False True False])


.. py:function:: random_strings_lognormal(logmean: arkouda.numpy.dtypes.numeric_scalars, logstd: arkouda.numpy.dtypes.numeric_scalars, size: arkouda.numpy.dtypes.int_scalars, characters: str = 'uppercase', seed: Optional[arkouda.numpy.dtypes.int_scalars] = None) -> arkouda.numpy.strings.Strings

   Generate random strings with log-normally distributed lengths and
   with characters drawn from a specified set.

   :param logmean: The log-mean of the length distribution
   :type logmean: numeric_scalars
   :param logstd: The log-standard-deviation of the length distribution
   :type logstd: numeric_scalars
   :param size: The number of strings to generate
   :type size: int_scalars
   :param characters: The set of characters to draw from
   :type characters: (uppercase, lowercase, numeric, printable, binary)
   :param seed: Value used to initialize the random number generator
   :type seed: int_scalars, optional

   :returns: The Strings object encapsulating a pdarray of random strings
   :rtype: Strings

   :raises TypeError: Raised if logmean is neither a float nor a int, logstd is not a float,
       seed is not an int, size is not an int, or if characters is not a str
   :raises ValueError: Raised if logstd <= 0 or size < 0

   .. seealso:: :py:obj:`random_strings_lognormal`, :py:obj:`randint`

   .. rubric:: Notes

   The lengths of the generated strings are distributed $Lognormal(\\mu, \\sigma^2)$,
   with :math:`\\mu = logmean` and :math:`\\sigma = logstd`. Thus, the strings will
   have an average length of :math:`exp(\\mu + 0.5*\\sigma^2)`, a minimum length of
   zero, and a heavy tail towards longer strings.

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.random_strings_lognormal(2, 0.25, 5, seed=1)
   array(['VWHJEX', 'BEBBXJHGM', 'RWOVKBUR', 'LNJCSDXD', 'NKEDQC'])

   >>> ak.random_strings_lognormal(2, 0.25, 5, seed=1, characters='printable')
   array(['eL96<O', ')o-GOe lR', ')PV yHf(', '._b3Yc&K', ',7Wjef'])


.. py:function:: random_strings_uniform(minlen: arkouda.numpy.dtypes.int_scalars, maxlen: arkouda.numpy.dtypes.int_scalars, size: arkouda.numpy.dtypes.int_scalars, characters: str = 'uppercase', seed: Union[None, arkouda.numpy.dtypes.int_scalars] = None) -> arkouda.numpy.strings.Strings

   Generate random strings with lengths uniformly distributed between
   minlen and maxlen, and with characters drawn from a specified set.

   :param minlen: The minimum allowed length of string
   :type minlen: int_scalars
   :param maxlen: The maximum allowed length of string
   :type maxlen: int_scalars
   :param size: The number of strings to generate
   :type size: int_scalars
   :param characters: The set of characters to draw from
   :type characters: (uppercase, lowercase, numeric, printable, binary)
   :param seed: Value used to initialize the random number generator
   :type seed: Union[None, int_scalars], optional

   :returns: The array of random strings
   :rtype: Strings

   :raises ValueError: Raised if minlen < 0, maxlen < minlen, or size < 0

   .. seealso:: :py:obj:`random_strings_lognormal`, :py:obj:`randint`

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.random_strings_uniform(minlen=1, maxlen=5, seed=8675309, size=5)
   array(['ECWO', 'WSS', 'TZG', 'RW', 'C'])

   >>> ak.random_strings_uniform(minlen=1, maxlen=5, seed=8675309, size=5,
   ... characters='printable')
   array(['2 .z', 'aom', '2d|', 'o(', 'M'])


.. py:function:: register_all(data: dict)

   Register all objects in the provided dictionary.

   This function iterates through the dictionary `data`, registering each object
   with its corresponding name. It is useful for batch registering multiple
   objects in Arkouda.

   :param data: A dictionary that maps the name to register the object to the object itself.
                For example, {"MyArray": ak.array([0, 1, 2])}.
   :type data: dict

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> data = { "array1": ak.array([0, 1, 2]), "array2": ak.array([3, 4, 5]) }
   >>> ak.register_all(data)

   After calling this function, "array1" and "array2" are registered
   in Arkouda, and can be accessed by their names.
   >>> ak.unregister_all(["array1", "array2"])


.. py:function:: repeat(a: Union[int, Sequence[int], arkouda.numpy.pdarrayclass.pdarray], repeats: Union[int, Sequence[int], arkouda.numpy.pdarrayclass.pdarray], axis: Union[None, int] = None) -> arkouda.numpy.pdarrayclass.pdarray

   Repeat each element of an array after themselves.

   :param a: Input array.
   :type a: int, Sequence of int, or pdarray
   :param repeats: The number of repetitions for each element.
                   `repeats` is broadcasted to fit the shape of the given axis.
   :type repeats: int, Sequence of int, or pdarray
   :param axis: The axis along which to repeat values.
                By default, use the flattened input array, and return a flat output array.
   :type axis: int, optional

   :returns: Output array which has the same shape as `a`, except along the given axis.
   :rtype: pdarray

   :raises ValueError: Raised if repeats is not an int or a 1-dimensional array, or if it contains
       negative values, if its size does not match the input arrays size along
       axis.
   :raises RuntimeError: Raised if the operation fails server-side.
   :raises TypeError: Raised if axis anything but None or int, or if either a or repeats is invalid
       (the a and repeat cases should be impossible).
   :raises IndexError: Raised if axis is invalid for the given rank.

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.repeat(3, 4)
   array([3 3 3 3])
   >>> x = ak.array([[1,2],[3,4]])
   >>> ak.repeat(x, 2)
   array([1 1 2 2 3 3 4 4])
   >>> ak.repeat(x, 3, axis=1)
   array([array([1 1 1 2 2 2]) array([3 3 3 4 4 4])])
   >>> ak.repeat(x, [1, 2], axis=0)
   array([array([1 2]) array([3 4]) array([3 4])])


.. py:function:: resolve_scalar_dtype(val: object) -> str

   Try to infer what dtype arkouda_server should treat val as.

   :param val: The object to determine the dtype of.
   :type val: object

   :returns: The dtype name, if it can be resolved, otherwise the type (as str).
   :rtype: str

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.resolve_scalar_dtype(1)
   'int64'
   >>> ak.resolve_scalar_dtype(2.0)
   'float64'


.. py:function:: result_type(*args: Union[pdarray, np.dtype, type]) -> Union[np.dtype, type]

   Determine the promoted result dtype of inputs, including support for Arkouda's bigint.

   Determine the result dtype that would be returned by a NumPy-like operation
   on the provided input arguments, accounting for Arkouda's extended types
   such as ak.bigint.

   This function mimics numpy.result_type, with support for Arkouda types.

   :param \*args: One or more input objects. These can be NumPy arrays, dtypes, Python
                  scalar types, or Arkouda pdarrays.
   :type \*args: Union[pdarray, np.dtype, type]

   :returns: The dtype (or equivalent Arkouda type) that results from applying
             type promotion rules to the inputs.
   :rtype: Union[np.dtype, type]

   .. rubric:: Notes

   This function is meant to be a drop-in replacement for numpy.result_type
   but includes logic to support Arkouda's bigint type.


.. py:function:: right_align(left, right)

   Map two arrays of sparse values to the 0-up index.

   Map two arrays of sparse values to the 0-up index set implied by the right array,
   discarding values from left that do not appear in right.

   :param left: Left-hand identifiers
   :type left: pdarray or a sequence of pdarrays
   :param right: Right-hand identifiers that define the index
   :type right: pdarray or a sequence of pdarrays

   :returns:

             keep : pdarray, bool
                 Logical index of left-hand values that survived
             aligned : (pdarray, pdarray)
                 Left and right arrays with values replaced by 0-up indices
   :rtype: pdarray, (pdarray, pdarray)


.. py:function:: rotl(x, rot) -> pdarray

   Rotate bits of <x> to the left by <rot>.

   :param x: Value(s) to rotate left.
   :type x: pdarray(int64/uint64) or integer
   :param rot: Amount(s) to rotate by.
   :type rot: pdarray(int64/uint64) or integer

   :returns: The rotated elements of x.
   :rtype: pdarray

   :raises TypeError: If input array is not int64 or uint64

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> A = ak.arange(10)
   >>> ak.rotl(A, A)
   array([0 2 8 24 64 160 384 896 2048 4608])


.. py:function:: rotr(x, rot) -> pdarray

   Rotate bits of <x> to the left by <rot>.

   :param x: Value(s) to rotate left.
   :type x: pdarray(int64/uint64) or integer
   :param rot: Amount(s) to rotate by.
   :type rot: pdarray(int64/uint64) or integer

   :returns: The rotated elements of x.
   :rtype: pdarray

   :raises TypeError: If input array is not int64 or uint64

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> A = ak.arange(10)
   >>> ak.rotr(1024 * A, A)
   array([0 512 512 384 256 160 96 56 32 18])


.. py:function:: round(pda: arkouda.numpy.pdarrayclass.pdarray, where: Union[bool, arkouda.numpy.pdarrayclass.pdarray] = True) -> arkouda.numpy.pdarrayclass.pdarray

   Return the element-wise rounding of the array.

   :param pda:
   :type pda: pdarray
   :param where: This condition is applied over the input. At locations where the condition is True, the
                 corresponding value will be acted on by the function. Elsewhere, it will retain its
                 original value. Default set to True.
   :type where: bool or pdarray, default=True

   :returns: A pdarray containing input array elements rounded to the nearest integer
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.round(ak.array([1.1, 2.5, 3.14159]))
   array([1.00000000... 3.00000000... 3.00000000...])


.. py:function:: scalar_array(value: Union[arkouda.numpy.dtypes.numeric_scalars, arkouda.numpy.dtypes.bool_scalars], dtype: Optional[Union[numpy.dtype, type, str, arkouda.numpy.dtypes.bigint]] = None) -> arkouda.numpy.pdarrayclass.pdarray

   Create a pdarray from a single scalar value.

   :param value: Value to create pdarray from
   :type value: numeric_scalars
   :param dtype: The data type of the created array.
   :type dtype: np.dtype, type, str, bigint, or None

   :returns: pdarray with a single element
   :rtype: pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.scalar_array(5)
   array([5])

   >>> ak.scalar_array(7.0)
   array([7.00000000000000000])

   :raises RuntimeError: Raised if value cannot be cast as dtype


.. py:class:: sctypeDict

   dict() -> new empty dictionary
   dict(mapping) -> new dictionary initialized from a mapping object's
       (key, value) pairs
   dict(iterable) -> new dictionary initialized as if via:
       d = {}
       for k, v in iterable:
           d[k] = v
   dict(**kwargs) -> new dictionary initialized with the name=value pairs
       in the keyword argument list.  For example:  dict(one=1, two=2)


   .. py:method:: clear()

      Remove all items from the dict.



   .. py:method:: copy()

      Return a shallow copy of the dict.



   .. py:method:: fromkeys(iterable, value=None, /)

      Create a new dictionary with keys from iterable and values set to value.



   .. py:method:: get(key, default=None, /)

      Return the value for key if key is in the dictionary, else default.



   .. py:method:: items()

      Return a set-like object providing a view on the dict's items.



   .. py:method:: keys()

      Return a set-like object providing a view on the dict's keys.



   .. py:method:: pop(*args, **kwargs)

      D.pop(k[,d]) -> v, remove specified key and return the corresponding value.

      If the key is not found, return the default if given; otherwise,
      raise a KeyError.



   .. py:method:: popitem()

      Remove and return a (key, value) pair as a 2-tuple.

      Pairs are returned in LIFO (last-in, first-out) order.
      Raises KeyError if the dict is empty.



   .. py:method:: setdefault(key, default=None, /)

      Insert key with a value of default if key is not in the dictionary.

      Return the value for key if key is in the dictionary, else default.



   .. py:method:: update(*args, **kwargs)

      D.update([E, ]**F) -> None.  Update D from mapping/iterable E and F.
      If E is present and has a .keys() method, then does:  for k in E.keys(): D[k] = E[k]
      If E is present and lacks a .keys() method, then does:  for k, v in E: D[k] = v
      In either case, this is followed by: for k in F:  D[k] = F[k]



   .. py:method:: values()

      Return an object providing a view on the dict's values.



.. py:function:: search_intervals(vals, intervals, tiebreak=None, hierarchical=True)

   Return the index of the best interval containing each query value.

   Given an array of query vals and non-overlapping, closed intervals, return
   the index of the best (see tiebreak) interval containing each query value,
   or -1 if not present in any interval.

   :param vals: Values to search for in intervals. If multiple arrays, each "row" is an item.
   :type vals: (sequence of) pdarray(int, uint, float)
   :param intervals: Non-overlapping, half-open intervals, as a tuple of
                     (lower_bounds_inclusive, upper_bounds_exclusive)
                     Must have same dtype(s) as vals.
   :type intervals: 2-tuple of (sequences of) pdarrays
   :param tiebreak: When a value is present in more than one interval, the interval with the
                    lowest tiebreak value will be chosen. If no tiebreak is given, the
                    first containing interval will be chosen.
   :type tiebreak: (optional) pdarray, numeric
   :param hierarchical: When True, sequences of pdarrays will be treated as components specifying
                        a single dimension (i.e. hierarchical)
                        When False, sequences of pdarrays will be specifying multi-dimensional intervals
   :type hierarchical: boolean

   :returns: **idx** -- Index of interval containing each query value, or -1 if not found
   :rtype: pdarray(int64)

   .. rubric:: Notes

   The return idx satisfies the following condition:
       present = idx > -1
       ((intervals[0][idx[present]] <= vals[present]) &
        (intervals[1][idx[present]] >= vals[present])).all()

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> starts = (ak.array([0, 5]), ak.array([0, 11]))
   >>> ends = (ak.array([5, 9]), ak.array([10, 20]))
   >>> vals = (ak.array([0, 0, 2, 5, 5, 6, 6, 9]), ak.array([0, 20, 1, 5, 15, 0, 12, 30]))
   >>> ak.search_intervals(vals, (starts, ends), hierarchical=False)
   array([0 -1 0 0 1 -1 1 -1])
   >>> ak.search_intervals(vals, (starts, ends))
   array([0 0 0 0 1 1 1 -1])
   >>> bi_starts = ak.bigint_from_uint_arrays([ak.cast(a, ak.uint64) for a in starts])
   >>> bi_ends = ak.bigint_from_uint_arrays([ak.cast(a, ak.uint64) for a in ends])
   >>> bi_vals = ak.bigint_from_uint_arrays([ak.cast(a, ak.uint64) for a in vals])
   >>> bi_starts, bi_ends, bi_vals
   (array([0 92233720368547758091]),
   array([92233720368547758090 166020696663385964564]),
   array([0 20 36893488147419103233 92233720368547758085 92233720368547758095
   110680464442257309696 110680464442257309708 166020696663385964574]))
   >>> ak.search_intervals(bi_vals, (bi_starts, bi_ends))
   array([0 0 0 0 1 1 1 -1])


.. py:function:: searchsorted(a: arkouda.numpy.pdarrayclass.pdarray, v: Union[arkouda.numpy.dtypes.int_scalars, arkouda.numpy.dtypes.float64, arkouda.numpy.dtypes.bigint, arkouda.numpy.pdarrayclass.pdarray], side: Literal['left', 'right'] = 'left', x2_sorted: bool = False) -> Union[int, arkouda.numpy.pdarrayclass.pdarray]

   Find indices where elements should be inserted to maintain order.

   Find the indices into a sorted array `a` such that, if the corresponding
   elements in `v` were inserted before the indices, the order of `a` would be preserved.

   :param a: 1-D input array. Must be sorted in ascending order. `sorter` is not currently supported.
   :type a: pdarray
   :param v: Values to insert into `a`. Can be a scalar or array-like.
   :type v: int_scalars, float64, bigint, or pdarray
   :param side: If 'left', the index of the first suitable location found is given.
                If 'right', return the last such index.
   :type side: {'left', 'right'}, default='left'
   :param x2_sorted: If True, assumes that `v` (x2) is already sorted in ascending order. This can improve performance
                     for large, sorted search arrays. If False, no assumption is made about the order of `v`.
   :type x2_sorted: bool, default=False

   :returns: **indices** -- If `v` is an array, returns an array of insertion points with the same shape.
             If `v` is a scalar, returns a single integer index.
   :rtype: int or pdarray

   :raises ValueError: If `a` has more than one dimension.
   :raises TypeError: If `a` has an unsupported dtype (i.e., not int64, uint64, bigint, or float64).
       If the dtype of `a` and `v` does not match

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.array([11, 12, 13, 14, 15])
   >>> ak.searchsorted(a, 13)
   2
   >>> ak.searchsorted(a, 13, side='right')
   3
   >>> v = ak.array([-10, 20, 12, 13])
   >>> ak.searchsorted(a, v)
   array([0 5 1 2])
   >>> v_sorted = ak.array([-10, 12, 13, 20])
   >>> ak.searchsorted(a, v_sorted, x2_sorted=True)
   array([0 1 2 5])


.. py:function:: setdiff1d(A: arkouda.pandas.groupbyclass.groupable, B: arkouda.pandas.groupbyclass.groupable, assume_unique: bool = False) -> Union[arkouda.numpy.pdarrayclass.pdarray, arkouda.pandas.groupbyclass.groupable]

   Find the set difference of two arrays.

   Return the sorted, unique values in `A` that are not in `B`.

   :param A:
   :type A: list of pdarrays, pdarray, Strings, or Categorical
   :param B:
   :type B: list of pdarrays, pdarray, Strings, or Categorical
   :param assume_unique: If True, the input arrays are both assumed to be unique, which
                         can speed up the calculation.  Default is False.
   :type assume_unique: bool

   :returns: Sorted 1D array/List of sorted pdarrays of values in `A` that are not in `B`.
   :rtype: pdarray/groupable

   :raises TypeError: Raised if either A or B is not a pdarray
   :raises RuntimeError: Raised if the dtype of either pdarray is not supported

   .. seealso:: :py:obj:`arkouda.pandas.groupbyclass.unique`, :py:obj:`setxor1d`

   .. rubric:: Notes

   ak.setdiff1d is not supported for bool pdarrays

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.array([1, 2, 3, 2, 4, 1])
   >>> b = ak.array([3, 4, 5, 6])
   >>> ak.setdiff1d(a, b)
   array([1 2])

   Multi-Array Example

   >>> a = ak.arange(1, 6)
   >>> b = ak.array([1, 5, 3, 4, 2])
   >>> c = ak.array([1, 4, 3, 2, 5])
   >>> d = ak.array([1, 2, 3, 5, 4])
   >>> multia = [a, a, a]
   >>> multib = [b, c, d]
   >>> ak.setdiff1d(multia, multib)
   [array([2 4 5]), array([2 4 5]), array([2 4 5])]


.. py:function:: seterr(**kwargs: _ErrorMode) -> Dict[str, _ErrorMode]

   Set how Arkouda handles floating-point errors.

   :param divide: Behavior for the corresponding error category.
   :type divide: {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional
   :param over: Behavior for the corresponding error category.
   :type over: {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional
   :param under: Behavior for the corresponding error category.
   :type under: {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional
   :param invalid: Behavior for the corresponding error category.
   :type invalid: {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional

   :returns: The previous settings.
   :rtype: dict

   .. rubric:: Notes

   This is a *scaffold* API. It does not change backend behavior yet; it only
   records the desired policy so future operations can consult it.


.. py:function:: seterrcall(func: Optional[Callable[[str, str], None]]) -> Optional[Callable[[str, str], None]]

   Set the callable invoked when an error category is set to 'call'.

   :param func: Function of signature (errtype: str, message: str) -> None.
                Pass None to clear.
   :type func: callable or None

   :returns: The previous callable.
   :rtype: callable or None

   .. rubric:: Notes

   This is a *stub* for API compatibility. Arkouda does not currently invoke
   this callable; it is stored for future use.


.. py:function:: setxor1d(A: arkouda.pandas.groupbyclass.groupable, B: arkouda.pandas.groupbyclass.groupable, assume_unique: bool = False) -> Union[arkouda.numpy.pdarrayclass.pdarray, arkouda.pandas.groupbyclass.groupable]

   Find the set exclusive-or (symmetric difference) of two arrays.

   Return the sorted, unique values that are in only one (not both) of the
   input arrays.

   :param A:
   :type A: list of pdarrays, pdarray, Strings, or Categorical
   :param B:
   :type B: list of pdarrays, pdarray, Strings, or Categorical
   :param assume_unique: If True, the input arrays are both assumed to be unique, which
                         can speed up the calculation.  Default is False.
   :type assume_unique: bool

   :returns: Sorted 1D array/List of sorted pdarrays of unique values that are in only one of the input
             arrays.
   :rtype: pdarray/groupable

   :raises TypeError: Raised if either A or B is not a groupable
   :raises RuntimeError: Raised if the dtype of either pdarray is not supported

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.array([1, 2, 3, 2, 4])
   >>> b = ak.array([2, 3, 5, 7, 5])
   >>> ak.setxor1d(a,b)
   array([1 4 5 7])

   Multi-Array Example

   >>> a = ak.arange(1, 6)
   >>> b = ak.array([1, 5, 3, 4, 2])
   >>> c = ak.array([1, 4, 3, 2, 5])
   >>> d = ak.array([1, 2, 3, 5, 4])
   >>> multia = [a, a, a]
   >>> multib = [b, c, d]
   >>> ak.setxor1d(multia, multib)
   [array([2 2 4 4 5 5]), array([2 5 2 4 4 5]), array([2 4 5 4 2 5])]


.. py:function:: shape(a: Union[arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.strings.Strings, arkouda.numpy.dtypes.all_scalars]) -> Tuple

   Return the shape of an array.

   :param a: Input array.
   :type a: pdarray, Strings, or all_scalars

   :returns: The elements of the shape tuple give the lengths of the
             corresponding array dimensions.
   :rtype: Tuple

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.shape(ak.eye(3,2))
   (3, 2)
   >>> ak.shape([[1, 3]])
   (1, 2)
   >>> ak.shape([0])
   (1,)
   >>> ak.shape(0)
   ()


.. py:function:: shares_memory(a, b)

   Return True if `a` and `b` share any Arkouda server-side buffers.

   This is an Arkouda analogue of numpy.shares_memory with a simpler definition:
   it checks for identical backing buffer *identities* (same server object names).

   .. rubric:: Notes

   - Because Arkouda commonly *materializes* results (rather than views),
     aliasing is rare and usually only true when objects literally reference
     the same backing buffers.
   - For compound containers (e.g., SegArray, Strings, Categorical), we check
     all of their component buffers.
   - If you introduce true view semantics in the future, teach `_ak_buffer_names`
     to surface the base buffer name(s) and view descriptors, and compare bases.


.. py:class:: short

   Bases: :py:obj:`numpy.signedinteger`


   Signed integer type, compatible with C ``short``.

       :Character code: ``'h'``
       :Canonical name: `numpy.short`
       :Alias on this platform (Linux x86_64): `numpy.int16`: 16-bit signed integer (``-32_768`` to ``32_767``).


   .. py:method:: bit_count(/)

      int16.bit_count() -> int

              Computes the number of 1-bits in the absolute value of the input.
              Analogous to the builtin `int.bit_count` or ``popcount`` in C++.

              Examples
              --------
              >>> np.int16(127).bit_count()
              7
              >>> np.int16(-127).bit_count()
              7



.. py:function:: sign(pda: arkouda.numpy.pdarrayclass.pdarray) -> arkouda.numpy.pdarrayclass.pdarray

   Return the element-wise sign of the array.

   :param pda:
   :type pda: pdarray

   :returns: A pdarray containing sign values of the input array elements
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.sign(ak.array([-10, -5, 0, 5, 10]))
   array([-1 -1 0 1 1])


.. py:class:: signedinteger

   Bases: :py:obj:`numpy.integer`


   Abstract base class of all signed integer scalar types.


.. py:function:: sin(pda: arkouda.numpy.pdarrayclass.pdarray, where: Union[bool, arkouda.numpy.pdarrayclass.pdarray] = True) -> arkouda.numpy.pdarrayclass.pdarray

   Return the element-wise sine of the array.

   :param pda:
   :type pda: pdarray
   :param where: This condition is broadcast over the input. At locations where the condition is True,
                 the sine will be applied to the corresponding value. Elsewhere, it will retain
                 its original value. Default set to True.
   :type where: bool or pdarray, default=True

   :returns: A pdarray containing sin for each element
             of the original pdarray
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.linspace(-1.5,0.75,4)
   >>> ak.sin(a)
   array([-0.99749498... -0.68163876... 0.00000000... 0.68163876...])


.. py:class:: single

   Bases: :py:obj:`numpy.floating`


   Single-precision floating-point number type, compatible with C ``float``.

       :Character code: ``'f'``
       :Canonical name: `numpy.single`
       :Alias on this platform (Linux x86_64): `numpy.float32`: 32-bit-precision floating-point number type: sign bit, 8 bits exponent, 23 bits mantissa.


   .. py:method:: as_integer_ratio(/)

      single.as_integer_ratio() -> (int, int)

              Return a pair of integers, whose ratio is exactly equal to the original
              floating point number, and with a positive denominator.
              Raise `OverflowError` on infinities and a `ValueError` on NaNs.

              >>> np.single(10.0).as_integer_ratio()
              (10, 1)
              >>> np.single(0.0).as_integer_ratio()
              (0, 1)
              >>> np.single(-.25).as_integer_ratio()
              (-1, 4)



   .. py:method:: is_integer(/)

      single.is_integer() -> bool

              Return ``True`` if the floating point number is finite with integral
              value, and ``False`` otherwise.

              .. versionadded:: 1.22

              Examples
              --------
              >>> np.single(-2.0).is_integer()
              True
              >>> np.single(3.2).is_integer()
              False



.. py:function:: sinh(pda: arkouda.numpy.pdarrayclass.pdarray, where: Union[bool, arkouda.numpy.pdarrayclass.pdarray] = True) -> arkouda.numpy.pdarrayclass.pdarray

   Return the element-wise hyperbolic sine of the array.

   :param pda:
   :type pda: pdarray
   :param where: This condition is broadcast over the input. At locations where the condition is True,
                 the hyperbolic sine will be applied to the corresponding value. Elsewhere, it will retain
                 its original value. Default set to True.
   :type where: bool or pdarray, default=True

   :returns: A pdarray containing hyperbolic sine for each element
             of the original pdarray
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.linspace(-0.9,0.7,4)
   >>> ak.sinh(a)
   array([-1.02651672... -0.37493812... 0.16743934... 0.75858370...])


.. py:function:: sort(pda: arkouda.numpy.pdarrayclass.pdarray, algorithm: SortingAlgorithm = SortingAlgorithm.RadixSortLSD, axis: arkouda.numpy.dtypes.int_scalars = -1) -> arkouda.numpy.pdarrayclass.pdarray

   Return a sorted copy of the array. Only sorts numeric arrays;
   for Strings, use argsort.

   :param pda: The array to sort (int64, uint64, or float64)
   :type pda: pdarray
   :param algorithm: The algorithm to be used for sorting the arrays.
   :type algorithm: SortingAlgorithm, default=SortingAlgorithm.RadixSortLSD
   :param axis: The axis to sort over. Setting to -1 means that it will sort over axis = ndim - 1.
   :type axis: int_scalars, default=-1

   :returns: The sorted copy of pda
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray
   :raises ValueError: Raised if sort attempted on a pdarray with an unsupported dtype
       such as bool

   .. seealso:: :py:obj:`argsort`

   .. rubric:: Notes

   Uses a least-significant-digit radix sort, which is stable and resilient
   to non-uniformity in data but communication intensive.

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.randint(0, 10, 10, seed=1)
   >>> a
   array([7 9 5 1 4 1 8 5 5 0])
   >>> sorted = ak.sort(a)
   >>> sorted
   array([0 1 1 4 5 5 5 7 8 9])


.. py:function:: sqrt(pda: pdarray, where: Union[arkouda.numpy.dtypes.bool_scalars, pdarray] = True) -> pdarray

   Takes the square root of array. If where is given, the operation will only take place in
   the positions where the where condition is True.

   :param pda: A pdarray of values the square roots of which will be computed
   :type pda: pdarray
   :param where: This condition is broadcast over the input. At locations where the condition is True, the
                 corresponding value will be square rooted. Elsewhere, it will retain its original value.
                 Default set to True.
   :type where: Boolean or pdarray

   :returns: a pdarray of square roots of the original values, or the original values themselves,
             subject to the boolean where condition.
   :rtype: pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.arange(5)
   >>> ak.sqrt(a)
   array([0.00000000000000000 1.00000000000000000 1.4142135623730951
            1.7320508075688772 2.00000000000000000])
   >>> ak.sqrt(a, ak.array([True, True, False, False, True]))
   array([0.00000000000000000 1.00000000000000000 2.00000000000000000
            3.00000000000000000 2.00000000000000000])

   :raises TypeError: raised if pda is not a pdarray of ak.int64 or ak.float64

   .. rubric:: Notes

   Square roots of negative numbers are returned as nan.


.. py:function:: square(pda: arkouda.numpy.pdarrayclass.pdarray, where: Union[bool, arkouda.numpy.pdarrayclass.pdarray] = True) -> arkouda.numpy.pdarrayclass.pdarray

   Return the element-wise square of the array.

   :param pda:
   :type pda: pdarray
   :param where: This condition is applied over the input. At locations where the condition is True, the
                 corresponding value will be acted on by the function. Elsewhere, it will retain its
                 original value. Default set to True.
   :type where: bool or pdarray, default=True

   :returns: A pdarray containing square values of the input
             array elements
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.square(ak.arange(1,5))
   array([1 4 9 16])


.. py:function:: squeeze(x: Union[arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.dtypes.numeric_scalars, arkouda.numpy.dtypes.bool_scalars], /, axis: Union[None, int, Tuple[int, Ellipsis]] = None) -> arkouda.numpy.pdarrayclass.pdarray

   Remove degenerate (size one) dimensions from an array.

   :param x: The array to squeeze
   :type x: pdarray
   :param axis: The axis or axes to squeeze (must have a size of one).
                If axis = None, all dimensions of size 1 will be squeezed.
   :type axis: int or Tuple[int, ...]

   :returns: A copy of x with the dimensions specified in the axis argument removed.
   :rtype: pdarray

   :raises RuntimeError: Raised if operation fails server-side.

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> x = ak.arange(10).reshape((1, 10, 1))
   >>> x.shape
   (1, 10, 1)
   >>> ak.squeeze(x, axis=None).shape
   (10,)
   >>> ak.squeeze(x, axis=2).shape
   (1, 10)
   >>> ak.squeeze(x, axis=(0, 2)).shape
   (10,)


.. py:function:: standard_normal(size: arkouda.numpy.dtypes.int_scalars, seed: Union[None, arkouda.numpy.dtypes.int_scalars] = None) -> arkouda.numpy.pdarrayclass.pdarray

   Draw real numbers from the standard normal distribution.

   :param size: The number of samples to draw (size of the returned array)
   :type size: int_scalars
   :param seed: Value used to initialize the random number generator
   :type seed: int_scalars

   :returns: The array of random numbers
   :rtype: pdarray

   :raises TypeError: Raised if size is not an int
   :raises ValueError: Raised if size < 0

   .. seealso:: :py:obj:`randint`

   .. rubric:: Notes

   For random samples from :math:`N(\\mu, \\sigma^2)`, use:

   ``(sigma * standard_normal(size)) + mu``

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.standard_normal(3,1)
   array([-0.68586185091150265 1.1723810583573377 0.567584107142031])


.. py:class:: str_

   A unicode string.

       This type strips trailing null codepoints.

       >>> s = np.str_("abc\x00")
       >>> s
       'abc'

       Unlike the builtin :class:`str`, this supports the
       :ref:`python:bufferobjects`, exposing its contents as UCS4:

       >>> m = memoryview(np.str_("abc"))
       >>> m.format
       '3w'
       >>> m.tobytes()
       b'a\x00\x00\x00b\x00\x00\x00c\x00\x00\x00'

       :Character code: ``'U'``


   .. py:method:: T(*args, **kwargs)

      Scalar attribute identical to the corresponding array attribute.

          Please see `ndarray.T`.



   .. py:method:: all(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.all`.



   .. py:method:: any(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.any`.



   .. py:method:: argmax(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.argmax`.



   .. py:method:: argmin(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.argmin`.



   .. py:method:: argsort(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.argsort`.



   .. py:method:: astype(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.astype`.



   .. py:method:: base(*args, **kwargs)

      Scalar attribute identical to the corresponding array attribute.

          Please see `ndarray.base`.



   .. py:method:: byteswap(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.byteswap`.



   .. py:method:: choose(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.choose`.



   .. py:method:: clip(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.clip`.



   .. py:method:: compress(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.compress`.



   .. py:method:: conj(*args, **kwargs)


   .. py:method:: conjugate(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.conjugate`.



   .. py:method:: copy(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.copy`.



   .. py:method:: cumprod(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.cumprod`.



   .. py:method:: cumsum(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.cumsum`.



   .. py:method:: data(*args, **kwargs)

      Pointer to start of data.



   .. py:method:: device(*args, **kwargs)


   .. py:method:: diagonal(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.diagonal`.



   .. py:method:: dtype(*args, **kwargs)

      Get array data-descriptor.



   .. py:method:: dump(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.dump`.



   .. py:method:: dumps(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.dumps`.



   .. py:method:: fill(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.fill`.



   .. py:method:: flags(*args, **kwargs)

      The integer value of flags.



   .. py:method:: flat(*args, **kwargs)

      A 1-D view of the scalar.



   .. py:method:: flatten(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.flatten`.



   .. py:method:: getfield(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.getfield`.



   .. py:method:: imag(*args, **kwargs)

      The imaginary part of the scalar.



   .. py:method:: item(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.item`.



   .. py:method:: itemset(*args, **kwargs)


   .. py:method:: itemsize(*args, **kwargs)

      The length of one element in bytes.



   .. py:method:: max(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.max`.



   .. py:method:: mean(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.mean`.



   .. py:method:: min(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.min`.



   .. py:method:: nbytes(*args, **kwargs)


   .. py:method:: ndim(*args, **kwargs)

      The number of array dimensions.



   .. py:method:: newbyteorder(*args, **kwargs)


   .. py:method:: nonzero(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.nonzero`.



   .. py:method:: prod(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.prod`.



   .. py:method:: ptp(*args, **kwargs)


   .. py:method:: put(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.put`.



   .. py:method:: ravel(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.ravel`.



   .. py:method:: real(*args, **kwargs)

      The real part of the scalar.



   .. py:method:: repeat(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.repeat`.



   .. py:method:: reshape(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.reshape`.



   .. py:method:: resize(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.resize`.



   .. py:method:: round(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.round`.



   .. py:method:: searchsorted(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.searchsorted`.



   .. py:method:: setfield(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.setfield`.



   .. py:method:: setflags(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.setflags`.



   .. py:method:: shape(*args, **kwargs)

      Tuple of array dimensions.



   .. py:method:: size(*args, **kwargs)

      The number of elements in the gentype.



   .. py:method:: sort(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.sort`.



   .. py:method:: squeeze(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.squeeze`.



   .. py:method:: std(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.std`.



   .. py:method:: strides(*args, **kwargs)

      Tuple of bytes steps in each dimension.



   .. py:method:: sum(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.sum`.



   .. py:method:: swapaxes(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.swapaxes`.



   .. py:method:: take(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.take`.



   .. py:method:: to_device(*args, **kwargs)


   .. py:method:: tobytes(*args, **kwargs)


   .. py:method:: tofile(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.tofile`.



   .. py:method:: tolist(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.tolist`.



   .. py:method:: tostring(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.tostring`.



   .. py:method:: trace(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.trace`.



   .. py:method:: transpose(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.transpose`.



   .. py:method:: var(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.var`.



   .. py:method:: view(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.view`.



.. py:class:: str_scalars

   Bases: :py:obj:`_NotIterable`


   Mixin to prevent iteration, without being compatible with Iterable.

   That is, we could do::

       def __iter__(self): raise TypeError()

   But this would make users of this mixin duck type-compatible with
   collections.abc.Iterable - isinstance(foo, Iterable) would be True.

   Luckily, we can instead prevent iteration by setting __iter__ to None, which
   is treated specially.


   .. py:method:: copy_with(params)


.. py:function:: string_operators(cls)

   Add common string operation methods to a StringAccessor class.

   This class decorator dynamically attaches string operations (`contains`,
   `startswith`, `endswith`) to the given class using the `_make_op` helper.

   :param cls: The accessor class to decorate.
   :type cls: type

   :returns: The accessor class with string methods added.
   :rtype: type

   .. rubric:: Notes

   Used internally to implement the `.str` accessor API.


.. py:function:: take(a: Union[arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.strings.Strings], indices: Union[arkouda.numpy.dtypes.numeric_scalars, arkouda.numpy.pdarrayclass.pdarray], axis: Optional[int] = None) -> arkouda.numpy.pdarrayclass.pdarray

   Take elements from an array along an axis.

   When axis is not None, this function does the same thing as “fancy” indexing (indexing arrays
   using arrays); however, it can be easier to use if you need elements along a given axis.
   A call such as ``np.take(arr, indices, axis=3)`` is equivalent to ``arr[:,:,:,indices,...]``.

   :param a: The array from which to take elements
   :type a: pdarray
   :param indices: The indices of the values to extract. Also allow scalars for indices.
   :type indices: numeric_scalars or pdarray
   :param axis: The axis over which to select values. By default, the flattened input array is used.
   :type axis: int, optional

   :returns: The returned array has the same type as `a`.
   :rtype: pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.array([4, 3, 5, 7, 6, 8])
   >>> indices = [0, 1, 4]
   >>> ak.take(a, indices)
   array([4 3 6])


.. py:function:: tan(pda: arkouda.numpy.pdarrayclass.pdarray, where: Union[bool, arkouda.numpy.pdarrayclass.pdarray] = True) -> arkouda.numpy.pdarrayclass.pdarray

   Return the element-wise tangent of the array.

   :param pda:
   :type pda: pdarray
   :param where: This condition is broadcast over the input. At locations where the condition is True,
                 the tangent will be applied to the corresponding value. Elsewhere, it will retain
                 its original value. Default set to True.
   :type where: bool or pdarray, default=True

   :returns: A pdarray containing tangent for each element
             of the original pdarray
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.linspace(-1.5,0.75,4)
   >>> ak.tan(a)
   array([-14.1014199... -0.93159645... 0.00000000... 0.93159645...])


.. py:function:: tanh(pda: arkouda.numpy.pdarrayclass.pdarray, where: Union[bool, arkouda.numpy.pdarrayclass.pdarray] = True) -> arkouda.numpy.pdarrayclass.pdarray

   Return the element-wise hyperbolic tangent of the array.

   :param pda:
   :type pda: pdarray
   :param where: This condition is broadcast over the input. At locations where the condition is True,
                 the hyperbolic tangent will be applied to the corresponding value. Elsewhere, it will retain
                 its original value. Default set to True.
   :type where: bool or pdarray, default=True

   :returns: A pdarray containing hyperbolic tangent for each element
             of the original pdarray
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.linspace(-0.9,0.7,4)
   >>> ak.tanh(a)
   array([-0.71629787... -0.35107264... 0.16514041... 0.60436777...])


.. py:function:: tile(A: arkouda.numpy.pdarrayclass.pdarray, /, reps: Union[int, Tuple[int, Ellipsis]]) -> arkouda.numpy.pdarrayclass.pdarray

   Construct an array by repeating A the number of times given by reps.

   If reps has length ``d``, the result will have dimension of ``max(d, A.ndim)``.

   If ``A.ndim < d``, A is promoted to be d-dimensional by prepending new axes. So a shape (3,) array is promoted to (1, 3) for 2-D replication, or shape (1, 1, 3) for 3-D replication. If this is not the desired behavior, promote A to d-dimensions manually before calling this function.

   If ``A.ndim > d``, reps is promoted to A.ndim by prepending 1’s to it. Thus for an A of shape (2, 3, 4, 5), a reps of (2, 2) is treated as (1, 1, 2, 2).

   :param A: The input pdarray to be tiled
   :type A: pdarray
   :param reps: The number of repetitions of A along each axis.
   :type reps: int or Tuple of int

   :returns: A new pdarray with the tiled data.
   :rtype: pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.array([0, 1, 2])
   >>> ak.tile(a, 2)
   array([0 1 2 0 1 2])
   >>> ak.tile(a, (2, 2))
   array([array([0 1 2 0 1 2]) array([0 1 2 0 1 2])])
   >>> ak.tile(a, (2, 1, 2))
   array([array([array([0 1 2 0 1 2])]) array([array([0 1 2 0 1 2])])])

   >>> b = ak.array([[1, 2], [3, 4]])
   >>> ak.tile(b, 2)
   array([array([1 2 1 2]) array([3 4 3 4])])
   >>> ak.tile(b, (2, 1))
   array([array([1 2]) array([3 4]) array([1 2]) array([3 4])])

   >>> c = ak.array([1, 2, 3, 4])
   >>> ak.tile(c, (4, 1))
   array([array([1 2 3 4]) array([1 2 3 4]) array([1 2 3 4]) array([1 2 3 4])])


.. py:class:: timedelta64

   Bases: :py:obj:`numpy.signedinteger`


   A timedelta stored as a 64-bit integer.

       See :ref:`arrays.datetime` for more information.

       :Character code: ``'m'``


.. py:function:: timedelta_range(start=None, end=None, periods=None, freq=None, name=None, closed=None, **kwargs)

   Return a fixed frequency TimedeltaIndex, with day as the default
   frequency. Alias for ``ak.Timedelta(pd.timedelta_range(args))``.
   Subject to size limit imposed by client.maxTransferBytes.

   :param start: Left bound for generating timedeltas.
   :type start: str or timedelta-like, default None
   :param end: Right bound for generating timedeltas.
   :type end: str or timedelta-like, default None
   :param periods: Number of periods to generate.
   :type periods: int, default None
   :param freq: Frequency strings can have multiples, e.g. '5H'.
   :type freq: str or DateOffset, default 'D'
   :param name: Name of the resulting TimedeltaIndex.
   :type name: str, default None
   :param closed: Make the interval closed with respect to the given frequency to
                  the 'left', 'right', or both sides (None).
   :type closed: str, default None

   :returns: **rng**
   :rtype: TimedeltaIndex

   .. rubric:: Notes

   Of the four parameters ``start``, ``end``, ``periods``, and ``freq``,
   exactly three must be specified. If ``freq`` is omitted, the resulting
   ``TimedeltaIndex`` will have ``periods`` linearly spaced elements between
   ``start`` and ``end`` (closed on both sides).

   To learn more about the frequency strings, please see `this link
   <https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases>`__.


.. py:function:: transpose(pda: arkouda.numpy.pdarrayclass.pdarray, axes: Optional[Tuple[arkouda.numpy.dtypes.int_scalars, Ellipsis]] = None) -> arkouda.numpy.pdarrayclass.pdarray

   Compute the transpose of a matrix.

   :param pda:
   :type pda: pdarray
   :param axes: If specified, must be a tuple which contains a permutation of the axes of pda.
   :type axes: Tuple[int,...] Optional, defaults to None

   :returns: the transpose of the input matrix
             For a 1-D array, this is the original array.
             For a 2-D array, this is the standard matrix transpose.
             For an n-D array, if axes are given, their order indicates how the axes are permuted.
             If axes is None, the axes are reversed.
   :rtype: pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.array([[1,2,3,4,5],[1,2,3,4,5]])
   >>> ak.transpose(a)
   array([array([1 1]) array([2 2]) array([3 3]) array([4 4]) array([5 5])])
   >>> z = ak.array(np.arange(27).reshape(3,3,3))
   >>> ak.transpose(z,axes=(1,0,2))
   array([array([array([0 1 2]) array([9 10 11]) array([18 19 20])]) array([array([3 4 5])
     array([12 13 14]) array([21 22 23])]) array([array([6 7 8]) array([15 16 17]) array([24 25 26])])])

   :raises ValueError: Raised if axes is not a legitimate permutation of the axes of pda
   :raises TypeError: Raised if pda is not a pdarray, or if axes is neither a tuple nor None


.. py:function:: tril(pda: arkouda.numpy.pdarrayclass.pdarray, diag: arkouda.numpy.dtypes.int_scalars = 0) -> arkouda.numpy.pdarrayclass.pdarray

   Return a copy of the pda with the upper triangle zeroed out.

   :param pda:
   :type pda: pdarray
   :param diag: | if diag = 0, zeros start just above the main diagonal
                | if diag = 1, zeros start at the main diagonal
                | if diag = 2, zeros start just below the main diagonal
                | etc. Default set to 0.
   :type diag: int_scalars, optional

   :returns: a copy of pda with zeros in the upper triangle
   :rtype: pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.array([[1,2,3,4,5],[2,3,4,5,6],[3,4,5,6,7],[4,5,6,7,8],[5,6,7,8,9]])
   >>> ak.tril(a,diag=4)
   array([array([1 2 3 4 5]) array([2 3 4 5 6]) array([3 4 5 6 7])
   array([4 5 6 7 8]) array([5 6 7 8 9])])
   >>> ak.tril(a,diag=3)
   array([array([1 2 3 4 0]) array([2 3 4 5 6]) array([3 4 5 6 7])
   array([4 5 6 7 8]) array([5 6 7 8 9])])
   >>> ak.tril(a,diag=2)
   array([array([1 2 3 0 0]) array([2 3 4 5 0]) array([3 4 5 6 7])
   array([4 5 6 7 8]) array([5 6 7 8 9])])
   >>> ak.tril(a,diag=1)
   array([array([1 2 0 0 0]) array([2 3 4 0 0]) array([3 4 5 6 0])
   array([4 5 6 7 8]) array([5 6 7 8 9])])
   >>> ak.tril(a,diag=0)
   array([array([1 0 0 0 0]) array([2 3 0 0 0]) array([3 4 5 0 0])
   array([4 5 6 7 0]) array([5 6 7 8 9])])

   .. rubric:: Notes

   Server returns an error if rank of pda < 2


.. py:function:: triu(pda: arkouda.numpy.pdarrayclass.pdarray, diag: arkouda.numpy.dtypes.int_scalars = 0) -> arkouda.numpy.pdarrayclass.pdarray

   Return a copy of the pda with the lower triangle zeroed out.

   :param pda:
   :type pda: pdarray
   :param diag: | if diag = 0, zeros start just below the main diagonal
                | if diag = 1, zeros start at the main diagonal
                | if diag = 2, zeros start just above the main diagonal
                | etc. Default set to 0.
   :type diag: int_scalars, default=0

   :returns: a copy of pda with zeros in the lower triangle
   :rtype: pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.array([[1,2,3,4,5],[2,3,4,5,6],[3,4,5,6,7],[4,5,6,7,8],[5,6,7,8,9]])
   >>> ak.triu(a,diag=0)
   array([array([1 2 3 4 5]) array([0 3 4 5 6]) array([0 0 5 6 7])
   array([0 0 0 7 8]) array([0 0 0 0 9])])
   >>> ak.triu(a,diag=1)
   array([array([0 2 3 4 5]) array([0 0 4 5 6]) array([0 0 0 6 7])
   array([0 0 0 0 8]) array([0 0 0 0 0])])
   >>> ak.triu(a,diag=2)
   array([array([0 0 3 4 5]) array([0 0 0 5 6]) array([0 0 0 0 7])
   array([0 0 0 0 0]) array([0 0 0 0 0])])
   >>> ak.triu(a,diag=3)
   array([array([0 0 0 4 5]) array([0 0 0 0 6]) array([0 0 0 0 0])
   array([0 0 0 0 0]) array([0 0 0 0 0])])
   >>> ak.triu(a,diag=4)
   array([array([0 0 0 0 5]) array([0 0 0 0 0]) array([0 0 0 0 0])
   array([0 0 0 0 0]) array([0 0 0 0 0])])

   .. rubric:: Notes

   Server returns an error if rank of pda < 2


.. py:function:: trunc(pda: arkouda.numpy.pdarrayclass.pdarray, where: Union[bool, arkouda.numpy.pdarrayclass.pdarray] = True) -> arkouda.numpy.pdarrayclass.pdarray

   Return the element-wise truncation of the array.

   :param pda:
   :type pda: pdarray
   :param where: This condition is applied over the input. At locations where the condition is True, the
                 corresponding value will be acted on by the function. Elsewhere, it will retain its
                 original value. Default set to True.
   :type where: bool or pdarray, default=True

   :returns: A pdarray containing input array elements truncated to the nearest integer
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.trunc(ak.array([1.1, 2.5, 3.14159]))
   array([1.00000000... 2.00000000... 3.00000000...])


.. py:function:: typename(char)

   Return a description for the given data type code.

   :param char: Data type code.
   :type char: str

   :returns: **out** -- Description of the input data type code.
   :rtype: str

   .. seealso:: :py:obj:`dtype`

   .. rubric:: Examples

   >>> import numpy as np
   >>> typechars = ['S1', '?', 'B', 'D', 'G', 'F', 'I', 'H', 'L', 'O', 'Q',
   ...              'S', 'U', 'V', 'b', 'd', 'g', 'f', 'i', 'h', 'l', 'q']
   >>> for typechar in typechars:
   ...     print(typechar, ' : ', np.typename(typechar))
   ...
   S1  :  character
   ?  :  bool
   B  :  unsigned char
   D  :  complex double precision
   G  :  complex long double precision
   F  :  complex single precision
   I  :  unsigned integer
   H  :  unsigned short
   L  :  unsigned long integer
   O  :  object
   Q  :  unsigned long long integer
   S  :  string
   U  :  unicode
   V  :  void
   b  :  signed char
   d  :  double precision
   g  :  long precision
   f  :  single precision
   i  :  integer
   h  :  short
   l  :  long integer
   q  :  long long integer


.. py:class:: ubyte

   Bases: :py:obj:`numpy.unsignedinteger`


   Unsigned integer type, compatible with C ``unsigned char``.

       :Character code: ``'B'``
       :Canonical name: `numpy.ubyte`
       :Alias on this platform (Linux x86_64): `numpy.uint8`: 8-bit unsigned integer (``0`` to ``255``).


   .. py:method:: bit_count(/)

      uint8.bit_count() -> int

              Computes the number of 1-bits in the absolute value of the input.
              Analogous to the builtin `int.bit_count` or ``popcount`` in C++.

              Examples
              --------
              >>> np.uint8(127).bit_count()
              7



.. py:class:: uint

   Bases: :py:obj:`numpy.unsignedinteger`


   Unsigned signed integer type, 64bit on 64bit systems and 32bit on 32bit
       systems.

       :Character code: ``'L'``
       :Canonical name: `numpy.uint`
       :Alias on this platform (Linux x86_64): `numpy.uint64`: 64-bit unsigned integer (``0`` to ``18_446_744_073_709_551_615``).
       :Alias on this platform (Linux x86_64): `numpy.uintp`: Unsigned integer large enough to fit pointer, compatible with C ``uintptr_t``.


   .. py:method:: bit_count(/)

      uint64.bit_count() -> int

              Computes the number of 1-bits in the absolute value of the input.
              Analogous to the builtin `int.bit_count` or ``popcount`` in C++.

              Examples
              --------
              >>> np.uint64(127).bit_count()
              7



.. py:class:: uint16

   Bases: :py:obj:`numpy.unsignedinteger`


   Unsigned integer type, compatible with C ``unsigned short``.

       :Character code: ``'H'``
       :Canonical name: `numpy.ushort`
       :Alias on this platform (Linux x86_64): `numpy.uint16`: 16-bit unsigned integer (``0`` to ``65_535``).


   .. py:method:: bit_count(/)

      uint16.bit_count() -> int

              Computes the number of 1-bits in the absolute value of the input.
              Analogous to the builtin `int.bit_count` or ``popcount`` in C++.

              Examples
              --------
              >>> np.uint16(127).bit_count()
              7



.. py:class:: uint32

   Bases: :py:obj:`numpy.unsignedinteger`


   Unsigned integer type, compatible with C ``unsigned int``.

       :Character code: ``'I'``
       :Canonical name: `numpy.uintc`
       :Alias on this platform (Linux x86_64): `numpy.uint32`: 32-bit unsigned integer (``0`` to ``4_294_967_295``).


   .. py:method:: bit_count(/)

      uint32.bit_count() -> int

              Computes the number of 1-bits in the absolute value of the input.
              Analogous to the builtin `int.bit_count` or ``popcount`` in C++.

              Examples
              --------
              >>> np.uint32(127).bit_count()
              7



.. py:class:: uint64

   Bases: :py:obj:`numpy.unsignedinteger`


   Unsigned signed integer type, 64bit on 64bit systems and 32bit on 32bit
       systems.

       :Character code: ``'L'``
       :Canonical name: `numpy.uint`
       :Alias on this platform (Linux x86_64): `numpy.uint64`: 64-bit unsigned integer (``0`` to ``18_446_744_073_709_551_615``).
       :Alias on this platform (Linux x86_64): `numpy.uintp`: Unsigned integer large enough to fit pointer, compatible with C ``uintptr_t``.


   .. py:method:: bit_count(/)

      uint64.bit_count() -> int

              Computes the number of 1-bits in the absolute value of the input.
              Analogous to the builtin `int.bit_count` or ``popcount`` in C++.

              Examples
              --------
              >>> np.uint64(127).bit_count()
              7



.. py:class:: uint8

   Bases: :py:obj:`numpy.unsignedinteger`


   Unsigned integer type, compatible with C ``unsigned char``.

       :Character code: ``'B'``
       :Canonical name: `numpy.ubyte`
       :Alias on this platform (Linux x86_64): `numpy.uint8`: 8-bit unsigned integer (``0`` to ``255``).


   .. py:method:: bit_count(/)

      uint8.bit_count() -> int

              Computes the number of 1-bits in the absolute value of the input.
              Analogous to the builtin `int.bit_count` or ``popcount`` in C++.

              Examples
              --------
              >>> np.uint8(127).bit_count()
              7



.. py:class:: uintc

   Bases: :py:obj:`numpy.unsignedinteger`


   Unsigned integer type, compatible with C ``unsigned int``.

       :Character code: ``'I'``
       :Canonical name: `numpy.uintc`
       :Alias on this platform (Linux x86_64): `numpy.uint32`: 32-bit unsigned integer (``0`` to ``4_294_967_295``).


   .. py:method:: bit_count(/)

      uint32.bit_count() -> int

              Computes the number of 1-bits in the absolute value of the input.
              Analogous to the builtin `int.bit_count` or ``popcount`` in C++.

              Examples
              --------
              >>> np.uint32(127).bit_count()
              7



.. py:class:: uintp

   Bases: :py:obj:`numpy.unsignedinteger`


   Unsigned signed integer type, 64bit on 64bit systems and 32bit on 32bit
       systems.

       :Character code: ``'L'``
       :Canonical name: `numpy.uint`
       :Alias on this platform (Linux x86_64): `numpy.uint64`: 64-bit unsigned integer (``0`` to ``18_446_744_073_709_551_615``).
       :Alias on this platform (Linux x86_64): `numpy.uintp`: Unsigned integer large enough to fit pointer, compatible with C ``uintptr_t``.


   .. py:method:: bit_count(/)

      uint64.bit_count() -> int

              Computes the number of 1-bits in the absolute value of the input.
              Analogous to the builtin `int.bit_count` or ``popcount`` in C++.

              Examples
              --------
              >>> np.uint64(127).bit_count()
              7



.. py:class:: ulonglong

   Bases: :py:obj:`numpy.unsignedinteger`


   Signed integer type, compatible with C ``unsigned long long``.

       :Character code: ``'Q'``


   .. py:method:: bit_count(/)


.. py:function:: uniform(size: Union[arkouda.numpy.dtypes.int_scalars, Tuple[arkouda.numpy.dtypes.int_scalars, Ellipsis]], low: arkouda.numpy.dtypes.numeric_scalars = float(0.0), high: arkouda.numpy.dtypes.numeric_scalars = 1.0, seed: Union[None, arkouda.numpy.dtypes.int_scalars] = None) -> arkouda.numpy.pdarrayclass.pdarray

   Generate a pdarray with uniformly distributed random float values
   in a specified range.

   :param size: The length or shape of the returned array
   :type size: Union[int_scalars, Tuple[int_scalars]
   :param low: The low value (inclusive) of the range, defaults to 0.0
   :type low: float_scalars
   :param high: The high value (inclusive) of the range, defaults to 1.0
   :type high: float_scalars
   :param seed: Value used to initialize the random number generator
   :type seed: int_scalars, optional

   :returns: Values drawn uniformly from the specified range
   :rtype: pdarray

   :raises TypeError: Raised if dtype.name not in DTypes, size is not an int, or if
       either low or high is not an int or float
   :raises ValueError: Raised if size < 0 or if high < low

   .. rubric:: Notes

   The logic for uniform is delegated to the ak.randint method which
   is invoked with a dtype of float64

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.uniform(3,seed=1701)
   array([0.011410423448327005 0.73618171558685619 0.12367222192448891])

   >>> ak.uniform(size=3,low=0,high=5,seed=0)
   array([0.30013431967121934 0.47383036230759112 1.0441791878997098])


.. py:function:: union1d(A: arkouda.pandas.groupbyclass.groupable, B: arkouda.pandas.groupbyclass.groupable) -> arkouda.pandas.groupbyclass.groupable

   Find the union of two arrays/List of Arrays.

   Return the unique, sorted array of values that are in either
   of the two input arrays.

   :param A:
   :type A: list of pdarrays, pdarray, Strings, or Categorical
   :param B:
   :type B: list of pdarrays, pdarray, Strings, or Categorical

   :returns: Unique, sorted union of the input arrays.
   :rtype: groupable

   :raises TypeError: Raised if either A or B is not a groupable
   :raises RuntimeError: Raised if the dtype of either input is not supported

   .. seealso:: :py:obj:`intersect1d`, :py:obj:`arkouda.pandas.groupbyclass.unique`

   .. rubric:: Examples

   >>> import arkouda as ak

   1D Example
   >>> ak.union1d(ak.array([-1, 0, 1]), ak.array([-2, 0, 2]))
   array([-2 -1 0 1 2])

   Multi-Array Example
   >>> a = ak.arange(1, 6)
   >>> b = ak.array([1, 5, 3, 4, 2])
   >>> c = ak.array([1, 4, 3, 2, 5])
   >>> d = ak.array([1, 2, 3, 5, 4])
   >>> multia = [a, a, a]
   >>> multib = [b, c, d]
   >>> ak.union1d(multia, multib)
   [array([1 2 2 3 4 4 5 5]), array([1 2 5 3 2 4 4 5]), array([1 2 4 3 5 4 2 5])]


.. py:function:: unregister(name: str) -> str

   Unregister an Arkouda object by its name.

   This function sends a request to unregister the Arkouda object associated
   with the specified `name`. It returns a response message indicating the
   success or failure of the operation.

   :param name: The name of the object to unregister.
   :type name: str

   :returns: A message indicating the result of the unregister operation.
   :rtype: str

   :raises RuntimeError: If the object associated with the given `name` does not exist or cannot
       be unregistered.

   .. rubric:: Examples

   >>> import arkouda as ak

   Unregister an existing object
   >>> obj = ak.array([1, 2, 3])
   >>> registered_obj = obj.register("my_array")
   >>> response = ak.unregister("my_array")
   >>> print(response)
   Unregistered PDARRAY my_array


.. py:function:: unregister_all(names: List[str])

   Unregister all Arkouda objects associated with the provided names.

   This function iterates through the list of `names`, unregistering each
   corresponding object from the Arkouda server.

   :param names: A list of registered names corresponding to Arkouda objects
                 that should be unregistered.
   :type names: List of str

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> data = { "array1": ak.array([0, 1, 2]), "array2": ak.array([3, 4, 5]) }
   >>> ak.register_all(data)

   After calling this function, "array1" and "array2" are registered
   in Arkouda, and can be accessed by their names.
   >>> ak.unregister_all(["array1", "array2"])

   "arr1" and "arr2" are now unregistered


.. py:class:: unsignedinteger

   Bases: :py:obj:`numpy.integer`


   Abstract base class of all unsigned integer scalar types.


.. py:function:: unsqueeze(p)

   Ensure that the input is returned as a list.

   If the input is a single pdarray, Strings, or Categorical object, wrap it in a list.
   Otherwise, return the input unchanged.

   :param p: The input object to be wrapped or returned as-is.
   :type p: pdarray, Strings, Categorical, or Sequence

   :returns: A list containing the input, or the input itself if it is already a sequence.
   :rtype: Sequence

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.array([1, 2, 3])
   >>> unsqueeze(a)
   [array([1 2 3])]


.. py:class:: ushort

   Bases: :py:obj:`numpy.unsignedinteger`


   Unsigned integer type, compatible with C ``unsigned short``.

       :Character code: ``'H'``
       :Canonical name: `numpy.ushort`
       :Alias on this platform (Linux x86_64): `numpy.uint16`: 16-bit unsigned integer (``0`` to ``65_535``).


   .. py:method:: bit_count(/)

      uint16.bit_count() -> int

              Computes the number of 1-bits in the absolute value of the input.
              Analogous to the builtin `int.bit_count` or ``popcount`` in C++.

              Examples
              --------
              >>> np.uint16(127).bit_count()
              7



.. py:function:: value_counts(pda: arkouda.numpy.pdarrayclass.pdarray) -> tuple[arkouda.groupbyclass.groupable, arkouda.numpy.pdarrayclass.pdarray]

   Count the occurrences of the unique values of an array.

   :param pda: The array of values to count
   :type pda: pdarray

   :returns: * **unique_values** (*pdarray, int64 or Strings*) -- The unique values, sorted in ascending order
             * **counts** (*pdarray, int64*) -- The number of times the corresponding unique value occurs

   :raises TypeError: Raised if the parameter is not a pdarray

   .. seealso:: :py:obj:`unique`, :py:obj:`histogram`

   .. rubric:: Notes

   This function differs from ``histogram()`` in that it only returns
   counts for values that are present, leaving out empty "bins". This
   function delegates all logic to the unique() method where the
   return_counts parameter is set to True.

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> A = ak.array([2, 0, 2, 4, 0, 0])
   >>> ak.value_counts(A)
   (array([0 2 4]), array([3 2 1]))


.. py:function:: vecdot(x1: arkouda.numpy.pdarrayclass.pdarray, x2: arkouda.numpy.pdarrayclass.pdarray, axis: Optional[Union[int, None]] = None) -> Union[arkouda.numpy.dtypes.numeric_scalars, arkouda.numpy.pdarrayclass.pdarray]

   Computes the numpy-style vecdot product of two matrices.  This differs from the
   vecdot function above.  See https://numpy.org/doc/stable/reference/index.html.

   :param x1:
   :type x1: pdarray
   :param x2:
   :type x2: pdarray
   :param axis:
   :type axis: int, None, optional, default = None

   :returns: x1 vecdot x2
   :rtype: pdarray, numeric_scalar

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.array([[1,2,3,4,5],[1,2,3,4,5]])
   >>> b = ak.array([[2,2,2,2,2],[2,2,2,2,2]])
   >>> ak.vecdot(a,b)
   array([30 30])
   >>> ak.vecdot(b,a)
   array([30 30])

   :raises ValueError: Raised if x1 and x2 can not be broadcast to a compatible shape
       or if the last dimensions of x1 and x2 don't match.

   .. rubric:: Notes

   This matches the behavior of numpy vecdot, but as commented above, it is not the
   behavior of the deprecated vecdot, which calls the chapel-side vecdot function.
   This function only uses broadcast_to, broadcast_shapes, ak.sum, and the
   binops pdarray multiplication function.  The last dimension of x1 and x2 must
   match, and it must be possible to broadcast them to a compatible shape.
   The deprecated vecdot can be computed via ak.vecdot(a,b,axis=0) on pdarrays
   of matching shape.


.. py:class:: void

   Bases: :py:obj:`numpy.flexible`


   np.void(length_or_data, /, dtype=None)

       Create a new structured or unstructured void scalar.

       Parameters
       ----------
       length_or_data : int, array-like, bytes-like, object
          One of multiple meanings (see notes).  The length or
          bytes data of an unstructured void.  Or alternatively,
          the data to be stored in the new scalar when `dtype`
          is provided.
          This can be an array-like, in which case an array may
          be returned.
       dtype : dtype, optional
          If provided the dtype of the new scalar.  This dtype must
          be "void" dtype (i.e. a structured or unstructured void,
          see also :ref:`defining-structured-types`).

          .. versionadded:: 1.24

       Notes
       -----
       For historical reasons and because void scalars can represent both
       arbitrary byte data and structured dtypes, the void constructor
       has three calling conventions:

       1. ``np.void(5)`` creates a ``dtype="V5"`` scalar filled with five
          ``\0`` bytes.  The 5 can be a Python or NumPy integer.
       2. ``np.void(b"bytes-like")`` creates a void scalar from the byte string.
          The dtype itemsize will match the byte string length, here ``"V10"``.
       3. When a ``dtype=`` is passed the call is roughly the same as an
          array creation.  However, a void scalar rather than array is returned.

       Please see the examples which show all three different conventions.

       Examples
       --------
       >>> np.void(5)
       np.void(b'\x00\x00\x00\x00\x00')
       >>> np.void(b'abcd')
       np.void(b'\x61\x62\x63\x64')
       >>> np.void((3.2, b'eggs'), dtype="d,S5")
       np.void((3.2, b'eggs'), dtype=[('f0', '<f8'), ('f1', 'S5')])
       >>> np.void(3, dtype=[('x', np.int8), ('y', np.int8)])
       np.void((3, 3), dtype=[('x', 'i1'), ('y', 'i1')])

       :Character code: ``'V'``


.. py:function:: vstack(tup: Sequence[arkouda.numpy.pdarrayclass.pdarray], *, dtype: Optional[Union[str, type]] = None, casting: Literal['no', 'equiv', 'safe', 'same_kind', 'unsafe'] = 'same_kind') -> arkouda.numpy.pdarrayclass.pdarray

   Stack arrays in sequence vertically (row wise).

   This is equivalent to concatenation along the first axis after
   1-D arrays of shape `(N,)` have been reshaped to `(1,N)`. Rebuilds arrays divided by ``vsplit``.

   This function makes most sense for arrays with up to 3 dimensions.
   For instance, for pixel-data with a height (first axis), width (second axis),
   and r/g/b channels (third axis). The functions ``concatenate``, ``stack`` and ``block``
   provide more general stacking and concatenation operations.

   :param tup: The arrays must have the same shape along all but the first axis. 1-D arrays
               must have the same length. In the case of a single array_like input, it will be
               treated as a sequence of arrays; i.e., each element along the zeroth axis is treated
               as a separate array.
   :type tup: sequence of pdarray
   :param dtype: If provided, the destination array will have this dtype.
   :type dtype: str or type, optional
   :param casting: Controls what kind of data casting may occur. Defaults to ‘same_kind’. Currently unused.
   :type casting: {"no", "equiv", "safe", "same_kind", "unsafe"], optional

   :returns: The array formed by stacking the given arrays, will be at least 2-D.
   :rtype: pdarray

   .. seealso:: :py:obj:`concatenate`, :py:obj:`stack`, :py:obj:`block`, :py:obj:`hstack`, :py:obj:`dstack`, :py:obj:`column_stack`, :py:obj:`hsplit`, :py:obj:`unstack`

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.array([1, 2, 3])
   >>> b = ak.array([4, 5, 6])
   >>> ak.vstack((a, b))
   array([array([1 2 3]) array([4 5 6])])

   >>> a = ak.array([[1],[2],[3]])
   >>> b = ak.array([[4],[5],[6]])
   >>> ak.vstack((a, b))
   array([array([1]) array([2]) array([3]) array([4]) array([5]) array([6])])


.. py:function:: where(condition: arkouda.numpy.pdarrayclass.pdarray, A: Union[str, arkouda.numpy.dtypes.numeric_scalars, arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.strings.Strings, arkouda.pandas.categorical.Categorical], B: Union[str, arkouda.numpy.dtypes.numeric_scalars, arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.strings.Strings, arkouda.pandas.categorical.Categorical]) -> Union[arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.strings.Strings, arkouda.pandas.categorical.Categorical]

   Return an array with elements chosen from A and B based upon a
   conditioning array. As is the case with numpy.where, the return array
   consists of values from the first array (A) where the conditioning array
   elements are True and from the second array (B) where the conditioning
   array elements are False.

   :param condition: Used to choose values from A or B
   :type condition: pdarray
   :param A: Value(s) used when condition is True
   :type A: str, numeric_scalars, pdarray, Strings, or Categorical
   :param B: Value(s) used when condition is False
   :type B: str, numeric_scalars, pdarray, Strings, or Categorical

   :returns: Values chosen from A where the condition is True and B where
             the condition is False
   :rtype: pdarray

   :raises TypeError: Raised if the condition object is not a pdarray, if A or B is not
       an int, np.int64, float, np.float64, bool, pdarray, str, Strings, Categorical
       if pdarray dtypes are not supported or do not match, or multiple
       condition clauses (see Notes section) are applied
   :raises ValueError: Raised if the shapes of the condition, A, and B pdarrays are unequal

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a1 = ak.arange(1,10)
   >>> a2 = ak.ones(9, dtype=np.int64)
   >>> cond = a1 < 5
   >>> ak.where(cond,a1,a2)
   array([1 2 3 4 1 1 1 1 1])

   >>> a1 = ak.arange(1,10)
   >>> a2 = ak.ones(9, dtype=np.int64)
   >>> cond = a1 == 5
   >>> ak.where(cond,a1,a2)
   array([1 1 1 1 5 1 1 1 1])

   >>> a1 = ak.arange(1,10)
   >>> a2 = 10
   >>> cond = a1 < 5
   >>> ak.where(cond,a1,a2)
   array([1 2 3 4 10 10 10 10 10])

   >>> s1 = ak.array([f'str {i}' for i in range(10)])
   >>> s2 = 'str 21'
   >>> cond = (ak.arange(10) % 2 == 0)
   >>> ak.where(cond,s1,s2)
   array(['str 0', 'str 21', 'str 2', 'str 21', 'str 4',
   'str 21', 'str 6', 'str 21', 'str 8', 'str 21'])

   >>> c1 = ak.Categorical(ak.array([f'str {i}' for i in range(10)]))
   >>> c2 = ak.Categorical(ak.array([f'str {i}' for i in range(9, -1, -1)]))
   >>> cond = (ak.arange(10) % 2 == 0)
   >>> ak.where(cond,c1,c2)
   array(['str 0', 'str 8', 'str 2', 'str 6', 'str 4',
   'str 4', 'str 6', 'str 2', 'str 8', 'str 0'])

   .. rubric:: Notes

   A and B must have the same dtype and only one conditional clause
   is supported e.g., n < 5, n > 1, which is supported in numpy
   is not currently supported in Arkouda


.. py:function:: write_log(log_msg: str, tag: str = 'ClientGeneratedLog', log_lvl: LogLevel = LogLevel.INFO)

   Allow the user to write custom logs.

   :param log_msg: The message to be added to the server log
   :type log_msg: str
   :param tag: The tag to use in the log. This takes the place of the server function name.
               Allows for easy identification of custom logs.
               Defaults to "ClientGeneratedLog"
   :type tag: str
   :param log_lvl: The type of log to be written
                   Defaults to LogLevel.INFO
   :type log_lvl: LogLevel

   .. seealso:: :py:obj:`LogLevel`


.. py:function:: xlogy(x: Union[arkouda.numpy.pdarrayclass.pdarray, numpy.float64], y: arkouda.numpy.pdarrayclass.pdarray)

   Computes x * log(y).

   :param x: x must have a datatype that is castable to float64
   :type x: pdarray or np.float64
   :param y:
   :type y: pdarray

   :rtype: arkouda.numpy.pdarrayclass.pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> from arkouda.scipy.special import xlogy
   >>> xlogy( ak.array([1, 2, 3, 4]),  ak.array([5,6,7,8]))
   array([1.6094379124341003 3.5835189384561099 5.8377304471659395 8.317766166719343])
   >>> xlogy( 5.0, ak.array([1, 2, 3, 4]))
   array([0.00000000000000000 3.4657359027997265 5.4930614433405491 6.9314718055994531])


.. py:function:: zero_up(vals)

   Map an array of sparse values to 0-up indices.

   :param vals: Array to map to dense index
   :type vals: pdarray

   :returns: **aligned** -- Array with values replaced by 0-up indices
   :rtype: pdarray


.. py:function:: zeros(size: Union[arkouda.numpy.dtypes.int_scalars, Tuple[arkouda.numpy.dtypes.int_scalars, Ellipsis], str], dtype: Union[numpy.dtype, type, str, arkouda.numpy.dtypes.bigint] = float64, max_bits: Optional[int] = None) -> arkouda.numpy.pdarrayclass.pdarray

   Create a pdarray filled with zeros.

   :param size: Size or shape of the array
   :type size: int_scalars or tuple of int_scalars
   :param dtype: Type of resulting array, default ak.float64
   :type dtype: all_scalars
   :param max_bits: Specifies the maximum number of bits; only used for bigint pdarrays
                    Included for consistency, as zeros are represented as all zeros, regardless
                    of the value of max_bits
   :type max_bits: int

   :returns: Zeros of the requested size or shape and dtype
   :rtype: pdarray

   :raises TypeError: Raised if the supplied dtype is not supported
   :raises RuntimeError: Raised if the size parameter is neither an int nor a str that is parseable to an int.
   :raises ValueError: Raised if the rank of the given shape is not in get_array_ranks() or is empty
       Raised if max_bits is not NONE and ndim does not equal 1

   .. seealso:: :py:obj:`ones`, :py:obj:`zeros_like`

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.zeros(5, dtype=ak.int64)
   array([0 0 0 0 0])

   >>> ak.zeros(5, dtype=ak.float64)
   array([0.00000000000000000 0.00000000000000000 0.00000000000000000
          0.00000000000000000 0.00000000000000000])

   >>> ak.zeros(5, dtype=ak.bool_)
   array([False False False False False])


.. py:function:: zeros_like(pda: arkouda.numpy.pdarrayclass.pdarray) -> arkouda.numpy.pdarrayclass.pdarray

   Create a zero-filled pdarray of the same size and dtype as an existing
   pdarray.

   :param pda: Array to use for size and dtype
   :type pda: pdarray

   :returns: Equivalent to ak.zeros(pda.size, pda.dtype)
   :rtype: pdarray

   :raises TypeError: Raised if the pda parameter is not a pdarray.

   .. seealso:: :py:obj:`zeros`, :py:obj:`ones_like`

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.zeros_like(ak.ones(5,dtype=ak.int64))
   array([0 0 0 0 0])

   >>> ak.zeros_like(ak.ones(5,dtype=ak.float64))
   array([0.00000000000000000 0.00000000000000000 0.00000000000000000
          0.00000000000000000 0.00000000000000000])

   >>> ak.zeros_like(ak.ones(5,dtype=ak.bool_))
   array([False False False False False])


