arkouda.numpy.segarray
======================

.. py:module:: arkouda.numpy.segarray


Classes
-------

.. autoapisummary::

   arkouda.numpy.segarray.SegArray


Module Contents
---------------

.. py:class:: SegArray(segments, values, lengths=None, grouping=None)

   .. py:method:: AND(x=None)


   .. py:method:: OR(x=None)


   .. py:method:: XOR(x=None)


   .. py:method:: aggregate(op, x=None)


   .. py:method:: all(x=None)


   .. py:method:: any(x=None)


   .. py:method:: append(other, axis=0)

      Append other to self, either vertically (axis=0, length of resulting SegArray
      increases), or horizontally (axis=1, each sub-array of other appends to the
      corresponding sub-array of self).

      :param other: Array of sub-arrays to append
      :type other: SegArray
      :param axis: Whether to append vertically (0) or horizontally (1). If axis=1, other
                   must be same size as self.
      :type axis: 0 or 1

      :returns: axis=0: New SegArray containing all sub-arrays
                axis=1: New SegArray of same length, with pairs of sub-arrays concatenated
      :rtype: SegArray



   .. py:method:: append_single(x, prepend=False)

      Append a single value to each sub-array.

      :param x: Single value to append to each sub-array
      :type x: pdarray or scalar

      :returns: Copy of original SegArray with values from x appended to each sub-array
      :rtype: SegArray



   .. py:method:: argmax(x=None)


   .. py:method:: argmin(x=None)


   .. py:method:: concat(x, axis=0, ordered=True)
      :classmethod:


      Concatenate a sequence of SegArrays.

      :param x: The SegArrays to concatenate
      :type x: sequence of SegArray
      :param axis: Select vertical (0) or horizontal (1) concatenation. If axis=1, all
                   SegArrays must have same size.
      :type axis: 0 or 1
      :param ordered: Must be True. This option is present for compatibility only, because unordered
                      concatenation is not yet supported.
      :type ordered: bool

      :returns: The input arrays joined into one SegArray
      :rtype: SegArray



   .. py:method:: copy()

      Return a deep copy.



   .. py:attribute:: dtype


   .. py:method:: filter(filter, discard_empty: bool = False)

      Filter values out of the SegArray object.

      :param filter: The value/s to be filtered out of the SegArray
      :type filter: pdarray, list, or value
      :param discard_empty: Defaults to False. When True, empty segments are removed from
                            the return SegArray
      :type discard_empty: bool

      :rtype: SegArray



   .. py:method:: from_multi_array(m)
      :classmethod:


      Construct a SegArray from a list of columns. This essentially transposes the input,
      resulting in an array of rows.

      :param m: List of columns, the rows of which will form the sub-arrays of the output
      :type m: list of pdarray or Strings

      :returns: Array of rows of input
      :rtype: SegArray



   .. py:method:: from_return_msg(rep_msg) -> SegArray
      :classmethod:



   .. py:method:: get_jth(j, return_origins=True, compressed=False, default=0)

      Select the j-th element of each sub-array, where possible.

      :param j: The index of the value to get from each sub-array. If j is negative,
                it counts backwards from the end of each sub-array.
      :type j: int
      :param return_origins: If True, return a logical index indicating where j is in bounds
      :type return_origins: bool
      :param compressed: If False, return array is same size as self, with default value
                         where j is out of bounds. If True, the return array only contains
                         values where j is in bounds.
      :type compressed: bool
      :param default: When compressed=False, the value to return when j is out of bounds
                      for the sub-array
      :type default: scalar

      :returns:

                val : pdarray
                    compressed=False: The j-th value of each sub-array where j is in
                    bounds and the default value where j is out of bounds.
                    compressed=True: The j-th values of only the sub-arrays where j is
                    in bounds
                origin_indices : pdarray, bool
                    A Boolean array that is True where j is in bounds for the sub-array.
      :rtype: pdarray, pdarray|bool

      .. rubric:: Notes

      If values are Strings, only the compressed format is supported.



   .. py:method:: get_length_n(n, return_origins=True)

      Return all sub-arrays of length n, as a list of columns.

      :param n: Length of sub-arrays to select
      :type n: int
      :param return_origins: Return a logical index indicating which sub-arrays are length n
      :type return_origins: bool

      :returns:

                columns : list of pdarray
                    An n-long list of pdarray, where each row is one of the n-long
                    sub-arrays from the SegArray. The number of rows is the number of
                    True values in the returned mask.
                origin_indices : pdarray, bool
                    Array of bool for each element of the SegArray, True where sub-array
                    has length n.
      :rtype: List of pdarray, pdarray|bool



   .. py:method:: get_ngrams(n, return_origins=True)

      Return all n-grams from all sub-arrays.

      :param n: Length of n-gram
      :type n: int
      :param return_origins: If True, return an int64 array indicating which sub-array
                             each returned n-gram came from.
      :type return_origins: bool

      :returns:

                ngrams : list of pdarray
                    An n-long list of pdarrays, essentially a table where each row is an n-gram.
                origin_indices : pdarray, int
                    The index of the sub-array from which the corresponding n-gram originated
      :rtype: pdarray, pdarray|int



   .. py:method:: get_prefixes(n, return_origins=True, proper=True)

      Return all sub-array prefixes of length n (for sub-arrays that are at least n+1 long).

      :param n: Length of suffix
      :type n: int
      :param return_origins: If True, return a logical index indicating which sub-arrays
                             were long enough to return an n-prefix
      :type return_origins: bool
      :param proper: If True, only return proper prefixes, i.e. from sub-arrays
                     that are at least n+1 long. If False, allow the entire
                     sub-array to be returned as a prefix.
      :type proper: bool

      :returns:

                prefixes : list of pdarray
                    An n-long list of pdarrays, essentially a table where each row is an n-prefix.
                    The number of rows is the number of True values in the returned mask.
                origin_indices : pdarray, bool
                    Boolean array that is True where the sub-array was long enough to return
                    an n-suffix, False otherwise.
      :rtype: List of pdarray, pdarray|bool



   .. py:method:: get_suffixes(n, return_origins=True, proper=True)

      Return the n-long suffix of each sub-array, where possible.

      :param n: Length of suffix
      :type n: int
      :param return_origins: If True, return a logical index indicating which sub-arrays
                             were long enough to return an n-suffix
      :type return_origins: bool
      :param proper: If True, only return proper suffixes, i.e. from sub-arrays
                     that are at least n+1 long. If False, allow the entire
                     sub-array to be returned as a suffix.
      :type proper: bool

      :returns:

                suffixes : list of pdarray
                    An n-long list of pdarrays, essentially a table where each row is an n-suffix.
                    The number of rows is the number of True values in the returned mask.
                origin_indices : pdarray, bool
                    Boolean array that is True where the sub-array was long enough to return
                    an n-suffix, False otherwise.
      :rtype: List of pdarray, pdarray|bool



   .. py:property:: grouping


   .. py:method:: hash() -> Tuple[arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.pdarrayclass.pdarray]

      Compute a 128-bit hash of each segment.

      :returns: A tuple of two int64 pdarrays. The ith hash value is the concatenation
                of the ith values from each array.
      :rtype: Tuple[pdarray,pdarray]



   .. py:method:: intersect(other)

      Computes the intersection of 2 SegArrays.

      :param other: SegArray to compute against
      :type other: SegArray

      :returns: Segments are the 1d intersections of the segments of self and other
      :rtype: SegArray

      .. seealso:: :py:obj:`pdarraysetops.intersect1d`

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> a = [1, 2, 3, 1, 4]
      >>> b = [3, 1, 4, 5]
      >>> c = [1, 3, 3, 5]
      >>> d = [2, 2, 4]
      >>> seg_a = ak.SegArray(ak.array([0, len(a)]), ak.array(a+b))
      >>> seg_b = ak.SegArray(ak.array([0, len(c)]), ak.array(c+d))
      >>> seg_a.intersect(seg_b)
      SegArray([
      [1 3]
      [4]
      ])



   .. py:method:: is_registered() -> bool

      Check if the name of the SegArray object is registered in the Symbol Table.

      :returns: True if SegArray is registered, false if not
      :rtype: bool

      .. seealso:: :py:obj:`register`, :py:obj:`unregister`, :py:obj:`attach`



   .. py:attribute:: logger


   .. py:method:: max(x=None)


   .. py:method:: mean(x=None)


   .. py:method:: min(x=None)


   .. py:property:: nbytes

      The size of the segarray in bytes.

      :returns: The size of the segarray in bytes.
      :rtype: int


   .. py:property:: non_empty


   .. py:method:: nunique(x=None)


   .. py:attribute:: objType
      :value: 'SegArray'



   .. py:method:: prepend_single(x)


   .. py:method:: prod(x=None)


   .. py:method:: read_hdf(prefix_path, dataset='segarray')
      :classmethod:


      Load a saved SegArray from HDF5. All arguments must match what
      was supplied to SegArray.save().

      :param prefix_path: Directory and filename prefix
      :type prefix_path: str
      :param dataset: Name prefix for saved data within the HDF5 files
      :type dataset: str

      :rtype: SegArray



   .. py:method:: register(user_defined_name)

      Register this SegArray object and underlying components with the Arkouda server.

      :param user_defined_name: user defined name which this SegArray object will be registered under
      :type user_defined_name: str

      :returns: The same SegArray which is now registered with the arkouda server and has an updated name.
                This is an in-place modification, the original is returned to support
                a fluid programming style.
                Please note you cannot register two different SegArrays with the same name.
      :rtype: SegArray

      :raises RegistrationError: Raised if the server could not register the SegArray object

      .. rubric:: Notes

      Objects registered with the server are immune to deletion until
      they are unregistered.

      .. seealso:: :py:obj:`unregister`, :py:obj:`attach`, :py:obj:`is_registered`



   .. py:attribute:: registered_name
      :type:  Optional[str]
      :value: None



   .. py:method:: remove_repeats(return_multiplicity=False)

      Condense sequences of repeated values within a sub-array to a single value.

      :param return_multiplicity: If True, also return the number of times each value was repeated.
      :type return_multiplicity: bool

      :returns:

                norepeats : SegArray
                    Sub-arrays with runs of repeated values replaced with single value
                multiplicity : SegArray
                    If return_multiplicity=True, this array contains the number of times
                    each value in the returned SegArray was repeated in the original SegArray.
      :rtype: Segarray, Segarray



   .. py:attribute:: segments


   .. py:method:: set_jth(i, j, v)

      Set the j-th element of each sub-array in a subset.

      :param i: Indices of sub-arrays to set j-th element
      :type i: pdarray, int
      :param j: Index of value to set in each sub-array. If j is negative, it counts
                backwards from the end of the sub-array.
      :type j: int
      :param v: The value(s) to set. If v is a pdarray, it must have same length as i.
      :type v: pdarray or scalar

      :raises ValueError: If j is out of bounds in any of the sub-arrays specified by i.



   .. py:method:: setdiff(other)

      Computes the set difference of 2 SegArrays.

      :param other: SegArray to compute against
      :type other: SegArray

      :returns: Segments are the 1d set difference of the segments of self and other
      :rtype: SegArray

      .. seealso:: :py:obj:`pdarraysetops.setdiff1d`

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> a = [1, 2, 3, 1, 4]
      >>> b = [3, 1, 4, 5]
      >>> c = [1, 3, 3, 5]
      >>> d = [2, 2, 4]
      >>> seg_a = ak.SegArray(ak.array([0, len(a)]), ak.array(a+b))
      >>> seg_b = ak.SegArray(ak.array([0, len(c)]), ak.array(c+d))
      >>> seg_a.setdiff(seg_b)
      SegArray([
      [2 4]
      [1 3 5]
      ])



   .. py:method:: setxor(other)

      Computes the symmetric difference of 2 SegArrays.

      :param other: SegArray to compute against
      :type other: SegArray

      :returns: Segments are the 1d symmetric difference of the segments of self and other
      :rtype: SegArray

      .. seealso:: :py:obj:`pdarraysetops.setxor1d`

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> a = [1, 2, 3, 1, 4]
      >>> b = [3, 1, 4, 5]
      >>> c = [1, 3, 3, 5]
      >>> d = [2, 2, 4]
      >>> seg_a = ak.SegArray(ak.array([0, len(a)]), ak.array(a+b))
      >>> seg_b = ak.SegArray(ak.array([0, len(c)]), ak.array(c+d))
      >>> seg_a.setxor(seg_b)
      SegArray([
      [2 4 5]
      [1 2 3 5]
      ])



   .. py:attribute:: size


   .. py:method:: sum(x=None)


   .. py:method:: to_hdf(prefix_path, dataset: str = 'segarray', mode: Literal['truncate', 'append'] = 'truncate', file_type: Literal['single', 'distribute'] = 'distribute')

      Save the SegArray to HDF5. The result is a collection of HDF5 files, one file
      per locale of the arkouda server, where each filename starts with prefix_path.

      :param prefix_path: Directory and filename prefix that all output files will share
      :type prefix_path: str
      :param dataset: Name prefix for saved data within the HDF5 file
      :type dataset: str
      :param mode: By default, truncate (overwrite) output files, if they exist.
                   If 'append', add data as a new column to existing files.
      :type mode: {'truncate', 'append'}
      :param file_type: Default: "distribute"
                        When set to single, dataset is written to a single file.
                        When distribute, dataset is written on a file per locale.
                        This is only supported by HDF5 files and will have no impact of Parquet Files.
      :type file_type: {"single", "distribute"}

      :rtype: None

      .. seealso:: :py:obj:`load`



   .. py:method:: to_ndarray()

      Convert the array into a numpy.ndarray containing sub-arrays.

      :returns: A numpy ndarray with the same sub-arrays (also numpy.ndarray) as this array
      :rtype: np.ndarray

      .. seealso:: :py:obj:`array`, :py:obj:`tolist`

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> segarr = ak.SegArray(ak.array([0, 4, 7]), ak.arange(12))
      >>> segarr.to_ndarray()
      array([array([0, 1, 2, 3]), array([4, 5, 6]), array([ 7,  8,  9, 10, 11])],
        dtype=object)
      >>> type(segarr.to_ndarray())
      <class 'numpy.ndarray'>



   .. py:method:: to_parquet(prefix_path, dataset='segarray', mode: Literal['truncate', 'append'] = 'truncate', compression: Optional[str] = None)

      Save the SegArray object to Parquet. The result is a collection of files,
      one file per locale of the arkouda server, where each filename starts
      with prefix_path. Each locale saves its chunk of the object to its
      corresponding file.

      :param prefix_path: Directory and filename prefix that all output files share
      :type prefix_path: str
      :param dataset: Name of the dataset to create in files (must not already exist)
      :type dataset: str
      :param mode: Deprecated.
                   Parameter kept to maintain functionality of other calls. Only Truncate
                   supported.
                   By default, truncate (overwrite) output files, if they exist.
                   If 'append', attempt to create new dataset in existing files.
      :type mode: {'truncate', 'append'}
      :param compression: (None | "snappy" | "gzip" | "brotli" | "zstd" | "lz4")
                          Sets the compression type used with Parquet files
      :type compression: str (Optional)

      :rtype: string message indicating result of save operation

      :raises RuntimeError: Raised if a server-side error is thrown saving the pdarray
      :raises ValueError: If write mode is not Truncate.

      .. rubric:: Notes

      - Append mode for Parquet has been deprecated. It was not implemented for SegArray.
      - The prefix_path must be visible to the arkouda server and the user must
      have write permission.
      - Output files have names of the form ``<prefix_path>_LOCALE<i>``, where ``<i>``
      ranges from 0 to ``numLocales`` for `file_type='distribute'`.
      - If any of the output files already exist and
      the mode is 'truncate', they will be overwritten. If the mode is 'append'
      and the number of output files is less than the number of locales or a
      dataset with the same name already exists, a ``RuntimeError`` will result.
      - Any file extension can be used.The file I/O does not rely on the extension to
      determine the file format.



   .. py:method:: tolist()

      Convert the segarray into a list containing sub-arrays.

      :returns: A list with the same sub-arrays (also list) as this segarray
      :rtype: list

      .. seealso:: :py:obj:`to_ndarray`

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> segarr = ak.SegArray(ak.array([0, 4, 7]), ak.arange(12))
      >>> segarr.tolist()
      [[0, 1, 2, 3], [4, 5, 6], [7, 8, 9, 10, 11]]
      >>> type(segarr.tolist())
      <class 'list'>



   .. py:method:: transfer(hostname: str, port: arkouda.numpy.dtypes.int_scalars)

      Send a Segmented Array to a different Arkouda server.

      :param hostname: The hostname where the Arkouda server intended to
                       receive the Segmented Array is running.
      :type hostname: str
      :param port: The port to send the array over. This needs to be an
                   open port (i.e., not one that the Arkouda server is
                   running on). This will open up `numLocales` ports,
                   each of which in succession, so will use ports of the
                   range {port..(port+numLocales)} (e.g., running an
                   Arkouda server of 4 nodes, port 1234 is passed as
                   `port`, Arkouda will use ports 1234, 1235, 1236,
                   and 1237 to send the array data).
                   This port much match the port passed to the call to
                   `ak.receive_array()`.
      :type port: int_scalars

      :rtype: A message indicating a complete transfer

      :raises ValueError: Raised if the op is not within the pdarray.BinOps set
      :raises TypeError: Raised if other is not a pdarray or the pdarray.dtype is not
          a supported dtype



   .. py:method:: union(other)

      Computes the union of 2 SegArrays.

      :param other: SegArray to compute against
      :type other: SegArray

      :returns: Segments are the 1d union of the segments of self and other
      :rtype: SegArray

      .. seealso:: :py:obj:`pdarraysetops.union1d`

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> a = [1, 2, 3, 1, 4]
      >>> b = [3, 1, 4, 5]
      >>> c = [1, 3, 3, 5]
      >>> d = [2, 2, 4]
      >>> seg_a = ak.SegArray(ak.array([0, len(a)]), ak.array(a+b))
      >>> seg_b = ak.SegArray(ak.array([0, len(c)]), ak.array(c+d))
      >>> seg_a.union(seg_b)
      SegArray([
      [1 2 3 4 5]
      [1 2 3 4 5]
      ])



   .. py:method:: unique(x=None) -> SegArray

      Return sub-arrays of unique values.

      :param x: The values to unique, per group. By default, the values of this
                SegArray's sub-arrays.
      :type x: pdarray

      :returns: Same number of sub-arrays as original SegArray, but elements in sub-array
                are unique and in sorted order.
      :rtype: SegArray



   .. py:method:: unregister()

      Unregister this SegArray object in the arkouda server which was previously
      registered using register() and/or attached to using attach().

      :raises RuntimeError: Raised if the server could not unregister the SegArray object from the Symbol Table

      .. rubric:: Notes

      Objects registered with the server are immune to deletion until
      they are unregistered.

      .. seealso:: :py:obj:`register`, :py:obj:`attach`, :py:obj:`is_registered`



   .. py:method:: update_hdf(prefix_path: str, dataset: str = 'segarray', repack: bool = True)

      Overwrite the dataset with the name provided with this SegArray object. If
      the dataset does not exist it is added.

      :param prefix_path: Directory and filename prefix that all output files share
      :type prefix_path: str
      :param dataset: Name of the dataset to create in files
      :type dataset: str
      :param repack: Default: True
                     HDF5 does not release memory on delete. When True, the inaccessible
                     data (that was overwritten) is removed. When False, the data remains, but is
                     inaccessible. Setting to false will yield better performance, but will cause
                     file sizes to expand.
      :type repack: bool

      :raises RuntimeError: Raised if a server-side error is thrown saving the SegArray

      .. rubric:: Notes

      - If file does not contain File_Format attribute to indicate how it was saved,
        the file name is checked for _LOCALE#### to determine if it is distributed.
      - If the dataset provided does not exist, it will be added
      - Because HDF5 deletes do not release memory, this will create a copy of the
        file with the new data



   .. py:attribute:: valsize


   .. py:attribute:: values


