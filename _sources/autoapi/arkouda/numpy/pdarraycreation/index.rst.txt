arkouda.numpy.pdarraycreation
=============================

.. py:module:: arkouda.numpy.pdarraycreation


Functions
---------

.. autoapisummary::

   arkouda.numpy.pdarraycreation.arange
   arkouda.numpy.pdarraycreation.array
   arkouda.numpy.pdarraycreation.bigint_from_uint_arrays
   arkouda.numpy.pdarraycreation.from_series
   arkouda.numpy.pdarraycreation.full
   arkouda.numpy.pdarraycreation.full_like
   arkouda.numpy.pdarraycreation.linspace
   arkouda.numpy.pdarraycreation.logspace
   arkouda.numpy.pdarraycreation.ones
   arkouda.numpy.pdarraycreation.ones_like
   arkouda.numpy.pdarraycreation.promote_to_common_dtype
   arkouda.numpy.pdarraycreation.randint
   arkouda.numpy.pdarraycreation.random_strings_lognormal
   arkouda.numpy.pdarraycreation.random_strings_uniform
   arkouda.numpy.pdarraycreation.scalar_array
   arkouda.numpy.pdarraycreation.standard_normal
   arkouda.numpy.pdarraycreation.uniform
   arkouda.numpy.pdarraycreation.zeros
   arkouda.numpy.pdarraycreation.zeros_like


Module Contents
---------------

.. py:function:: arange(__arg1: arkouda.numpy.dtypes.int_scalars, *, dtype: Optional[Union[numpy.dtype, type, arkouda.numpy.dtypes.bigint]] = None, max_bits: Optional[int] = None) -> arkouda.numpy.pdarrayclass.pdarray
                 arange(__arg1: arkouda.numpy.dtypes.int_scalars, __arg2: arkouda.numpy.dtypes.int_scalars, *, dtype: Optional[Union[numpy.dtype, type, arkouda.numpy.dtypes.bigint]] = None, max_bits: Optional[int] = None) -> arkouda.numpy.pdarrayclass.pdarray
                 arange(__arg1: arkouda.numpy.dtypes.int_scalars, __arg2: arkouda.numpy.dtypes.int_scalars, __arg3: arkouda.numpy.dtypes.int_scalars, *, dtype: Optional[Union[numpy.dtype, type, arkouda.numpy.dtypes.bigint]] = None, max_bits: Optional[int] = None) -> arkouda.numpy.pdarrayclass.pdarray

   # noqa: DAR102
   arange([start,] stop[, step,] dtype=int64)

   Create a pdarray of consecutive integers within the interval [start, stop).
   If only one arg is given then arg is the stop parameter. If two args are
   given, then the first arg is start and second is stop. If three args are
   given, then the first arg is start, second is stop, third is step.

   The return value is cast to type dtype

   :param start:
   :type start: int_scalars, optional
   :param stop:
   :type stop: int_scalars, optional
   :param step: if one of these three is supplied, it's used as stop, and start = 0, step = 1
                if two of them are supplied, start = start, stop = stop, step = 1
                if all three are supplied, start = start, stop = stop, step = step
   :type step: int_scalars, optional
   :param dtype: The target dtype to cast values to
   :type dtype: np.dtype, type, or str
   :param max_bits: Specifies the maximum number of bits; only used for bigint pdarrays
   :type max_bits: int

   :returns: Integers from start (inclusive) to stop (exclusive) by step
   :rtype: pdarray

   :raises ValueError: Raised if none of start, stop, step was supplied
   :raises TypeError: Raised if start, stop, or step is not an int object
   :raises ZeroDivisionError: Raised if step == 0

   .. seealso:: :py:obj:`linspace`, :py:obj:`zeros`, :py:obj:`ones`, :py:obj:`randint`

   .. rubric:: Notes

   Negative steps result in decreasing values. Currently, only int64
   pdarrays can be created with this method. For float64 arrays, use
   the linspace method.

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.arange(0, 5, 1)
   array([0 1 2 3 4])

   >>> ak.arange(5, 0, -1)
   array([5 4 3 2 1])

   >>> ak.arange(0, 10, 2)
   array([0 2 4 6 8])

   >>> ak.arange(-5, -10, -1)
   array([-5 -6 -7 -8 -9])


.. py:function:: array(a: Union[arkouda.numpy.pdarrayclass.pdarray, numpy.ndarray, Iterable, arkouda.numpy.strings.Strings], dtype: Union[numpy.dtype, type, str, None] = None, copy: bool = False, max_bits: int = -1) -> Union[arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.strings.Strings]

   Convert a Python, NumPy, or Arkouda array-like into a `pdarray` or `Strings` object,
   transferring data to the Arkouda server.

   :param a: The array-like input to convert. Supported types include Arkouda `Strings`, `pdarray`,
             NumPy `ndarray`, or Python iterables such as list, tuple, range, or deque.
   :type a: Union[pdarray, np.ndarray, Iterable, Strings]
   :param dtype: The target dtype to cast values to. This may be a NumPy dtype object,
                 a NumPy scalar type (e.g. `np.int64`), or a string (e.g. `'int64'`, `'str'`).
   :type dtype: Union[np.dtype, type, str], optional
   :param copy: If True, a deep copy of the array is made. If False, no copy is made if the input
                is already a `pdarray`. **Note**: Arkouda does not currently support views or shallow copies.
                This differs from NumPy. Also, the default (`False`) is chosen to reduce performance overhead.
   :type copy: bool, default=False
   :param max_bits: The maximum number of bits for bigint arrays. Ignored for other dtypes.
   :type max_bits: int, optional

   :returns: A `pdarray` stored on the Arkouda server, or a `Strings` object.
   :rtype: Union[pdarray, Strings]

   :raises TypeError: - If `a` is not a `pdarray`, `np.ndarray`, or Python iterable.
       - If `a` is of string type and `dtype` is not `ak.str_`.
   :raises RuntimeError: - If input size exceeds `ak.client.maxTransferBytes`.
       - If `a.dtype` is unsupported or incompatible with Arkouda.
       - If `a.size * a.itemsize > maxTransferBytes`.
   :raises ValueError: - If `a`'s rank is not supported (see `get_array_ranks()`).
       - If the server response is malformed or missing required fields.

   .. seealso::

      :py:obj:`pdarray.to_ndarray`
          Convert back from Arkouda to NumPy.

   .. rubric:: Notes

   - Arkouda does not currently support shallow copies or views; all copies are deep.
   - The number of bytes transferred to the server is limited by `ak.client.maxTransferBytes`.
     This prevents saturating the network during large transfers. To increase this limit,
     set `ak.client.maxTransferBytes` to a larger value manually.
   - If the input is a Unicode string array (`dtype.kind == 'U'` or `dtype='str'`),
     this function recursively creates a `Strings` object from two internal `pdarray`s
     (one for offsets and one for concatenated string bytes).

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.array(np.arange(1, 10))
   array([1 2 3 4 5 6 7 8 9])

   >>> ak.array(range(1, 10))
   array([1 2 3 4 5 6 7 8 9])

   >>> strings = ak.array([f'string {i}' for i in range(5)])
   >>> type(strings)
   <class 'arkouda.numpy.strings.Strings'>


.. py:function:: bigint_from_uint_arrays(arrays, max_bits=-1)

   Create a bigint pdarray from an iterable of uint pdarrays.
   The first item in arrays will be the highest 64 bits and
   the last item will be the lowest 64 bits.

   :param arrays: An iterable of uint pdarrays used to construct the bigint pdarray.
                  The first item in arrays will be the highest 64 bits and
                  the last item will be the lowest 64 bits.
   :type arrays: Sequence[pdarray]
   :param max_bits: Specifies the maximum number of bits; only used for bigint pdarrays
   :type max_bits: int

   :returns: bigint pdarray constructed from uint arrays
   :rtype: pdarray

   :raises TypeError: Raised if any pdarray in arrays has a dtype other than uint or
       if the pdarrays are not the same size.
   :raises RuntimeError: Raised if there is a server-side error thrown

   .. seealso:: :py:obj:`pdarray.bigint_to_uint_arrays`

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.bigint_from_uint_arrays([ak.ones(5, dtype=ak.uint64), ak.arange(5, dtype=ak.uint64)])
   >>> a
   array([18446744073709551616 18446744073709551617 18446744073709551618
   18446744073709551619 18446744073709551620])

   >>> a.dtype
   dtype(bigint)

   >>> all(a[i] == 2**64 + i for i in range(5))
   True


.. py:function:: from_series(series: pandas.Series, dtype: Optional[Union[type, str]] = None) -> Union[arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.strings.Strings]

   Converts a Pandas Series to an Arkouda pdarray or Strings object. If
   dtype is None, the dtype is inferred from the Pandas Series. Otherwise,
   the dtype parameter is set if the dtype of the Pandas Series is to be
   overridden or is  unknown (for example, in situations where the Series
   dtype is object).

   :param series: The Pandas Series with a dtype of bool, float64, int64, or string
   :type series: Pandas Series
   :param dtype: The valid dtype types are np.bool, np.float64, np.int64, and np.str
   :type dtype: Optional[type]

   :rtype: Union[pdarray,Strings]

   :raises TypeError: Raised if series is not a Pandas Series object
   :raises ValueError: Raised if the Series dtype is not bool, float64, int64, string, datetime, or timedelta

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> np.random.seed(1701)
   >>> ak.from_series(pd.Series(np.random.randint(0,10,5)))
   array([4 3 3 5 0])

   >>> ak.from_series(pd.Series(['1', '2', '3', '4', '5']),dtype=np.int64)
   array([1 2 3 4 5])

   >>> np.random.seed(1701)
   >>> ak.from_series(pd.Series(np.random.uniform(low=0.0,high=1.0,size=3)))
   array([0.089433234324597599 0.1153776854774361 0.51874393620990389])

   >>> ak.from_series(
   ...     pd.Series([
   ...         '0.57600036956445599',
   ...         '0.41619265571741659',
   ...         '0.6615356693784662',
   ...     ]),
   ...     dtype=np.float64,
   ... )
   array([0.57600036956445599 0.41619265571741659 0.6615356693784662])

   >>> np.random.seed(1864)
   >>> ak.from_series(pd.Series(np.random.choice([True, False],size=5)))
   array([True True True False False])

   >>> ak.from_series(pd.Series(['True', 'False', 'False', 'True', 'True']), dtype=bool)
   array([True True True True True])

   >>> ak.from_series(pd.Series(['a', 'b', 'c', 'd', 'e'], dtype="string"))
   array(['a', 'b', 'c', 'd', 'e'])

   >>> ak.from_series(pd.Series(pd.to_datetime(['1/1/2018', np.datetime64('2018-01-01')])))
   array([1514764800000000000 1514764800000000000])

   .. rubric:: Notes

   The supported datatypes are bool, float64, int64, string, and datetime64[ns]. The
   data type is either inferred from the the Series or is set via the dtype parameter.

   Series of datetime or timedelta are converted to Arkouda arrays of dtype int64 (nanoseconds)

   A Pandas Series containing strings has a dtype of object. Arkouda assumes the Series
   contains strings and sets the dtype to str


.. py:function:: full(size: Union[arkouda.numpy.dtypes.int_scalars, Tuple[arkouda.numpy.dtypes.int_scalars, Ellipsis], str], fill_value: Union[arkouda.numpy.dtypes.numeric_scalars, str], dtype: Optional[Union[numpy.dtype, type, str, arkouda.numpy.dtypes.bigint]] = None, max_bits: Optional[int] = None) -> Union[arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.strings.Strings]

   Create a pdarray filled with fill_value.

   :param size: Size or shape of the array
   :type size: int_scalars or tuple of int_scalars
   :param fill_value: Value with which the array will be filled
   :type fill_value: int_scalars or str
   :param dtype: Resulting array type, default float64
   :type dtype: all_scalars
   :param max_bits: Specifies the maximum number of bits; only used for bigint pdarrays
   :type max_bits: int

   :returns: array of the requested size and dtype filled with fill_value
   :rtype: pdarray or Strings

   :raises TypeError: Raised if the supplied dtype is not supported
   :raises RuntimeError: Raised if the size parameter is neither an int nor a str that is parseable to an int.
   :raises ValueError: Raised if the rank of the given shape is not in get_array_ranks() or is empty
       Raised if max_bits is not NONE and ndim does not equal 1

   .. seealso:: :py:obj:`zeros`, :py:obj:`ones`

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.full(5, 7, dtype=ak.int64)
   array([7 7 7 7 7])

   >>> ak.full(5, 9, dtype=ak.float64)
   array([9.00000000000000000 9.00000000000000000 9.00000000000000000
          9.00000000000000000 9.00000000000000000])

   >>> ak.full(5, 5, dtype=ak.bool_)
   array([True True True True True])


.. py:function:: full_like(pda: arkouda.numpy.pdarrayclass.pdarray, fill_value: arkouda.numpy.dtypes.numeric_scalars) -> Union[arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.strings.Strings]

   Create a pdarray filled with fill_value of the same size and dtype as an existing
   pdarray.

   :param pda: Array to use for size and dtype
   :type pda: pdarray
   :param fill_value: Value with which the array will be filled
   :type fill_value: int_scalars

   :returns: Equivalent to ak.full(pda.size, fill_value, pda.dtype)
   :rtype: pdarray

   :raises TypeError: Raised if the pda parameter is not a pdarray.

   .. seealso:: :py:obj:`ones_like`, :py:obj:`zeros_like`

   .. rubric:: Notes

   Logic for generating the pdarray is delegated to the ak.full method.
   Accordingly, the supported dtypes match are defined by the ak.full method.

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.full_like(ak.full(5,7,dtype=ak.int64),6)
   array([6 6 6 6 6])

   >>> ak.full_like(ak.full(7,9,dtype=ak.float64),10)
   array([10.00000000000000000 10.00000000000000000 10.00000000000000000
          10.00000000000000000 10.00000000000000000 10.00000000000000000 10.00000000000000000])

   >>> ak.full_like(ak.full(5,True,dtype=ak.bool_),False)
   array([False False False False False])


.. py:function:: linspace(start: Union[arkouda.numpy.dtypes.numeric_scalars, arkouda.numpy.pdarrayclass.pdarray], stop: Union[arkouda.numpy.dtypes.numeric_scalars, arkouda.numpy.pdarrayclass.pdarray], num: arkouda.numpy.dtypes.int_scalars = 50, endpoint: Union[None, bool] = True, dtype: Optional[type] = float64, axis: arkouda.numpy.dtypes.int_scalars = 0) -> arkouda.numpy.pdarrayclass.pdarray

   Return evenly spaced numbers over a specified interval.

   Returns `num` evenly spaced samples, calculated over the
   interval [`start`, `stop`].

   The endpoint of the interval can optionally be excluded.

   :param start: The starting value of the sequence.
   :type start: Union[numeric_scalars, pdarray]
   :param stop: The end value of the sequence, unless `endpoint` is set to False.
                In that case, the sequence consists of all but the last of ``num + 1``
                evenly spaced samples, so that `stop` is excluded.  Note that the step
                size changes when `endpoint` is False.
   :type stop: Union[numeric_scalars, pdarray]
   :param num: Number of samples to generate. Default is 50. Must be non-negative.
   :type num: int, optional
   :param endpoint: If True, `stop` is the last sample. Otherwise, it is not included.
                    Default is True.
   :type endpoint: bool, optional
   :param dtype: Allowed for compatibility with numpy linspace, but anything entered
                 is ignored.  The output is always ak.float64.
   :type dtype: dtype, optional
   :param axis: The axis in the result to store the samples.  Relevant only if start
                or stop are array-like.  By default (0), the samples will be along a
                new axis inserted at the beginning. Use -1 to get an axis at the end.
   :type axis: int, optional

   :returns: There are `num` equally spaced samples in the closed interval
             ``[start, stop]`` or the half-open interval ``[start, stop)``
             (depending on whether `endpoint` is True or False).
   :rtype: pdarray

   :raises TypeError: Raised if start or stop is not a float or a pdarray, or if num
       is not an int, or if endpoint is not a bool, or if dtype is anything
       other than None or float64, or axis is not an integer.
   :raises ValueError: Raised if axis is not a valid axis for the given data.

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.linspace(0,1,3)
   array([0.00000000000000000 0.5 1.00000000000000000])
   >>> ak.linspace(1,0,3)
   array([1.00000000000000000 0.5 0.00000000000000000])
   >>> ak.linspace(0,1,3,endpoint=False)
   array([0.00000000000000000 0.33333333333333331 0.66666666666666663])
   >>> ak.linspace(0,ak.array([2,3]),3)
   array([array([0.00000000000000000 0.00000000000000000])
       array([1.00000000000000000 1.5]) array([2.00000000000000000 3.00000000000000000])])
   >>> ak.linspace(ak.array([0,1]),3,3)
   array([array([0.00000000000000000 1.00000000000000000])
       array([1.5 2.00000000000000000]) array([3.00000000000000000 3.00000000000000000])])
   >>> ak.linspace(ak.array([0,1]),ak.array([2,3]),3)
   array([array([0.00000000000000000 1.00000000000000000])
       array([1.00000000000000000 2.00000000000000000])
       array([2.00000000000000000 3.00000000000000000])])


.. py:function:: logspace(start: Union[arkouda.numpy.dtypes.numeric_scalars, arkouda.numpy.pdarrayclass.pdarray], stop: Union[arkouda.numpy.dtypes.numeric_scalars, arkouda.numpy.pdarrayclass.pdarray], num: arkouda.numpy.dtypes.int_scalars = 50, base: arkouda.numpy.dtypes.numeric_scalars = 10.0, endpoint: Union[None, bool] = True, dtype: Optional[type] = float64, axis: Union[None, arkouda.numpy.dtypes.int_scalars] = 0) -> arkouda.numpy.pdarrayclass.pdarray

   Create a pdarray of numbers evenly spaced on a log scale.

   :param start: The starting value of the sequence.
   :type start: Union[numeric_scalars, pdarray]
   :param stop: The end value of the sequence, unless `endpoint` is set to False.
                In that case, the sequence consists of all but the last of ``num + 1``
                evenly spaced samples, so that `stop` is excluded.  Note that the step
                size changes when `endpoint` is False.
   :type stop: Union[numeric_scalars, pdarray]
   :param num: Number of samples to generate. Default is 50. Must be non-negative.
   :type num: int, optional
   :param base: the base of the log space, defaults to 10.0.
   :type base: numeric_scalars, optional
   :param endpoint: If True, `stop` is the last sample. Otherwise, it is not included.
                    Default is True.
   :type endpoint: bool, optional
   :param dtype: allowed for compatibility with numpy, but ignored.  Outputs are always float
   :type dtype: Union[None, float64]
   :param axis: The axis in the result to store the samples.  Relevant only if start
                or stop are array-like.  By default (0), the samples will be along a
                new axis inserted at the beginning. Use -1 to get an axis at the end.
   :type axis: int, optional

   :returns: There are `num` equally spaced (logarithmically) samples in the closed interval
             base**``[start, stop]`` or the half-open interval base**``[start, stop)``
             (depending on whether `endpoint` is True or False).
   :rtype: pdarray

   :raises TypeError: Raised if start or stop is not a float or a pdarray, or if num
       is not an int, or if endpoint is not a bool, or if dtype is anything
       other than None or float64, or axis is not an integer.
   :raises ValueError: Raised if axis is not a valid axis for the given data, or if base < 0.

   .. seealso:: :py:obj:`linspace`

   .. rubric:: Notes

   If start is greater than stop, the pdarray values are generated
   in descending order.

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.logspace(2,3,3,4)
   array([16.00000000000000000 32.00000000000000000 64.00000000000000000])
   >>> ak.logspace(2,3,3,4,endpoint=False)
   array([16.00000000000000000 25.398416831491197 40.317473596635935])
   >>> ak.logspace(0,1,3,4)
   array([1.00000000000000000 2.00000000000000000 4.00000000000000000])
   >>> ak.logspace(1,0,3,4)
   array([4.00000000000000000 2.00000000000000000 1.00000000000000000])
   >>> ak.logspace(0,1,3,endpoint=False)
   array([1.00000000000000000 2.1544346900318838 4.6415888336127784])
   >>> ak.logspace(0,ak.array([2,3]),3,base=2)
   array([array([1.00000000000000000 1.00000000000000000])
       array([2.00000000000000000 2.8284271247461903])
       array([4.00000000000000000 8.00000000000000000])])
   >>> ak.logspace(ak.array([0,1]),3,3,base=3)
   array([array([1.00000000000000000 3.00000000000000000])
       array([5.196152422706632 9.00000000000000000])
       array([27.00000000000000000 27.00000000000000000])])
   >>> ak.logspace(ak.array([0,1]),ak.array([2,3]),3,base=4)
   array([array([1.00000000000000000 4.00000000000000000])
       array([4.00000000000000000 16.00000000000000000])
       array([16.00000000000000000 64.00000000000000000])])


.. py:function:: ones(size: Union[arkouda.numpy.dtypes.int_scalars, Tuple[arkouda.numpy.dtypes.int_scalars, Ellipsis], str], dtype: Union[numpy.dtype, type, str, arkouda.numpy.dtypes.bigint] = float64, max_bits: Optional[int] = None) -> arkouda.numpy.pdarrayclass.pdarray

   Create a pdarray filled with ones.

   :param size: Size or shape of the array
   :type size: int_scalars or tuple of int_scalars
   :param dtype: Resulting array type, default ak.float64
   :type dtype: Union[float64, int64, bool]
   :param max_bits: Specifies the maximum number of bits; only used for bigint pdarrays
                    Included for consistency, as ones are all zeros ending on a one, regardless
                    of max_bits
   :type max_bits: int

   :returns: Ones of the requested size or shape and dtype
   :rtype: pdarray

   :raises TypeError: Raised if the supplied dtype is not supported
   :raises RuntimeError: Raised if the size parameter is neither an int nor a str that is parseable to an int.
   :raises ValueError: Raised if the rank of the given shape is not in get_array_ranks() or is empty

   .. seealso:: :py:obj:`zeros`, :py:obj:`ones_like`

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.ones(5, dtype=ak.int64)
   array([1 1 1 1 1])

   >>> ak.ones(5, dtype=ak.float64)
   array([1.00000000000000000 1.00000000000000000 1.00000000000000000
          1.00000000000000000 1.00000000000000000])

   >>> ak.ones(5, dtype=ak.bool_)
   array([True True True True True])

   .. rubric:: Notes

   Logic for generating the pdarray is delegated to the ak.full method.


.. py:function:: ones_like(pda: arkouda.numpy.pdarrayclass.pdarray) -> arkouda.numpy.pdarrayclass.pdarray

   Create a one-filled pdarray of the same size and dtype as an existing
   pdarray.

   :param pda: Array to use for size and dtype
   :type pda: pdarray

   :returns: Equivalent to ak.ones(pda.size, pda.dtype)
   :rtype: pdarray

   :raises TypeError: Raised if the pda parameter is not a pdarray.

   .. seealso:: :py:obj:`ones`, :py:obj:`zeros_like`

   .. rubric:: Notes

   Logic for generating the pdarray is delegated to the ak.ones method.
   Accordingly, the supported dtypes match are defined by the ak.ones method.

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.ones_like(ak.zeros(5,dtype=ak.int64))
   array([1 1 1 1 1])

   >>> ak.ones_like(ak.zeros(5,dtype=ak.float64))
   array([1.00000000000000000 1.00000000000000000 1.00000000000000000
          1.00000000000000000 1.00000000000000000])

   >>> ak.ones_like(ak.zeros(5,dtype=ak.bool_))
   array([True True True True True])


.. py:function:: promote_to_common_dtype(arrays: List[arkouda.numpy.pdarrayclass.pdarray]) -> Tuple[Any, List[arkouda.numpy.pdarrayclass.pdarray]]

   Promote a list of pdarrays to a common dtype.

   :param arrays: List of pdarrays to promote
   :type arrays: List[pdarray]

   :returns: The common dtype of the pdarrays and the list of pdarrays promoted to that dtype
   :rtype: dtype, List[pdarray]

   :raises TypeError: Raised if any pdarray is a non-numeric type

   .. seealso:: :py:obj:`pdarray.promote_dtype`

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.arange(5)
   >>> b = ak.ones(5, dtype=ak.float64)
   >>> dtype, promoted = ak.promote_to_common_dtype([a, b])
   >>> dtype
   dtype('float64')
   >>> all(isinstance(p, ak.pdarray) and p.dtype == dtype for p in promoted)
   True


.. py:function:: randint(low: arkouda.numpy.dtypes.numeric_scalars, high: arkouda.numpy.dtypes.numeric_scalars, size: Union[arkouda.numpy.dtypes.int_scalars, Tuple[arkouda.numpy.dtypes.int_scalars, Ellipsis]] = 1, dtype=akint64, seed: Optional[arkouda.numpy.dtypes.int_scalars] = None) -> arkouda.numpy.pdarrayclass.pdarray

   Generate a pdarray of randomized int, float, or bool values in a
   specified range bounded by the low and high parameters.

   :param low: The low value (inclusive) of the range
   :type low: numeric_scalars
   :param high: The high value (exclusive for int, inclusive for float) of the range
   :type high: numeric_scalars
   :param size: The size or shape of the returned array
   :type size: int_scalars or tuple of int_scalars
   :param dtype: The dtype of the array
   :type dtype: Union[int64, float64, bool]
   :param seed: Index for where to pull the first returned value
   :type seed: int_scalars, optional

   :returns: Values drawn uniformly from the specified range having the desired dtype
   :rtype: pdarray

   :raises TypeError: Raised if dtype.name not in DTypes, size is not an int, low or high is
       not an int or float, or seed is not an int
   :raises ValueError: Raised if size < 0 or if high < low

   .. rubric:: Notes

   Calling randint with dtype=float64 will result in uniform non-integral
   floating point values.

   Ranges >= 2**64 in size is undefined behavior because
   it exceeds the maximum value that can be stored on the server (uint64)

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.randint(0, 10, 5, seed=1701)
   array([6 5 1 6 3])

   >>> ak.randint(0, 1, 3, seed=1701, dtype=ak.float64)
   array([0.011410423448327005 0.73618171558685619 0.12367222192448891])

   >>> ak.randint(0, 1, 5, seed=1701, dtype=ak.bool_)
   array([False True False True False])


.. py:function:: random_strings_lognormal(logmean: arkouda.numpy.dtypes.numeric_scalars, logstd: arkouda.numpy.dtypes.numeric_scalars, size: arkouda.numpy.dtypes.int_scalars, characters: str = 'uppercase', seed: Optional[arkouda.numpy.dtypes.int_scalars] = None) -> arkouda.numpy.strings.Strings

   Generate random strings with log-normally distributed lengths and
   with characters drawn from a specified set.

   :param logmean: The log-mean of the length distribution
   :type logmean: numeric_scalars
   :param logstd: The log-standard-deviation of the length distribution
   :type logstd: numeric_scalars
   :param size: The number of strings to generate
   :type size: int_scalars
   :param characters: The set of characters to draw from
   :type characters: (uppercase, lowercase, numeric, printable, binary)
   :param seed: Value used to initialize the random number generator
   :type seed: int_scalars, optional

   :returns: The Strings object encapsulating a pdarray of random strings
   :rtype: Strings

   :raises TypeError: Raised if logmean is neither a float nor a int, logstd is not a float,
       seed is not an int, size is not an int, or if characters is not a str
   :raises ValueError: Raised if logstd <= 0 or size < 0

   .. seealso:: :py:obj:`random_strings_lognormal`, :py:obj:`randint`

   .. rubric:: Notes

   The lengths of the generated strings are distributed $Lognormal(\mu, \sigma^2)$,
   with :math:`\mu = logmean` and :math:`\sigma = logstd`. Thus, the strings will
   have an average length of :math:`exp(\mu + 0.5*\sigma^2)`, a minimum length of
   zero, and a heavy tail towards longer strings.

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.random_strings_lognormal(2, 0.25, 5, seed=1)
   array(['VWHJEX', 'BEBBXJHGM', 'RWOVKBUR', 'LNJCSDXD', 'NKEDQC'])

   >>> ak.random_strings_lognormal(2, 0.25, 5, seed=1, characters='printable')
   array(['eL96<O', ')o-GOe lR', ')PV yHf(', '._b3Yc&K', ',7Wjef'])


.. py:function:: random_strings_uniform(minlen: arkouda.numpy.dtypes.int_scalars, maxlen: arkouda.numpy.dtypes.int_scalars, size: arkouda.numpy.dtypes.int_scalars, characters: str = 'uppercase', seed: Union[None, arkouda.numpy.dtypes.int_scalars] = None) -> arkouda.numpy.strings.Strings

   Generate random strings with lengths uniformly distributed between
   minlen and maxlen, and with characters drawn from a specified set.

   :param minlen: The minimum allowed length of string
   :type minlen: int_scalars
   :param maxlen: The maximum allowed length of string
   :type maxlen: int_scalars
   :param size: The number of strings to generate
   :type size: int_scalars
   :param characters: The set of characters to draw from
   :type characters: (uppercase, lowercase, numeric, printable, binary)
   :param seed: Value used to initialize the random number generator
   :type seed: Union[None, int_scalars], optional

   :returns: The array of random strings
   :rtype: Strings

   :raises ValueError: Raised if minlen < 0, maxlen < minlen, or size < 0

   .. seealso:: :py:obj:`random_strings_lognormal`, :py:obj:`randint`

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.random_strings_uniform(minlen=1, maxlen=5, seed=8675309, size=5)
   array(['ECWO', 'WSS', 'TZG', 'RW', 'C'])

   >>> ak.random_strings_uniform(minlen=1, maxlen=5, seed=8675309, size=5,
   ... characters='printable')
   array(['2 .z', 'aom', '2d|', 'o(', 'M'])


.. py:function:: scalar_array(value: arkouda.numpy.dtypes.numeric_scalars, dtype: Optional[Union[numpy.dtype, type, str, arkouda.numpy.dtypes.bigint]] = None) -> arkouda.numpy.pdarrayclass.pdarray

   Create a pdarray from a single scalar value.

   :param value: Value to create pdarray from
   :type value: numeric_scalars

   :returns: pdarray with a single element
   :rtype: pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.scalar_array(5)
   array([5])

   >>> ak.scalar_array(7.0)
   array([7.00000000000000000])

   :raises RuntimeError: Raised if value cannot be cast as dtype


.. py:function:: standard_normal(size: arkouda.numpy.dtypes.int_scalars, seed: Union[None, arkouda.numpy.dtypes.int_scalars] = None) -> arkouda.numpy.pdarrayclass.pdarray

   Draw real numbers from the standard normal distribution.

   :param size: The number of samples to draw (size of the returned array)
   :type size: int_scalars
   :param seed: Value used to initialize the random number generator
   :type seed: int_scalars

   :returns: The array of random numbers
   :rtype: pdarray

   :raises TypeError: Raised if size is not an int
   :raises ValueError: Raised if size < 0

   .. seealso:: :py:obj:`randint`

   .. rubric:: Notes

   For random samples from :math:`N(\mu, \sigma^2)`, use:

   ``(sigma * standard_normal(size)) + mu``

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.standard_normal(3,1)
   array([-0.68586185091150265 1.1723810583573377 0.567584107142031])


.. py:function:: uniform(size: arkouda.numpy.dtypes.int_scalars, low: arkouda.numpy.dtypes.numeric_scalars = float(0.0), high: arkouda.numpy.dtypes.numeric_scalars = 1.0, seed: Union[None, arkouda.numpy.dtypes.int_scalars] = None) -> arkouda.numpy.pdarrayclass.pdarray

   Generate a pdarray with uniformly distributed random float values
   in a specified range.

   :param low: The low value (inclusive) of the range, defaults to 0.0
   :type low: float_scalars
   :param high: The high value (inclusive) of the range, defaults to 1.0
   :type high: float_scalars
   :param size: The length of the returned array
   :type size: int_scalars
   :param seed: Value used to initialize the random number generator
   :type seed: int_scalars, optional

   :returns: Values drawn uniformly from the specified range
   :rtype: pdarray

   :raises TypeError: Raised if dtype.name not in DTypes, size is not an int, or if
       either low or high is not an int or float
   :raises ValueError: Raised if size < 0 or if high < low

   .. rubric:: Notes

   The logic for uniform is delegated to the ak.randint method which
   is invoked with a dtype of float64

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.uniform(3,seed=1701)
   array([0.011410423448327005 0.73618171558685619 0.12367222192448891])

   >>> ak.uniform(size=3,low=0,high=5,seed=0)
   array([0.30013431967121934 0.47383036230759112 1.0441791878997098])


.. py:function:: zeros(size: Union[arkouda.numpy.dtypes.int_scalars, Tuple[arkouda.numpy.dtypes.int_scalars, Ellipsis], str], dtype: Union[numpy.dtype, type, str, arkouda.numpy.dtypes.bigint] = float64, max_bits: Optional[int] = None) -> arkouda.numpy.pdarrayclass.pdarray

   Create a pdarray filled with zeros.

   :param size: Size or shape of the array
   :type size: int_scalars or tuple of int_scalars
   :param dtype: Type of resulting array, default ak.float64
   :type dtype: all_scalars
   :param max_bits: Specifies the maximum number of bits; only used for bigint pdarrays
                    Included for consistency, as zeros are represented as all zeros, regardless
                    of the value of max_bits
   :type max_bits: int

   :returns: Zeros of the requested size or shape and dtype
   :rtype: pdarray

   :raises TypeError: Raised if the supplied dtype is not supported
   :raises RuntimeError: Raised if the size parameter is neither an int nor a str that is parseable to an int.
   :raises ValueError: Raised if the rank of the given shape is not in get_array_ranks() or is empty
       Raised if max_bits is not NONE and ndim does not equal 1

   .. seealso:: :py:obj:`ones`, :py:obj:`zeros_like`

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.zeros(5, dtype=ak.int64)
   array([0 0 0 0 0])

   >>> ak.zeros(5, dtype=ak.float64)
   array([0.00000000000000000 0.00000000000000000 0.00000000000000000
          0.00000000000000000 0.00000000000000000])

   >>> ak.zeros(5, dtype=ak.bool_)
   array([False False False False False])


.. py:function:: zeros_like(pda: arkouda.numpy.pdarrayclass.pdarray) -> arkouda.numpy.pdarrayclass.pdarray

   Create a zero-filled pdarray of the same size and dtype as an existing
   pdarray.

   :param pda: Array to use for size and dtype
   :type pda: pdarray

   :returns: Equivalent to ak.zeros(pda.size, pda.dtype)
   :rtype: pdarray

   :raises TypeError: Raised if the pda parameter is not a pdarray.

   .. seealso:: :py:obj:`zeros`, :py:obj:`ones_like`

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.zeros_like(ak.ones(5,dtype=ak.int64))
   array([0 0 0 0 0])

   >>> ak.zeros_like(ak.ones(5,dtype=ak.float64))
   array([0.00000000000000000 0.00000000000000000 0.00000000000000000
          0.00000000000000000 0.00000000000000000])

   >>> ak.zeros_like(ak.ones(5,dtype=ak.bool_))
   array([False False False False False])


