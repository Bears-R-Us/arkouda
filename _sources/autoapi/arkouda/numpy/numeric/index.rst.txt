arkouda.numpy.numeric
=====================

.. py:module:: arkouda.numpy.numeric


Classes
-------

.. autoapisummary::

   arkouda.numpy.numeric.ErrorMode


Functions
---------

.. autoapisummary::

   arkouda.numpy.numeric.abs
   arkouda.numpy.numeric.arccos
   arkouda.numpy.numeric.arccosh
   arkouda.numpy.numeric.arcsin
   arkouda.numpy.numeric.arcsinh
   arkouda.numpy.numeric.arctan
   arkouda.numpy.numeric.arctan2
   arkouda.numpy.numeric.arctanh
   arkouda.numpy.numeric.array_equal
   arkouda.numpy.numeric.cast
   arkouda.numpy.numeric.ceil
   arkouda.numpy.numeric.clip
   arkouda.numpy.numeric.cos
   arkouda.numpy.numeric.cosh
   arkouda.numpy.numeric.count_nonzero
   arkouda.numpy.numeric.cumprod
   arkouda.numpy.numeric.cumsum
   arkouda.numpy.numeric.deg2rad
   arkouda.numpy.numeric.exp
   arkouda.numpy.numeric.expm1
   arkouda.numpy.numeric.eye
   arkouda.numpy.numeric.floor
   arkouda.numpy.numeric.hash
   arkouda.numpy.numeric.histogram
   arkouda.numpy.numeric.histogram2d
   arkouda.numpy.numeric.histogramdd
   arkouda.numpy.numeric.isfinite
   arkouda.numpy.numeric.isinf
   arkouda.numpy.numeric.isnan
   arkouda.numpy.numeric.log
   arkouda.numpy.numeric.log10
   arkouda.numpy.numeric.log1p
   arkouda.numpy.numeric.log2
   arkouda.numpy.numeric.matmul
   arkouda.numpy.numeric.median
   arkouda.numpy.numeric.nextafter
   arkouda.numpy.numeric.percentile
   arkouda.numpy.numeric.putmask
   arkouda.numpy.numeric.quantile
   arkouda.numpy.numeric.rad2deg
   arkouda.numpy.numeric.round
   arkouda.numpy.numeric.sign
   arkouda.numpy.numeric.sin
   arkouda.numpy.numeric.sinh
   arkouda.numpy.numeric.square
   arkouda.numpy.numeric.take
   arkouda.numpy.numeric.tan
   arkouda.numpy.numeric.tanh
   arkouda.numpy.numeric.transpose
   arkouda.numpy.numeric.tril
   arkouda.numpy.numeric.triu
   arkouda.numpy.numeric.trunc
   arkouda.numpy.numeric.value_counts
   arkouda.numpy.numeric.vecdot
   arkouda.numpy.numeric.where


Module Contents
---------------

.. py:class:: ErrorMode(*args, **kwds)

   Bases: :py:obj:`enum.Enum`


   Create a collection of name/value pairs.

   Example enumeration:

   >>> class Color(Enum):
   ...     RED = 1
   ...     BLUE = 2
   ...     GREEN = 3

   Access them by:

   - attribute access:

     >>> Color.RED
     <Color.RED: 1>

   - value lookup:

     >>> Color(1)
     <Color.RED: 1>

   - name lookup:

     >>> Color['RED']
     <Color.RED: 1>

   Enumerations can be iterated over, and know how many members they have:

   >>> len(Color)
   3

   >>> list(Color)
   [<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]

   Methods can be added to enumerations, and members can have their own
   attributes -- see the documentation for details.


   .. py:attribute:: ignore
      :value: 'ignore'



   .. py:attribute:: return_validity
      :value: 'return_validity'



   .. py:attribute:: strict
      :value: 'strict'



.. py:function:: abs(pda: arkouda.numpy.pdarrayclass.pdarray) -> arkouda.numpy.pdarrayclass.pdarray

   Return the element-wise absolute value of the array.

   :param pda:
   :type pda: pdarray

   :returns: A pdarray containing absolute values of the input array elements
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.abs(ak.arange(-5,-1))
   array([5 4 3 2])

   >>> ak.abs(ak.linspace(-5,-1,5))
   array([5.00000000000000000 4.00000000000000000 3.00000000000000000
   2.00000000000000000 1.00000000000000000])


.. py:function:: arccos(pda: arkouda.numpy.pdarrayclass.pdarray, where: Union[bool, arkouda.numpy.pdarrayclass.pdarray] = True) -> arkouda.numpy.pdarrayclass.pdarray

   Return the element-wise inverse cosine of the array. The result is between 0 and pi.

   :param pda:
   :type pda: pdarray
   :param where: This condition is broadcast over the input. At locations where the condition is True,
                 the inverse cosine will be applied to the corresponding value. Elsewhere, it will retain
                 its original value. Default set to True.
   :type where: bool or pdarray, default=True

   :returns: A pdarray containing inverse cosine for each element
             of the original pdarray
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.linspace(-0.7,0.5,4)
   >>> ak.arccos(a)
   array([2.3461938234056494 1.8754889808102941 1.4706289056333368 1.0471975511965979])


.. py:function:: arccosh(pda: arkouda.numpy.pdarrayclass.pdarray, where: Union[bool, arkouda.numpy.pdarrayclass.pdarray] = True) -> arkouda.numpy.pdarrayclass.pdarray

   Return the element-wise inverse hyperbolic cosine of the array.

   :param pda:
   :type pda: pdarray
   :param where: This condition is broadcast over the input. At locations where the condition is True,
                 the inverse hyperbolic cosine will be applied to the corresponding value. Elsewhere, it will
                 retain its original value. Default set to True.
   :type where: bool or pdarray, default=True

   :returns: A pdarray containing inverse hyperbolic cosine for each element
             of the original pdarray
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.linspace(1,500,4)
   >>> ak.arccosh(a)
   array([0.00000000000000000 5.8131260830342795 6.5032874256927515 6.9077542789806374])


.. py:function:: arcsin(pda: arkouda.numpy.pdarrayclass.pdarray, where: Union[bool, arkouda.numpy.pdarrayclass.pdarray] = True) -> arkouda.numpy.pdarrayclass.pdarray

   Return the element-wise inverse sine of the array. The result is between -pi/2 and pi/2.

   :param pda:
   :type pda: pdarray
   :param where: This condition is broadcast over the input. At locations where the condition is True,
                 the inverse sine will be applied to the corresponding value. Elsewhere, it will retain
                 its original value. Default set to True.
   :type where: bool or pdarray, default=True

   :returns: A pdarray containing inverse sine for each element
             of the original pdarray
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.linspace(-0.7,0.5,4)
   >>> ak.arcsin(a)
   array([-0.77539749661075297 -0.30469265401539752 0.10016742116155977 0.52359877559829893])


.. py:function:: arcsinh(pda: arkouda.numpy.pdarrayclass.pdarray, where: Union[bool, arkouda.numpy.pdarrayclass.pdarray] = True) -> arkouda.numpy.pdarrayclass.pdarray

   Return the element-wise inverse hyperbolic sine of the array.

   :param pda:
   :type pda: pdarray
   :param where: This condition is broadcast over the input. At locations where the condition is True,
                 the inverse hyperbolic sine will be applied to the corresponding value. Elsewhere, it will retain
                 its original value. Default set to True.
   :type where: bool or pdarray, default=True

   :returns: A pdarray containing inverse hyperbolic sine for each element
             of the original pdarray
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.linspace(-500,500,4)
   >>> ak.arcsinh(a)
   array([-6.9077562789806368 -5.8091519901925297 5.8091519901925297 6.9077562789806368])


.. py:function:: arctan(pda: arkouda.numpy.pdarrayclass.pdarray, where: Union[bool, arkouda.numpy.pdarrayclass.pdarray] = True) -> arkouda.numpy.pdarrayclass.pdarray

   Return the element-wise inverse tangent of the array. The result is between -pi/2 and pi/2.

   :param pda:
   :type pda: pdarray
   :param where: This condition is broadcast over the input. At locations where the condition is True,
                 the inverse tangent will be applied to the corresponding value. Elsewhere, it will retain
                 its original value. Default set to True.
   :type where: bool or pdarray, default=True

   :returns: A pdarray containing inverse tangent for each element
             of the original pdarray
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.linspace(-10.7,10.5,4)
   >>> ak.arctan(a)
   array([-1.4776090650260174 -1.3022168962760161 1.2873750736468446 1.4758446204521403])


.. py:function:: arctan2(num: Union[arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.dtypes.numeric_scalars], denom: Union[arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.dtypes.numeric_scalars], where: Union[bool, arkouda.numpy.pdarrayclass.pdarray] = True) -> arkouda.numpy.pdarrayclass.pdarray

   Return the element-wise inverse tangent of the array pair. The result chosen is the
   signed angle in radians between the ray ending at the origin and passing through the
   point (1,0), and the ray ending at the origin and passing through the point (denom, num).
   The result is between -pi and pi.

   :param num: Numerator of the arctan2 argument.
   :type num: pdarray or numeric_scalars
   :param denom: Denominator of the arctan2 argument.
   :type denom: pdarray or numeric_scalars
   :param where: This condition is broadcast over the input. At locations where the condition is True,
                 the inverse tangent will be applied to the corresponding values. Elsewhere, it will retain
                 its original value. Default set to True.
   :type where: bool or pdarray, default=True

   :returns: A pdarray containing inverse tangent for each corresponding element pair
             of the original pdarray, using the signed values or the numerator and
             denominator to get proper placement on unit circle.
   :rtype: pdarray

   :raises TypeError: | Raised if any parameter fails the typechecking
       | Raised if any element of pdarrays num and denom is not a supported type
       | Raised if both num and denom are scalars
       | Raised if where is neither boolean nor a pdarray of boolean

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> x = ak.array([1,-1,-1,1])
   >>> y = ak.array([1,1,-1,-1])
   >>> ak.arctan2(y,x)
   array([0.78539816339744828 2.3561944901923448 -2.3561944901923448 -0.78539816339744828])


.. py:function:: arctanh(pda: arkouda.numpy.pdarrayclass.pdarray, where: Union[bool, arkouda.numpy.pdarrayclass.pdarray] = True) -> arkouda.numpy.pdarrayclass.pdarray

   Return the element-wise inverse hyperbolic tangent of the array.

   :param pda:
   :type pda: pdarray
   :param where: This condition is broadcast over the input. At locations where the condition is True,
                 the inverse hyperbolic tangent will be applied to the corresponding value. Elsewhere,
                 it will retain its original value. Default set to True.
   :type where: bool or pdarray, default=True

   :returns: A pdarray containing inverse hyperbolic tangent for each element
             of the original pdarray
   :rtype: pdarray

   :raises TypeError: Raised if the parameters are not a pdarray or numeric scalar.

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.linspace(-.999,.999,4)
   >>> ak.arctanh(a)
   array([-3.8002011672501994 -0.34619863713154242 0.34619863713154253 3.8002011672501994])


.. py:function:: array_equal(pda_a: arkouda.numpy.pdarrayclass.pdarray, pda_b: arkouda.numpy.pdarrayclass.pdarray, equal_nan: bool = False) -> bool

   Compares two pdarrays for equality.
   If neither array has any nan elements, then if all elements are pairwise equal,
   it returns True.
   If equal_Nan is False, then any nan element in either array gives a False return.
   If equal_Nan is True, then pairwise-corresponding nans are considered equal.

   :param pda_a:
   :type pda_a: pdarray
   :param pda_b:
   :type pda_b: pdarray
   :param equal_nan: Determines how to handle nans
   :type equal_nan: bool, default=False

   :returns:

             With string data:
                False if one array is type ak.str_ & the other isn't, True if both are ak.str_ & they match.

             With numeric data:
                True if neither array has any nan elements, and all elements pairwise equal.

                True if equal_Nan True, all non-nans pairwise equal & nans in pda_a correspond to nans in pda_b

                False if equal_Nan False, & either array has any nan element.
   :rtype: boolean

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.randint(0,10,10,dtype=ak.float64)
   >>> b = a
   >>> ak.array_equal(a,b)
   True
   >>> b[9] = np.nan
   >>> ak.array_equal(a,b)
   False
   >>> a[9] = np.nan
   >>> ak.array_equal(a,b)
   False
   >>> ak.array_equal(a,b,True)
   True


.. py:function:: cast(pda: Union[arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.strings.Strings, arkouda.categorical.Categorical], dt: Union[numpy.dtype, type, str, arkouda.numpy.dtypes.bigint], errors: ErrorMode = ErrorMode.strict) -> Union[Union[arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.strings.Strings, arkouda.categorical.Categorical], Tuple[arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.pdarrayclass.pdarray]]

   Cast an array to another dtype.

   :param pda: The array of values to cast
   :type pda: pdarray, Strings, or Categorical
   :param dt: The target dtype to cast values to
   :type dt: np.dtype, type, str, or bigint
   :param errors: Controls how errors are handled when casting strings to a numeric type
                  (ignored for casts from numeric types).
                      - strict: raise RuntimeError if *any* string cannot be converted
                      - ignore: never raise an error. Uninterpretable strings get
                          converted to NaN (float64), -2**63 (int64), zero (uint64 and
                          uint8), or False (bool)
                      - return_validity: in addition to returning the same output as
                        "ignore", also return a bool array indicating where the cast
                        was successful.
                  Default set to strict.
   :type errors: {strict, ignore, return_validity}, default=ErrorMode.strict

   :returns:

             pdarray or Strings
                 Array of values cast to desired dtype
             [validity : pdarray(bool)]
                 If errors="return_validity" and input is Strings, a second array is
                 returned with True where the cast succeeded and False where it failed.
   :rtype: Union[Union[pdarray, Strings, Categorical], Tuple[pdarray, pdarray]]

   .. rubric:: Notes

   The cast is performed according to Chapel's casting rules and is NOT safe
   from overflows or underflows. The user must ensure that the target dtype
   has the precision and capacity to hold the desired result.

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.cast(ak.linspace(1.0,5.0,5), dt=ak.int64)
   array([1 2 3 4 5])

   >>> ak.cast(ak.arange(0,5), dt=ak.float64).dtype
   dtype('float64')

   >>> ak.cast(ak.arange(0,5), dt=ak.bool_)
   array([False True True True True])

   >>> ak.cast(ak.linspace(0,4,5), dt=ak.bool_)
   array([False True True True True])


.. py:function:: ceil(pda: arkouda.numpy.pdarrayclass.pdarray) -> arkouda.numpy.pdarrayclass.pdarray

   Return the element-wise ceiling of the array.

   :param pda:
   :type pda: pdarray

   :returns: A pdarray containing ceiling values of the input array elements
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.ceil(ak.linspace(1.1,5.5,5))
   array([2.00000000000000000 3.00000000000000000 4.00000000000000000
   5.00000000000000000 6.00000000000000000])


.. py:function:: clip(pda: arkouda.numpy.pdarrayclass.pdarray, lo: Union[arkouda.numpy.dtypes.numeric_scalars, arkouda.numpy.pdarrayclass.pdarray], hi: Union[arkouda.numpy.dtypes.numeric_scalars, arkouda.numpy.pdarrayclass.pdarray]) -> arkouda.numpy.pdarrayclass.pdarray

   Clip (limit) the values in an array to a given range [lo,hi]

   Given an array a, values outside the range are clipped to the
   range edges, such that all elements lie in the range.

   There is no check to enforce that lo < hi.  If lo > hi, the corresponding
   value of the array will be set to hi.

   If lo or hi (or both) are pdarrays, the check is by pairwise elements.
   See examples.

   :param pda: the array of values to clip
   :type pda: pdarray
   :param lo: the lower value of the clipping range
   :type lo: numeric_scalars or pdarray
   :param hi: the higher value of the clipping range
              If lo or hi (or both) are pdarrays, the check is by pairwise elements.
              See examples.
   :type hi: numeric_scalars or pdarray

   :returns:

             A pdarray matching pda, except that element x remains x if lo <= x <= hi,
                                                     or becomes lo if x < lo,
                                                     or becomes hi if x > hi.
   :rtype: pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.array([1,2,3,4,5,6,7,8,9,10])
   >>> ak.clip(a,3,8)
   array([3 3 3 4 5 6 7 8 8 8])
   >>> ak.clip(a,3,8.0)
   array([3.00000000000000000 3.00000000000000000 3.00000000000000000 4.00000000000000000
          5.00000000000000000 6.00000000000000000 7.00000000000000000 8.00000000000000000
          8.00000000000000000 8.00000000000000000])
   >>> ak.clip(a,None,7)
   array([1 2 3 4 5 6 7 7 7 7])
   >>> ak.clip(a,5,None)
   array([5 5 5 5 5 6 7 8 9 10])
   >>> ak.clip(a,None,None) # doctest: +SKIP
   ValueError: Either min or max must be supplied.
   >>> ak.clip(a,ak.array([2,2,3,3,8,8,5,5,6,6]),8)
   array([2 2 3 4 8 8 7 8 8 8])
   >>> ak.clip(a,4,ak.array([10,9,8,7,6,5,5,5,5,5]))
   array([4 4 4 4 5 5 5 5 5 5])

   .. rubric:: Notes

   Either lo or hi may be None, but not both.
   If lo > hi, all x = hi.
   If all inputs are int64, output is int64, but if any input is float64, output is float64.

   :raises ValueError: Raised if both lo and hi are None


.. py:function:: cos(pda: arkouda.numpy.pdarrayclass.pdarray, where: Union[bool, arkouda.numpy.pdarrayclass.pdarray] = True) -> arkouda.numpy.pdarrayclass.pdarray

   Return the element-wise cosine of the array.

   :param pda:
   :type pda: pdarray
   :param where: This condition is broadcast over the input. At locations where the condition is True,
                 the cosine will be applied to the corresponding value. Elsewhere, it will retain
                 its original value. Default set to True.
   :type where: bool or pdarray, default=True

   :returns: A pdarray containing cosine for each element
             of the original pdarray
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.linspace(-1.5,0.75,4)
   >>> ak.cos(a)
   array([0.070737201667702906 0.7316888688738209 1.00000000000000000 0.7316888688738209])


.. py:function:: cosh(pda: arkouda.numpy.pdarrayclass.pdarray, where: Union[bool, arkouda.numpy.pdarrayclass.pdarray] = True) -> arkouda.numpy.pdarrayclass.pdarray

   Return the element-wise hyperbolic cosine of the array.

   :param pda:
   :type pda: pdarray
   :param where: This condition is broadcast over the input. At locations where the condition is True,
                 the hyperbolic cosine will be applied to the corresponding value. Elsewhere, it will retain
                 its original value. Default set to True.
   :type where: bool or pdarray, default=True

   :returns: A pdarray containing hyperbolic cosine for each element
             of the original pdarray
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.linspace(-0.9,0.7,4)
   >>> ak.cosh(a)
   array([1.4330863854487745 1.0679787433708894 1.0139210688781299 1.255169005630943])


.. py:function:: count_nonzero(pda: arkouda.numpy.pdarrayclass.pdarray) -> numpy.int64

   Compute the nonzero count of a given array. 1D case only, for now.

   :param pda: The input data, in pdarray form, numeric, bool, or str
   :type pda: pdarray

   :returns: The nonzero count of the entire pdarray
   :rtype: np.int64

   :raises TypeError: Raised if the parameter is not a pdarray with numeric, bool, or str datatype
   :raises ValueError: Raised if sum applied to the pdarray doesn't come back with a scalar

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> pda = ak.array([0,4,7,8,1,3,5,2,-1])
   >>> ak.count_nonzero(pda)
   np.int64(8)
   >>> pda = ak.array([False,True,False,True,False])
   >>> ak.count_nonzero(pda)
   np.int64(2)
   >>> pda = ak.array(["hello","","there"])
   >>> ak.count_nonzero(pda)
   np.int64(2)


.. py:function:: cumprod(pda: arkouda.numpy.pdarrayclass.pdarray) -> arkouda.numpy.pdarrayclass.pdarray

   Return the cumulative product over the array.

   The product is inclusive, such that the ``i`` th element of the
   result is the product of elements up to and including ``i``.

   :param pda:
   :type pda: pdarray

   :returns: A pdarray containing cumulative products for each element
             of the original pdarray
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.cumprod(ak.arange(1,5))
   array([1 2 6 24])

   >>> ak.cumprod(ak.uniform(5,1.0,5.0, seed=1))
   array([4.1485937992669886 5.5470437965703221 22.201091353048209
       79.702126856955317 298.26551591732482])


.. py:function:: cumsum(pda: arkouda.numpy.pdarrayclass.pdarray) -> arkouda.numpy.pdarrayclass.pdarray

   Return the cumulative sum over the array.

   The sum is inclusive, such that the ``i`` th element of the
   result is the sum of elements up to and including ``i``.

   :param pda:
   :type pda: pdarray

   :returns: A pdarray containing cumulative sums for each element
             of the original pdarray
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.cumsum(ak.arange(1,5))
   array([1 3 6 10])

   >>> ak.cumsum(ak.uniform(5,1.0,5.0, seed=1))
   array([4.1485937992669886 5.4856839230459 9.4880124005630435 13.078021809988414 16.820274716898091])

   >>> ak.cumsum(ak.randint(0, 1, 5, dtype=ak.bool_, seed=1))
   array([1 1 2 3 4])


.. py:function:: deg2rad(pda: arkouda.numpy.pdarrayclass.pdarray, where: Union[bool, arkouda.numpy.pdarrayclass.pdarray] = True) -> arkouda.numpy.pdarrayclass.pdarray

   Converts angles element-wise from degrees to radians.

   :param pda:
   :type pda: pdarray
   :param where: This condition is broadcast over the input. At locations where the condition is True, the
                 corresponding value will be converted from degrees to radians. Elsewhere, it will retain its
                 original value. Default set to True.
   :type where: bool or pdarray, default=True

   :returns: A pdarray containing an angle converted to radians, from degrees, for each element
             of the original pdarray
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.linspace(0,359,4)
   >>> ak.deg2rad(a)
   array([0.00000000000000000 2.0885773382198809 4.1771546764397618 6.2657320146596422])


.. py:function:: exp(pda: arkouda.numpy.pdarrayclass.pdarray) -> arkouda.numpy.pdarrayclass.pdarray

   Return the element-wise exponential of the array.

   :param pda:
   :type pda: pdarray

   :returns: A pdarray containing exponential values of the input
             array elements
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.exp(ak.arange(1,5))
   array([2.7182818284590451 7.3890560989306504 20.085536923187668 54.598150033144236])

   >>> ak.exp(ak.uniform(4, 1.0, 5.0, seed=1))
   array([63.344862048230922 3.8079467144568273 54.725428723251447 36.234416869913829])


.. py:function:: expm1(pda: arkouda.numpy.pdarrayclass.pdarray) -> arkouda.numpy.pdarrayclass.pdarray

   Return the element-wise exponential of the array minus one.

   :param pda:
   :type pda: pdarray

   :returns: A pdarray containing e raised to each of the inputs,
             then subtracting one.
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.expm1(ak.arange(1,5))
   array([1.7182818284590451 6.3890560989306504 19.085536923187668 53.598150033144236])

   >>> ak.expm1(ak.uniform(5,1.0,5.0, seed=1))
   array([62.344862048230922 2.8079467144568273 53.725428723251447
       35.234416869913829 41.192939934258227])


.. py:function:: eye(rows: arkouda.numpy.dtypes.int_scalars, cols: arkouda.numpy.dtypes.int_scalars, diag: arkouda.numpy.dtypes.int_scalars = 0, dt: type = ak_float64) -> arkouda.numpy.pdarrayclass.pdarray

   Return a pdarray with zeros everywhere except along a diagonal, which is all ones.
   The matrix need not be square.

   :param rows:
   :type rows: int_scalars
   :param cols:
   :type cols: int_scalars
   :param diag: | if diag = 0, zeros start at element [0,0] and proceed along diagonal
                | if diag > 0, zeros start at element [0,diag] and proceed along diagonal
                | if diag < 0, zeros start at element [diag,0] and proceed along diagonal
                | etc. Default set to 0.
   :type diag: int_scalars, default=0
   :param dt: The data type of the elements in the matrix being returned. Default set to ak_int64
   :type dt: type, default=ak_int64

   :returns: an array of zeros with ones along the specified diagonal
   :rtype: pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.eye(rows=4,cols=4,diag=0,dt=ak.int64)
   array([array([1 0 0 0]) array([0 1 0 0]) array([0 0 1 0]) array([0 0 0 1])])
   >>> ak.eye(rows=3,cols=3,diag=1,dt=ak.float64)
   array([array([0.00000000000000000 1.00000000000000000 0.00000000000000000])
   array([0.00000000000000000 0.00000000000000000 1.00000000000000000])
   array([0.00000000000000000 0.00000000000000000 0.00000000000000000])])
   >>> ak.eye(rows=4,cols=4,diag=-1,dt=ak.bool_)
   array([array([False False False False]) array([True False False False])
   array([False True False False]) array([False False True False])])

   .. rubric:: Notes

   if rows = cols and diag = 0, the result is an identity matrix
   Server returns an error if rank of pda < 2


.. py:function:: floor(pda: arkouda.numpy.pdarrayclass.pdarray) -> arkouda.numpy.pdarrayclass.pdarray

   Return the element-wise floor of the array.

   :param pda:
   :type pda: pdarray

   :returns: A pdarray containing floor values of the input array elements
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.floor(ak.linspace(1.1,5.5,5))
   array([1.00000000000000000 2.00000000000000000 3.00000000000000000
   4.00000000000000000 5.00000000000000000])


.. py:function:: hash(pda: Union[Union[arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.strings.Strings, arkouda.numpy.segarray.SegArray, arkouda.categorical.Categorical], List[Union[arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.strings.Strings, arkouda.numpy.segarray.SegArray, arkouda.categorical.Categorical]]], full: bool = True) -> Union[Tuple[arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.pdarrayclass.pdarray], arkouda.numpy.pdarrayclass.pdarray]

   Return an element-wise hash of the array or list of arrays.

   :param pda:
   :type pda: pdarray, Strings, SegArray, or Categorical     or List of pdarray, Strings, SegArray, or Categorical
   :param full: This is only used when a single pdarray is passed into hash
                By default, a 128-bit hash is computed and returned as
                two int64 arrays. If full=False, then a 64-bit hash
                is computed and returned as a single int64 array.
   :type full: bool, default=True

   :returns: If full=True or a list of pdarrays is passed,
             a 2-tuple of pdarrays containing the high
             and low 64 bits of each hash, respectively.
             If full=False and a single pdarray is passed,
             a single pdarray containing a 64-bit hash
   :rtype: hashes

   :raises TypeError: Raised if the parameter is not a pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.randint(0,65536,3,seed=8675309)
   >>> ak.hash(a,full=False)
   array([6132219720275344925 189443193828113335 14797568559700425150])
   >>> ak.hash(a)
   (array([12228890592923494910 17773622519799422780 16661993598191972647]),
       array([2936052102410048944 15730675498625067356 4746877828134486787]))

   .. rubric:: Notes

   In the case of a single pdarray being passed, this function
   uses the SIPhash algorithm, which can output either a 64-bit
   or 128-bit hash. However, the 64-bit hash runs a significant
   risk of collisions when applied to more than a few million
   unique values. Unless the number of unique values is known to
   be small, the 128-bit hash is strongly recommended.

   Note that this hash should not be used for security, or for
   any cryptographic application. Not only is SIPhash not
   intended for such uses, but this implementation employs a
   fixed key for the hash, which makes it possible for an
   adversary with control over input to engineer collisions.

   In the case of a list of pdrrays, Strings, Categoricals, or Segarrays
   being passed, a non-linear function must be applied to each
   array since hashes of subsequent arrays cannot be simply XORed
   because equivalent values will cancel each other out, hence we
   do a rotation by the ordinal of the array.


.. py:function:: histogram(pda: arkouda.numpy.pdarrayclass.pdarray, bins: arkouda.numpy.dtypes.int_scalars = 10, range: Optional[Tuple[arkouda.numpy.dtypes.numeric_scalars, arkouda.numpy.dtypes.numeric_scalars]] = None) -> Tuple[arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.pdarrayclass.pdarray]

   Compute a histogram of evenly spaced bins over the range of an array.

   :param pda: The values to histogram
   :type pda: pdarray
   :param bins: The number of equal-size bins to use (default: 10)
   :type bins: int_scalars, default=10
   :param range: The range of the values to count.
                 Values outside of this range are dropped.
                 By default, all values are counted.
   :type range: (minVal, maxVal), optional

   :returns: The number of values present in each bin and the bin edges
   :rtype: (pdarray, Union[pdarray, int64 or float64])

   :raises TypeError: Raised if the parameter is not a pdarray or if bins is
       not an int.
   :raises ValueError: Raised if bins < 1
   :raises NotImplementedError: Raised if pdarray dtype is bool or uint8

   .. seealso:: :py:obj:`value_counts`, :py:obj:`histogram2d`

   .. rubric:: Notes

   The bins are evenly spaced in the interval [pda.min(), pda.max()].
   If range parameter is provided, the interval is [range[0], range[1]].

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> import matplotlib.pyplot as plt
   >>> A = ak.arange(0, 10, 1)
   >>> nbins = 3
   >>> h, b = ak.histogram(A, bins=nbins)
   >>> h
   array([3 3 4])
   >>> b
   array([0.00000000000000000 3.00000000000000000 6.00000000000000000 9.00000000000000000])

   To plot, export the left edges and the histogram to NumPy
   >>> b_np = b.to_ndarray()
   >>> import numpy as np
   >>> b_widths = np.diff(b_np)
   >>> plt.bar(b_np[:-1], h.to_ndarray(), width=b_widths, align='edge', edgecolor='black')
   <BarContainer object of 3 artists>
   >>> plt.show() # doctest: +SKIP


.. py:function:: histogram2d(x: arkouda.numpy.pdarrayclass.pdarray, y: arkouda.numpy.pdarrayclass.pdarray, bins: Union[arkouda.numpy.dtypes.int_scalars, Sequence[arkouda.numpy.dtypes.int_scalars]] = 10, range: Optional[Tuple[Tuple[arkouda.numpy.dtypes.numeric_scalars, arkouda.numpy.dtypes.numeric_scalars], Tuple[arkouda.numpy.dtypes.numeric_scalars, arkouda.numpy.dtypes.numeric_scalars]]] = None) -> Tuple[arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.pdarrayclass.pdarray]

   Compute the bi-dimensional histogram of two data samples with evenly spaced bins

   :param x: A pdarray containing the x coordinates of the points to be histogrammed.
   :type x: pdarray
   :param y: A pdarray containing the y coordinates of the points to be histogrammed.
   :type y: pdarray
   :param bins: The number of equal-size bins to use.
                If int, the number of bins for the two dimensions (nx=ny=bins).
                If [int, int], the number of bins in each dimension (nx, ny = bins).
                Defaults to 10
   :type bins: int_scalars or [int, int], default=10
   :param range: The ranges of the values in x and y to count.
                 Values outside of these ranges are dropped.
                 By default, all values are counted.
   :type range: ((xMin, xMax), (yMin, yMax)), optional

   :returns:

             hist : pdarray
                 shape(nx, ny)
                 The bi-dimensional histogram of samples x and y.
                 Values in x are histogrammed along the first dimension and
                 values in y are histogrammed along the second dimension.

             x_edges : pdarray
                 The bin edges along the first dimension.

             y_edges : pdarray
                 The bin edges along the second dimension.
   :rtype: Tuple[pdarray, pdarray, pdarray]

   :raises TypeError: Raised if x or y parameters are not pdarrays or if bins is
       not an int or (int, int).
   :raises ValueError: Raised if bins < 1
   :raises NotImplementedError: Raised if pdarray dtype is bool or uint8

   .. seealso:: :py:obj:`histogram`

   .. rubric:: Notes

   The x bins are evenly spaced in the interval [x.min(), x.max()]
   and y bins are evenly spaced in the interval [y.min(), y.max()].
   If range parameter is provided, the intervals are given
   by range[0] for x and range[1] for y..

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> x = ak.arange(0, 10, 1)
   >>> y = ak.arange(9, -1, -1)
   >>> nbins = 3
   >>> h, x_edges, y_edges = ak.histogram2d(x, y, bins=nbins)
   >>> h
   array([array([0.00000000000000000 0.00000000000000000 3.00000000000000000])
          array([0.00000000000000000 2.00000000000000000 1.00000000000000000])
          array([3.00000000000000000 1.00000000000000000 0.00000000000000000])])
   >>> x_edges
   array([0.00000000000000000 3.00000000000000000 6.00000000000000000 9.00000000000000000])
   >>> y_edges
   array([0.00000000000000000 3.00000000000000000 6.00000000000000000 9.00000000000000000])


.. py:function:: histogramdd(sample: Sequence[arkouda.numpy.pdarrayclass.pdarray], bins: Union[arkouda.numpy.dtypes.int_scalars, Sequence[arkouda.numpy.dtypes.int_scalars]] = 10, range: Optional[Sequence[Optional[Tuple[arkouda.numpy.dtypes.numeric_scalars, arkouda.numpy.dtypes.numeric_scalars]]]] = None) -> Tuple[arkouda.numpy.pdarrayclass.pdarray, Sequence[arkouda.numpy.pdarrayclass.pdarray]]

   Compute the multidimensional histogram of data in sample with evenly spaced bins.

   :param sample: A sequence of pdarrays containing the coordinates of the points to be histogrammed.
   :type sample: Sequence of pdarray
   :param bins: The number of equal-size bins to use.
                If int, the number of bins for all dimensions (nx=ny=...=bins).
                If [int, int, ...], the number of bins in each dimension (nx, ny, ... = bins).
                Defaults to 10
   :type bins: int_scalars or Sequence of int_scalars, default=10
   :param range: The ranges of the values to count for each array in sample.
                 Values outside of these ranges are dropped.
                 By default, all values are counted.
   :type range: Sequence[optional (minVal, maxVal)], optional

   :returns:

             hist : pdarray
                 shape(nx, ny, ..., nd)
                 The multidimensional histogram of pdarrays in sample.
                 Values in first pdarray are histogrammed along the first dimension.
                 Values in second pdarray are histogrammed along the second dimension and so on.

             edges : List[pdarray]
                 A list of pdarrays containing the bin edges for each dimension.
   :rtype: Tuple[pdarray, Sequence[pdarray]]

   :raises ValueError: Raised if bins < 1
   :raises NotImplementedError: Raised if pdarray dtype is bool or uint8

   .. seealso:: :py:obj:`histogram`

   .. rubric:: Notes

   The bins for each dimension, m, are evenly spaced in the interval [m.min(), m.max()]
   or in the inverval determined by range[dimension], if provided.

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> x = ak.arange(0, 10, 1)
   >>> y = ak.arange(9, -1, -1)
   >>> z = ak.where(x % 2 == 0, x, y)
   >>> h, edges = ak.histogramdd((x, y,z), bins=(2,2,3))
   >>> h
   array([array([array([0.00000000000000000 0.00000000000000000 0.00000000000000000])
       array([2.00000000000000000 1.00000000000000000 2.00000000000000000])])
       array([array([2.00000000000000000 1.00000000000000000 2.00000000000000000])
       array([0.00000000000000000 0.00000000000000000 0.00000000000000000])])])
   >>> edges
   [array([0.00000000000000000 4.5 9.00000000000000000]),
       array([0.00000000000000000 4.5 9.00000000000000000]),
       array([0.00000000000000000 2.6666666666666665 5.333333333333333 8.00000000000000000])]


.. py:function:: isfinite(pda: arkouda.numpy.pdarrayclass.pdarray) -> arkouda.numpy.pdarrayclass.pdarray

   Return the element-wise isfinite check applied to the array.

   :param pda:
   :type pda: pdarray

   :returns: A pdarray containing boolean values indicating whether the
             input array elements are finite
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray
   :raises RuntimeError: if the underlying pdarray is not float-based

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.isfinite(ak.array([1.0, 2.0, ak.inf]))
   array([True True False])


.. py:function:: isinf(pda: arkouda.numpy.pdarrayclass.pdarray) -> arkouda.numpy.pdarrayclass.pdarray

   Return the element-wise isinf check applied to the array.

   :param pda:
   :type pda: pdarray

   :returns: A pdarray containing boolean values indicating whether the
             input array elements are infinite (positive or negative)
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray
   :raises RuntimeError: if the underlying pdarray is not float-based

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.isinf(ak.array([1.0, 2.0, ak.inf]))
   array([False False True])


.. py:function:: isnan(pda: arkouda.numpy.pdarrayclass.pdarray) -> arkouda.numpy.pdarrayclass.pdarray

   Return the element-wise isnan check applied to the array.

   :param pda:
   :type pda: pdarray

   :returns: A pdarray containing boolean values indicating whether the
             input array elements are NaN
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray
   :raises RuntimeError: if the underlying pdarray is not float-based

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.isnan(ak.array([1.0, 2.0, np.log(-1)]))
   array([False False True])


.. py:function:: log(pda: arkouda.numpy.pdarrayclass.pdarray) -> arkouda.numpy.pdarrayclass.pdarray

   Return the element-wise natural log of the array.

   :param pda:
   :type pda: pdarray

   :returns: A pdarray containing natural log values of the input
             array elements
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray

   .. rubric:: Notes

   Logarithms with other bases can be computed as follows:

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> A = ak.array([1, 10, 100])

   Natural log
   >>> ak.log(A)
   array([0.00000000000000000 2.3025850929940459 4.6051701859880918])

   Log base 10
   >>> ak.log(A) / np.log(10)
   array([0.00000000000000000 1.00000000000000000 2.00000000000000000])

   Log base 2
   >>> ak.log(A) / np.log(2)
   array([0.00000000000000000 3.3219280948873626 6.6438561897747253])


.. py:function:: log10(pda: arkouda.numpy.pdarrayclass.pdarray) -> arkouda.numpy.pdarrayclass.pdarray

   Return the element-wise base 10 log of the array.

   :param pda: array to compute on
   :type pda: pdarray

   :returns: pdarray containing base 10 log values of the input array elements
   :rtype: pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.arange(1,5)
   >>> ak.log10(a)
   array([0.00000000000000000 0.3010299956639812 0.47712125471966244 0.6020599913279624])


.. py:function:: log1p(pda: arkouda.numpy.pdarrayclass.pdarray) -> arkouda.numpy.pdarrayclass.pdarray

   Return the element-wise natural log of one plus the array.

   :param pda: array to compute on
   :type pda: pdarray

   :returns: pdarray containing natural log values of the input array elements,
             adding one before taking the log
   :rtype: pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.log1p(ak.arange(1,5))
   array([0.69314718055994529 1.0986122886681098 1.3862943611198906 1.6094379124341003])


.. py:function:: log2(pda: arkouda.numpy.pdarrayclass.pdarray) -> arkouda.numpy.pdarrayclass.pdarray

   Return the element-wise base 2 log of the array.

   :param pda: array to compute on
   :type pda: pdarray

   :returns: pdarray containing base 2 log values of the input array elements
   :rtype: pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.arange(1,5)
   >>> ak.log2(a)
   array([0.00000000000000000 1.00000000000000000 1.5849625007211561 2.00000000000000000])


.. py:function:: matmul(pdaLeft: arkouda.numpy.pdarrayclass.pdarray, pdaRight: arkouda.numpy.pdarrayclass.pdarray) -> arkouda.numpy.pdarrayclass.pdarray

   Compute the product of two matrices.

   :param pdaLeft:
   :type pdaLeft: pdarray
   :param pdaRight:
   :type pdaRight: pdarray

   :returns: the matrix product pdaLeft x pdaRight
   :rtype: pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.array([[1,2,3,4,5],[1,2,3,4,5]])
   >>> b = ak.array([[1,1],[2,2],[3,3],[4,4],[5,5]])
   >>> ak.matmul(a,b)
   array([array([55 55]) array([55 55])])

   >>> x = ak.array([[1,2,3],[1.1,2.1,3.1]])
   >>> y = ak.array([[1,1,1],[0,2,2],[0,0,3]])
   >>> ak.matmul(x,y)
   array([array([1.00000000000000000 5.00000000000000000 14.00000000000000000])
   array([1.1000000000000001 5.3000000000000007 14.600000000000001])])

   .. rubric:: Notes

   Server returns an error if shapes of pdaLeft and pdaRight
   are incompatible with matrix multiplication.


.. py:function:: median(pda: arkouda.numpy.pdarrayclass.pdarray) -> numpy.float64

   Compute the median of a given array.  1d case only, for now.

   :param pda: The input data, in pdarray form, numeric type or boolean
   :type pda: pdarray

   :returns: | The median of the entire pdarray
             | The array is sorted, and then if the number of elements is odd,
                 the return value is the middle element.  If even, then the
                 mean of the two middle elements.
   :rtype: np.float64

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> pda = ak.array([0,4,7,8,1,3,5,2,-1])
   >>> ak.median(pda)
   np.float64(3.0)
   >>> pda = ak.array([0,1,3,3,1,2,3,4,2,3])
   >>> ak.median(pda)
   np.float64(2.5)


.. py:function:: nextafter(x1: Union[arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.dtypes.numeric_scalars, arkouda.numpy.dtypes.bigint], x2: Union[arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.dtypes.numeric_scalars, arkouda.numpy.dtypes.bigint]) -> Union[arkouda.numpy.pdarrayclass.pdarray, float]

   Return the next floating-point value after `x1` towards `x2`, element-wise.
   Accuracy only guaranteed for 64 bit values.

   :param x1: Values to find the next representable value of.
   :type x1: pdarray, numeric_scalars, or bigint
   :param x2: The direction where to look for the next representable value of `x1`.
              If `x1.shape != x2.shape`, they must be broadcastable to a common shape
              (which becomes the shape of the output).
   :type x2: pdarray, numeric_scalars, or bigint

   :returns: The next representable values of `x1` in the direction of `x2`.
             This is a scalar if both `x1` and `x2` are scalars.
   :rtype: pdarray or float

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> eps = np.finfo(np.float64).eps
   >>> ak.nextafter(1, 2) == 1 + eps
    np.True_
   >>> a = ak.array([1, 2])
   >>> b = ak.array([2, 1])
   >>> ak.nextafter(a, b) == ak.array([eps + 1, 2 - eps])
   array([True True])


.. py:function:: percentile(a: arkouda.numpy.pdarrayclass.pdarray, q: Optional[Union[arkouda.numpy.dtypes.numeric_scalars, Tuple[arkouda.numpy.dtypes.numeric_scalars], numpy.ndarray]] = 0.5, axis: Optional[Union[arkouda.numpy.dtypes.int_scalars, Tuple[arkouda.numpy.dtypes.int_scalars, Ellipsis], None]] = None, method: Optional[str] = 'linear', keepdims: bool = False) -> Union[arkouda.numpy.dtypes.numeric_scalars, arkouda.numpy.pdarrayclass.pdarray]

   Compute the q-th percentile of the data along the specified axis.

   :param a: data whose percentile will be computed
   :type a: pdarray
   :param q: a scalar, tuple, or np.ndarray of q values for the computation.  All values
             must be in the range 0 <= q <= 100
   :type q: pdarray, Tuple, or np.ndarray
   :param axis: the axis or axes along which the percentiles are computed.  The default is None,
                which computes the percenntile along a flattened version of the array.
   :type axis: None, int scalar, or tuple of int scalars
   :param method: one of "inverted_cdf," "averaged_inverted_cdf", "closest_observation",
                  "interpolated_inverted_cdf", "hazen", "weibull", "linear", 'median_unbiased",
                  "normal_unbiased", "lower"," higher", "midpoint"
   :type method: string
   :param keepdims: True if the degenerate axes are to be retained after slicing, False if not
   :type keepdims: bool

   :returns: If q is a scalar and axis is None, the result is a scalar.
             If q is a scalar and axis is supplied, the result is a pdarray of rank len(axis)
             less than the rank of a.
             If q is an array and axis is None, the result is a pdarray of shape q.shape
             If q is an array and axis is None, the result is a pdarray of rank q.ndim +
             pda.ndim - len(axis).  However, there is an intermediate result which is of rank
             q.ndim + pda.ndim.  If this is not in the compiled ranks, an error will be thrown
             even if the final result would be in the compiled ranks.
   :rtype: pdarray or scalar

   .. rubric:: Notes

   np.percentile also supports the method "nearest," however its behavior does not match
   the numpy documentation, so it's not supported here.
   np.percentile also allows for weighted inputs, but only for the method "inverted_cdf."
   That also is not supported here.

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.array([[1,2,3,4,5],[1,2,3,4,5]])
   >>> q = 70
   >>> ak.percentile(a,q,axis=None,method="linear")
   np.float64(4.0)
   >>> ak.percentile(a,q,axis=1,method="lower")
   array([3.00000000000000000 3.00000000000000000])
   >>> q = np.array([40,60])
   >>> ak.percentile(a,q,axis=None,method="weibull")
   array([2.4000000000000004 3.5999999999999996])
   >>> a = ak.array([[1,2],[5,3]])
   >>> ak.percentile(a,q,axis=0,method="hazen")
   array([array([2.2000000000000002 2.2999999999999998])
       array([3.7999999999999998 2.6999999999999997])])

   :raises ValueError: Raised if scalar q or any value of array q is outside the range [0,100]
       Raised if the method is not one of the 12 supported methods.
       Raised if the result would have a rank not in the compiled ranks.


.. py:function:: putmask(A: arkouda.numpy.pdarrayclass.pdarray, mask: arkouda.numpy.pdarrayclass.pdarray, Values: arkouda.numpy.pdarrayclass.pdarray) -> None

   Overwrite elements of A with elements from B based upon a mask array.
   Similar to numpy.putmask, where mask = False, A retains its original value,
   but where mask = True, A is overwritten with the corresponding entry from Values.

   This is similar to ak.where, except that (1) no new pdarray is created, and
   (2) Values does not have to be the same size as A and mask.

   :param A: Value(s) used when mask is False (see Notes for allowed dtypes)
   :type A: pdarray
   :param mask: Used to choose values from A or B, must be same size as A, and of type ak.bool_
   :type mask: pdarray
   :param Values: Value(s) used when mask is False (see Notes for allowed dtypes)
   :type Values: pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.array(np.arange(10))
   >>> ak.putmask (a,a>2,a**2)
   >>> a
   array([0 1 2 9 16 25 36 49 64 81])

   >>> a = ak.array(np.arange(10))
   >>> values = ak.array([3,2])
   >>> ak.putmask (a,a>2,values)
   >>> a
   array([0 1 2 2 3 2 3 2 3 2])

   :raises RuntimeError: Raised if mask is not same size as A, or if A.dtype and Values.dtype are not
       an allowed pair (see Notes for details).

   .. rubric:: Notes

   | A and mask must be the same size.  Values can be any size.
   | Allowed dtypes for A and Values conform to types accepted by numpy putmask.
   | If A is ak.float64, Values can be ak.float64, ak.int64, ak.uint64, ak.bool_.
   | If A is ak.int64, Values can be ak.int64 or ak.bool_.
   | If A is ak.uint64, Values can be ak.uint64, or ak.bool_.
   | If A is ak.bool_, Values must be ak.bool_.

   Only one conditional clause is supported e.g., n < 5, n > 1.

   multi-dim pdarrays are now implemented.


.. py:function:: quantile(a: arkouda.numpy.pdarrayclass.pdarray, q: Optional[Union[arkouda.numpy.dtypes.numeric_scalars, Tuple[arkouda.numpy.dtypes.numeric_scalars], numpy.ndarray, arkouda.numpy.pdarrayclass.pdarray]] = 0.5, axis: Optional[Union[arkouda.numpy.dtypes.int_scalars, Tuple[arkouda.numpy.dtypes.int_scalars, Ellipsis], None]] = None, method: Optional[str] = 'linear', keepdims: bool = False) -> Union[arkouda.numpy.dtypes.numeric_scalars, arkouda.numpy.pdarrayclass.pdarray]

   Compute the q-th quantile of the data along the specified axis.

   :param a: data whose quantile will be computed
   :type a: pdarray
   :param q: a scalar, tuple, or np.ndarray of q values for the computation.  All values
             must be in the range 0 <= q <= 1
   :type q: pdarray, Tuple, or np.ndarray
   :param axis: the axis or axes along which the quantiles are computed.  The default is None,
                which computes the quantile along a flattened version of the array.
   :type axis: None, int scalar, or tuple of int scalars
   :param method: one of "inverted_cdf," "averaged_inverted_cdf", "closest_observation",
                  "interpolated_inverted_cdf", "hazen", "weibull", "linear", 'median_unbiased",
                  "normal_unbiased", "lower"," higher", "midpoint"
   :type method: string
   :param keepdims: True if the degenerate axes are to be retained after slicing, False if not
   :type keepdims: bool

   :returns: If q is a scalar and axis is None, the result is a scalar.
             If q is a scalar and axis is supplied, the result is a pdarray of rank len(axis)
             less than the rank of a.
             If q is an array and axis is None, the result is a pdarray of shape q.shape
             If q is an array and axis is None, the result is a pdarray of rank q.ndim +
             pda.ndim - len(axis).  However, there is an intermediate result which is of rank
             q.ndim + pda.ndim.  If this is not in the compiled ranks, an error will be thrown
             even if the final result would be in the compiled ranks.
   :rtype: pdarray or scalar

   .. rubric:: Notes

   np.quantile also supports the method "nearest," however its behavior does not match
   the numpy documentation, so it's not supported here.
   np.quantile also allows for weighted inputs, but only for the method "inverted_cdf."
   That also is not supported here.

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.array([[1,2,3,4,5],[1,2,3,4,5]])
   >>> q = 0.7
   >>> ak.quantile(a,q,axis=None,method="linear")
   np.float64(4.0)
   >>> ak.quantile(a,q,axis=1,method="lower")
   array([3.00000000000000000 3.00000000000000000])
   >>> q = np.array([0.4,0.6])
   >>> ak.quantile(a,q,axis=None,method="weibull")
   array([2.4000000000000004 3.5999999999999996])
   >>> a = ak.array([[1,2],[5,3]])
   >>> ak.quantile(a,q,axis=0,method="hazen")
   array([array([2.2000000000000002 2.2999999999999998])
       array([3.7999999999999998 2.6999999999999997])])

   :raises ValueError: Raised if scalar q or any value of array q is outside the range [0,1]
       Raised if the method is not one of the 12 supported methods.
       Raised if the result would have a rank not in the compiled ranks.


.. py:function:: rad2deg(pda: arkouda.numpy.pdarrayclass.pdarray, where: Union[bool, arkouda.numpy.pdarrayclass.pdarray] = True) -> arkouda.numpy.pdarrayclass.pdarray

   Converts angles element-wise from radians to degrees.

   :param pda:
   :type pda: pdarray
   :param where: This condition is broadcast over the input. At locations where the condition is True, the
                 corresponding value will be converted from radians to degrees. Elsewhere, it will retain its
                 original value. Default set to True.
   :type where: bool or pdarray, default=True

   :returns: A pdarray containing an angle converted to degrees, from radians, for each element
             of the original pdarray
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.linspace(0,6.28,4)
   >>> ak.rad2deg(a)
   array([0.00000000000000000 119.93916511405233 239.87833022810466 359.81749534215703])


.. py:function:: round(pda: arkouda.numpy.pdarrayclass.pdarray) -> arkouda.numpy.pdarrayclass.pdarray

   Return the element-wise rounding of the array.

   :param pda:
   :type pda: pdarray

   :returns: A pdarray containing input array elements rounded to the nearest integer
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.round(ak.array([1.1, 2.5, 3.14159]))
   array([1.00000000000000000 3.00000000000000000 3.00000000000000000])


.. py:function:: sign(pda: arkouda.numpy.pdarrayclass.pdarray) -> arkouda.numpy.pdarrayclass.pdarray

   Return the element-wise sign of the array.

   :param pda:
   :type pda: pdarray

   :returns: A pdarray containing sign values of the input array elements
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.sign(ak.array([-10, -5, 0, 5, 10]))
   array([-1 -1 0 1 1])


.. py:function:: sin(pda: arkouda.numpy.pdarrayclass.pdarray, where: Union[bool, arkouda.numpy.pdarrayclass.pdarray] = True) -> arkouda.numpy.pdarrayclass.pdarray

   Return the element-wise sine of the array.

   :param pda:
   :type pda: pdarray
   :param where: This condition is broadcast over the input. At locations where the condition is True,
                 the sine will be applied to the corresponding value. Elsewhere, it will retain
                 its original value. Default set to True.
   :type where: bool or pdarray, default=True

   :returns: A pdarray containing sin for each element
             of the original pdarray
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.linspace(-1.5,0.75,4)
   >>> ak.sin(a)
   array([-0.99749498660405445 -0.68163876002333412 0.00000000000000000 0.68163876002333412])


.. py:function:: sinh(pda: arkouda.numpy.pdarrayclass.pdarray, where: Union[bool, arkouda.numpy.pdarrayclass.pdarray] = True) -> arkouda.numpy.pdarrayclass.pdarray

   Return the element-wise hyperbolic sine of the array.

   :param pda:
   :type pda: pdarray
   :param where: This condition is broadcast over the input. At locations where the condition is True,
                 the hyperbolic sine will be applied to the corresponding value. Elsewhere, it will retain
                 its original value. Default set to True.
   :type where: bool or pdarray, default=True

   :returns: A pdarray containing hyperbolic sine for each element
             of the original pdarray
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.linspace(-0.9,0.7,4)
   >>> ak.sinh(a)
   array([-1.0265167257081753 -0.37493812328444776 0.16743934398751592 0.75858370183953339])


.. py:function:: square(pda: arkouda.numpy.pdarrayclass.pdarray) -> arkouda.numpy.pdarrayclass.pdarray

   Return the element-wise square of the array.

   :param pda:
   :type pda: pdarray

   :returns: A pdarray containing square values of the input
             array elements
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.square(ak.arange(1,5))
   array([1 4 9 16])


.. py:function:: take(a: arkouda.numpy.pdarrayclass.pdarray, indices: Union[arkouda.numpy.dtypes.numeric_scalars, arkouda.numpy.pdarrayclass.pdarray], axis: Optional[int] = None) -> arkouda.numpy.pdarrayclass.pdarray

   Take elements from an array along an axis.

   When axis is not None, this function does the same thing as fancy indexing (indexing arrays
   using arrays); however, it can be easier to use if you need elements along a given axis.
   A call such as ``np.take(arr, indices, axis=3)`` is equivalent to ``arr[:,:,:,indices,...]``.

   :param a: The array from which to take elements
   :type a: pdarray
   :param indices: The indices of the values to extract. Also allow scalars for indices.
   :type indices: numeric_scalars or pdarray
   :param axis: The axis over which to select values. By default, the flattened input array is used.
   :type axis: int, optional

   :returns: The returned array has the same type as `a`.
   :rtype: pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.array([4, 3, 5, 7, 6, 8])
   >>> indices = [0, 1, 4]
   >>> ak.take(a, indices)
   array([4 3 6])


.. py:function:: tan(pda: arkouda.numpy.pdarrayclass.pdarray, where: Union[bool, arkouda.numpy.pdarrayclass.pdarray] = True) -> arkouda.numpy.pdarrayclass.pdarray

   Return the element-wise tangent of the array.

   :param pda:
   :type pda: pdarray
   :param where: This condition is broadcast over the input. At locations where the condition is True,
                 the tangent will be applied to the corresponding value. Elsewhere, it will retain
                 its original value. Default set to True.
   :type where: bool or pdarray, default=True

   :returns: A pdarray containing tangent for each element
             of the original pdarray
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.linspace(-1.5,0.75,4)
   >>> ak.tan(a)
   array([-14.101419947171719 -0.93159645994407247 0.00000000000000000 0.93159645994407247])


.. py:function:: tanh(pda: arkouda.numpy.pdarrayclass.pdarray, where: Union[bool, arkouda.numpy.pdarrayclass.pdarray] = True) -> arkouda.numpy.pdarrayclass.pdarray

   Return the element-wise hyperbolic tangent of the array.

   :param pda:
   :type pda: pdarray
   :param where: This condition is broadcast over the input. At locations where the condition is True,
                 the hyperbolic tangent will be applied to the corresponding value. Elsewhere, it will retain
                 its original value. Default set to True.
   :type where: bool or pdarray, default=True

   :returns: A pdarray containing hyperbolic tangent for each element
             of the original pdarray
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.linspace(-0.9,0.7,4)
   >>> ak.tanh(a)
   array([-0.71629787019902447 -0.35107264597890853 0.1651404129246293 0.60436777711716361])


.. py:function:: transpose(pda: arkouda.numpy.pdarrayclass.pdarray, axes: Optional[Tuple[int, Ellipsis]] = None) -> arkouda.numpy.pdarrayclass.pdarray

   Compute the transpose of a matrix.

   :param pda:
   :type pda: pdarray
   :param axes: If specified, must be a tuple which contains a permutation of the axes of pda.
   :type axes: Tuple[int,...] Optional, defaults to None

   :returns: the transpose of the input matrix
             For a 1-D array, this is the original array.
             For a 2-D array, this is the standard matrix transpose.
             For an n-D array, if axes are given, their order indicates how the axes are permuted.
             If axes is None, the axes are reversed.
   :rtype: pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.array([[1,2,3,4,5],[1,2,3,4,5]])
   >>> ak.transpose(a)
   array([array([1 1]) array([2 2]) array([3 3]) array([4 4]) array([5 5])])
   >>> z = ak.array(np.arange(27).reshape(3,3,3))
   >>> ak.transpose(z,axes=(1,0,2))
   array([array([array([0 1 2]) array([9 10 11]) array([18 19 20])]) array([array([3 4 5])
     array([12 13 14]) array([21 22 23])]) array([array([6 7 8]) array([15 16 17]) array([24 25 26])])])

   :raises ValueError: Raised if axes is not a legitimate permutation of the axes of pda
   :raises TypeError: Raised if pda is not a pdarray, or if axes is neither a tuple nor None


.. py:function:: tril(pda: arkouda.numpy.pdarrayclass.pdarray, diag: arkouda.numpy.dtypes.int_scalars = 0) -> arkouda.numpy.pdarrayclass.pdarray

   Return a copy of the pda with the upper triangle zeroed out

   :param pda:
   :type pda: pdarray
   :param diag: | if diag = 0, zeros start just above the main diagonal
                | if diag = 1, zeros start at the main diagonal
                | if diag = 2, zeros start just below the main diagonal
                | etc. Default set to 0.
   :type diag: int_scalars, optional

   :returns: a copy of pda with zeros in the upper triangle
   :rtype: pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.array([[1,2,3,4,5],[2,3,4,5,6],[3,4,5,6,7],[4,5,6,7,8],[5,6,7,8,9]])
   >>> ak.tril(a,diag=4)
   array([array([1 2 3 4 5]) array([2 3 4 5 6]) array([3 4 5 6 7])
   array([4 5 6 7 8]) array([5 6 7 8 9])])
   >>> ak.tril(a,diag=3)
   array([array([1 2 3 4 0]) array([2 3 4 5 6]) array([3 4 5 6 7])
   array([4 5 6 7 8]) array([5 6 7 8 9])])
   >>> ak.tril(a,diag=2)
   array([array([1 2 3 0 0]) array([2 3 4 5 0]) array([3 4 5 6 7])
   array([4 5 6 7 8]) array([5 6 7 8 9])])
   >>> ak.tril(a,diag=1)
   array([array([1 2 0 0 0]) array([2 3 4 0 0]) array([3 4 5 6 0])
   array([4 5 6 7 8]) array([5 6 7 8 9])])
   >>> ak.tril(a,diag=0)
   array([array([1 0 0 0 0]) array([2 3 0 0 0]) array([3 4 5 0 0])
   array([4 5 6 7 0]) array([5 6 7 8 9])])

   .. rubric:: Notes

   Server returns an error if rank of pda < 2


.. py:function:: triu(pda: arkouda.numpy.pdarrayclass.pdarray, diag: arkouda.numpy.dtypes.int_scalars = 0) -> arkouda.numpy.pdarrayclass.pdarray

   Return a copy of the pda with the lower triangle zeroed out

   :param pda:
   :type pda: pdarray
   :param diag: | if diag = 0, zeros start just below the main diagonal
                | if diag = 1, zeros start at the main diagonal
                | if diag = 2, zeros start just above the main diagonal
                | etc. Default set to 0.
   :type diag: int_scalars, default=0

   :returns: a copy of pda with zeros in the lower triangle
   :rtype: pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.array([[1,2,3,4,5],[2,3,4,5,6],[3,4,5,6,7],[4,5,6,7,8],[5,6,7,8,9]])
   >>> ak.triu(a,diag=0)
   array([array([1 2 3 4 5]) array([0 3 4 5 6]) array([0 0 5 6 7])
   array([0 0 0 7 8]) array([0 0 0 0 9])])
   >>> ak.triu(a,diag=1)
   array([array([0 2 3 4 5]) array([0 0 4 5 6]) array([0 0 0 6 7])
   array([0 0 0 0 8]) array([0 0 0 0 0])])
   >>> ak.triu(a,diag=2)
   array([array([0 0 3 4 5]) array([0 0 0 5 6]) array([0 0 0 0 7])
   array([0 0 0 0 0]) array([0 0 0 0 0])])
   >>> ak.triu(a,diag=3)
   array([array([0 0 0 4 5]) array([0 0 0 0 6]) array([0 0 0 0 0])
   array([0 0 0 0 0]) array([0 0 0 0 0])])
   >>> ak.triu(a,diag=4)
   array([array([0 0 0 0 5]) array([0 0 0 0 0]) array([0 0 0 0 0])
   array([0 0 0 0 0]) array([0 0 0 0 0])])

   .. rubric:: Notes

   Server returns an error if rank of pda < 2


.. py:function:: trunc(pda: arkouda.numpy.pdarrayclass.pdarray) -> arkouda.numpy.pdarrayclass.pdarray

   Return the element-wise truncation of the array.

   :param pda:
   :type pda: pdarray

   :returns: A pdarray containing input array elements truncated to the nearest integer
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.trunc(ak.array([1.1, 2.5, 3.14159]))
   array([1.00000000000000000 2.00000000000000000 3.00000000000000000])


.. py:function:: value_counts(pda: arkouda.numpy.pdarrayclass.pdarray) -> tuple[arkouda.groupbyclass.groupable, arkouda.numpy.pdarrayclass.pdarray]

   Count the occurrences of the unique values of an array.

   :param pda: The array of values to count
   :type pda: pdarray

   :returns: * **unique_values** (*pdarray, int64 or Strings*) -- The unique values, sorted in ascending order
             * **counts** (*pdarray, int64*) -- The number of times the corresponding unique value occurs

   :raises TypeError: Raised if the parameter is not a pdarray

   .. seealso:: :py:obj:`unique`, :py:obj:`histogram`

   .. rubric:: Notes

   This function differs from ``histogram()`` in that it only returns
   counts for values that are present, leaving out empty "bins". This
   function delegates all logic to the unique() method where the
   return_counts parameter is set to True.

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> A = ak.array([2, 0, 2, 4, 0, 0])
   >>> ak.value_counts(A)
   (array([0 2 4]), array([3 2 1]))


.. py:function:: vecdot(x1: arkouda.numpy.pdarrayclass.pdarray, x2: arkouda.numpy.pdarrayclass.pdarray, axis: Optional[Union[int, None]] = None) -> Union[arkouda.numpy.dtypes.numeric_scalars, arkouda.numpy.pdarrayclass.pdarray]

   Computes the numpy-style vecdot product of two matrices.  This differs from the
   vecdot function above.  See https://numpy.org/doc/stable/reference/index.html.

   :param x1:
   :type x1: pdarray
   :param x2:
   :type x2: pdarray
   :param axis:
   :type axis: int, None, optional, default = None

   :returns: x1 vecdot x2
   :rtype: pdarray, numeric_scalar

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.array([[1,2,3,4,5],[1,2,3,4,5]])
   >>> b = ak.array([[2,2,2,2,2],[2,2,2,2,2]])
   >>> ak.vecdot(a,b)
   array([30 30])
   >>> ak.vecdot(b,a)
   array([30 30])

   :raises ValueError: Raised if x1 and x2 can not be broadcast to a compatible shape
       or if the last dimensions of x1 and x2 don't match.

   .. rubric:: Notes

   This matches the behavior of numpy vecdot, but as commented above, it is not the
   behavior of the deprecated vecdot, which calls the chapel-side vecdot function.
   This function only uses broadcast_dims, broadcast_to_shape, ak.sum, and the
   binops pdarray multiplication function.  The last dimension of x1 and x2 must
   match, and it must be possible to broadcast them to a compatible shape.
   The deprecated vecdot can be computed via ak.vecdot(a,b,axis=0) on pdarrays
   of matching shape.


.. py:function:: where(condition: arkouda.numpy.pdarrayclass.pdarray, A: Union[str, arkouda.numpy.dtypes.numeric_scalars, arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.strings.Strings, arkouda.categorical.Categorical], B: Union[str, arkouda.numpy.dtypes.numeric_scalars, arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.strings.Strings, arkouda.categorical.Categorical]) -> Union[arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.strings.Strings, arkouda.categorical.Categorical]

   Return an array with elements chosen from A and B based upon a
   conditioning array. As is the case with numpy.where, the return array
   consists of values from the first array (A) where the conditioning array
   elements are True and from the second array (B) where the conditioning
   array elements are False.

   :param condition: Used to choose values from A or B
   :type condition: pdarray
   :param A: Value(s) used when condition is True
   :type A: str, numeric_scalars, pdarray, Strings, or Categorical
   :param B: Value(s) used when condition is False
   :type B: str, numeric_scalars, pdarray, Strings, or Categorical

   :returns: Values chosen from A where the condition is True and B where
             the condition is False
   :rtype: pdarray

   :raises TypeError: Raised if the condition object is not a pdarray, if A or B is not
       an int, np.int64, float, np.float64, bool, pdarray, str, Strings, Categorical
       if pdarray dtypes are not supported or do not match, or multiple
       condition clauses (see Notes section) are applied
   :raises ValueError: Raised if the shapes of the condition, A, and B pdarrays are unequal

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a1 = ak.arange(1,10)
   >>> a2 = ak.ones(9, dtype=np.int64)
   >>> cond = a1 < 5
   >>> ak.where(cond,a1,a2)
   array([1 2 3 4 1 1 1 1 1])

   >>> a1 = ak.arange(1,10)
   >>> a2 = ak.ones(9, dtype=np.int64)
   >>> cond = a1 == 5
   >>> ak.where(cond,a1,a2)
   array([1 1 1 1 5 1 1 1 1])

   >>> a1 = ak.arange(1,10)
   >>> a2 = 10
   >>> cond = a1 < 5
   >>> ak.where(cond,a1,a2)
   array([1 2 3 4 10 10 10 10 10])

   >>> s1 = ak.array([f'str {i}' for i in range(10)])
   >>> s2 = 'str 21'
   >>> cond = (ak.arange(10) % 2 == 0)
   >>> ak.where(cond,s1,s2)
   array(['str 0', 'str 21', 'str 2', 'str 21', 'str 4',
   'str 21', 'str 6', 'str 21', 'str 8', 'str 21'])

   >>> c1 = ak.Categorical(ak.array([f'str {i}' for i in range(10)]))
   >>> c2 = ak.Categorical(ak.array([f'str {i}' for i in range(9, -1, -1)]))
   >>> cond = (ak.arange(10) % 2 == 0)
   >>> ak.where(cond,c1,c2)
   array(['str 0', 'str 8', 'str 2', 'str 6', 'str 4',
   'str 4', 'str 6', 'str 2', 'str 8', 'str 0'])

   .. rubric:: Notes

   A and B must have the same dtype and only one conditional clause
   is supported e.g., n < 5, n > 1, which is supported in numpy
   is not currently supported in Arkouda


