arkouda.numpy.pdarrayclass
==========================

.. py:module:: arkouda.numpy.pdarrayclass


Exceptions
----------

.. autoapisummary::

   arkouda.numpy.pdarrayclass.RegistrationError


Classes
-------

.. autoapisummary::

   arkouda.numpy.pdarrayclass.pdarray


Functions
---------

.. autoapisummary::

   arkouda.numpy.pdarrayclass.allclose
   arkouda.numpy.pdarrayclass.argmaxk
   arkouda.numpy.pdarrayclass.argmink
   arkouda.numpy.pdarrayclass.clear
   arkouda.numpy.pdarrayclass.clz
   arkouda.numpy.pdarrayclass.corr
   arkouda.numpy.pdarrayclass.cov
   arkouda.numpy.pdarrayclass.create_pdarray
   arkouda.numpy.pdarrayclass.ctz
   arkouda.numpy.pdarrayclass.diff
   arkouda.numpy.pdarrayclass.divmod
   arkouda.numpy.pdarrayclass.dot
   arkouda.numpy.pdarrayclass.fmod
   arkouda.numpy.pdarrayclass.logical_not
   arkouda.numpy.pdarrayclass.maxk
   arkouda.numpy.pdarrayclass.mink
   arkouda.numpy.pdarrayclass.mod
   arkouda.numpy.pdarrayclass.parity
   arkouda.numpy.pdarrayclass.popcount
   arkouda.numpy.pdarrayclass.power
   arkouda.numpy.pdarrayclass.rotl
   arkouda.numpy.pdarrayclass.rotr
   arkouda.numpy.pdarrayclass.sqrt


Module Contents
---------------

.. py:exception:: RegistrationError

   Bases: :py:obj:`Exception`


   Error/Exception used when the Arkouda Server cannot register an object.


.. py:function:: allclose(a: pdarray, b: pdarray, rtol: float = 1e-05, atol: float = 1e-08, equal_nan: bool = False) -> bool

   Returns True if all elements of ``a`` and ``b`` are equal within a tolerance.

   This function compares two arrays elementwise and returns True if they are
   equal within the tolerance defined by the parameters ``rtol`` and ``atol``.
   The comparison uses the formula: absolute(a - b) <= (atol + rtol * absolute(b))

   :param a: First array to compare.
   :type a: pdarray
   :param b: Second array to compare.
   :type b: pdarray
   :param rtol: Relative tolerance. Default is 1e-5.
   :type rtol: float, optional
   :param atol: Absolute tolerance. Default is 1e-8.
   :type atol: float, optional
   :param equal_nan: Whether to consider NaNs in corresponding positions as equal.
                     Default is False.
   :type equal_nan: bool, optional

   :returns: True if all elements are equal within the specified tolerance,
             False otherwise.
   :rtype: bool

   :raises TypeError: If either ``a`` or ``b`` is not a ``pdarray``.
   :raises TypeError: If either array has dtype ``bigint``, which is not supported.
   :raises ValueError: If ``a`` and ``b`` have different shapes.

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> x = ak.array([1.0, 2.0, 3.0])
   >>> y = ak.array([1.0, 2.00001, 2.99999])
   >>> ak.allclose(x, y)
   True


.. py:function:: argmaxk(pda: pdarray, k: arkouda.numpy.dtypes.int_scalars) -> pdarray

   Find the indices corresponding to the `k` maximum values of an array.

   Returns the largest `k` values of an array, sorted

   :param pda: Input array.
   :type pda: pdarray
   :param k: The desired count of indices corresponding to maxmum array values
   :type k: int_scalars

   :returns: The indices of the maximum `k` values from the pda, sorted
   :rtype: pdarray

   :raises TypeError: Raised if pda is not a pdarray or k is not an integer
   :raises ValueError: Raised if the pda is empty, or pda.ndim > 1, or k < 1

   .. rubric:: Notes

   This call is equivalent in value to ak.argsort(a)[k:]
   and generally outperforms this operation.

   This reduction will see a significant drop in performance as `k` grows
   beyond a certain value. This value is system dependent, but generally
   about a `k` of 5 million is where performance degradation has been observed.

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> A = ak.array([10,5,1,3,7,2,9,0])
   >>> ak.argmaxk(A, 3)
   array([4 6 0])
   >>> ak.argmaxk(A, 4)
   array([1 4 6 0])


.. py:function:: argmink(pda: pdarray, k: arkouda.numpy.dtypes.int_scalars) -> pdarray

   Finds the indices corresponding to the `k` minimum values of an array.

   :param pda: Input array.
   :type pda: pdarray
   :param k: The desired count of indices corresponding to minimum array values
   :type k: int_scalars

   :returns: The indices of the minimum `k` values from the pda, sorted
   :rtype: pdarray

   :raises TypeError: Raised if pda is not a pdarray or k is not an integer
   :raises ValueError: Raised if the pda is empty, or pda.ndim > 1, or k < 1

   .. rubric:: Notes

   This call is equivalent in value to ak.argsort(a)[:k]
   and generally outperforms this operation.

   This reduction will see a significant drop in performance as `k` grows
   beyond a certain value. This value is system dependent, but generally
   about a `k` of 5 million is where performance degradation has been observed.

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> A = ak.array([10,5,1,3,7,2,9,0])
   >>> ak.argmink(A, 3)
   array([7 2 5])
   >>> ak.argmink(A, 4)
   array([7 2 5 3])


.. py:function:: clear() -> None

   Send a clear message to clear all unregistered data from the server symbol table.

   :raises RuntimeError: Raised if there is a server-side error in executing clear request


.. py:function:: clz(pda: pdarray) -> pdarray

   Count leading zeros for each integer in an array.

   :param pda: Input array (must be integral).
   :type pda: pdarray, int64, uint64, bigint

   :returns: The number of leading zeros of each element.
   :rtype: pdarray

   :raises TypeError: If input array is not int64, uint64, or bigint

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> A = ak.arange(10)
   >>> ak.clz(A)
   array([64 63 62 62 61 61 61 61 60 60])


.. py:function:: corr(x: pdarray, y: pdarray) -> numpy.float64

   Return the correlation between x and y.

   :param x: One of the pdarrays used to calculate correlation
   :type x: pdarray
   :param y: One of the pdarrays used to calculate correlation
   :type y: pdarray

   :returns: The scalar correlation of the two pdarrays
   :rtype: np.float64

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.arange(10)
   >>> b = a + 1
   >>> ak.corr(a,b)
   np.float64(0.9999999999999998)
   >>> a.corr(b)
   np.float64(0.9999999999999998)

   :raises TypeError: Raised if x or y is not a pdarray instance
   :raises RuntimeError: Raised if there's a server-side error thrown

   .. seealso:: :py:obj:`std`, :py:obj:`cov`

   .. rubric:: Notes

   The correlation is calculated by
   cov(x, y) / (x.std(ddof=1) * y.std(ddof=1))


.. py:function:: cov(x: pdarray, y: pdarray) -> numpy.float64

   Return the covariance of x and y.

   :param x: One of the pdarrays used to calculate covariance
   :type x: pdarray
   :param y: One of the pdarrays used to calculate covariance
   :type y: pdarray

   :returns: The scalar covariance of the two pdarrays
   :rtype: np.float64

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.arange(10)
   >>> b = a + 1
   >>> ak.cov(a,b)
   np.float64(9.166666666666666)
   >>> a.cov(b)
   np.float64(9.166666666666666)

   :raises TypeError: Raised if x or y is not a pdarray instance
   :raises RuntimeError: Raised if there's a server-side error thrown

   .. seealso:: :py:obj:`mean`, :py:obj:`var`

   .. rubric:: Notes

   The covariance is calculated by
   ``cov = ((x - x.mean()) * (y - y.mean())).sum() / (x.size - 1)``.


.. py:function:: create_pdarray(rep_msg: Union[str, memoryview], max_bits=None) -> pdarray

   Return a pdarray instance pointing to an array created by the arkouda server.
   The user should not call this function directly.

   :param rep_msg: space-delimited string containing the pdarray name, datatype, size
                   dimension, shape,and itemsize
   :type rep_msg: str

   :returns: A pdarray with the same attributes and data as the pdarray; on GPU
   :rtype: pdarray

   :raises ValueError: If there's an error in parsing the rep_msg parameter into the six
       values needed to create the pdarray instance
   :raises RuntimeError: Raised if a server-side error is thrown in the process of creating
       the pdarray instance


.. py:function:: ctz(pda: pdarray) -> pdarray

   Count trailing zeros for each integer in an array.

   :param pda: Input array (must be integral).
   :type pda: pdarray, int64, uint64, bigint

   :returns: The number of trailing zeros of each element.
   :rtype: pdarray

   .. rubric:: Notes

   ctz(0) is defined to be zero.

   :raises TypeError: If input array is not int64, uint64, or bigint

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> A = ak.arange(10)
   >>> ak.ctz(A)
   array([0 0 1 0 2 0 1 0 3 0])


.. py:function:: diff(a: pdarray, n: int = 1, axis: int = -1, prepend=None, append=None) -> pdarray

   Calculate the n-th discrete difference along the given axis.

   The first difference is given by ``out[i] = a[i+1] - a[i]`` along the given axis,
   higher differences are calculated by using diff iteratively.

   :param a: The array to calculate the difference
   :type a: pdarray
   :param n: The order of the finite difference. Default is 1.
   :type n: int, optional
   :param axis: The axis along which to calculate the difference. Default is the last axis.
   :type axis: int, optional
   :param prepend: The pdarray to prepend to `a` along `axis` before calculating the difference.
   :type prepend: pdarray, optional
   :param append: The pdarray to append to `a` along `axis` before calculating the difference.
   :type append: pdarray, optional

   :returns: The n-th differences. The shape of the output is the same as `a`
             except along `axis` where the dimension is smaller by `n`. The
             type of the output is the same as the type of the difference
             between any two elements of `a`. This is the same as the type of
             `a` in most cases. A notable exception is `datetime64`, which
             results in a `timedelta64` output array.
   :rtype: pdarray

   .. rubric:: Notes

   Type is preserved for boolean arrays, so the result will contain
   `False` when consecutive elements are the same and `True` when they
   differ.

   For unsigned integer arrays, the results will also be unsigned. This
   should not be surprising, as the result is consistent with
   calculating the difference directly.

   If this is not desirable, then the array should be cast to a larger
   integer type first:

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.array([1, 2, 4, 7, 0])
   >>> ak.diff(a)
   array([1 2 3 -7])
   >>> ak.diff(a, n=2)
   array([1 1 -10])

   >>> a = ak.array([[1, 3, 6, 10], [0, 5, 6, 8]])
   >>> ak.diff(a)
   array([array([2 3 4]) array([5 1 2])])
   >>> ak.diff(a, axis=0)
   array([array([-1 2 0 -2])])


.. py:function:: divmod(x: Union[arkouda.numpy.dtypes.numeric_scalars, pdarray], y: Union[arkouda.numpy.dtypes.numeric_scalars, pdarray], where: Union[arkouda.numpy.dtypes.bool_scalars, pdarray] = True) -> Tuple[pdarray, pdarray]

   :param x: The dividend array, the values that will be the numerator of the floordivision and will be
             acted on by the bases for modular division.
   :type x: numeric_scalars(float_scalars, int_scalars) or pdarray
   :param y: The divisor array, the values that will be the denominator of the division and will be the
             bases for the modular division.
   :type y: numeric_scalars(float_scalars, int_scalars) or pdarray
   :param where: This condition is broadcast over the input. At locations where the condition is True, the
                 corresponding value will be divided using floor and modular division. Elsewhere, it will retain
                 its original value. Default set to True.
   :type where: Boolean or pdarray

   :returns: Returns a tuple that contains quotient and remainder of the division
   :rtype: (pdarray, pdarray)

   :raises TypeError: At least one entry must be a pdarray
   :raises ValueError: If both inputs are both pdarrays, their size must match
   :raises ZeroDivisionError: No entry in y is allowed to be 0, to prevent division by zero

   .. rubric:: Notes

   The div is calculated by x // y
   The mod is calculated by x % y

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> x = ak.arange(5, 10)
   >>> y = ak.array([2, 1, 4, 5, 8])
   >>> ak.divmod(x,y)
   (array([2 6 1 1 1]), array([1 0 3 3 1]))
   >>> ak.divmod(x,y, x % 2 == 0)
   (array([5 6 7 1 9]), array([5 0 7 3 9]))


.. py:function:: dot(pda1: Union[int, numpy.int64, numpy.float64, numpy.uint64, pdarray], pda2: Union[int, numpy.int64, numpy.float64, numpy.uint64, pdarray]) -> Union[arkouda.numpy.dtypes.numeric_scalars, numpy.bool, pdarray]

   Computes dot product of two arrays.

   If pda1 and pda2 are 1-D vectors of identical length, returns the conventional dot product.

   If both pda1 and pda2 are scalars, returns their product.

   If one of pda1, pda2 is a scalar, and the other a pdarray, returns the pdarray multiplied
   by the scalar.

   If both pda1 and pda2 are 2-D arrays, returns the matrix multiplication.

   If pda1 is M-D and pda2 is 1-D, returns a sum product over the last axis of pda1 and pda2.

   If pda1 is M-D and pda2 is N-D, returns a sum product over the last axis of pda1 and the
   next-to-last axis of pda2, e.g.:

   For example, If pda1 has rank (3,3,4) and pda2 has rank (4,2), then the result of
   ak.dot(pda1,pda2) has rank (3,3,2), and

   result[i,j,k] = sum( pda1[i, j, :] * pda2[:, k] )

   :param pda1:
   :type pda1: Union[np.int64, np.float64, np.uint64, pdarray],
   :param pda2:
   :type pda2: Union[np.int64, np.float64, np.uint64, pdarray],

   :returns: as described above
   :rtype: Union[numeric_scalars, pdarray]

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.dot(ak.array([1, 2, 3]),ak.array([4,5,6]))
   np.int64(32)
   >>> ak.dot(ak.array([1, 2, 3]),5)
   array([5 10 15])
   >>> ak.dot(5,ak.array([2, 3, 4]))
   array([10 15 20])
   >>> ak.dot(ak.arange(9).reshape(3,3),ak.arange(6).reshape(3,2))
   array([array([10 13]) array([28 40]) array([46 67])])
   >>> ak.dot(ak.arange(27).reshape(3,3,3),ak.array([2,3,4]))
   array([array([11 38 65]) array([92 119 146]) array([173 200 227])])
   >>> ak.dot(ak.arange(36).reshape(3,3,4),ak.arange(8).reshape(4,2))
   array([array([array([28 34]) array([76 98]) array([124 162])]) array([array([172 226])
       array([220 290]) array([268 354])]) array([array([316 418]) array([364 482]) array([412 546])])])

   :raises ValueError: Raised if either pdda1 or pda2 is not an allowed type, or if shapes are incompatible.


.. py:function:: fmod(dividend: Union[pdarray, arkouda.numpy.dtypes.numeric_scalars], divisor: Union[pdarray, arkouda.numpy.dtypes.numeric_scalars]) -> pdarray

   Returns the element-wise remainder of division.

   It is equivalent to np.fmod, the remainder has the same sign as the dividend.

   :param dividend: The array being acted on by the bases for the modular division.
   :type dividend: numeric scalars or pdarray
   :param divisor: The array that will be the bases for the modular division.
   :type divisor: numeric scalars or pdarray

   :returns: an array that contains the element-wise remainder of division.
   :rtype: pdarray

   :raises TypeError: Raised if neither dividend nor divisor is a pdarray (at least one must be)
       or if any scalar or pdarray element is not one of int, uint, float, bigint


.. py:function:: logical_not(x: pdarray) -> pdarray
                 logical_not(x: arkouda.numpy.dtypes.numeric_scalars) -> arkouda.numpy.dtypes.bool_

   Compute the truth value of NOT *x* element-wise.

   This function returns a boolean ``pdarray`` where each element is
   the logical negation of the corresponding element in ``x``. For
   boolean arrays, this is equivalent to applying the unary ``~``
   operator. For numeric arrays, zero is treated as False and
   non-zero as True.

   :param x: Input array on which to compute element-wise logical NOT.
   :type x: pdarray

   :returns: A boolean ``pdarray`` with the same shape as ``x`` containing
             the result of the NOT operation applied element-wise.
   :rtype: pdarray

   .. rubric:: Notes

   This is a simplified version of :func:`numpy.logical_not`. It
   currently does not support keyword arguments such as ``out`` or
   ``where``, and always allocates a new result array.

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> x = ak.array([True, False, True])
   >>> ak.logical_not(x)
   array([False  True False])

   >>> y = ak.array([0, 1, 2])
   >>> ak.logical_not(y)
   array([True False False])


.. py:function:: maxk(pda: pdarray, k: arkouda.numpy.dtypes.int_scalars) -> pdarray

   Find the `k` maximum values of an array.

   Returns the largest `k` values of an array, sorted

   :param pda: Input array.
   :type pda: pdarray
   :param k: The desired count of maximum values to be returned by the output.
   :type k: int_scalars

   :returns: The maximum `k` values from pda, sorted
   :rtype: pdarray

   :raises TypeError: Raised if pda is not a pdarray or k is not an integer
   :raises ValueError: Raised if the pda is empty, or pda.ndim > 1, or k < 1

   .. rubric:: Notes

   This call is equivalent in value to a[ak.argsort(a)[k:]]

   and generally outperforms this operation.

   This reduction will see a significant drop in performance as `k` grows
   beyond a certain value. This value is system dependent, but generally
   about a `k` of 5 million is where performance degredation has been observed.

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> A = ak.array([10,5,1,3,7,2,9,0])
   >>> ak.maxk(A, 3)
   array([7 9 10])
   >>> ak.maxk(A, 4)
   array([5 7 9 10])


.. py:function:: mink(pda: pdarray, k: arkouda.numpy.dtypes.int_scalars) -> pdarray

   Find the `k` minimum values of an array.

   Returns the smallest `k` values of an array, sorted

   :param pda: Input array.
   :type pda: pdarray
   :param k: The desired count of minimum values to be returned by the output.
   :type k: int_scalars

   :returns: The minimum `k` values from pda, sorted
   :rtype: pdarray

   :raises TypeError: Raised if pda is not a pdarray
   :raises ValueError: Raised if the pda is empty, or pda.ndim > 1, or k < 1

   .. rubric:: Notes

   This call is equivalent in value to a[ak.argsort(a)[:k]]
   and generally outperforms this operation.

   This reduction will see a significant drop in performance as `k` grows
   beyond a certain value. This value is system dependent, but generally
   about a `k` of 5 million is where performance degredation has been observed.

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> A = ak.array([10,5,1,3,7,2,9,0])
   >>> ak.mink(A, 3)
   array([0 1 2])
   >>> ak.mink(A, 4)
   array([0 1 2 3])


.. py:function:: mod(dividend, divisor) -> pdarray

   Returns the element-wise remainder of division.

   Computes the remainder complementary to the floor_divide function.
   It is equivalent to np.mod, the remainder has the same sign as the divisor.

   :param dividend: pdarray : The numeric scalar or pdarray being acted on by the bases for the modular division.
   :param divisor: pdarray : The numeric scalar or pdarray that will be the bases for the modular division.

   :returns: an array that contains the element-wise remainder of division.
   :rtype: pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.array([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20])
   >>> b = ak.array([2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7,8,8])
   >>> ak.mod(a,b)
   array([1 0 1 1 2 0 3 0 1 0 1 2 1 2 3 2 3 4 3 4])

   :raises ValueError: raised if shapes of dividend and divisor are incompatible


.. py:function:: parity(pda: pdarray) -> pdarray

   Find the bit parity (XOR of all bits) for each integer in an array.

   :param pda: Input array (must be integral).
   :type pda: pdarray, int64, uint64, bigint

   :returns: The parity of each element: 0 if even number of bits set, 1 if odd.
   :rtype: pdarray

   :raises TypeError: If input array is not int64, uint64, or bigint

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> A = ak.arange(10)
   >>> ak.parity(A)
   array([0 1 1 0 1 0 0 1 1 0])


.. py:class:: pdarray(name: str, mydtype: numpy.dtype, size: arkouda.numpy.dtypes.int_scalars, ndim: arkouda.numpy.dtypes.int_scalars, shape: Tuple[int, Ellipsis], itemsize: arkouda.numpy.dtypes.int_scalars, max_bits: Optional[int] = None)

   The basic arkouda array class. This class contains only the
   attributes of the array; the data resides on the arkouda
   server. When a server operation results in a new array, arkouda
   will create a pdarray instance that points to the array data on
   the server. As such, the user should not initialize pdarray
   instances directly.

   .. attribute:: name

      The server-side identifier for the array

      :type: str

   .. attribute:: dtype

      The element dtype of the array

      :type: type

   .. attribute:: size

      The number of elements in the array

      :type: int_scalars

   .. attribute:: ndim

      The rank of the array

      :type: int_scalars

   .. attribute:: shape

      A tuple containing the sizes of each dimension of the array

      :type: Tuple[int, ...]

   .. attribute:: itemsize

      The size in bytes of each element

      :type: int_scalars


   .. py:attribute:: BinOps


   .. py:attribute:: OpEqOps


   .. py:method:: all(axis: Optional[Union[int, Tuple[int, Ellipsis]]] = None, keepdims: bool = False) -> Union[arkouda.numpy.dtypes.bool_scalars, pdarray]

      Return True iff all elements of the array along the given axis evaluate to True.

      :param axis: The axis or axes along which to do the operation
                   If None, the computation is done across the entire array.
      :type axis: int, Tuple[int, ...], optional, default = None
      :param keepdims: Whether to keep the singleton dimension(s) along `axis` in the result.
      :type keepdims: bool, optional, default = False

      :returns: boolean if axis is omitted, pdarray if axis is supplied
      :rtype: boolean or pdarray

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> ak.all(ak.array([True,False,False]))
      np.False_
      >>> ak.all(ak.array([[True,True,False],[False,True,True]]),axis=0)
      array([False True False])
      >>> ak.all(ak.array([[True,True,True],[False,False,False]]),axis=0,keepdims=True)
      array([array([False False False])])
      >>> ak.all(ak.array([[True,True,True],[False,False,False]]),axis=1,keepdims=True)
      array([array([True]) array([False])])
      >>> ak.array([True,False,False]).all()
      np.False_

      :raises TypeError: Raised if pda is not a pdarray instance
      :raises RuntimeError: Raised if there's a server-side error thrown

      .. rubric:: Notes

      Works as a method of a pdarray (e.g. a.any()) or a standalone function (e.g. ak.all(a))



   .. py:method:: any(axis: Optional[Union[int, Tuple[int, Ellipsis]]] = None, keepdims: bool = False) -> Union[arkouda.numpy.dtypes.bool_scalars, pdarray]

      Return True iff any element of the array along the given axis evaluates to True.

      :param axis: The axis or axes along which to do the operation
                   If None, the computation is done across the entire array.
      :type axis: int, Tuple[int, ...], optional, default = None
      :param keepdims: Whether to keep the singleton dimension(s) along `axis` in the result.
      :type keepdims: bool, optional, default = False

      :returns: boolean if axis is omitted, else pdarray if axis is supplied
      :rtype: boolean or pdarray

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> ak.any(ak.array([True,False,False]))
      np.True_
      >>> ak.any(ak.array([[True,True,False],[False,True,True]]),axis=0)
      array([True True True])
      >>> ak.any(ak.array([[True,True,True],[False,False,False]]),axis=0,keepdims=True)
      array([array([True True True])])
      >>> ak.any(ak.array([[True,True,True],[False,False,False]]),axis=1,keepdims=True)
      array([array([True]) array([False])])
      >>> ak.array([True,False,False]).any()
      np.True_

      :raises TypeError: Raised if pda is not a pdarray instance
      :raises RuntimeError: Raised if there's a server-side error thrown

      .. rubric:: Notes

      Works as a method of a pdarray (e.g. a.any()) or a standalone function (e.g. ak.any(a))



   .. py:method:: argmax(axis: Optional[Union[int, None]] = None, keepdims: bool = False) -> Union[numpy.int64, numpy.uint64, pdarray]

      Return index of the first occurrence of the maximum along the given axis.

      :param axis: The axis or axes along which to do the operation
                   If None, the computation is done across the entire array.
      :type axis: int, Tuple[int, ...], optional, default = None
      :param keepdims: Whether to keep the singleton dimension(s) along `axis` in the result.
      :type keepdims: bool, optional, default = False

      :returns: int64 or uint64 if axis is omitted, in which case operation is done over entire array
                pdarray if axis is supplied, in which case the operation is done along that axis
      :rtype: int64, uint64 or pdarray

      :raises TypeError: Raised if pda is not a pdarray instance
      :raises RuntimeError: Raised if there's a server-side error thrown

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> ak.argmax(ak.array([1,2,3,4,5]))
      np.int64(4)
      >>> ak.argmax(ak.array([5.5,4.5,3.5,2.5,1.5]))
      np.int64(0)
      >>> ak.array([[1,2,3],[5,4,3]]).argmax(axis=1)
      array([2 0])

      .. rubric:: Notes

      Works as a method of a pdarray (e.g. a.argmax()) or a standalone function (e.g. ak.argmax(a))



   .. py:method:: argmaxk(k: arkouda.numpy.dtypes.int_scalars) -> pdarray

      Finds the indices corresponding to the `k` maximum values of an array.

      See ``arkouda.argmaxk`` for details.



   .. py:method:: argmin(axis: Optional[Union[int, None]] = None, keepdims: bool = False) -> Union[numpy.int64, numpy.uint64, pdarray]

      Return index of the first occurrence of the minimum along the given axis.

      :param axis: The axis or axes along which to do the operation
                   If None, the computation is done across the entire array.
      :type axis: int, Tuple[int, ...], optional, default = None
      :param keepdims: Whether to keep the singleton dimension(s) along `axis` in the result.
      :type keepdims: bool, optional, default = False

      :returns: int64 or uint64 if axis is omitted, in which case operation is done over entire array
                pdarray if axis is supplied, in which case the operation is done along that axis
      :rtype: int64, uint64 or pdarray

      :raises TypeError: Raised if pda is not a pdarray instance
      :raises RuntimeError: Raised if there's a server-side error thrown

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> ak.argmin(ak.array([1,2,3,4,5]))
      np.int64(0)
      >>> ak.argmin(ak.array([5.5,4.5,3.5,2.5,1.5]))
      np.int64(4)
      >>> ak.array([[1,2,3],[5,4,3]]).argmin(axis=1)
      array([0 2])

      .. rubric:: Notes

      Works as a method of a pdarray (e.g. a.argmin()) or a standalone function (e.g. ak.argmin(a))



   .. py:method:: argmink(k: arkouda.numpy.dtypes.int_scalars) -> pdarray

      Finds the indices corresponding to the `k` minimum values of an array.

      See ``arkouda.argmink`` for details.



   .. py:method:: argsort(algorithm: arkouda.numpy.sorting.SortingAlgorithm = SortingAlgorithm.RadixSortLSD, axis: arkouda.numpy.dtypes.int_scalars = 0, ascending: bool = True) -> pdarray

      Return the permutation that sorts the pdarray.

      :param algorithm: The algorithm to use for sorting.
      :type algorithm: SortingAlgorithm, default SortingAlgorithm.RadixSortLSD
      :param axis: The axis to sort along. Must be between -1 and the array rank.
      :type axis: int_scalars, default 0
      :param ascending: Whether to sort in ascending order. If False, returns a reversed permutation.
                        Note: ascending=False is only supported for 1D arrays.
      :type ascending: bool, default True

      :returns: The indices that would sort the array.
      :rtype: pdarray

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> a = ak.array([42, 7, 19])
      >>> a.argsort()
      array([1 2 0])
      >>> a[a.argsort()]
      array([7 19 42])
      >>> a.argsort(ascending=False)
      array([0 2 1])



   .. py:method:: astype(dtype) -> pdarray

      Cast values of pdarray to provided dtype.

      :param dtype: Dtype to cast to
      :type dtype: np.dtype or str

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> ak.array([1,2,3]).astype(ak.float64)
      array([1.00000000000000000 2.00000000000000000 3.00000000000000000])
      >>> ak.array([1.5,2.5]).astype(ak.int64)
      array([1 2])
      >>> ak.array([True,False]).astype(ak.int64)
      array([1 0])

      :returns: An arkouda pdarray with values converted to the specified data type
      :rtype: pdarray

      .. rubric:: Notes

      This is essentially shorthand for ak.cast(x, '<dtype>') where x is a pdarray.



   .. py:method:: bigint_to_uint_arrays() -> List[pdarray]

      Create a list of uint pdarrays from a bigint pdarray.
      The first item in return will be the highest 64 bits of the
      bigint pdarray and the last item will be the lowest 64 bits.

      :returns: A list of uint pdarrays where:
                The first item in return will be the highest 64 bits of the
                bigint pdarray and the last item will be the lowest 64 bits.
      :rtype: List[pdarrays]

      :raises RuntimeError: Raised if there is a server-side error thrown

      .. seealso:: :py:obj:`pdarraycreation.bigint_from_uint_arrays`

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> a = ak.arange(2**64, 2**64 + 5)
      >>> a
      array([18446744073709551616 18446744073709551617 18446744073709551618
      18446744073709551619 18446744073709551620])
      >>> a.bigint_to_uint_arrays()
      [array([1 1 1 1 1]), array([0 1 2 3 4])]



   .. py:method:: clz() -> pdarray

      Count the number of leading zeros in each element.

      See `ak.clz`.



   .. py:method:: copy() -> pdarray

      Return an array copy of the given object.

      :returns: A deep copy of the pdarray.
      :rtype: pdarray



   .. py:method:: corr(y: pdarray) -> numpy.float64

      Compute the correlation between self and y using pearson correlation coefficient.

      See ``arkouda.corr`` for details.



   .. py:method:: cov(y: pdarray) -> numpy.float64

      Compute the covariance between self and y.



   .. py:method:: ctz() -> pdarray

      Count the number of trailing zeros in each element.

      See `ak.ctz`.



   .. py:attribute:: dtype
      :type:  numpy.dtype


   .. py:method:: equals(other) -> arkouda.numpy.dtypes.bool_scalars

      Whether pdarrays are the same size and all entries are equal.

      :param other: object to compare.
      :type other: object

      :returns: True if the pdarrays are the same, o.w. False.
      :rtype: bool_scalars

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> a = ak.array([1, 2, 3])
      >>> a_cpy = ak.array([1, 2, 3])
      >>> a.equals(a_cpy)
      np.True_
      >>> a2 = ak.array([1, 2, 5])
      >>> a.equals(a2)
      np.False_



   .. py:method:: fill(value: Union[arkouda.numpy.dtypes.numeric_scalars, arkouda.numpy.dtypes.bool_scalars]) -> None

      Fill the array (in place) with a constant value.

      :param value:
      :type value: numeric_scalars

      :raises TypeError: Raised if value is not an int, int64, float, or float64



   .. py:method:: flatten()

      Return a copy of the array collapsed into one dimension.

      :rtype: A copy of the input array, flattened to one dimension.

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> a = ak.array([[3,2,1],[2,3,1]])
      >>> a.flatten()
      array([3 2 1 2 3 1])



   .. py:method:: format_other(other) -> str

      Attempt to cast scalar other to the element dtype of this pdarray,
      and print the resulting value to a string (e.g. for sending to a
      server command). The user should not call this function directly.

      :param other: The scalar to be cast to the pdarray.dtype
      :type other: object

      :rtype: string representation of np.dtype corresponding to the other parameter

      :raises TypeError: Raised if the other parameter cannot be converted to
          Numpy dtype



   .. py:property:: inferred_type
      :type: Union[str, None]


      Return a string of the type inferred from the values.


   .. py:method:: info() -> str

      Return a JSON formatted string containing information about all components of self.

      :returns: JSON string containing information about all components of self
      :rtype: str



   .. py:method:: is_registered() -> numpy.bool_

      Return True iff the object is contained in the registry.

      :returns: Indicates if the object is contained in the registry
      :rtype: bool

      :raises RuntimeError: Raised if there's a server-side error thrown

      .. note::

         This will return True if the object is registered itself or as a component
         of another object



   .. py:method:: is_sorted(axis: Optional[Union[int, Tuple[int, Ellipsis]]] = None, keepdims: bool = False) -> Union[arkouda.numpy.dtypes.bool_scalars, pdarray]

      Return True iff the array (or given axis of the array) is monotonically non-decreasing.

      :param axis: The axis or axes along which to do the operation
                   If None, the computation is done across the entire array.
      :type axis: int, Tuple[int, ...], optional, default = None
      :param keepdims: Whether to keep the singleton dimension(s) along `axis` in the result.
      :type keepdims: bool, optional, default = False

      :returns: boolean if axis is omitted, else pdarray if axis is supplied
      :rtype: boolean or pdarray

      :raises TypeError: Raised if pda is not a pdarray instance
      :raises RuntimeError: Raised if there's a server-side error thrown

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> ak.is_sorted(ak.array([1,2,3,4,5]))
      np.True_
      >>> ak.is_sorted(ak.array([5,4,3,2,1]))
      np.False_
      >>> ak.array([[1,2,3],[5,4,3]]).is_sorted(axis=1)
      array([True False])

      .. rubric:: Notes

      Works as a method of a pdarray (e.g. a.is_sorted()) or a
      standalone function (e.g. ak.is_sorted(a))



   .. py:attribute:: itemsize
      :type:  arkouda.numpy.dtypes.int_scalars


   .. py:method:: logical_not() -> pdarray

      Compute the truth value of NOT *self* element-wise.

      This method is equivalent to :func:`arkouda.logical_not(self)`.
      It returns a boolean ``pdarray`` where each element is the
      logical negation of the corresponding element in ``self``.

      :returns: A boolean ``pdarray`` with the same shape as ``self``
                containing the result of the NOT operation.
      :rtype: pdarray

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> a = ak.array([True, False, True])
      >>> a.logical_not()
      array([False  True False])
      >>> ak.logical_not(a)
      array([False  True False])

      .. rubric:: Notes

      Works as a method of a ``pdarray`` (e.g. ``a.logical_not()``)
      or as a standalone function (e.g. ``ak.logical_not(a)``). For
      boolean arrays, this is equivalent to applying the unary ``~``
      operator. For numeric arrays, zero is treated as False and
      non-zero as True.



   .. py:method:: max(axis: Optional[Union[int, Tuple[int, Ellipsis]]] = None, keepdims: bool = False) -> Union[arkouda.numpy.dtypes.numeric_scalars, pdarray]

      Return max of array elements along the given axis.

      :param axis: The axis or axes along which to do the operation
                   If None, the computation is done across the entire array.
      :type axis: int, Tuple[int, ...], optional, default = None
      :param keepdims: Whether to keep the singleton dimension(s) along `axis` in the result.
      :type keepdims: bool, optional, default = False

      :returns: numeric_scalar if axis is omitted, in which case operation is done over entire array
                pdarray if axis is supplied, in which case the operation is done along that axis
      :rtype: numeric_scalar or pdarray

      :raises TypeError: Raised if pda is not a pdarray instance
      :raises RuntimeError: Raised if there's a server-side error thrown

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> ak.max(ak.array([1,2,3,4,5]))
      np.int64(5)
      >>> ak.max(ak.array([5.5,4.5,3.5,2.5,1.5]))
      np.float64(5.5)
      >>> ak.array([[1,2,3],[5,4,3]]).max(axis=1)
      array([3 5])

      .. rubric:: Notes

      Works as a method of a pdarray (e.g. a.max()) or a standalone function (e.g. ak.max(a))



   .. py:property:: max_bits


   .. py:method:: maxk(k: arkouda.numpy.dtypes.int_scalars) -> pdarray

      Compute the maximum "k" values.

      See ``arkouda.maxk`` for details.



   .. py:method:: mean(axis: Optional[Union[int, Tuple[int, Ellipsis]]] = None, keepdims: bool = False) -> Union[arkouda.numpy.dtypes.numeric_scalars, pdarray]

      Return the mean of the array.

      :param axis: The axis or axes along which to do the operation
                   If None, the computation is done across the entire array.
      :type axis: int, Tuple[int, ...], optional, default = None
      :param keepdims: Whether to keep the singleton dimension(s) along `axis` in the result.
      :type keepdims: bool, optional, default = False

      :returns: The mean calculated from the pda sum and size, along the axis/axes if
                those are given.
      :rtype: Union[np.float64, pdarray]

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> a = ak.arange(10)
      >>> ak.mean(a)
      np.float64(4.5)
      >>> a.mean()
      np.float64(4.5)
      >>> a = ak.arange(10).reshape(2,5)
      >>> a.mean(axis=0)
      array([2.5 3.5 4.5 5.5 6.5])
      >>> ak.mean(a,axis=0)
      array([2.5 3.5 4.5 5.5 6.5])
      >>> a.mean(axis=1)
      array([2.00000000000000000 7.00000000000000000])
      >>> ak.mean(a,axis=1)
      array([2.00000000000000000 7.00000000000000000])

      :raises Raised if pda is not a pdarray instance:

      RuntimeError
          Raised if there's a server-side error thrown



   .. py:method:: min(axis: Optional[Union[int, Tuple[int, Ellipsis]]] = None, keepdims: bool = False) -> Union[arkouda.numpy.dtypes.numeric_scalars, pdarray]

      Return min of array elements along the given axis.

      :param axis: The axis or axes along which to do the operation
                   If None, the computation is done across the entire array.
      :type axis: int, Tuple[int, ...], optional, default = None
      :param keepdims: Whether to keep the singleton dimension(s) along `axis` in the result.
      :type keepdims: bool, optional, default = False

      :returns: numeric_scalar if axis is omitted, in which case operation is done over entire array
                pdarray if axis is supplied, in which case the operation is done along that axis
      :rtype: numeric_scalar or pdarray

      :raises TypeError: Raised if pda is not a pdarray instance
      :raises RuntimeError: Raised if there's a server-side error thrown

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> ak.min(ak.array([1,2,3,4,5]))
      np.int64(1)
      >>> ak.min(ak.array([5.5,4.5,3.5,2.5,1.5]))
      np.float64(1.5)
      >>> ak.array([[1,2,3],[5,4,3]]).min(axis=1)
      array([1 3])

      .. rubric:: Notes

      Works as a method of a pdarray (e.g. a.min()) or a standalone function (e.g. ak.min(a))



   .. py:method:: mink(k: arkouda.numpy.dtypes.int_scalars) -> pdarray

      Compute the minimum "k" values.

      See ``arkouda.mink`` for details.



   .. py:attribute:: name
      :type:  str


   .. py:property:: nbytes

      The size of the pdarray in bytes.

      :returns: The size of the pdarray in bytes.
      :rtype: int


   .. py:attribute:: ndim
      :type:  arkouda.numpy.dtypes.int_scalars


   .. py:attribute:: objType
      :value: 'pdarray'



   .. py:method:: opeq(other, op)


   .. py:method:: parity() -> pdarray

      Find the parity (XOR of all bits) in each element.

      See `ak.parity`.



   .. py:method:: popcount() -> pdarray

      Find the population (number of bits set) in each element.

      See `ak.popcount`.



   .. py:method:: pretty_print_info() -> None

      Print information about all components of self in a human-readable format.



   .. py:method:: prod(axis: Optional[Union[int, Tuple[int, Ellipsis]]] = None, keepdims: bool = False) -> Union[arkouda.numpy.dtypes.numeric_scalars, pdarray]

      Return prod of array elements along the given axis.

      :param axis: The axis or axes along which to do the operation
                   If None, the computation is done across the entire array.
      :type axis: int, Tuple[int, ...], optional, defalt = None
      :param keepdims: Whether to keep the singleton dimension(s) along `axis` in the result.
      :type keepdims: bool, optional, default = False

      :returns: numeric_scalars if axis is omitted, in which case operation is done over entire array
                pdarray if axis is supplied, in which case the operation is done along that axis
      :rtype: numeric_scalars or pdarray

      :raises TypeError: Raised if pda is not a pdarray instance
      :raises RuntimeError: Raised if there's a server-side error thrown

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> ak.prod(ak.array([1,2,3,4,5]))
      np.int64(120)
      >>> ak.prod(ak.array([5.5,4.5,3.5,2.5,1.5]))
      np.float64(324.84375)
      >>> ak.array([[1,2,3],[5,4,3]]).prod(axis=1)
      array([6 60])

      .. rubric:: Notes

      Works as a method of a pdarray (e.g. a.prod()) or a standalone function (e.g. ak.prod(a))



   .. py:method:: register(user_defined_name: str) -> pdarray

      Register this pdarray with a user defined name in the arkouda server
      so it can be attached to later using pdarray.attach().

      This is an in-place operation, registering a pdarray more than once will
      update the name in the registry and remove the previously registered name.
      A name can only be registered to one pdarray at a time.

      :param user_defined_name: user defined name array is to be registered under
      :type user_defined_name: str

      :returns: The same pdarray which is now registered with the arkouda server and has an updated name.
                This is an in-place modification, the original is returned to support a
                fluid programming style.
                Please note you cannot register two different pdarrays with the same name.
      :rtype: pdarray

      :raises TypeError: Raised if user_defined_name is not a str
      :raises RegistrationError: If the server was unable to register the pdarray with the user_defined_name
          If the user is attempting to register more than one pdarray with the same name,
          the former should be unregistered first to free up the registration name.

      .. seealso:: :py:obj:`attach`, :py:obj:`unregister`, :py:obj:`is_registered`, :py:obj:`list_registry`, :py:obj:`unregister_pdarray_by_name`

      .. rubric:: Notes

      Registered names/pdarrays in the server are immune to deletion
      until they are unregistered.

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> a = ak.zeros(3)
      >>> a.register("my_zeros")
      array([0.00000000000000000 0.00000000000000000 0.00000000000000000])

      potentially disconnect from server and reconnect to server
      >>> b = ak.attach("my_zeros")
      >>> b.unregister()



   .. py:attribute:: registered_name
      :type:  Optional[str]
      :value: None



   .. py:method:: reshape(*shape)

      Gives a new shape to an array without changing its data.

      :param shape: The new shape should be compatible with the original shape.
      :type shape: int, tuple of ints, or pdarray

      :returns: a pdarray with the same data, reshaped to the new shape
      :rtype: pdarray

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> a = ak.array([[3,2,1],[2,3,1]])
      >>> a.reshape((3,2))
      array([array([3 2]) array([1 2]) array([3 1])])
      >>> a.reshape(3,2)
      array([array([3 2]) array([1 2]) array([3 1])])
      >>> a.reshape((6,1))
      array([array([3]) array([2]) array([1]) array([2]) array([3]) array([1])])

      .. rubric:: Notes

      only available as a method, not as a standalone function, i.e.,
      a.reshape(compatibleShape) is valid, but ak.reshape(a,compatibleShape) is not.



   .. py:method:: rotl(other) -> pdarray

      Rotate bits left by <other>.



   .. py:method:: rotr(other) -> pdarray

      Rotate bits right by <other>.



   .. py:property:: shape

      Return the shape of an array.

      :returns: The elements of the shape tuple give the lengths of the corresponding array dimensions.
      :rtype: tuple of int


   .. py:attribute:: size
      :type:  arkouda.numpy.dtypes.int_scalars


   .. py:method:: slice_bits(low, high) -> pdarray

      Return a pdarray containing only bits from low to high of self.

      This is zero indexed and inclusive on both ends, so slicing the bottom 64 bits is
      pda.slice_bits(0, 63)

      :param low: The lowest bit included in the slice (inclusive)
                  zero indexed, so the first bit is 0
      :type low: int
      :param high: The highest bit included in the slice (inclusive)
      :type high: int

      :returns: A new pdarray containing the bits of self from low to high
      :rtype: pdarray

      :raises RuntimeError: Raised if there is a server-side error thrown

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> p = ak.array([2**65 + (2**64 - 1)])
      >>> bin(p[0])
      '0b101111111111111111111111111111111111111111111111111111111111111111'
      >>> bin(p.slice_bits(64, 65)[0])
      '0b10'
      >>> a = ak.array([143,15])
      >>> a.slice_bits(1,3)
      array([7 7])
      >>> a.slice_bits(4,9)
      array([8 0])
      >>> a.slice_bits(1,9)
      array([71 7])



   .. py:method:: std(ddof: arkouda.numpy.dtypes.int_scalars = 0, axis: Optional[Union[int, Tuple[int, Ellipsis]]] = None, keepdims: Optional[bool] = False) -> Union[numpy.float64, pdarray]

      Return the standard deviation of values in the array. The standard
      deviation is implemented as the square root of the variance.

      :param ddof: "Delta Degrees of Freedom" used in calculating std
      :type ddof: int_scalars
      :param axis: The axis or axes along which to do the operation
                   If None, the computation is done across the entire array.
      :type axis: int, Tuple[int, ...], optional, default = None
      :param keepdims: Whether to keep the singleton dimension(s) along `axis` in the result.
      :type keepdims: bool, optional, default = False

      :returns:

                The scalar standard deviation of the array, or the standard deviation
                 along the axis/axes if supplied
      :rtype: Union[np.float64, pdarray]

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> a = ak.arange(10)
      >>> ak.std(a)
      np.float64(2.8722813232690143)
      >>> a.std()
      np.float64(2.8722813232690143)
      >>> a = ak.arange(10).reshape(2,5)
      >>> a.std(axis=0)
      array([2.5 2.5 2.5 2.5 2.5])
      >>> ak.std(a,axis=0)
      array([2.5 2.5 2.5 2.5 2.5])
      >>> a.std(axis=1)
      array([1.4142135623730951 1.4142135623730951])
      >>> ak.std(a,axis=1)
      array([1.4142135623730951 1.4142135623730951])

      :raises TypeError: Raised if pda is not a pdarray instance or ddof is not an integer
      :raises ValueError: Raised if ddof is an integer < 0
      :raises RuntimeError: Raised if there's a server-side error thrown

      .. seealso:: :py:obj:`mean`, :py:obj:`var`

      .. rubric:: Notes

      The standard deviation is the square root of the average of the squared
      deviations from the mean, i.e., ``std = sqrt(mean((x - x.mean())**2))``.

      The average squared deviation is normally calculated as
      ``x.sum() / N``, where ``N = len(x)``.  If, however, `ddof` is specified,
      the divisor ``N - ddof`` is used instead. In standard statistical
      practice, ``ddof=1`` provides an unbiased estimator of the variance
      of the infinite population. ``ddof=0`` provides a maximum likelihood
      estimate of the variance for normally distributed variables. The
      standard deviation computed in this function is the square root of
      the estimated variance, so even with ``ddof=1``, it will not be an
      unbiased estimate of the standard deviation per se.



   .. py:method:: sum(axis: Optional[Union[int, Tuple[int, Ellipsis]]] = None, keepdims: bool = False) -> Union[arkouda.numpy.dtypes.numeric_scalars, pdarray]

      Return sum of array elements along the given axis.

      :param axis: The axis or axes along which to do the operation
                   If None, the computation is done across the entire array.
      :type axis: int, Tuple[int, ...], optional, default = None
      :param keepdims: Whether to keep the singleton dimension(s) along `axis` in the result.
      :type keepdims: bool, optional, default = False

      :returns: numeric_scalars if axis is omitted, in which case operation is done over entire array
                pdarray if axis is supplied, in which case the operation is done along that axis
      :rtype: numeric_scalars or pdarray

      :raises TypeError: Raised if pda is not a pdarray instance
      :raises RuntimeError: Raised if there's a server-side error thrown

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> ak.sum(ak.array([1,2,3,4,5]))
      np.int64(15)
      >>> ak.sum(ak.array([5.5,4.5,3.5,2.5,1.5]))
      np.float64(17.5)
      >>> ak.array([[1,2,3],[5,4,3]]).sum(axis=1)
      array([6 12])

      .. rubric:: Notes

      Works as a method of a pdarray (e.g. a.sum()) or a standalone function (e.g. ak.sum(a))



   .. py:method:: take(indices: Union[arkouda.numpy.dtypes.numeric_scalars, pdarray], axis: Optional[int] = None) -> pdarray

      Take elements from the array along an axis.

      When axis is not None, this function does the same thing as fancy indexing (indexing arrays
      using arrays); however, it can be easier to use if you need elements along a given axis.
      A call such as ``np.take(arr, indices, axis=3)`` is equivalent to ``arr[:,:,:,indices,...]``.

      :param indices: The indices of the values to extract. Also allow scalars for indices.
      :type indices: numeric_scalars or pdarray
      :param axis: The axis over which to select values. By default, the flattened input array is used.
      :type axis: int, optional

      :returns: The returned array has the same type as `a`.
      :rtype: pdarray

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> a = ak.array([4, 3, 5, 7, 6, 8])
      >>> indices = [0, 1, 4]
      >>> a.take(indices)
      array([4 3 6])



   .. py:method:: to_csv(prefix_path: str, dataset: str = 'array', col_delim: str = ',', overwrite: bool = False)

      Write pdarry to CSV file(s).  File will contain a single column
      with the pdarray data.  All CSV files written by Arkouda include
      a header denoting data types of the columns.

      :param prefix_path: filename prefix to be used for saving files.  Files will have
                          _LOCALE#### appended when they are written to disk.
      :type prefix_path: str
      :param dataset: column name to save the pdarray under.
      :type dataset: str, defaults to "array"
      :param col_delim: value to be used to separate columns within the file.  Please
                        be sure that the value used DOES NOT appear in your dataset.
      :type col_delim: str, defaults to ","
      :param overwrite: If True, existing files matching the provided path will be overwritten.
                        if False and existing files are found, an error will be returned.
      :type overwrite: bool, defaults to False

      :returns: **response message**
      :rtype: str

      :raises ValueError: Raised if all datasets are not present in all parquet files or if one
          or more of the specified files do not exist
      :raises RuntimeError: Raised if one or more of the specified files cannot be opened.
          if 'allow_errors' is true, this may be raised if no values are returned
          from the server.
      :raises TypeError: Raise if the server returns an unknown arkouda_type

      .. rubric:: Notes

      - CSV format is not currently supported by load/load_all operations
      - The column delimiter is expected to be the same for all column names and data
      - Be sure that column delimiters are not found within your data.
      - All CSV files must delimit rows using newline ("\\n") at this time.



   .. py:method:: to_cuda()

      Convert the array to a Numba DeviceND array, transferring array data from the
      arkouda server to Python via ndarray. If the array exceeds a builtin size limit,
      a RuntimeError is raised.

      :returns: A Numba ndarray with the same attributes and data as the pdarray; on GPU
      :rtype: numba.DeviceNDArray

      :raises ImportError: Raised if CUDA is not available
      :raises ModuleNotFoundError: Raised if Numba is either not installed or not enabled
      :raises RuntimeError: Raised if there is a server-side error thrown in the course of retrieving
          the pdarray.

      .. rubric:: Notes

      The number of bytes in the array cannot exceed ``client.maxTransferBytes``,
      otherwise a ``RuntimeError`` will be raised. This is to protect the user
      from overflowing the memory of the system on which the Python client
      is running, under the assumption that the server is running on a
      distributed system with much more memory than the client. The user
      may override this limit by setting client.maxTransferBytes to a larger
      value, but proceed with caution.

      .. seealso:: :py:obj:`array`

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> a = ak.arange(0, 5, 1)
      >>> a.to_cuda() # doctest: +SKIP
      array([0, 1, 2, 3, 4])
      >>> type(a.to_cuda()) # doctest: +SKIP
      numpy.devicendarray



   .. py:method:: to_hdf(prefix_path: str, dataset: str = 'array', mode: Literal['truncate', 'append'] = 'truncate', file_type: Literal['single', 'distribute'] = 'distribute') -> str

      Save the pdarray to HDF5.
      The object can be saved to a collection of files or single file.

      :param prefix_path: Directory and filename prefix that all output files share
      :type prefix_path: str
      :param dataset: Name of the dataset to create in files (must not already exist)
      :type dataset: str
      :param mode: By default, truncate (overwrite) output files, if they exist.
                   If 'append', attempt to create new dataset in existing files.
      :type mode: {'truncate', 'append'}
      :param file_type: Default: "distribute"
                        When set to single, dataset is written to a single file.
                        When distribute, dataset is written on a file per locale.
                        This is only supported by HDF5 files and will have no impact of Parquet Files.
      :type file_type: {"single", "distribute"}

      :rtype: string message indicating result of save operation

      :raises RuntimeError: Raised if a server-side error is thrown saving the pdarray

      .. rubric:: Notes

      - The prefix_path must be visible to the arkouda server and the user must
      have write permission.
      - Output files have names of the form ``<prefix_path>_LOCALE<i>``, where ``<i>``
      ranges from 0 to ``numLocales`` for `file_type='distribute'`. Otherwise,
      the file name will be `prefix_path`.
      - If any of the output files already exist and
      the mode is 'truncate', they will be overwritten. If the mode is 'append'
      and the number of output files is less than the number of locales or a
      dataset with the same name already exists, a ``RuntimeError`` will result.
      - Any file extension can be used.The file I/O does not rely on the extension to
      determine the file format.

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> a = ak.arange(25)

      Saving without an extension
      >>> a.to_hdf('path/prefix', dataset='array') # doctest: +SKIP
      Saves the array to numLocales HDF5 files with the name ``cwd/path/name_prefix_LOCALE####``

      Saving with an extension (HDF5)
      >>> a.to_hdf('path/prefix.h5', dataset='array') # doctest: +SKIP
      Saves the array to numLocales HDF5 files with the name
      ``cwd/path/name_prefix_LOCALE####.h5`` where #### is replaced by each locale number

      Saving to a single file
      >>> a.to_hdf('path/prefix.hdf5', dataset='array', file_type='single') # doctest: +SKIP
      Saves the array in to single hdf5 file on the root node.
      ``cwd/path/name_prefix.hdf5``



   .. py:method:: to_ndarray() -> numpy.ndarray

      Convert the array to a np.ndarray, transferring array data from the
      Arkouda server to client-side Python. Note: if the pdarray size exceeds
      client.maxTransferBytes, a RuntimeError is raised.

      :returns: A numpy ndarray with the same attributes and data as the pdarray
      :rtype: np.ndarray

      :raises RuntimeError: Raised if there is a server-side error thrown, if the pdarray size
          exceeds the built-in client.maxTransferBytes size limit, or if the bytes
          received does not match expected number of bytes

      .. rubric:: Notes

      The number of bytes in the array cannot exceed ``client.maxTransferBytes``,
      otherwise a ``RuntimeError`` will be raised. This is to protect the user
      from overflowing the memory of the system on which the Python client
      is running, under the assumption that the server is running on a
      distributed system with much more memory than the client. The user
      may override this limit by setting client.maxTransferBytes to a larger
      value, but proceed with caution.

      .. seealso:: :py:obj:`array`, :py:obj:`tolist`

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> a = ak.arange(0, 5, 1)
      >>> a.to_ndarray()
      array([0, 1, 2, 3, 4])
      >>> type(a.to_ndarray())
      <class 'numpy.ndarray'>



   .. py:method:: to_parquet(prefix_path: str, dataset: str = 'array', mode: Literal['truncate', 'append'] = 'truncate', compression: Optional[str] = None) -> str

      Save the pdarray to Parquet. The result is a collection of files,
      one file per locale of the arkouda server, where each filename starts
      with prefix_path. Each locale saves its chunk of the array to its
      corresponding file.

      :param prefix_path: Directory and filename prefix that all output files share
      :type prefix_path: str
      :param dataset: Name of the dataset to create in files (must not already exist)
      :type dataset: str
      :param mode: By default, truncate (overwrite) output files, if they exist.
                   If 'append', attempt to create new dataset in existing files.
      :type mode: {'truncate', 'append'}
      :param compression: (None | "snappy" | "gzip" | "brotli" | "zstd" | "lz4")
                          Sets the compression type used with Parquet files
      :type compression: str (Optional)

      :rtype: string message indicating result of save operation

      :raises RuntimeError: Raised if a server-side error is thrown saving the pdarray

      .. rubric:: Notes

      - The prefix_path must be visible to the arkouda server and the user must
      have write permission.
      - Output files have names of the form ``<prefix_path>_LOCALE<i>``, where ``<i>``
      ranges from 0 to ``numLocales`` for `file_type='distribute'`.
      - 'append' write mode is supported, but is not efficient.
      - If any of the output files already exist and
      the mode is 'truncate', they will be overwritten. If the mode is 'append'
      and the number of output files is less than the number of locales or a
      dataset with the same name already exists, a ``RuntimeError`` will result.
      - Any file extension can be used.The file I/O does not rely on the extension to
      determine the file format.

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> a = ak.arange(25)

      Saving without an extension
      >>> a.to_parquet('path/prefix', dataset='array') # doctest: +SKIP
      Saves the array to numLocales HDF5 files with the name ``cwd/path/name_prefix_LOCALE####``

      Saving with an extension (HDF5)
      >>> a.to_parqet('path/prefix.parquet', dataset='array') # doctest: +SKIP
      Saves the array to numLocales HDF5 files with the name
      ``cwd/path/name_prefix_LOCALE####.parquet`` where #### is replaced by each locale number



   .. py:method:: tolist() -> List[arkouda.numpy.dtypes.numeric_scalars]

      Convert the array to a list, transferring array data from the
      Arkouda server to client-side Python. Note: if the pdarray size exceeds
      client.maxTransferBytes, a RuntimeError is raised.

      :returns: A list with the same data as the pdarray
      :rtype: List[numeric_scalars]

      :raises RuntimeError: Raised if there is a server-side error thrown, if the pdarray size
          exceeds the built-in client.maxTransferBytes size limit, or if the bytes
          received does not match expected number of bytes

      .. rubric:: Notes

      The number of bytes in the array cannot exceed ``client.maxTransferBytes``,
      otherwise a ``RuntimeError`` will be raised. This is to protect the user
      from overflowing the memory of the system on which the Python client
      is running, under the assumption that the server is running on a
      distributed system with much more memory than the client. The user
      may override this limit by setting client.maxTransferBytes to a larger
      value, but proceed with caution.

      .. seealso:: :py:obj:`to_ndarray`

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> a = ak.arange(0, 5, 1)
      >>> a.tolist()
      [0, 1, 2, 3, 4]
      >>> type(a.tolist())
      <class 'list'>



   .. py:method:: transfer(hostname: str, port: arkouda.numpy.dtypes.int_scalars)

      Send a pdarray to a different Arkouda server.

      :param hostname: The hostname where the Arkouda server intended to
                       receive the pdarray is running.
      :type hostname: str
      :param port: The port to send the array over. This needs to be an
                   open port (i.e., not one that the Arkouda server is
                   running on). This will open up `numLocales` ports,
                   each of which in succession, so will use ports of the
                   range {port..(port+numLocales)} (e.g., running an
                   Arkouda server of 4 nodes, port 1234 is passed as
                   `port`, Arkouda will use ports 1234, 1235, 1236,
                   and 1237 to send the array data).
                   This port much match the port passed to the call to
                   `ak.receive_array()`.
      :type port: int_scalars

      :rtype: A message indicating a complete transfer

      :raises ValueError: Raised if the op is not within the pdarray.BinOps set
      :raises TypeError: Raised if other is not a pdarray or the pdarray.dtype is not
          a supported dtype



   .. py:method:: unregister() -> None

      Unregister a pdarray in the arkouda server which was previously
      registered using register() and/or attahced to using attach().

      :raises RuntimeError: Raised if the server could not find the internal name/symbol to remove

      .. seealso:: :py:obj:`register`, :py:obj:`unregister`, :py:obj:`is_registered`, :py:obj:`unregister_pdarray_by_name`, :py:obj:`list_registry`

      .. rubric:: Notes

      Registered names/pdarrays in the server are immune to deletion until
      they are unregistered.

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> a = ak.zeros(3)
      >>> a.register("my_zeros")
      array([0.00000000000000000 0.00000000000000000 0.00000000000000000])

      potentially disconnect from server and reconnect to server
      >>> b = ak.attach("my_zeros")
      >>> b.unregister()



   .. py:method:: update_hdf(prefix_path: str, dataset: str = 'array', repack: bool = True)

      Overwrite the dataset with the name provided with this pdarray. If
      the dataset does not exist it is added.

      :param prefix_path: Directory and filename prefix that all output files share
      :type prefix_path: str
      :param dataset: Name of the dataset to create in files
      :type dataset: str
      :param repack: Default: True
                     HDF5 does not release memory on delete. When True, the inaccessible
                     data (that was overwritten) is removed. When False, the data remains, but is
                     inaccessible. Setting to false will yield better performance, but will cause
                     file sizes to expand.
      :type repack: bool

      :rtype: str - success message if successful

      :raises RuntimeError: Raised if a server-side error is thrown saving the pdarray

      .. rubric:: Notes

      - If file does not contain File_Format attribute to indicate how it was saved,
        the file name is checked for _LOCALE#### to determine if it is distributed.
      - If the dataset provided does not exist, it will be added



   .. py:method:: value_counts()

      Count the occurrences of the unique values of self.

      :returns:

                unique_values : pdarray
                    The unique values, sorted in ascending order

                counts : pdarray, int64
                    The number of times the corresponding unique value occurs
      :rtype: pdarray, pdarray|int64

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> ak.array([2, 0, 2, 4, 0, 0]).value_counts()
      (array([0 2 4]), array([3 2 1]))



   .. py:method:: var(ddof: arkouda.numpy.dtypes.int_scalars = 0, axis: Optional[Union[int, Tuple[int, Ellipsis]]] = None, keepdims: Optional[bool] = False) -> Union[numpy.float64, pdarray]

      Return the variance of values in the array.

      :param ddof: "Delta Degrees of Freedom" used in calculating var
      :type ddof: int_scalars
      :param axis: The axis or axes along which to do the operation
                   If None, the computation is done across the entire array.
      :type axis: int, Tuple[int, ...], optional, default = None
      :param keepdims: Whether to keep the singleton dimension(s) along `axis` in the result.
      :type keepdims: bool, optional, default = False

      :returns: The scalar variance of the array, or the variance along the axis/axes
                if supplied
      :rtype: Union[np.float64, pdarray]

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> a = ak.arange(10)
      >>> ak.var(a)
      np.float64(8.25)
      >>> a.var()
      np.float64(8.25)
      >>> a = ak.arange(10).reshape(2,5)
      >>> a.var(axis=0)
      array([6.25 6.25 6.25 6.25 6.25])
      >>> ak.var(a,axis=0)
      array([6.25 6.25 6.25 6.25 6.25])
      >>> a.var(axis=1)
      array([2.00000000000000000 2.00000000000000000])
      >>> ak.var(a,axis=1)
      array([2.00000000000000000 2.00000000000000000])

      :raises TypeError: Raised if pda is not a pdarray instance
      :raises ValueError: Raised if the ddof >= pdarray size
      :raises RuntimeError: Raised if there's a server-side error thrown

      .. seealso:: :py:obj:`mean`, :py:obj:`std`

      .. rubric:: Notes

      The variance is the average of the squared deviations from the mean,
      i.e.,  ``var = mean((x - x.mean())**2)``.

      The mean is normally calculated as ``x.sum() / N``, where ``N = len(x)``.
      If, however, `ddof` is specified, the divisor ``N - ddof`` is used
      instead.  In standard statistical practice, ``ddof=1`` provides an
      unbiased estimator of the variance of a hypothetical infinite population.
      ``ddof=0`` provides a maximum likelihood estimate of the variance for
      normally distributed variables.



.. py:function:: popcount(pda: pdarray) -> pdarray

   Find the population (number of bits set) for each integer in an array.

   :param pda: Input array (must be integral).
   :type pda: pdarray, int64, uint64, bigint

   :returns: The number of bits set (1) in each element
   :rtype: pdarray

   :raises TypeError: If input array is not int64, uint64, or bigint

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> A = ak.arange(10)
   >>> ak.popcount(A)
   array([0 1 1 2 1 2 2 3 1 2])


.. py:function:: power(pda: pdarray, pwr: Union[int, float, pdarray], where: Union[arkouda.numpy.dtypes.bool_scalars, pdarray] = True) -> pdarray

   Raises an array to a power. If where is given, the operation will only take place in the positions
   where the where condition is True.

   Note:
   Our implementation of the where argument deviates from numpy. The difference in behavior occurs
   at positions where the where argument contains a False. In numpy, these position will have
   uninitialized memory (which can contain anything and will vary between runs). We have chosen to
   instead return the value of the original array in these positions.

   :param pda: A pdarray of values that will be raised to a power (pwr)
   :type pda: pdarray
   :param pwr: The power(s) that pda is raised to
   :type pwr: integer, float, or pdarray
   :param where: This condition is broadcast over the input. At locations where the condition is True, the
                 corresponding value will be raised to the respective power. Elsewhere, it will retain its
                 original value. Default set to True.
   :type where: Boolean or pdarray

   :returns: a pdarray of values raised to a power, under the boolean where condition.
   :rtype: pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.arange(5)
   >>> ak.power(a, 3)
   array([0 1 8 27 64])
   >>> ak.power(a, 3, a % 2 == 0)
   array([0 1 8 3 64])

   :raises TypeError: raised if pda is not a pdarray, or if pwe is not an int, float, or pdarray
   :raises ValueError: raised if pda and power are of incompatible dimensions


.. py:function:: rotl(x, rot) -> pdarray

   Rotate bits of <x> to the left by <rot>.

   :param x: Value(s) to rotate left.
   :type x: pdarray(int64/uint64) or integer
   :param rot: Amount(s) to rotate by.
   :type rot: pdarray(int64/uint64) or integer

   :returns: The rotated elements of x.
   :rtype: pdarray

   :raises TypeError: If input array is not int64 or uint64

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> A = ak.arange(10)
   >>> ak.rotl(A, A)
   array([0 2 8 24 64 160 384 896 2048 4608])


.. py:function:: rotr(x, rot) -> pdarray

   Rotate bits of <x> to the left by <rot>.

   :param x: Value(s) to rotate left.
   :type x: pdarray(int64/uint64) or integer
   :param rot: Amount(s) to rotate by.
   :type rot: pdarray(int64/uint64) or integer

   :returns: The rotated elements of x.
   :rtype: pdarray

   :raises TypeError: If input array is not int64 or uint64

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> A = ak.arange(10)
   >>> ak.rotr(1024 * A, A)
   array([0 512 512 384 256 160 96 56 32 18])


.. py:function:: sqrt(pda: pdarray, where: Union[arkouda.numpy.dtypes.bool_scalars, pdarray] = True) -> pdarray

   Takes the square root of array. If where is given, the operation will only take place in
   the positions where the where condition is True.

   :param pda: A pdarray of values the square roots of which will be computed
   :type pda: pdarray
   :param where: This condition is broadcast over the input. At locations where the condition is True, the
                 corresponding value will be square rooted. Elsewhere, it will retain its original value.
                 Default set to True.
   :type where: Boolean or pdarray

   :returns: a pdarray of square roots of the original values, or the original values themselves,
             subject to the boolean where condition.
   :rtype: pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.arange(5)
   >>> ak.sqrt(a)
   array([0.00000000000000000 1.00000000000000000 1.4142135623730951
            1.7320508075688772 2.00000000000000000])
   >>> ak.sqrt(a, ak.array([True, True, False, False, True]))
   array([0.00000000000000000 1.00000000000000000 2.00000000000000000
            3.00000000000000000 2.00000000000000000])

   :raises TypeError: raised if pda is not a pdarray of ak.int64 or ak.float64

   .. rubric:: Notes

   Square roots of negative numbers are returned as nan.


