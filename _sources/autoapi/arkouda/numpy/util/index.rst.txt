arkouda.numpy.util
==================

.. py:module:: arkouda.numpy.util


Functions
---------

.. autoapisummary::

   arkouda.numpy.util.attach
   arkouda.numpy.util.attach_all
   arkouda.numpy.util.broadcast_arrays
   arkouda.numpy.util.broadcast_dims
   arkouda.numpy.util.broadcast_shapes
   arkouda.numpy.util.convert_bytes
   arkouda.numpy.util.convert_if_categorical
   arkouda.numpy.util.copy
   arkouda.numpy.util.generic_concat
   arkouda.numpy.util.get_callback
   arkouda.numpy.util.identity
   arkouda.numpy.util.invert_permutation
   arkouda.numpy.util.is_float
   arkouda.numpy.util.is_int
   arkouda.numpy.util.is_numeric
   arkouda.numpy.util.is_registered
   arkouda.numpy.util.map
   arkouda.numpy.util.may_share_memory
   arkouda.numpy.util.register
   arkouda.numpy.util.register_all
   arkouda.numpy.util.report_mem
   arkouda.numpy.util.shares_memory
   arkouda.numpy.util.sparse_sum_help
   arkouda.numpy.util.unregister
   arkouda.numpy.util.unregister_all


Module Contents
---------------

.. py:function:: attach(name: str)

   Attach a previously created Arkouda object by its registered name.

   This function retrieves an Arkouda object (e.g., `pdarray`, `DataFrame`,
   `Series`, etc.) associated with a given `name`. It returns the corresponding
   object based on the type of object stored under that name.

   :param name: The name of the object to attach.
   :type name: str

   :returns: The Arkouda object associated with the given `name`. The returned object
             could be of any supported type, such as `pdarray`, `DataFrame`, `Series`,
             etc.
   :rtype: object

   :raises ValueError: If the object type in the response message does not match any known types.

   .. rubric:: Examples

   >>> import arkouda as ak

   Attach an existing pdarray
   >>> obj = ak.array([1, 2, 3])
   >>> registered_obj = obj.register("my_array")
   >>> arr = ak.attach("my_array")
   >>> print(arr)
   [1 2 3]
   >>> registered_obj.unregister()


.. py:function:: attach_all(names: list)

   Attach to all objects registered with the provided names.

   This function returns a dictionary mapping each name in the input list
   to the corresponding Arkouda object retrieved using `attach`.

   :param names: A list of names corresponding to registered Arkouda objects.
   :type names: List of str

   :returns: A dictionary mapping each name to the attached Arkouda object.
   :rtype: dict

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> data = { "arr1": ak.array([0, 1, 2]), "arr2": ak.array([3, 4, 5]) }
   >>> ak.register_all(data)

   Assuming "arr1" and "arr2" were previously registered
   >>> attached_objs = ak.attach_all(["arr1", "arr2"])
   >>> print(attached_objs["arr1"])
   [0 1 2]
   >>> print(type(attached_objs["arr2"]))
   <class 'arkouda.numpy.pdarrayclass.pdarray'>
   >>> ak.unregister_all(["arr1", "arr2"])


.. py:function:: broadcast_arrays(*arrays: arkouda.numpy.pdarrayclass.pdarray) -> List[arkouda.numpy.pdarrayclass.pdarray]

   Broadcast arrays to a common shape.

   :param arrays: The arrays to broadcast. Must be broadcastable to a common shape.
   :type arrays: pdarray

   :returns: A list whose elements are the given Arrays broadcasted to the common shape.
   :rtype: List

   :raises ValueError: Raised by broadcast_to if a common shape cannot be determined.

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.arange(10).reshape(1,2,5)
   >>> b = ak.arange(20).reshape(4,1,5)
   >>> c = ak.broadcast_arrays(a,b)
   >>> c[0][0,:,:]
   array([array([0 1 2 3 4]) array([5 6 7 8 9])])
   >>> c[1][:,0,0]
   array([0 5 10 15])


.. py:function:: broadcast_dims(sa: Sequence[int], sb: Sequence[int]) -> Tuple[int, Ellipsis]

   Determine the broadcasted shape of two arrays given their shapes.

   This function implements the broadcasting rules from the Array API standard
   to compute the shape resulting from broadcasting two arrays together.

   See: https://data-apis.org/array-api/latest/API_specification/broadcasting.html#algorithm

   :param sa: The shape of the first array.
   :type sa: Sequence[int]
   :param sb: The shape of the second array.
   :type sb: Sequence[int]

   :returns: The broadcasted shape resulting from combining `sa` and `sb`.
   :rtype: Tuple[int, ...]

   :raises ValueError: If the shapes are not compatible for broadcasting.

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> from arkouda.numpy.util import broadcast_dims
   >>> broadcast_dims((5, 1), (1, 3))
   (5, 3)

   >>> broadcast_dims((4,), (3, 1))
   (3, 4)


.. py:function:: broadcast_shapes(*shapes: Tuple[int, Ellipsis]) -> Tuple[int, Ellipsis]

   Determine a broadcasted shape, given an arbitary number of shapes.

   This function implements the broadcasting rules from the Array API standard
   to compute the shape resulting from broadcasting two arrays together.

   See: https://data-apis.org/array-api/latest/API_specification/broadcasting.html#algorithm

   :param shapes: a list or tuple of the shapes to be broadcast
   :type shapes: Tuple[int, ...]

   :returns: The broadcasted shape
   :rtype: Tuple[int, ...]

   :raises ValueError: If the shapes are not compatible for broadcasting.

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.broadcast_shapes((1,2,3),(4,1,3),(4,2,1))
   (4, 2, 3)


.. py:function:: convert_bytes(nbytes: arkouda.numpy.dtypes.int_scalars, unit: Literal['B', 'KB', 'MB', 'GB'] = 'B') -> arkouda.numpy.dtypes.numeric_scalars

   Convert a number of bytes to a larger unit: KB, MB, or GB.

   :param nbytes: The number of bytes to convert.
   :type nbytes: int_scalars
   :param unit: The unit to convert to. One of {"B", "KB", "MB", "GB"}.
   :type unit: {"B", "KB", "MB", "GB"}, default="B"

   :returns: The converted value in the specified unit.
   :rtype: numeric_scalars

   :raises ValueError: If `unit` is not one of {"B", "KB", "MB", "GB"}.

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> from arkouda.numpy.util import convert_bytes
   >>> convert_bytes(2048, unit="KB")
   2.0

   >>> convert_bytes(1048576, unit="MB")
   1.0

   >>> convert_bytes(1073741824, unit="GB")
   1.0


.. py:function:: convert_if_categorical(values)

   Convert a Categorical array to a Strings array for display purposes.

   If the input is a Categorical, it is converted to its string labels
   based on its codes. If not, the input is returned unchanged.

   :param values: The input array, which may be a Categorical.
   :type values: Categorical or any

   :returns: The string labels if `values` is a Categorical, otherwise the original input.
   :rtype: Strings or original type

   .. rubric:: Examples

   >>> import arkouda as ak

   Example with a Categorical
   >>> categories = ak.array(["apple", "banana", "cherry"])
   >>> cat = ak.Categorical(categories)
   >>> result = convert_if_categorical(cat)
   >>> print(result)
   ['apple', 'banana', 'cherry']

   Example with a non-Categorical input
   >>> values = ak.array([1, 2, 3])
   >>> result = convert_if_categorical(values)
   >>> print(result)
   [1 2 3]


.. py:function:: copy(a: Union[arkouda.numpy.strings.Strings, arkouda.numpy.pdarrayclass.pdarray]) -> Union[arkouda.numpy.strings.Strings, arkouda.numpy.pdarrayclass.pdarray]

   Return a deep copy of the given Arkouda object.

   :param a: The object to copy.
   :type a: Union[Strings, pdarray]

   :returns: A deep copy of the pdarray or Strings object.
   :rtype: Union[Strings, pdarray]

   :raises TypeError: If the input is not a Strings or pdarray instance.


.. py:function:: generic_concat(items, ordered=True)

.. py:function:: get_callback(x)

.. py:function:: identity(x)

.. py:function:: invert_permutation(perm: arkouda.numpy.pdarrayclass.pdarray) -> arkouda.numpy.pdarrayclass.pdarray

   Compute the inverse of a permutation array.

   The inverse permutation undoes the effect of the original permutation.
   For a valid permutation array `perm`, this function returns an array `inv`
   such that `inv[perm[i]] == i` for all `i`.

   :param perm: A permutation of the integers `[0, N-1]`, where `N` is the length of the array.
   :type perm: pdarray

   :returns: The inverse of the input permutation.
   :rtype: pdarray

   :raises ValueError: If `perm` is not a valid permutation of the range `[0, N-1]`, such as
       containing duplicates or missing values.

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> from arkouda import array, invert_permutation
   >>> perm = array([2, 0, 3, 1])
   >>> inv = invert_permutation(perm)
   >>> print(inv)
   [1 3 0 2]


.. py:function:: is_float(arry: Union[arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.strings.Strings, arkouda.pandas.categorical.Categorical, arkouda.pandas.series.Series, arkouda.pandas.index.Index]) -> bool

   Check if the dtype of the given array-like object is a float type.

   :param arry: The object to check.
   :type arry: pdarray, Strings, Categorical, Series, or Index

   :returns: True if the dtype of `arry` is a float type, False otherwise.
   :rtype: bool

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> data = ak.array([1.0, 2, 3, 4, float('nan')])
   >>> ak.util.is_float(data)
   True

   >>> data2 = ak.arange(5)
   >>> ak.util.is_float(data2)
   False

   >>> strings = ak.array(["1.0", "2.0"])
   >>> ak.util.is_float(strings)
   False


.. py:function:: is_int(arry: Union[arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.strings.Strings, arkouda.pandas.categorical.Categorical, arkouda.pandas.series.Series, arkouda.pandas.index.Index]) -> bool

   Check if the dtype of the given array-like object is an integer type.

   :param arry: The object to check.
   :type arry: pdarray, Strings, Categorical, Series, or Index

   :returns: True if the dtype of `arry` is an integer type, False otherwise.
   :rtype: bool

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> data = ak.array([1.0, 2, 3, 4, float('nan')])
   >>> ak.util.is_int(data)
   False

   >>> data2 = ak.arange(5)
   >>> ak.util.is_int(data2)
   True

   >>> strings = ak.array(["1", "2"])
   >>> ak.util.is_int(strings)
   False


.. py:function:: is_numeric(arry: Union[arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.strings.Strings, arkouda.pandas.categorical.Categorical, arkouda.pandas.series.Series, arkouda.pandas.index.Index]) -> bool

   Check if the dtype of the given array-like object is numeric.

   :param arry: The object to check.
   :type arry: pdarray, Strings, Categorical, Series, or Index

   :returns: True if the dtype of `arry` is numeric, False otherwise.
   :rtype: bool

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> data = ak.array([1, 2, 3, 4, 5])
   >>> ak.util.is_numeric(data)
   True

   >>> strings = ak.array(["a", "b", "c"])
   >>> ak.util.is_numeric(strings)
   False

   >>> from arkouda import Categorical
   >>> cat = Categorical(strings)
   >>> ak.util.is_numeric(cat)
   False


.. py:function:: is_registered(name: str, as_component: bool = False) -> bool

   Determine if the provided name is associated with a registered Arkouda object.

   This function checks if the `name` is found in the registry of objects,
   and optionally checks if it is registered as a component of a registered object.

   :param name: The name to check for in the registry.
   :type name: str
   :param as_component: When True, the function checks if the name is registered as a component
                        of a registered object (rather than as a standalone object).
   :type as_component: bool, default=False

   :returns: `True` if the name is found in the registry, `False` otherwise.
   :rtype: bool

   :raises KeyError: If the registry query encounters an issue (e.g., invalid registry data or access issues).

   .. rubric:: Examples

   >>> import arkouda as ak

   Check if a name is registered as an object
   >>> obj = ak.array([1, 2, 3])
   >>> registered_obj = obj.register("my_array")
   >>> result = ak.is_registered("my_array")
   >>> print(result)
   True
   >>> registered_obj.unregister()

   Check if a name is registered as a component
   >>> result = ak.is_registered("my_component", as_component=True)
   >>> print(result)
   False


.. py:function:: map(values: Union[arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.strings.Strings, arkouda.pandas.categorical.Categorical], mapping: Union[dict, arkouda.Series]) -> Union[arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.strings.Strings]

   Map the values of an array according to an input mapping.

   :param values: The values to be mapped.
   :type values: pdarray, Strings, or Categorical
   :param mapping: The mapping correspondence. A dictionary or Series that defines how
                   to map the `values` array.
   :type mapping: dict or Series

   :returns: A new array with the values mapped by the provided mapping.
             The return type matches the type of `values`. If the input `Series`
             has Categorical values, the return type will be `Strings`.
   :rtype: Union[pdarray, Strings]

   :raises TypeError: If `mapping` is not of type `dict` or `Series`.
       If `values` is not of type `pdarray`, `Categorical`, or `Strings`.
   :raises ValueError: If a mapping with tuple keys has inconsistent lengths, or if a MultiIndex
       mapping has a different number of levels than the GroupBy keys.

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> from arkouda.numpy.util import map
   >>> a = ak.array([2, 3, 2, 3, 4])
   >>> a
   array([2 3 2 3 4])
   >>> ak.util.map(a, {4: 25.0, 2: 30.0, 1: 7.0, 3: 5.0})
   array([30.00000000000000000 5.00000000000000000 30.00000000000000000
   5.00000000000000000 25.00000000000000000])
   >>> s = ak.Series(ak.array(["a", "b", "c", "d"]), index=ak.array([4, 2, 1, 3]))
   >>> ak.util.map(a, s)
   array(['b', 'd', 'b', 'd', 'a'])


.. py:function:: may_share_memory(a, b)

   Conservative version akin to numpy.may_share_memory.

   For now it just defers to shares_memory.



.. py:function:: register(obj, name)

   Register an Arkouda object with a user-specified name.

   This function registers the provided Arkouda object (`obj`) under a
   given name (`name`). It is backwards compatible with earlier versions
   of Arkouda.

   :param obj: The Arkouda object to register.
   :type obj: Arkouda object
   :param name: The name to associate with the object.
   :type name: str

   :returns: The input object, now registered with the specified name.
   :rtype: Registered object

   :raises AttributeError: If `obj` does not have a `register` method.

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> from arkouda.numpy.util import register
   >>> obj = ak.array([1, 2, 3])
   >>> registered_obj = register(obj, "my_array")
   >>> print(registered_obj)
   [1 2 3]
   >>> registered_obj.unregister()

   Example of registering a different Arkouda object
   >>> categories = ak.array(["apple", "banana", "cherry"])
   >>> cat = ak.Categorical(categories)
   >>> registered_cat = register(cat, "my_cat")
   >>> print(registered_cat)
   ['apple', 'banana', 'cherry']


.. py:function:: register_all(data: dict)

   Register all objects in the provided dictionary.

   This function iterates through the dictionary `data`, registering each object
   with its corresponding name. It is useful for batch registering multiple
   objects in Arkouda.

   :param data: A dictionary that maps the name to register the object to the object itself.
                For example, {"MyArray": ak.array([0, 1, 2])}.
   :type data: dict

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> data = { "array1": ak.array([0, 1, 2]), "array2": ak.array([3, 4, 5]) }
   >>> ak.register_all(data)

   After calling this function, "array1" and "array2" are registered
   in Arkouda, and can be accessed by their names.
   >>> ak.unregister_all(["array1", "array2"])


.. py:function:: report_mem(pre='')

.. py:function:: shares_memory(a, b)

   Return True if `a` and `b` share any Arkouda server-side buffers.

   This is an Arkouda analogue of numpy.shares_memory with a simpler definition:
   it checks for identical backing buffer *identities* (same server object names).

   .. rubric:: Notes

   - Because Arkouda commonly *materializes* results (rather than views),
     aliasing is rare and usually only true when objects literally reference
     the same backing buffers.
   - For compound containers (e.g., SegArray, Strings, Categorical), we check
     all of their component buffers.
   - If you introduce true view semantics in the future, teach `_ak_buffer_names`
     to surface the base buffer name(s) and view descriptors, and compare bases.


.. py:function:: sparse_sum_help(idx1: arkouda.numpy.pdarrayclass.pdarray, idx2: arkouda.numpy.pdarrayclass.pdarray, val1: arkouda.numpy.pdarrayclass.pdarray, val2: arkouda.numpy.pdarrayclass.pdarray, merge: bool = True, percent_transfer_limit: int = 100) -> Tuple[arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.pdarrayclass.pdarray]

   Sum two sparse matrices together.

   This function returns the result of summing two sparse matrices by combining
   their indices and values. Internally, it performs the equivalent of:

       ak.GroupBy(ak.concatenate([idx1, idx2])).sum(ak.concatenate((val1, val2)))

   :param idx1: Indices for the first sparse matrix.
   :type idx1: pdarray
   :param idx2: Indices for the second sparse matrix.
   :type idx2: pdarray
   :param val1: Values for the first sparse matrix.
   :type val1: pdarray
   :param val2: Values for the second sparse matrix.
   :type val2: pdarray
   :param merge: If True, the indices are combined using a merge-based workflow.
                 If False, a sort-based workflow is used.
   :type merge: bool, default=True
   :param percent_transfer_limit: Only used when `merge` is True. This defines the maximum percentage of
                                  data allowed to move between locales during the merge. If this threshold
                                  is exceeded, a sort-based workflow is used instead.
   :type percent_transfer_limit: int, default=100

   :returns: A tuple containing:
             - The indices of the resulting sparse matrix.
             - The summed values associated with those indices.
   :rtype: Tuple[pdarray, pdarray]

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> idx1 = ak.array([0, 1, 3, 4, 7, 9])
   >>> idx2 = ak.array([0, 1, 3, 6, 9])
   >>> vals1 = idx1
   >>> vals2 = ak.array([10, 11, 13, 16, 19])
   >>> ak.util.sparse_sum_help(idx1, idx2, vals1, vals2)
   (array([0 1 3 4 6 7 9]), array([10 12 16 4 16 7 28]))

   >>> ak.GroupBy(ak.concatenate([idx1, idx2])).sum(ak.concatenate((vals1, vals2)))
   (array([0 1 3 4 6 7 9]), array([10 12 16 4 16 7 28]))


.. py:function:: unregister(name: str) -> str

   Unregister an Arkouda object by its name.

   This function sends a request to unregister the Arkouda object associated
   with the specified `name`. It returns a response message indicating the
   success or failure of the operation.

   :param name: The name of the object to unregister.
   :type name: str

   :returns: A message indicating the result of the unregister operation.
   :rtype: str

   :raises RuntimeError: If the object associated with the given `name` does not exist or cannot
       be unregistered.

   .. rubric:: Examples

   >>> import arkouda as ak

   Unregister an existing object
   >>> obj = ak.array([1, 2, 3])
   >>> registered_obj = obj.register("my_array")
   >>> response = ak.unregister("my_array")
   >>> print(response)
   Unregistered PDARRAY my_array


.. py:function:: unregister_all(names: List[str])

   Unregister all Arkouda objects associated with the provided names.

   This function iterates through the list of `names`, unregistering each
   corresponding object from the Arkouda server.

   :param names: A list of registered names corresponding to Arkouda objects
                 that should be unregistered.
   :type names: List of str

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> data = { "array1": ak.array([0, 1, 2]), "array2": ak.array([3, 4, 5]) }
   >>> ak.register_all(data)

   After calling this function, "array1" and "array2" are registered
   in Arkouda, and can be accessed by their names.
   >>> ak.unregister_all(["array1", "array2"])

   "arr1" and "arr2" are now unregistered


