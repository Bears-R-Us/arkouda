arkouda.numpy.pdarraysetops
===========================

.. py:module:: arkouda.numpy.pdarraysetops


Functions
---------

.. autoapisummary::

   arkouda.numpy.pdarraysetops.concatenate
   arkouda.numpy.pdarraysetops.in1d
   arkouda.numpy.pdarraysetops.indexof1d
   arkouda.numpy.pdarraysetops.intersect1d
   arkouda.numpy.pdarraysetops.setdiff1d
   arkouda.numpy.pdarraysetops.setxor1d
   arkouda.numpy.pdarraysetops.union1d


Module Contents
---------------

.. py:function:: concatenate(arrays: Sequence[Union[arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.strings.Strings, arkouda.pandas.categorical.Categorical]], axis: int = 0, ordered: bool = True) -> Union[arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.strings.Strings, arkouda.pandas.categorical.Categorical, Sequence[arkouda.pandas.categorical.Categorical]]

   Concatenate a list or tuple of ``pdarray`` or ``Strings`` objects into
   one ``pdarray`` or ``Strings`` object, respectively.

   :param arrays: The arrays to concatenate. Must all have same dtype.
   :type arrays: Sequence[Union[pdarray,Strings,Categorical]]
   :param axis: The axis along which the arrays will be joined.
                If axis is None, arrays are flattened before use. Only for use with pdarray, and when
                ordered is True. Default is 0.
   :type axis: int, default = 0
   :param ordered: If True (default), the arrays will be appended in the
                   order given. If False, array data may be interleaved
                   in blocks, which can greatly improve performance but
                   results in non-deterministic ordering of elements.
   :type ordered: bool

   :returns: Single pdarray or Strings object containing all values, returned in
             the original order
   :rtype: Union[pdarray,Strings,Categorical]

   :raises ValueError: Raised if arrays is empty or if pdarrays have differing dtypes
   :raises TypeError: Raised if arrays is not a pdarrays or Strings python Sequence such as a
       list or tuple
   :raises RuntimeError: Raised if any array elements are dtypes for which
       concatenate has not been implemented.

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.concatenate([ak.array([1, 2, 3]), ak.array([4, 5, 6])])
   array([1 2 3 4 5 6])

   >>> ak.concatenate([ak.array([True,False,True]),ak.array([False,True,True])])
   array([True False True False True True])

   >>> ak.concatenate([ak.array(['one','two']),ak.array(['three','four','five'])])
   array(['one', 'two', 'three', 'four', 'five'])


.. py:function:: in1d(A: arkouda.pandas.groupbyclass.groupable, B: arkouda.pandas.groupbyclass.groupable, assume_unique: bool = False, symmetric: bool = False, invert: bool = False) -> arkouda.pandas.groupbyclass.groupable

   Test whether each element of a 1-D array is also present in a second array.

   Returns a boolean array the same length as `A` that is True
   where an element of `A` is in `B` and False otherwise.

   Supports multi-level, i.e. test if rows of a are in the set of rows of b.
   But note that multi-dimensional pdarrays are not supported.

   :param A: Entries will be tested for membership in B
   :type A: list of pdarrays, pdarray, Strings, or Categorical
   :param B: The set of elements in which to test membership
   :type B: list of pdarrays, pdarray, Strings, or Categorical
   :param assume_unique: If true, assume rows of a and b are each unique and sorted.
                         By default, sort and unique them explicitly.
   :type assume_unique: bool, optional, defaults to False
   :param symmetric: Return in1d(A, B), in1d(B, A) when A and B are single items.
   :type symmetric: bool, optional, defaults to False
   :param invert: If True, the values in the returned array are inverted (that is,
                  False where an element of `A` is in `B` and True otherwise).
                  Default is False. ``ak.in1d(a, b, invert=True)`` is equivalent
                  to (but is faster than) ``~ak.in1d(a, b)``.
   :type invert: bool, optional, defaults to False

   :returns: True for each row in a that is contained in b
   :rtype: groupable

   :raises TypeError: Raised if either A or B is not a pdarray, Strings, or Categorical
       object, or if both are pdarrays and either has rank > 1,
       or if invert is not a bool
   :raises RuntimeError: Raised if the dtype of either array is not supported

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.in1d(ak.array([-1, 0, 1]), ak.array([-2, 0, 2]))
   array([False True False])

   >>> ak.in1d(ak.array(['one','two']),ak.array(['two', 'three','four','five']))
   array([False True])

   .. seealso:: :py:obj:`arkouda.pandas.groupbyclass.unique`, :py:obj:`intersect1d`, :py:obj:`union1d`

   .. rubric:: Notes

   `in1d` can be considered as an element-wise function version of the
   python keyword `in`, for 1-D sequences. ``in1d(a, b)`` is logically
   equivalent to ``ak.array([item in b for item in a])``, but is much
   faster and scales to arbitrarily large ``a``.

   ak.in1d is not supported for bool or float64 pdarrays


.. py:function:: indexof1d(query: arkouda.pandas.groupbyclass.groupable, space: arkouda.pandas.groupbyclass.groupable) -> arkouda.numpy.pdarrayclass.pdarray

   Return indices of query items in a search list of items. Items not found will be excluded.
   When duplicate terms are present in search space return indices of all occurrences.

   :param query: The items to search for. If multiple arrays, each "row" is an item.
   :type query: (sequence of) pdarray or Strings or Categorical
   :param space: The set of items in which to search. Must have same shape/dtype as query.
   :type space: (sequence of) pdarray or Strings or Categorical

   :returns: For each item in query that is found in space, its index in space.
   :rtype: pdarray

   .. rubric:: Notes

   This is an alias of
   `ak.find(query, space, all_occurrences=True, remove_missing=True).values`

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> select_from = ak.arange(10)
   >>> query = select_from[ak.randint(0, select_from.size, 20, seed=10)]
   >>> space = select_from[ak.randint(0, select_from.size, 20, seed=11)]

   remove some values to ensure that query has entries
   which don't appear in space

   >>> space = space[space != 9]
   >>> space = space[space != 3]

   >>> ak.indexof1d(query, space)
   array([0 4 1 3 10 2 6 12 13 5 7 8 9 14 5 7 11 15 5 7 0 4])

   :raises TypeError: Raised if either `query` or `space` is not a pdarray, Strings, or
       Categorical object
   :raises RuntimeError: Raised if the dtype of either array is not supported


.. py:function:: intersect1d(ar1: arkouda.pandas.groupbyclass.groupable, ar2: arkouda.pandas.groupbyclass.groupable, assume_unique: bool = False) -> Union[arkouda.numpy.pdarrayclass.pdarray, arkouda.pandas.groupbyclass.groupable]

   Find the intersection of two arrays.

   Return the sorted, unique values that are in both of the input arrays.

   :param ar1:
   :type ar1: list of pdarrays, pdarray, Strings, or Categorical
   :param ar2:
   :type ar2: list of pdarrays, pdarray, Strings, or Categorical
   :param assume_unique: If True, the input arrays are both assumed to be unique, which
                         can speed up the calculation.  Default is False.
   :type assume_unique: bool

   :returns: Sorted 1D array/List of sorted pdarrays of common and unique elements.
   :rtype: pdarray/groupable

   :raises TypeError: Raised if either ar1 or ar2 is not a groupable
   :raises RuntimeError: Raised if the dtype of either pdarray is not supported

   .. seealso:: :py:obj:`arkouda.pandas.groupbyclass.unique`, :py:obj:`union1d`

   .. rubric:: Examples

   >>> import arkouda as ak

   1D Example
   >>> ak.intersect1d(ak.array([1, 3, 4, 3]), ak.array([3, 1, 2, 1]))
   array([1 3])

   Multi-Array Example
   >>> a = ak.arange(5)
   >>> b = ak.array([1, 5, 3, 4, 2])
   >>> c = ak.array([1, 4, 3, 2, 5])
   >>> d = ak.array([1, 2, 3, 5, 4])
   >>> multia = [a, a, a]
   >>> multib = [b, c, d]
   >>> ak.intersect1d(multia, multib)
   [array([1 3]), array([1 3]), array([1 3])]


.. py:function:: setdiff1d(ar1: arkouda.pandas.groupbyclass.groupable, ar2: arkouda.pandas.groupbyclass.groupable, assume_unique: bool = False) -> Union[arkouda.numpy.pdarrayclass.pdarray, arkouda.pandas.groupbyclass.groupable]

   Find the set difference of two arrays.

   Return the sorted, unique values in `A` that are not in `B`.

   :param ar1:
   :type ar1: list of pdarrays, pdarray, Strings, or Categorical
   :param ar2:
   :type ar2: list of pdarrays, pdarray, Strings, or Categorical
   :param assume_unique: If True, the input arrays are both assumed to be unique, which
                         can speed up the calculation.  Default is False.
   :type assume_unique: bool

   :returns: Sorted 1D array/List of sorted pdarrays of values in `ar1` that are not in `ar2`.
   :rtype: pdarray/groupable

   :raises TypeError: Raised if either ar1 or ar2 is not a pdarray
   :raises RuntimeError: Raised if the dtype of either pdarray is not supported

   .. seealso:: :py:obj:`arkouda.pandas.groupbyclass.unique`, :py:obj:`setxor1d`

   .. rubric:: Notes

   ak.setdiff1d is not supported for bool pdarrays

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.array([1, 2, 3, 2, 4, 1])
   >>> b = ak.array([3, 4, 5, 6])
   >>> ak.setdiff1d(a, b)
   array([1 2])

   Multi-Array Example

   >>> a = ak.arange(1, 6)
   >>> b = ak.array([1, 5, 3, 4, 2])
   >>> c = ak.array([1, 4, 3, 2, 5])
   >>> d = ak.array([1, 2, 3, 5, 4])
   >>> multia = [a, a, a]
   >>> multib = [b, c, d]
   >>> ak.setdiff1d(multia, multib)
   [array([2 4 5]), array([2 4 5]), array([2 4 5])]


.. py:function:: setxor1d(ar1: arkouda.pandas.groupbyclass.groupable, ar2: arkouda.pandas.groupbyclass.groupable, assume_unique: bool = False) -> Union[arkouda.numpy.pdarrayclass.pdarray, arkouda.pandas.groupbyclass.groupable]

   Find the set exclusive-or (symmetric difference) of two arrays.

   Return the sorted, unique values that are in only one (not both) of the
   input arrays.

   :param ar1:
   :type ar1: list of pdarrays, pdarray, Strings, or Categorical
   :param ar2:
   :type ar2: list of pdarrays, pdarray, Strings, or Categorical
   :param assume_unique: If True, the input arrays are both assumed to be unique, which
                         can speed up the calculation.  Default is False.
   :type assume_unique: bool

   :returns: Sorted 1D array/List of sorted pdarrays of unique values that are in only one of the input
             arrays.
   :rtype: pdarray/groupable

   :raises TypeError: Raised if either ar1 or ar2 is not a groupable
   :raises RuntimeError: Raised if the dtype of either pdarray is not supported

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.array([1, 2, 3, 2, 4])
   >>> b = ak.array([2, 3, 5, 7, 5])
   >>> ak.setxor1d(a,b)
   array([1 4 5 7])

   Multi-Array Example

   >>> a = ak.arange(1, 6)
   >>> b = ak.array([1, 5, 3, 4, 2])
   >>> c = ak.array([1, 4, 3, 2, 5])
   >>> d = ak.array([1, 2, 3, 5, 4])
   >>> multia = [a, a, a]
   >>> multib = [b, c, d]
   >>> ak.setxor1d(multia, multib)
   [array([2 2 4 4 5 5]), array([2 5 2 4 4 5]), array([2 4 5 4 2 5])]


.. py:function:: union1d(ar1: arkouda.pandas.groupbyclass.groupable, ar2: arkouda.pandas.groupbyclass.groupable) -> arkouda.pandas.groupbyclass.groupable

   Find the union of two arrays/List of Arrays.

   Return the unique, sorted array of values that are in either
   of the two input arrays.

   :param ar1:
   :type ar1: list of pdarrays, pdarray, Strings, or Categorical
   :param ar2:
   :type ar2: list of pdarrays, pdarray, Strings, or Categorical

   :returns: Unique, sorted union of the input arrays.
   :rtype: groupable

   :raises TypeError: Raised if either ar1 or ar2 is not a groupable
   :raises RuntimeError: Raised if the dtype of either input is not supported

   .. seealso:: :py:obj:`intersect1d`, :py:obj:`arkouda.pandas.groupbyclass.unique`

   .. rubric:: Examples

   >>> import arkouda as ak

   1D Example
   >>> ak.union1d(ak.array([-1, 0, 1]), ak.array([-2, 0, 2]))
   array([-2 -1 0 1 2])

   Multi-Array Example
   >>> a = ak.arange(1, 6)
   >>> b = ak.array([1, 5, 3, 4, 2])
   >>> c = ak.array([1, 4, 3, 2, 5])
   >>> d = ak.array([1, 2, 3, 5, 4])
   >>> multia = [a, a, a]
   >>> multib = [b, c, d]
   >>> ak.union1d(multia, multib)
   [array([1 2 2 3 4 4 5 5]), array([1 2 5 3 2 4 4 5]), array([1 2 4 3 5 4 2 5])]


