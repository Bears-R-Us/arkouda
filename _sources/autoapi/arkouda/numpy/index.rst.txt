arkouda.numpy
=============

.. py:module:: arkouda.numpy


Attributes
----------

.. autoapisummary::

   arkouda.numpy.Inf
   arkouda.numpy.Infinity
   arkouda.numpy.NAN
   arkouda.numpy.NINF
   arkouda.numpy.NZERO
   arkouda.numpy.NaN
   arkouda.numpy.PINF
   arkouda.numpy.PZERO
   arkouda.numpy.e
   arkouda.numpy.euler_gamma
   arkouda.numpy.inf
   arkouda.numpy.infty
   arkouda.numpy.nan
   arkouda.numpy.newaxis
   arkouda.numpy.pi


Classes
-------

.. autoapisummary::

   arkouda.numpy.bool_
   arkouda.numpy.byte
   arkouda.numpy.cdouble
   arkouda.numpy.clongdouble
   arkouda.numpy.csingle
   arkouda.numpy.double
   arkouda.numpy.finfo
   arkouda.numpy.float32
   arkouda.numpy.float64
   arkouda.numpy.floating
   arkouda.numpy.half
   arkouda.numpy.iinfo
   arkouda.numpy.int16
   arkouda.numpy.int32
   arkouda.numpy.int64
   arkouda.numpy.int8
   arkouda.numpy.int_
   arkouda.numpy.intc
   arkouda.numpy.integer
   arkouda.numpy.intp
   arkouda.numpy.longdouble
   arkouda.numpy.longlong
   arkouda.numpy.number
   arkouda.numpy.short
   arkouda.numpy.signedinteger
   arkouda.numpy.single
   arkouda.numpy.ubyte
   arkouda.numpy.uint
   arkouda.numpy.uint16
   arkouda.numpy.uint32
   arkouda.numpy.uint64
   arkouda.numpy.uint8
   arkouda.numpy.uintc
   arkouda.numpy.ulonglong
   arkouda.numpy.ushort


Functions
---------

.. autoapisummary::

   arkouda.numpy.floor
   arkouda.numpy.isscalar
   arkouda.numpy.issubdtype


Module Contents
---------------

.. py:data:: Inf
   :type:  float

.. py:data:: Infinity
   :type:  float

.. py:data:: NAN
   :type:  float

.. py:data:: NINF
   :type:  float

.. py:data:: NZERO
   :type:  float

.. py:data:: NaN
   :type:  float

.. py:data:: PINF
   :type:  float

.. py:data:: PZERO
   :type:  float

.. py:class:: bool_(value)

   Bases: :py:obj:`numpy.generic`


   Boolean type (True or False), stored as a byte.

       .. warning::

          The :class:`bool_` type is not a subclass of the :class:`int_` type
          (the :class:`bool_` is not even a number type). This is different
          than Python's default implementation of :class:`bool` as a
          sub-class of :class:`int`.

       :Character code: ``'?'``



.. py:class:: byte(value)

   Bases: :py:obj:`numpy.signedinteger`


   Signed integer type, compatible with C ``char``.

       :Character code: ``'b'``
       :Canonical name: `numpy.byte`
       :Alias on this platform (Linux x86_64): `numpy.int8`: 8-bit signed integer (``-128`` to ``127``).



   .. py:method:: bit_count(*args, **kwargs)

      int8.bit_count() -> int

              Computes the number of 1-bits in the absolute value of the input.
              Analogous to the builtin `int.bit_count` or ``popcount`` in C++.

              Examples
              --------
              >>> np.int8(127).bit_count()
              7
              >>> np.int8(-127).bit_count()
              7




.. py:class:: cdouble(value)

   Bases: :py:obj:`numpy.complexfloating`


   Complex number type composed of two double-precision floating-point
       numbers, compatible with Python `complex`.

       :Character code: ``'D'``
       :Canonical name: `numpy.cdouble`
       :Alias: `numpy.cfloat`
       :Alias: `numpy.complex_`
       :Alias on this platform (Linux x86_64): `numpy.complex128`: Complex number type composed of 2 64-bit-precision floating-point numbers.



.. py:class:: clongdouble(value)

   Bases: :py:obj:`numpy.complexfloating`


   Complex number type composed of two extended-precision floating-point
       numbers.

       :Character code: ``'G'``
       :Alias: `numpy.clongfloat`
       :Alias: `numpy.longcomplex`
       :Alias on this platform (Linux x86_64): `numpy.complex256`: Complex number type composed of 2 128-bit extended-precision floating-point numbers.



.. py:class:: csingle(value)

   Bases: :py:obj:`numpy.complexfloating`


   Complex number type composed of two single-precision floating-point
       numbers.

       :Character code: ``'F'``
       :Canonical name: `numpy.csingle`
       :Alias: `numpy.singlecomplex`
       :Alias on this platform (Linux x86_64): `numpy.complex64`: Complex number type composed of 2 32-bit-precision floating-point numbers.



.. py:class:: double(value)

   Bases: :py:obj:`numpy.floating`


   Double-precision floating-point number type, compatible with Python `float`
       and C ``double``.

       :Character code: ``'d'``
       :Canonical name: `numpy.double`
       :Alias: `numpy.float_`
       :Alias on this platform (Linux x86_64): `numpy.float64`: 64-bit precision floating-point number type: sign bit, 11 bits exponent, 52 bits mantissa.



   .. py:method:: as_integer_ratio(*args, **kwargs)

      double.as_integer_ratio() -> (int, int)

              Return a pair of integers, whose ratio is exactly equal to the original
              floating point number, and with a positive denominator.
              Raise `OverflowError` on infinities and a `ValueError` on NaNs.

              >>> np.double(10.0).as_integer_ratio()
              (10, 1)
              >>> np.double(0.0).as_integer_ratio()
              (0, 1)
              >>> np.double(-.25).as_integer_ratio()
              (-1, 4)




   .. py:method:: fromhex(string, /)

      Create a floating-point number from a hexadecimal string.

      >>> float.fromhex('0x1.ffffp10')
      2047.984375
      >>> float.fromhex('-0x1p-1074')
      -5e-324




   .. py:method:: hex(/)

      Return a hexadecimal representation of a floating-point number.

      >>> (-0.1).hex()
      '-0x1.999999999999ap-4'
      >>> 3.14159.hex()
      '0x1.921f9f01b866ep+1'




   .. py:method:: is_integer(*args, **kwargs)

      double.is_integer() -> bool

              Return ``True`` if the floating point number is finite with integral
              value, and ``False`` otherwise.

              .. versionadded:: 1.22

              Examples
              --------
              >>> np.double(-2.0).is_integer()
              True
              >>> np.double(3.2).is_integer()
              False




.. py:data:: e
   :type:  float

.. py:data:: euler_gamma
   :type:  float

.. py:class:: finfo

   finfo(dtype)

   Machine limits for floating point types.

   .. attribute:: bits

      The number of bits occupied by the type.

      :type: int

   .. attribute:: dtype

      Returns the dtype for which `finfo` returns information. For complex
      input, the returned dtype is the associated ``float*`` dtype for its
      real and complex components.

      :type: dtype

   .. attribute:: eps

      The difference between 1.0 and the next smallest representable float
      larger than 1.0. For example, for 64-bit binary floats in the IEEE-754
      standard, ``eps = 2**-52``, approximately 2.22e-16.

      :type: float

   .. attribute:: epsneg

      The difference between 1.0 and the next smallest representable float
      less than 1.0. For example, for 64-bit binary floats in the IEEE-754
      standard, ``epsneg = 2**-53``, approximately 1.11e-16.

      :type: float

   .. attribute:: iexp

      The number of bits in the exponent portion of the floating point
      representation.

      :type: int

   .. attribute:: machep

      The exponent that yields `eps`.

      :type: int

   .. attribute:: max

      The largest representable number.

      :type: floating point number of the appropriate type

   .. attribute:: maxexp

      The smallest positive power of the base (2) that causes overflow.

      :type: int

   .. attribute:: min

      The smallest representable number, typically ``-max``.

      :type: floating point number of the appropriate type

   .. attribute:: minexp

      The most negative power of the base (2) consistent with there
      being no leading 0's in the mantissa.

      :type: int

   .. attribute:: negep

      The exponent that yields `epsneg`.

      :type: int

   .. attribute:: nexp

      The number of bits in the exponent including its sign and bias.

      :type: int

   .. attribute:: nmant

      The number of bits in the mantissa.

      :type: int

   .. attribute:: precision

      The approximate number of decimal digits to which this kind of
      float is precise.

      :type: int

   .. attribute:: resolution

      The approximate decimal resolution of this type, i.e.,
      ``10**-precision``.

      :type: floating point number of the appropriate type

   .. attribute:: tiny

      An alias for `smallest_normal`, kept for backwards compatibility.

      :type: float

   .. attribute:: smallest_normal

      The smallest positive floating point number with 1 as leading bit in
      the mantissa following IEEE-754 (see Notes).

      :type: float

   .. attribute:: smallest_subnormal

      The smallest positive floating point number with 0 as leading bit in
      the mantissa following IEEE-754.

      :type: float

   :param dtype: Kind of floating point or complex floating point
                 data-type about which to get information.
   :type dtype: float, dtype, or instance

   .. seealso::

      :obj:`iinfo`
          The equivalent for integer data types.

      :obj:`spacing`
          The distance between a value and the nearest adjacent number

      :obj:`nextafter`
          The next floating point value after x1 towards x2

   .. rubric:: Notes

   For developers of NumPy: do not instantiate this at the module level.
   The initial calculation of these parameters is expensive and negatively
   impacts import times.  These objects are cached, so calling ``finfo()``
   repeatedly inside your functions is not a problem.

   Note that ``smallest_normal`` is not actually the smallest positive
   representable value in a NumPy floating point type. As in the IEEE-754
   standard [1]_, NumPy floating point types make use of subnormal numbers to
   fill the gap between 0 and ``smallest_normal``. However, subnormal numbers
   may have significantly reduced precision [2]_.

   This function can also be used for complex data types as well. If used,
   the output will be the same as the corresponding real float type
   (e.g. numpy.finfo(numpy.csingle) is the same as numpy.finfo(numpy.single)).
   However, the output is true for the real and imaginary components.

   .. rubric:: References

   .. [1] IEEE Standard for Floating-Point Arithmetic, IEEE Std 754-2008,
          pp.1-70, 2008, http://www.doi.org/10.1109/IEEESTD.2008.4610935
   .. [2] Wikipedia, "Denormal Numbers",
          https://en.wikipedia.org/wiki/Denormal_number

   .. rubric:: Examples

   >>> np.finfo(np.float64).dtype
   dtype('float64')
   >>> np.finfo(np.complex64).dtype
   dtype('float32')


   .. py:property:: smallest_normal
      Return the value for the smallest normal.

      :returns: **smallest_normal** -- Value for the smallest normal.
      :rtype: float

      :Warns: **UserWarning** -- If the calculated value for the smallest normal is requested for
              double-double.


   .. py:property:: tiny
      Return the value for tiny, alias of smallest_normal.

      :returns: **tiny** -- Value for the smallest normal, alias of smallest_normal.
      :rtype: float

      :Warns: **UserWarning** -- If the calculated value for the smallest normal is requested for
              double-double.


.. py:class:: float32(value)

   Bases: :py:obj:`numpy.floating`


   Single-precision floating-point number type, compatible with C ``float``.

       :Character code: ``'f'``
       :Canonical name: `numpy.single`
       :Alias on this platform (Linux x86_64): `numpy.float32`: 32-bit-precision floating-point number type: sign bit, 8 bits exponent, 23 bits mantissa.



   .. py:method:: as_integer_ratio(*args, **kwargs)

      single.as_integer_ratio() -> (int, int)

              Return a pair of integers, whose ratio is exactly equal to the original
              floating point number, and with a positive denominator.
              Raise `OverflowError` on infinities and a `ValueError` on NaNs.

              >>> np.single(10.0).as_integer_ratio()
              (10, 1)
              >>> np.single(0.0).as_integer_ratio()
              (0, 1)
              >>> np.single(-.25).as_integer_ratio()
              (-1, 4)




   .. py:method:: is_integer(*args, **kwargs)

      single.is_integer() -> bool

              Return ``True`` if the floating point number is finite with integral
              value, and ``False`` otherwise.

              .. versionadded:: 1.22

              Examples
              --------
              >>> np.single(-2.0).is_integer()
              True
              >>> np.single(3.2).is_integer()
              False




.. py:class:: float64(value)

   Bases: :py:obj:`numpy.floating`


   Double-precision floating-point number type, compatible with Python `float`
       and C ``double``.

       :Character code: ``'d'``
       :Canonical name: `numpy.double`
       :Alias: `numpy.float_`
       :Alias on this platform (Linux x86_64): `numpy.float64`: 64-bit precision floating-point number type: sign bit, 11 bits exponent, 52 bits mantissa.



   .. py:method:: as_integer_ratio(*args, **kwargs)

      double.as_integer_ratio() -> (int, int)

              Return a pair of integers, whose ratio is exactly equal to the original
              floating point number, and with a positive denominator.
              Raise `OverflowError` on infinities and a `ValueError` on NaNs.

              >>> np.double(10.0).as_integer_ratio()
              (10, 1)
              >>> np.double(0.0).as_integer_ratio()
              (0, 1)
              >>> np.double(-.25).as_integer_ratio()
              (-1, 4)




   .. py:method:: fromhex(string, /)

      Create a floating-point number from a hexadecimal string.

      >>> float.fromhex('0x1.ffffp10')
      2047.984375
      >>> float.fromhex('-0x1p-1074')
      -5e-324




   .. py:method:: hex(/)

      Return a hexadecimal representation of a floating-point number.

      >>> (-0.1).hex()
      '-0x1.999999999999ap-4'
      >>> 3.14159.hex()
      '0x1.921f9f01b866ep+1'




   .. py:method:: is_integer(*args, **kwargs)

      double.is_integer() -> bool

              Return ``True`` if the floating point number is finite with integral
              value, and ``False`` otherwise.

              .. versionadded:: 1.22

              Examples
              --------
              >>> np.double(-2.0).is_integer()
              True
              >>> np.double(3.2).is_integer()
              False




.. py:class:: floating(value)

   Bases: :py:obj:`numpy.inexact`


   Abstract base class of all floating-point scalar types.



.. py:function:: floor(pda: arkouda.pdarrayclass.pdarray) -> arkouda.pdarrayclass.pdarray

   Return the element-wise floor of the array.

   :param pda:
   :type pda: pdarray

   :returns: A pdarray containing floor values of the input array elements
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray

   .. rubric:: Examples

   >>> ak.floor(ak.linspace(1.1,5.5,5))
   array([1, 2, 3, 4, 5])


.. py:class:: half(value)

   Bases: :py:obj:`numpy.floating`


   Half-precision floating-point number type.

       :Character code: ``'e'``
       :Canonical name: `numpy.half`
       :Alias on this platform (Linux x86_64): `numpy.float16`: 16-bit-precision floating-point number type: sign bit, 5 bits exponent, 10 bits mantissa.



   .. py:method:: as_integer_ratio(*args, **kwargs)

      half.as_integer_ratio() -> (int, int)

              Return a pair of integers, whose ratio is exactly equal to the original
              floating point number, and with a positive denominator.
              Raise `OverflowError` on infinities and a `ValueError` on NaNs.

              >>> np.half(10.0).as_integer_ratio()
              (10, 1)
              >>> np.half(0.0).as_integer_ratio()
              (0, 1)
              >>> np.half(-.25).as_integer_ratio()
              (-1, 4)




   .. py:method:: is_integer(*args, **kwargs)

      half.is_integer() -> bool

              Return ``True`` if the floating point number is finite with integral
              value, and ``False`` otherwise.

              .. versionadded:: 1.22

              Examples
              --------
              >>> np.half(-2.0).is_integer()
              True
              >>> np.half(3.2).is_integer()
              False




.. py:class:: iinfo

   iinfo(type)

   Machine limits for integer types.

   .. attribute:: bits

      The number of bits occupied by the type.

      :type: int

   .. attribute:: dtype

      Returns the dtype for which `iinfo` returns information.

      :type: dtype

   .. attribute:: min

      The smallest integer expressible by the type.

      :type: int

   .. attribute:: max

      The largest integer expressible by the type.

      :type: int

   :param int_type: The kind of integer data type to get information about.
   :type int_type: integer type, dtype, or instance

   .. seealso::

      :obj:`finfo`
          The equivalent for floating point data types.

   .. rubric:: Examples

   With types:

   >>> ii16 = np.iinfo(np.int16)
   >>> ii16.min
   -32768
   >>> ii16.max
   32767
   >>> ii32 = np.iinfo(np.int32)
   >>> ii32.min
   -2147483648
   >>> ii32.max
   2147483647

   With instances:

   >>> ii32 = np.iinfo(np.int32(10))
   >>> ii32.min
   -2147483648
   >>> ii32.max
   2147483647


   .. py:property:: max
      Maximum value of given dtype.


   .. py:property:: min
      Minimum value of given dtype.


.. py:data:: inf
   :type:  float

.. py:data:: infty
   :type:  float

.. py:class:: int16(value)

   Bases: :py:obj:`numpy.signedinteger`


   Signed integer type, compatible with C ``short``.

       :Character code: ``'h'``
       :Canonical name: `numpy.short`
       :Alias on this platform (Linux x86_64): `numpy.int16`: 16-bit signed integer (``-32_768`` to ``32_767``).



   .. py:method:: bit_count(*args, **kwargs)

      int16.bit_count() -> int

              Computes the number of 1-bits in the absolute value of the input.
              Analogous to the builtin `int.bit_count` or ``popcount`` in C++.

              Examples
              --------
              >>> np.int16(127).bit_count()
              7
              >>> np.int16(-127).bit_count()
              7




.. py:class:: int32(value)

   Bases: :py:obj:`numpy.signedinteger`


   Signed integer type, compatible with C ``int``.

       :Character code: ``'i'``
       :Canonical name: `numpy.intc`
       :Alias on this platform (Linux x86_64): `numpy.int32`: 32-bit signed integer (``-2_147_483_648`` to ``2_147_483_647``).



   .. py:method:: bit_count(*args, **kwargs)

      int32.bit_count() -> int

              Computes the number of 1-bits in the absolute value of the input.
              Analogous to the builtin `int.bit_count` or ``popcount`` in C++.

              Examples
              --------
              >>> np.int32(127).bit_count()
              7
              >>> np.int32(-127).bit_count()
              7




.. py:class:: int64(value)

   Bases: :py:obj:`numpy.signedinteger`


   Signed integer type, compatible with Python `int` and C ``long``.

       :Character code: ``'l'``
       :Canonical name: `numpy.int_`
       :Alias on this platform (Linux x86_64): `numpy.int64`: 64-bit signed integer (``-9_223_372_036_854_775_808`` to ``9_223_372_036_854_775_807``).
       :Alias on this platform (Linux x86_64): `numpy.intp`: Signed integer large enough to fit pointer, compatible with C ``intptr_t``.



   .. py:method:: bit_count(*args, **kwargs)

      int64.bit_count() -> int

              Computes the number of 1-bits in the absolute value of the input.
              Analogous to the builtin `int.bit_count` or ``popcount`` in C++.

              Examples
              --------
              >>> np.int64(127).bit_count()
              7
              >>> np.int64(-127).bit_count()
              7




.. py:class:: int8(value)

   Bases: :py:obj:`numpy.signedinteger`


   Signed integer type, compatible with C ``char``.

       :Character code: ``'b'``
       :Canonical name: `numpy.byte`
       :Alias on this platform (Linux x86_64): `numpy.int8`: 8-bit signed integer (``-128`` to ``127``).



   .. py:method:: bit_count(*args, **kwargs)

      int8.bit_count() -> int

              Computes the number of 1-bits in the absolute value of the input.
              Analogous to the builtin `int.bit_count` or ``popcount`` in C++.

              Examples
              --------
              >>> np.int8(127).bit_count()
              7
              >>> np.int8(-127).bit_count()
              7




.. py:class:: int_(value)

   Bases: :py:obj:`numpy.signedinteger`


   Signed integer type, compatible with Python `int` and C ``long``.

       :Character code: ``'l'``
       :Canonical name: `numpy.int_`
       :Alias on this platform (Linux x86_64): `numpy.int64`: 64-bit signed integer (``-9_223_372_036_854_775_808`` to ``9_223_372_036_854_775_807``).
       :Alias on this platform (Linux x86_64): `numpy.intp`: Signed integer large enough to fit pointer, compatible with C ``intptr_t``.



   .. py:method:: bit_count(*args, **kwargs)

      int64.bit_count() -> int

              Computes the number of 1-bits in the absolute value of the input.
              Analogous to the builtin `int.bit_count` or ``popcount`` in C++.

              Examples
              --------
              >>> np.int64(127).bit_count()
              7
              >>> np.int64(-127).bit_count()
              7




.. py:class:: intc(value)

   Bases: :py:obj:`numpy.signedinteger`


   Signed integer type, compatible with C ``int``.

       :Character code: ``'i'``
       :Canonical name: `numpy.intc`
       :Alias on this platform (Linux x86_64): `numpy.int32`: 32-bit signed integer (``-2_147_483_648`` to ``2_147_483_647``).



   .. py:method:: bit_count(*args, **kwargs)

      int32.bit_count() -> int

              Computes the number of 1-bits in the absolute value of the input.
              Analogous to the builtin `int.bit_count` or ``popcount`` in C++.

              Examples
              --------
              >>> np.int32(127).bit_count()
              7
              >>> np.int32(-127).bit_count()
              7




.. py:class:: integer(value)

   Bases: :py:obj:`numpy.number`


   Abstract base class of all integer scalar types.



   .. py:method:: denominator(*args, **kwargs)

      denominator of value (1)




   .. py:method:: is_integer(*args, **kwargs)

      integer.is_integer() -> bool

          Return ``True`` if the number is finite with integral value.

          .. versionadded:: 1.22

          Examples
          --------
          >>> np.int64(-2).is_integer()
          True
          >>> np.uint32(5).is_integer()
          True




   .. py:method:: numerator(*args, **kwargs)

      numerator of value (the value itself)




.. py:class:: intp(value)

   Bases: :py:obj:`numpy.signedinteger`


   Signed integer type, compatible with Python `int` and C ``long``.

       :Character code: ``'l'``
       :Canonical name: `numpy.int_`
       :Alias on this platform (Linux x86_64): `numpy.int64`: 64-bit signed integer (``-9_223_372_036_854_775_808`` to ``9_223_372_036_854_775_807``).
       :Alias on this platform (Linux x86_64): `numpy.intp`: Signed integer large enough to fit pointer, compatible with C ``intptr_t``.



   .. py:method:: bit_count(*args, **kwargs)

      int64.bit_count() -> int

              Computes the number of 1-bits in the absolute value of the input.
              Analogous to the builtin `int.bit_count` or ``popcount`` in C++.

              Examples
              --------
              >>> np.int64(127).bit_count()
              7
              >>> np.int64(-127).bit_count()
              7




.. py:function:: isscalar(element)

   Returns True if the type of `element` is a scalar type.

   :param element: Input argument, can be of any type and shape.
   :type element: any

   :returns: **val** -- True if `element` is a scalar type, False if it is not.
   :rtype: bool

   .. seealso::

      :obj:`ndim`
          Get the number of dimensions of an array

   .. rubric:: Notes

   If you need a stricter way to identify a *numerical* scalar, use
   ``isinstance(x, numbers.Number)``, as that returns ``False`` for most
   non-numerical elements such as strings.

   In most cases ``np.ndim(x) == 0`` should be used instead of this function,
   as that will also return true for 0d arrays. This is how numpy overloads
   functions in the style of the ``dx`` arguments to `gradient` and the ``bins``
   argument to `histogram`. Some key differences:

   +--------------------------------------+---------------+-------------------+
   | x                                    |``isscalar(x)``|``np.ndim(x) == 0``|
   +======================================+===============+===================+
   | PEP 3141 numeric objects (including  | ``True``      | ``True``          |
   | builtins)                            |               |                   |
   +--------------------------------------+---------------+-------------------+
   | builtin string and buffer objects    | ``True``      | ``True``          |
   +--------------------------------------+---------------+-------------------+
   | other builtin objects, like          | ``False``     | ``True``          |
   | `pathlib.Path`, `Exception`,         |               |                   |
   | the result of `re.compile`           |               |                   |
   +--------------------------------------+---------------+-------------------+
   | third-party objects like             | ``False``     | ``True``          |
   | `matplotlib.figure.Figure`           |               |                   |
   +--------------------------------------+---------------+-------------------+
   | zero-dimensional numpy arrays        | ``False``     | ``True``          |
   +--------------------------------------+---------------+-------------------+
   | other numpy arrays                   | ``False``     | ``False``         |
   +--------------------------------------+---------------+-------------------+
   | `list`, `tuple`, and other sequence  | ``False``     | ``False``         |
   | objects                              |               |                   |
   +--------------------------------------+---------------+-------------------+

   .. rubric:: Examples

   >>> np.isscalar(3.1)
   True
   >>> np.isscalar(np.array(3.1))
   False
   >>> np.isscalar([3.1])
   False
   >>> np.isscalar(False)
   True
   >>> np.isscalar('numpy')
   True

   NumPy supports PEP 3141 numbers:

   >>> from fractions import Fraction
   >>> np.isscalar(Fraction(5, 17))
   True
   >>> from numbers import Number
   >>> np.isscalar(Number())
   True


.. py:function:: issubdtype(arg1, arg2)

   Returns True if first argument is a typecode lower/equal in type hierarchy.

   This is like the builtin :func:`issubclass`, but for `dtype`\ s.

   :param arg1: `dtype` or object coercible to one
   :type arg1: dtype_like
   :param arg2: `dtype` or object coercible to one
   :type arg2: dtype_like

   :returns: **out**
   :rtype: bool

   .. seealso::

      :ref:`arrays.scalars`
          Overview of the numpy type hierarchy.

      :obj:`issubsctype`, :obj:`issubclass_`

   .. rubric:: Examples

   `issubdtype` can be used to check the type of arrays:

   >>> ints = np.array([1, 2, 3], dtype=np.int32)
   >>> np.issubdtype(ints.dtype, np.integer)
   True
   >>> np.issubdtype(ints.dtype, np.floating)
   False

   >>> floats = np.array([1, 2, 3], dtype=np.float32)
   >>> np.issubdtype(floats.dtype, np.integer)
   False
   >>> np.issubdtype(floats.dtype, np.floating)
   True

   Similar types of different sizes are not subdtypes of each other:

   >>> np.issubdtype(np.float64, np.float32)
   False
   >>> np.issubdtype(np.float32, np.float64)
   False

   but both are subtypes of `floating`:

   >>> np.issubdtype(np.float64, np.floating)
   True
   >>> np.issubdtype(np.float32, np.floating)
   True

   For convenience, dtype-like objects are allowed too:

   >>> np.issubdtype('S1', np.string_)
   True
   >>> np.issubdtype('i4', np.signedinteger)
   True


.. py:class:: longdouble(value)

   Bases: :py:obj:`numpy.floating`


   Extended-precision floating-point number type, compatible with C
       ``long double`` but not necessarily with IEEE 754 quadruple-precision.

       :Character code: ``'g'``
       :Alias: `numpy.longfloat`
       :Alias on this platform (Linux x86_64): `numpy.float128`: 128-bit extended-precision floating-point number type.



   .. py:method:: as_integer_ratio(*args, **kwargs)

      longdouble.as_integer_ratio() -> (int, int)

              Return a pair of integers, whose ratio is exactly equal to the original
              floating point number, and with a positive denominator.
              Raise `OverflowError` on infinities and a `ValueError` on NaNs.

              >>> np.longdouble(10.0).as_integer_ratio()
              (10, 1)
              >>> np.longdouble(0.0).as_integer_ratio()
              (0, 1)
              >>> np.longdouble(-.25).as_integer_ratio()
              (-1, 4)




   .. py:method:: is_integer(*args, **kwargs)

      longdouble.is_integer() -> bool

              Return ``True`` if the floating point number is finite with integral
              value, and ``False`` otherwise.

              .. versionadded:: 1.22

              Examples
              --------
              >>> np.longdouble(-2.0).is_integer()
              True
              >>> np.longdouble(3.2).is_integer()
              False




.. py:class:: longlong(value)

   Bases: :py:obj:`numpy.signedinteger`


   Signed integer type, compatible with C ``long long``.

       :Character code: ``'q'``



   .. py:method:: bit_count(*args, **kwargs)


.. py:data:: nan
   :type:  float

.. py:data:: newaxis
   :type:  None

.. py:class:: number(value)

   Bases: :py:obj:`numpy.generic`


   Abstract base class of all numeric scalar types.



.. py:data:: pi
   :type:  float

.. py:class:: short(value)

   Bases: :py:obj:`numpy.signedinteger`


   Signed integer type, compatible with C ``short``.

       :Character code: ``'h'``
       :Canonical name: `numpy.short`
       :Alias on this platform (Linux x86_64): `numpy.int16`: 16-bit signed integer (``-32_768`` to ``32_767``).



   .. py:method:: bit_count(*args, **kwargs)

      int16.bit_count() -> int

              Computes the number of 1-bits in the absolute value of the input.
              Analogous to the builtin `int.bit_count` or ``popcount`` in C++.

              Examples
              --------
              >>> np.int16(127).bit_count()
              7
              >>> np.int16(-127).bit_count()
              7




.. py:class:: signedinteger(value)

   Bases: :py:obj:`numpy.integer`


   Abstract base class of all signed integer scalar types.



.. py:class:: single(value)

   Bases: :py:obj:`numpy.floating`


   Single-precision floating-point number type, compatible with C ``float``.

       :Character code: ``'f'``
       :Canonical name: `numpy.single`
       :Alias on this platform (Linux x86_64): `numpy.float32`: 32-bit-precision floating-point number type: sign bit, 8 bits exponent, 23 bits mantissa.



   .. py:method:: as_integer_ratio(*args, **kwargs)

      single.as_integer_ratio() -> (int, int)

              Return a pair of integers, whose ratio is exactly equal to the original
              floating point number, and with a positive denominator.
              Raise `OverflowError` on infinities and a `ValueError` on NaNs.

              >>> np.single(10.0).as_integer_ratio()
              (10, 1)
              >>> np.single(0.0).as_integer_ratio()
              (0, 1)
              >>> np.single(-.25).as_integer_ratio()
              (-1, 4)




   .. py:method:: is_integer(*args, **kwargs)

      single.is_integer() -> bool

              Return ``True`` if the floating point number is finite with integral
              value, and ``False`` otherwise.

              .. versionadded:: 1.22

              Examples
              --------
              >>> np.single(-2.0).is_integer()
              True
              >>> np.single(3.2).is_integer()
              False




.. py:class:: ubyte(value)

   Bases: :py:obj:`numpy.unsignedinteger`


   Unsigned integer type, compatible with C ``unsigned char``.

       :Character code: ``'B'``
       :Canonical name: `numpy.ubyte`
       :Alias on this platform (Linux x86_64): `numpy.uint8`: 8-bit unsigned integer (``0`` to ``255``).



   .. py:method:: bit_count(*args, **kwargs)

      uint8.bit_count() -> int

              Computes the number of 1-bits in the absolute value of the input.
              Analogous to the builtin `int.bit_count` or ``popcount`` in C++.

              Examples
              --------
              >>> np.uint8(127).bit_count()
              7




.. py:class:: uint(value)

   Bases: :py:obj:`numpy.unsignedinteger`


   Unsigned integer type, compatible with C ``unsigned long``.

       :Character code: ``'L'``
       :Canonical name: `numpy.uint`
       :Alias on this platform (Linux x86_64): `numpy.uint64`: 64-bit unsigned integer (``0`` to ``18_446_744_073_709_551_615``).
       :Alias on this platform (Linux x86_64): `numpy.uintp`: Unsigned integer large enough to fit pointer, compatible with C ``uintptr_t``.



   .. py:method:: bit_count(*args, **kwargs)

      uint64.bit_count() -> int

              Computes the number of 1-bits in the absolute value of the input.
              Analogous to the builtin `int.bit_count` or ``popcount`` in C++.

              Examples
              --------
              >>> np.uint64(127).bit_count()
              7




.. py:class:: uint16(value)

   Bases: :py:obj:`numpy.unsignedinteger`


   Unsigned integer type, compatible with C ``unsigned short``.

       :Character code: ``'H'``
       :Canonical name: `numpy.ushort`
       :Alias on this platform (Linux x86_64): `numpy.uint16`: 16-bit unsigned integer (``0`` to ``65_535``).



   .. py:method:: bit_count(*args, **kwargs)

      uint16.bit_count() -> int

              Computes the number of 1-bits in the absolute value of the input.
              Analogous to the builtin `int.bit_count` or ``popcount`` in C++.

              Examples
              --------
              >>> np.uint16(127).bit_count()
              7




.. py:class:: uint32(value)

   Bases: :py:obj:`numpy.unsignedinteger`


   Unsigned integer type, compatible with C ``unsigned int``.

       :Character code: ``'I'``
       :Canonical name: `numpy.uintc`
       :Alias on this platform (Linux x86_64): `numpy.uint32`: 32-bit unsigned integer (``0`` to ``4_294_967_295``).



   .. py:method:: bit_count(*args, **kwargs)

      uint32.bit_count() -> int

              Computes the number of 1-bits in the absolute value of the input.
              Analogous to the builtin `int.bit_count` or ``popcount`` in C++.

              Examples
              --------
              >>> np.uint32(127).bit_count()
              7




.. py:class:: uint64(value)

   Bases: :py:obj:`numpy.unsignedinteger`


   Unsigned integer type, compatible with C ``unsigned long``.

       :Character code: ``'L'``
       :Canonical name: `numpy.uint`
       :Alias on this platform (Linux x86_64): `numpy.uint64`: 64-bit unsigned integer (``0`` to ``18_446_744_073_709_551_615``).
       :Alias on this platform (Linux x86_64): `numpy.uintp`: Unsigned integer large enough to fit pointer, compatible with C ``uintptr_t``.



   .. py:method:: bit_count(*args, **kwargs)

      uint64.bit_count() -> int

              Computes the number of 1-bits in the absolute value of the input.
              Analogous to the builtin `int.bit_count` or ``popcount`` in C++.

              Examples
              --------
              >>> np.uint64(127).bit_count()
              7




.. py:class:: uint8(value)

   Bases: :py:obj:`numpy.unsignedinteger`


   Unsigned integer type, compatible with C ``unsigned char``.

       :Character code: ``'B'``
       :Canonical name: `numpy.ubyte`
       :Alias on this platform (Linux x86_64): `numpy.uint8`: 8-bit unsigned integer (``0`` to ``255``).



   .. py:method:: bit_count(*args, **kwargs)

      uint8.bit_count() -> int

              Computes the number of 1-bits in the absolute value of the input.
              Analogous to the builtin `int.bit_count` or ``popcount`` in C++.

              Examples
              --------
              >>> np.uint8(127).bit_count()
              7




.. py:class:: uintc(value)

   Bases: :py:obj:`numpy.unsignedinteger`


   Unsigned integer type, compatible with C ``unsigned int``.

       :Character code: ``'I'``
       :Canonical name: `numpy.uintc`
       :Alias on this platform (Linux x86_64): `numpy.uint32`: 32-bit unsigned integer (``0`` to ``4_294_967_295``).



   .. py:method:: bit_count(*args, **kwargs)

      uint32.bit_count() -> int

              Computes the number of 1-bits in the absolute value of the input.
              Analogous to the builtin `int.bit_count` or ``popcount`` in C++.

              Examples
              --------
              >>> np.uint32(127).bit_count()
              7




.. py:class:: ulonglong(value)

   Bases: :py:obj:`numpy.unsignedinteger`


   Signed integer type, compatible with C ``unsigned long long``.

       :Character code: ``'Q'``



   .. py:method:: bit_count(*args, **kwargs)


.. py:class:: ushort(value)

   Bases: :py:obj:`numpy.unsignedinteger`


   Unsigned integer type, compatible with C ``unsigned short``.

       :Character code: ``'H'``
       :Canonical name: `numpy.ushort`
       :Alias on this platform (Linux x86_64): `numpy.uint16`: 16-bit unsigned integer (``0`` to ``65_535``).



   .. py:method:: bit_count(*args, **kwargs)

      uint16.bit_count() -> int

              Computes the number of 1-bits in the absolute value of the input.
              Analogous to the builtin `int.bit_count` or ``popcount`` in C++.

              Examples
              --------
              >>> np.uint16(127).bit_count()
              7




