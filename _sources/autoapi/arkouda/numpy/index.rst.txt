arkouda.numpy
=============

.. py:module:: arkouda.numpy


Submodules
----------

.. toctree::
   :maxdepth: 1

   /autoapi/arkouda/numpy/dtypes/index
   /autoapi/arkouda/numpy/random/index


Attributes
----------

.. autoapisummary::

   arkouda.numpy.Inf
   arkouda.numpy.Infinity
   arkouda.numpy.NAN
   arkouda.numpy.NINF
   arkouda.numpy.NZERO
   arkouda.numpy.NaN
   arkouda.numpy.PINF
   arkouda.numpy.PZERO
   arkouda.numpy.e
   arkouda.numpy.euler_gamma
   arkouda.numpy.inf
   arkouda.numpy.infty
   arkouda.numpy.nan
   arkouda.numpy.pi


Classes
-------

.. autoapisummary::

   arkouda.numpy.ARKOUDA_SUPPORTED_DTYPES
   arkouda.numpy.ARKOUDA_SUPPORTED_INTS
   arkouda.numpy.BoolDType
   arkouda.numpy.ByteDType
   arkouda.numpy.BytesDType
   arkouda.numpy.CLongDoubleDType
   arkouda.numpy.Complex128DType
   arkouda.numpy.Complex64DType
   arkouda.numpy.DType
   arkouda.numpy.DTypeObjects
   arkouda.numpy.DTypes
   arkouda.numpy.DataSource
   arkouda.numpy.DateTime64DType
   arkouda.numpy.ErrorMode
   arkouda.numpy.False_
   arkouda.numpy.Float16DType
   arkouda.numpy.Float32DType
   arkouda.numpy.Float64DType
   arkouda.numpy.Int16DType
   arkouda.numpy.Int32DType
   arkouda.numpy.Int64DType
   arkouda.numpy.Int8DType
   arkouda.numpy.IntDType
   arkouda.numpy.LongDType
   arkouda.numpy.LongDoubleDType
   arkouda.numpy.LongLongDType
   arkouda.numpy.NUMBER_FORMAT_STRINGS
   arkouda.numpy.NumericDTypes
   arkouda.numpy.ObjectDType
   arkouda.numpy.RankWarning
   arkouda.numpy.ScalarDTypes
   arkouda.numpy.ScalarType
   arkouda.numpy.SeriesDTypes
   arkouda.numpy.ShortDType
   arkouda.numpy.StrDType
   arkouda.numpy.TimeDelta64DType
   arkouda.numpy.TooHardError
   arkouda.numpy.True_
   arkouda.numpy.UByteDType
   arkouda.numpy.UInt16DType
   arkouda.numpy.UInt32DType
   arkouda.numpy.UInt64DType
   arkouda.numpy.UInt8DType
   arkouda.numpy.UIntDType
   arkouda.numpy.ULongDType
   arkouda.numpy.ULongLongDType
   arkouda.numpy.UShortDType
   arkouda.numpy.VoidDType
   arkouda.numpy.all_scalars
   arkouda.numpy.bigint
   arkouda.numpy.bitType
   arkouda.numpy.bool_
   arkouda.numpy.bool_scalars
   arkouda.numpy.byte
   arkouda.numpy.bytes_
   arkouda.numpy.cdouble
   arkouda.numpy.cfloat
   arkouda.numpy.character
   arkouda.numpy.clongdouble
   arkouda.numpy.clongfloat
   arkouda.numpy.complex128
   arkouda.numpy.complex64
   arkouda.numpy.csingle
   arkouda.numpy.datetime64
   arkouda.numpy.double
   arkouda.numpy.finfo
   arkouda.numpy.flexible
   arkouda.numpy.float16
   arkouda.numpy.float32
   arkouda.numpy.float64
   arkouda.numpy.float_
   arkouda.numpy.float_scalars
   arkouda.numpy.floating
   arkouda.numpy.format_parser
   arkouda.numpy.half
   arkouda.numpy.iinfo
   arkouda.numpy.inexact
   arkouda.numpy.int16
   arkouda.numpy.int32
   arkouda.numpy.int64
   arkouda.numpy.int8
   arkouda.numpy.intTypes
   arkouda.numpy.int_
   arkouda.numpy.int_scalars
   arkouda.numpy.intc
   arkouda.numpy.integer
   arkouda.numpy.intp
   arkouda.numpy.longdouble
   arkouda.numpy.longfloat
   arkouda.numpy.longlong
   arkouda.numpy.number
   arkouda.numpy.numeric_and_bool_scalars
   arkouda.numpy.numeric_scalars
   arkouda.numpy.numpy_scalars
   arkouda.numpy.object_
   arkouda.numpy.sctypeDict
   arkouda.numpy.sctypes
   arkouda.numpy.short
   arkouda.numpy.signedinteger
   arkouda.numpy.single
   arkouda.numpy.str_
   arkouda.numpy.str_scalars
   arkouda.numpy.timedelta64
   arkouda.numpy.ubyte
   arkouda.numpy.uint
   arkouda.numpy.uint16
   arkouda.numpy.uint32
   arkouda.numpy.uint64
   arkouda.numpy.uint8
   arkouda.numpy.uintc
   arkouda.numpy.uintp
   arkouda.numpy.ulonglong
   arkouda.numpy.unsignedinteger
   arkouda.numpy.ushort
   arkouda.numpy.void


Functions
---------

.. autoapisummary::

   arkouda.numpy.abs
   arkouda.numpy.add_newdoc
   arkouda.numpy.arccos
   arkouda.numpy.arccosh
   arkouda.numpy.arcsin
   arkouda.numpy.arcsinh
   arkouda.numpy.arctan
   arkouda.numpy.arctan2
   arkouda.numpy.arctanh
   arkouda.numpy.array_equal
   arkouda.numpy.base_repr
   arkouda.numpy.binary_repr
   arkouda.numpy.cast
   arkouda.numpy.ceil
   arkouda.numpy.clip
   arkouda.numpy.cos
   arkouda.numpy.cosh
   arkouda.numpy.count_nonzero
   arkouda.numpy.cumprod
   arkouda.numpy.cumsum
   arkouda.numpy.deg2rad
   arkouda.numpy.deprecate
   arkouda.numpy.deprecate_with_doc
   arkouda.numpy.disp
   arkouda.numpy.dtype
   arkouda.numpy.exp
   arkouda.numpy.expm1
   arkouda.numpy.eye
   arkouda.numpy.flip
   arkouda.numpy.floor
   arkouda.numpy.format_float_positional
   arkouda.numpy.format_float_scientific
   arkouda.numpy.get_byteorder
   arkouda.numpy.get_server_byteorder
   arkouda.numpy.hash
   arkouda.numpy.histogram
   arkouda.numpy.histogram2d
   arkouda.numpy.histogramdd
   arkouda.numpy.isSupportedBool
   arkouda.numpy.isSupportedDType
   arkouda.numpy.isSupportedFloat
   arkouda.numpy.isSupportedInt
   arkouda.numpy.isSupportedNumber
   arkouda.numpy.isfinite
   arkouda.numpy.isinf
   arkouda.numpy.isnan
   arkouda.numpy.isscalar
   arkouda.numpy.issctype
   arkouda.numpy.issubclass_
   arkouda.numpy.issubdtype
   arkouda.numpy.log
   arkouda.numpy.log10
   arkouda.numpy.log1p
   arkouda.numpy.log2
   arkouda.numpy.matmul
   arkouda.numpy.maximum_sctype
   arkouda.numpy.median
   arkouda.numpy.putmask
   arkouda.numpy.rad2deg
   arkouda.numpy.resolve_scalar_dtype
   arkouda.numpy.round
   arkouda.numpy.shape
   arkouda.numpy.sign
   arkouda.numpy.sin
   arkouda.numpy.sinh
   arkouda.numpy.square
   arkouda.numpy.squeeze
   arkouda.numpy.tan
   arkouda.numpy.tanh
   arkouda.numpy.tile
   arkouda.numpy.transpose
   arkouda.numpy.tril
   arkouda.numpy.triu
   arkouda.numpy.trunc
   arkouda.numpy.typename
   arkouda.numpy.value_counts
   arkouda.numpy.vecdot
   arkouda.numpy.where


Module Contents
---------------

.. py:class:: ARKOUDA_SUPPORTED_DTYPES

   frozenset() -> empty frozenset object
   frozenset(iterable) -> frozenset object

   Build an immutable unordered collection of unique elements.



   .. py:method:: copy(*args, **kwargs)

      Return a shallow copy of a set.




   .. py:method:: difference(*args, **kwargs)

      Return the difference of two or more sets as a new set.

      (i.e. all elements that are in this set but not the others.)




   .. py:method:: intersection(*args, **kwargs)

      Return the intersection of two sets as a new set.

      (i.e. all elements that are in both sets.)




   .. py:method:: isdisjoint(*args, **kwargs)

      Return True if two sets have a null intersection.




   .. py:method:: issubset(*args, **kwargs)

      Report whether another set contains this set.




   .. py:method:: issuperset(*args, **kwargs)

      Report whether this set contains another set.




   .. py:method:: symmetric_difference(*args, **kwargs)

      Return the symmetric difference of two sets as a new set.

      (i.e. all elements that are in exactly one of the sets.)




   .. py:method:: union(*args, **kwargs)

      Return the union of sets as a new set.

      (i.e. all elements that are in either set.)




.. py:class:: ARKOUDA_SUPPORTED_INTS

   Built-in immutable sequence.

   If no argument is given, the constructor returns an empty tuple.
   If iterable is specified the tuple is initialized from iterable's items.

   If the argument is a tuple, the return value is the same object.



   .. py:method:: count(value, /)

      Return number of occurrences of value.




   .. py:method:: index(value, start=0, stop=9223372036854775807, /)

      Return first index of value.

      Raises ValueError if the value is not present.




.. py:class:: BoolDType(obj, align=False, copy=False)

   Bases: :py:obj:`numpy.dtype`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.



.. py:class:: ByteDType(obj, align=False, copy=False)

   Bases: :py:obj:`numpy.dtype`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.



.. py:class:: BytesDType(obj, align=False, copy=False)

   Bases: :py:obj:`numpy.dtype`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.



.. py:class:: CLongDoubleDType(obj, align=False, copy=False)

   Bases: :py:obj:`numpy.dtype`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.



.. py:class:: Complex128DType(obj, align=False, copy=False)

   Bases: :py:obj:`numpy.dtype`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.



.. py:class:: Complex64DType(obj, align=False, copy=False)

   Bases: :py:obj:`numpy.dtype`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.



.. py:class:: DType

   An enumeration.



   .. py:method:: BIGINT(*args, **kwargs)

      An enumeration.




   .. py:method:: BOOL(*args, **kwargs)

      An enumeration.




   .. py:method:: COMPLEX128(*args, **kwargs)

      An enumeration.




   .. py:method:: COMPLEX64(*args, **kwargs)

      An enumeration.




   .. py:method:: FLOAT(*args, **kwargs)

      An enumeration.




   .. py:method:: FLOAT32(*args, **kwargs)

      An enumeration.




   .. py:method:: FLOAT64(*args, **kwargs)

      An enumeration.




   .. py:method:: INT(*args, **kwargs)

      An enumeration.




   .. py:method:: INT16(*args, **kwargs)

      An enumeration.




   .. py:method:: INT32(*args, **kwargs)

      An enumeration.




   .. py:method:: INT64(*args, **kwargs)

      An enumeration.




   .. py:method:: INT8(*args, **kwargs)

      An enumeration.




   .. py:method:: STR(*args, **kwargs)

      An enumeration.




   .. py:method:: UINT(*args, **kwargs)

      An enumeration.




   .. py:method:: UINT16(*args, **kwargs)

      An enumeration.




   .. py:method:: UINT32(*args, **kwargs)

      An enumeration.




   .. py:method:: UINT64(*args, **kwargs)

      An enumeration.




   .. py:method:: UINT8(*args, **kwargs)

      An enumeration.




   .. py:method:: name(*args, **kwargs)

      The name of the Enum member.




   .. py:method:: value(*args, **kwargs)

      The value of the Enum member.




.. py:class:: DTypeObjects

   frozenset() -> empty frozenset object
   frozenset(iterable) -> frozenset object

   Build an immutable unordered collection of unique elements.



   .. py:method:: copy(*args, **kwargs)

      Return a shallow copy of a set.




   .. py:method:: difference(*args, **kwargs)

      Return the difference of two or more sets as a new set.

      (i.e. all elements that are in this set but not the others.)




   .. py:method:: intersection(*args, **kwargs)

      Return the intersection of two sets as a new set.

      (i.e. all elements that are in both sets.)




   .. py:method:: isdisjoint(*args, **kwargs)

      Return True if two sets have a null intersection.




   .. py:method:: issubset(*args, **kwargs)

      Report whether another set contains this set.




   .. py:method:: issuperset(*args, **kwargs)

      Report whether this set contains another set.




   .. py:method:: symmetric_difference(*args, **kwargs)

      Return the symmetric difference of two sets as a new set.

      (i.e. all elements that are in exactly one of the sets.)




   .. py:method:: union(*args, **kwargs)

      Return the union of sets as a new set.

      (i.e. all elements that are in either set.)




.. py:class:: DTypes

   frozenset() -> empty frozenset object
   frozenset(iterable) -> frozenset object

   Build an immutable unordered collection of unique elements.



   .. py:method:: copy(*args, **kwargs)

      Return a shallow copy of a set.




   .. py:method:: difference(*args, **kwargs)

      Return the difference of two or more sets as a new set.

      (i.e. all elements that are in this set but not the others.)




   .. py:method:: intersection(*args, **kwargs)

      Return the intersection of two sets as a new set.

      (i.e. all elements that are in both sets.)




   .. py:method:: isdisjoint(*args, **kwargs)

      Return True if two sets have a null intersection.




   .. py:method:: issubset(*args, **kwargs)

      Report whether another set contains this set.




   .. py:method:: issuperset(*args, **kwargs)

      Report whether this set contains another set.




   .. py:method:: symmetric_difference(*args, **kwargs)

      Return the symmetric difference of two sets as a new set.

      (i.e. all elements that are in exactly one of the sets.)




   .. py:method:: union(*args, **kwargs)

      Return the union of sets as a new set.

      (i.e. all elements that are in either set.)




.. py:class:: DataSource

   DataSource(destpath='.')

   A generic data source file (file, http, ftp, ...).

   DataSources can be local files or remote files/URLs.  The files may
   also be compressed or uncompressed. DataSource hides some of the
   low-level details of downloading the file, allowing you to simply pass
   in a valid file path (or URL) and obtain a file object.

   :param destpath: Path to the directory where the source file gets downloaded to for
                    use.  If `destpath` is None, a temporary directory will be created.
                    The default path is the current directory.
   :type destpath: str or None, optional

   .. rubric:: Notes

   URLs require a scheme string (``http://``) to be used, without it they
   will fail::

       >>> repos = np.DataSource()
       >>> repos.exists('www.google.com/index.html')
       False
       >>> repos.exists('http://www.google.com/index.html')
       True

   Temporary directories are deleted when the DataSource is deleted.

   .. rubric:: Examples

   ::

       >>> ds = np.DataSource('/home/guido')
       >>> urlname = 'http://www.google.com/'
       >>> gfile = ds.open('http://www.google.com/')
       >>> ds.abspath(urlname)
       '/home/guido/www.google.com/index.html'

       >>> ds = np.DataSource(None)  # use with temporary file
       >>> ds.open('/home/guido/foobar.txt')
       <open file '/home/guido.foobar.txt', mode 'r' at 0x91d4430>
       >>> ds.abspath('/home/guido/foobar.txt')
       '/tmp/.../home/guido/foobar.txt'


   .. py:method:: abspath(path)

      Return absolute path of file in the DataSource directory.

      If `path` is an URL, then `abspath` will return either the location
      the file exists locally or the location it would exist when opened
      using the `open` method.

      :param path: Can be a local file or a remote URL.
      :type path: str

      :returns: **out** -- Complete path, including the `DataSource` destination directory.
      :rtype: str

      .. rubric:: Notes

      The functionality is based on `os.path.abspath`.



   .. py:method:: exists(path)

      Test if path exists.

      Test if `path` exists as (and in this order):

      - a local file.
      - a remote URL that has been downloaded and stored locally in the
        `DataSource` directory.
      - a remote URL that has not been downloaded, but is valid and
        accessible.

      :param path: Can be a local file or a remote URL.
      :type path: str

      :returns: **out** -- True if `path` exists.
      :rtype: bool

      .. rubric:: Notes

      When `path` is an URL, `exists` will return True if it's either
      stored locally in the `DataSource` directory, or is a valid remote
      URL.  `DataSource` does not discriminate between the two, the file
      is accessible if it exists in either location.



   .. py:method:: open(path, mode='r', encoding=None, newline=None)

      Open and return file-like object.

      If `path` is an URL, it will be downloaded, stored in the
      `DataSource` directory and opened from there.

      :param path: Local file path or URL to open.
      :type path: str
      :param mode: Mode to open `path`.  Mode 'r' for reading, 'w' for writing,
                   'a' to append. Available modes depend on the type of object
                   specified by `path`. Default is 'r'.
      :type mode: {'r', 'w', 'a'}, optional
      :param encoding: Open text file with given encoding. The default encoding will be
                       what `io.open` uses.
      :type encoding: {None, str}, optional
      :param newline: Newline to use when reading text file.
      :type newline: {None, str}, optional

      :returns: **out** -- File object.
      :rtype: file object



.. py:class:: DateTime64DType(obj, align=False, copy=False)

   Bases: :py:obj:`numpy.dtype`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.



.. py:class:: ErrorMode

   An enumeration.



   .. py:method:: ignore(*args, **kwargs)

      An enumeration.




   .. py:method:: name(*args, **kwargs)

      The name of the Enum member.




   .. py:method:: return_validity(*args, **kwargs)

      An enumeration.




   .. py:method:: strict(*args, **kwargs)

      An enumeration.




   .. py:method:: value(*args, **kwargs)

      The value of the Enum member.




.. py:class:: False_(value)

   Bases: :py:obj:`numpy.generic`


   Boolean type (True or False), stored as a byte.

       .. warning::

          The :class:`bool_` type is not a subclass of the :class:`int_` type
          (the :class:`bool_` is not even a number type). This is different
          than Python's default implementation of :class:`bool` as a
          sub-class of :class:`int`.

       :Character code: ``'?'``



.. py:class:: Float16DType(obj, align=False, copy=False)

   Bases: :py:obj:`numpy.dtype`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.



.. py:class:: Float32DType(obj, align=False, copy=False)

   Bases: :py:obj:`numpy.dtype`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.



.. py:class:: Float64DType(obj, align=False, copy=False)

   Bases: :py:obj:`numpy.dtype`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.



.. py:data:: Inf
   :type:  float

.. py:data:: Infinity
   :type:  float

.. py:class:: Int16DType(obj, align=False, copy=False)

   Bases: :py:obj:`numpy.dtype`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.



.. py:class:: Int32DType(obj, align=False, copy=False)

   Bases: :py:obj:`numpy.dtype`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.



.. py:class:: Int64DType(obj, align=False, copy=False)

   Bases: :py:obj:`numpy.dtype`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.



.. py:class:: Int8DType(obj, align=False, copy=False)

   Bases: :py:obj:`numpy.dtype`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.



.. py:class:: IntDType(obj, align=False, copy=False)

   Bases: :py:obj:`numpy.dtype`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.



.. py:class:: LongDType(obj, align=False, copy=False)

   Bases: :py:obj:`numpy.dtype`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.



.. py:class:: LongDoubleDType(obj, align=False, copy=False)

   Bases: :py:obj:`numpy.dtype`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.



.. py:class:: LongLongDType(obj, align=False, copy=False)

   Bases: :py:obj:`numpy.dtype`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.



.. py:data:: NAN
   :type:  float

.. py:data:: NINF
   :type:  float

.. py:class:: NUMBER_FORMAT_STRINGS

   dict() -> new empty dictionary
   dict(mapping) -> new dictionary initialized from a mapping object's
       (key, value) pairs
   dict(iterable) -> new dictionary initialized as if via:
       d = {}
       for k, v in iterable:
           d[k] = v
   dict(**kwargs) -> new dictionary initialized with the name=value pairs
       in the keyword argument list.  For example:  dict(one=1, two=2)



   .. py:method:: clear(*args, **kwargs)

      D.clear() -> None.  Remove all items from D.




   .. py:method:: copy(*args, **kwargs)

      D.copy() -> a shallow copy of D




   .. py:method:: fromkeys(iterable, value=None, /)

      Create a new dictionary with keys from iterable and values set to value.




   .. py:method:: get(key, default=None, /)

      Return the value for key if key is in the dictionary, else default.




   .. py:method:: items(*args, **kwargs)

      D.items() -> a set-like object providing a view on D's items




   .. py:method:: keys(*args, **kwargs)

      D.keys() -> a set-like object providing a view on D's keys




   .. py:method:: pop(*args, **kwargs)

      D.pop(k[,d]) -> v, remove specified key and return the corresponding value.

      If key is not found, default is returned if given, otherwise KeyError is raised




   .. py:method:: popitem()

      Remove and return a (key, value) pair as a 2-tuple.

      Pairs are returned in LIFO (last-in, first-out) order.
      Raises KeyError if the dict is empty.




   .. py:method:: setdefault(key, default=None, /)

      Insert key with a value of default if key is not in the dictionary.

      Return the value for key if key is in the dictionary, else default.




   .. py:method:: update(*args, **kwargs)

      D.update([E, ]**F) -> None.  Update D from dict/iterable E and F.
      If E is present and has a .keys() method, then does:  for k in E: D[k] = E[k]
      If E is present and lacks a .keys() method, then does:  for k, v in E: D[k] = v
      In either case, this is followed by: for k in F:  D[k] = F[k]




   .. py:method:: values(*args, **kwargs)

      D.values() -> an object providing a view on D's values




.. py:data:: NZERO
   :type:  float

.. py:data:: NaN
   :type:  float

.. py:class:: NumericDTypes

   frozenset() -> empty frozenset object
   frozenset(iterable) -> frozenset object

   Build an immutable unordered collection of unique elements.



   .. py:method:: copy(*args, **kwargs)

      Return a shallow copy of a set.




   .. py:method:: difference(*args, **kwargs)

      Return the difference of two or more sets as a new set.

      (i.e. all elements that are in this set but not the others.)




   .. py:method:: intersection(*args, **kwargs)

      Return the intersection of two sets as a new set.

      (i.e. all elements that are in both sets.)




   .. py:method:: isdisjoint(*args, **kwargs)

      Return True if two sets have a null intersection.




   .. py:method:: issubset(*args, **kwargs)

      Report whether another set contains this set.




   .. py:method:: issuperset(*args, **kwargs)

      Report whether this set contains another set.




   .. py:method:: symmetric_difference(*args, **kwargs)

      Return the symmetric difference of two sets as a new set.

      (i.e. all elements that are in exactly one of the sets.)




   .. py:method:: union(*args, **kwargs)

      Return the union of sets as a new set.

      (i.e. all elements that are in either set.)




.. py:class:: ObjectDType(obj, align=False, copy=False)

   Bases: :py:obj:`numpy.dtype`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.



.. py:data:: PINF
   :type:  float

.. py:data:: PZERO
   :type:  float

.. py:class:: RankWarning

   Issued by `polyfit` when the Vandermonde matrix is rank deficient.

   For more information, a way to suppress the warning, and an example of
   `RankWarning` being issued, see `polyfit`.




.. py:class:: ScalarDTypes

   frozenset() -> empty frozenset object
   frozenset(iterable) -> frozenset object

   Build an immutable unordered collection of unique elements.



   .. py:method:: copy(*args, **kwargs)

      Return a shallow copy of a set.




   .. py:method:: difference(*args, **kwargs)

      Return the difference of two or more sets as a new set.

      (i.e. all elements that are in this set but not the others.)




   .. py:method:: intersection(*args, **kwargs)

      Return the intersection of two sets as a new set.

      (i.e. all elements that are in both sets.)




   .. py:method:: isdisjoint(*args, **kwargs)

      Return True if two sets have a null intersection.




   .. py:method:: issubset(*args, **kwargs)

      Report whether another set contains this set.




   .. py:method:: issuperset(*args, **kwargs)

      Report whether this set contains another set.




   .. py:method:: symmetric_difference(*args, **kwargs)

      Return the symmetric difference of two sets as a new set.

      (i.e. all elements that are in exactly one of the sets.)




   .. py:method:: union(*args, **kwargs)

      Return the union of sets as a new set.

      (i.e. all elements that are in either set.)




.. py:class:: ScalarType

   Built-in immutable sequence.

   If no argument is given, the constructor returns an empty tuple.
   If iterable is specified the tuple is initialized from iterable's items.

   If the argument is a tuple, the return value is the same object.



   .. py:method:: count(value, /)

      Return number of occurrences of value.




   .. py:method:: index(value, start=0, stop=9223372036854775807, /)

      Return first index of value.

      Raises ValueError if the value is not present.




.. py:class:: SeriesDTypes

   dict() -> new empty dictionary
   dict(mapping) -> new dictionary initialized from a mapping object's
       (key, value) pairs
   dict(iterable) -> new dictionary initialized as if via:
       d = {}
       for k, v in iterable:
           d[k] = v
   dict(**kwargs) -> new dictionary initialized with the name=value pairs
       in the keyword argument list.  For example:  dict(one=1, two=2)



   .. py:method:: clear(*args, **kwargs)

      D.clear() -> None.  Remove all items from D.




   .. py:method:: copy(*args, **kwargs)

      D.copy() -> a shallow copy of D




   .. py:method:: fromkeys(iterable, value=None, /)

      Create a new dictionary with keys from iterable and values set to value.




   .. py:method:: get(key, default=None, /)

      Return the value for key if key is in the dictionary, else default.




   .. py:method:: items(*args, **kwargs)

      D.items() -> a set-like object providing a view on D's items




   .. py:method:: keys(*args, **kwargs)

      D.keys() -> a set-like object providing a view on D's keys




   .. py:method:: pop(*args, **kwargs)

      D.pop(k[,d]) -> v, remove specified key and return the corresponding value.

      If key is not found, default is returned if given, otherwise KeyError is raised




   .. py:method:: popitem()

      Remove and return a (key, value) pair as a 2-tuple.

      Pairs are returned in LIFO (last-in, first-out) order.
      Raises KeyError if the dict is empty.




   .. py:method:: setdefault(key, default=None, /)

      Insert key with a value of default if key is not in the dictionary.

      Return the value for key if key is in the dictionary, else default.




   .. py:method:: update(*args, **kwargs)

      D.update([E, ]**F) -> None.  Update D from dict/iterable E and F.
      If E is present and has a .keys() method, then does:  for k in E: D[k] = E[k]
      If E is present and lacks a .keys() method, then does:  for k, v in E: D[k] = v
      In either case, this is followed by: for k in F:  D[k] = F[k]




   .. py:method:: values(*args, **kwargs)

      D.values() -> an object providing a view on D's values




.. py:class:: ShortDType(obj, align=False, copy=False)

   Bases: :py:obj:`numpy.dtype`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.



.. py:class:: StrDType(obj, align=False, copy=False)

   Bases: :py:obj:`numpy.dtype`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.



.. py:class:: TimeDelta64DType(obj, align=False, copy=False)

   Bases: :py:obj:`numpy.dtype`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.



.. py:class:: TooHardError

   max_work was exceeded.

       This is raised whenever the maximum number of candidate solutions
       to consider specified by the ``max_work`` parameter is exceeded.
       Assigning a finite number to max_work may have caused the operation
       to fail.





.. py:class:: True_(value)

   Bases: :py:obj:`numpy.generic`


   Boolean type (True or False), stored as a byte.

       .. warning::

          The :class:`bool_` type is not a subclass of the :class:`int_` type
          (the :class:`bool_` is not even a number type). This is different
          than Python's default implementation of :class:`bool` as a
          sub-class of :class:`int`.

       :Character code: ``'?'``



.. py:class:: UByteDType(obj, align=False, copy=False)

   Bases: :py:obj:`numpy.dtype`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.



.. py:class:: UInt16DType(obj, align=False, copy=False)

   Bases: :py:obj:`numpy.dtype`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.



.. py:class:: UInt32DType(obj, align=False, copy=False)

   Bases: :py:obj:`numpy.dtype`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.



.. py:class:: UInt64DType(obj, align=False, copy=False)

   Bases: :py:obj:`numpy.dtype`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.



.. py:class:: UInt8DType(obj, align=False, copy=False)

   Bases: :py:obj:`numpy.dtype`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.



.. py:class:: UIntDType(obj, align=False, copy=False)

   Bases: :py:obj:`numpy.dtype`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.



.. py:class:: ULongDType(obj, align=False, copy=False)

   Bases: :py:obj:`numpy.dtype`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.



.. py:class:: ULongLongDType(obj, align=False, copy=False)

   Bases: :py:obj:`numpy.dtype`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.



.. py:class:: UShortDType(obj, align=False, copy=False)

   Bases: :py:obj:`numpy.dtype`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.



.. py:class:: VoidDType(obj, align=False, copy=False)

   Bases: :py:obj:`numpy.dtype`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.



.. py:function:: abs(pda: arkouda.pdarrayclass.pdarray) -> arkouda.pdarrayclass.pdarray

   Return the element-wise absolute value of the array.

   :param pda:
   :type pda: pdarray

   :returns: A pdarray containing absolute values of the input array elements
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray

   .. rubric:: Examples

   >>> ak.abs(ak.arange(-5,-1))
   array([5 4 3 2])

   >>> ak.abs(ak.linspace(-5,-1,5))
   array([5.00000000000000000 4.00000000000000000 3.00000000000000000
   2.00000000000000000 1.00000000000000000])


.. py:function:: add_newdoc(place, obj, doc, warn_on_python=True)

   Add documentation to an existing object, typically one defined in C

   The purpose is to allow easier editing of the docstrings without requiring
   a re-compile. This exists primarily for internal use within numpy itself.

   :param place: The absolute name of the module to import from
   :type place: str
   :param obj: The name of the object to add documentation to, typically a class or
               function name
   :type obj: str
   :param doc: If a string, the documentation to apply to `obj`

               If a tuple, then the first element is interpreted as an attribute of
               `obj` and the second as the docstring to apply - ``(method, docstring)``

               If a list, then each element of the list should be a tuple of length
               two - ``[(method1, docstring1), (method2, docstring2), ...]``
   :type doc: {str, Tuple[str, str], List[Tuple[str, str]]}
   :param warn_on_python: If True, the default, emit `UserWarning` if this is used to attach
                          documentation to a pure-python object.
   :type warn_on_python: bool

   .. rubric:: Notes

   This routine never raises an error if the docstring can't be written, but
   will raise an error if the object being documented does not exist.

   This routine cannot modify read-only docstrings, as appear
   in new-style classes or built-in functions. Because this
   routine never raises an error the caller must check manually
   that the docstrings were changed.

   Since this function grabs the ``char *`` from a c-level str object and puts
   it into the ``tp_doc`` slot of the type of `obj`, it violates a number of
   C-API best-practices, by:

   - modifying a `PyTypeObject` after calling `PyType_Ready`
   - calling `Py_INCREF` on the str and losing the reference, so the str
     will never be released

   If possible it should be avoided.


.. py:class:: all_scalars(origin, params, *, inst=True, name=None)

   Bases: :py:obj:`_GenericAlias`


   The central part of internal API.

   This represents a generic version of type 'origin' with type arguments 'params'.
   There are two kind of these aliases: user defined and special. The special ones
   are wrappers around builtin collections and ABCs in collections.abc. These must
   have 'name' always set. If 'inst' is False, then the alias can't be instantiated,
   this is used by e.g. typing.List and typing.Dict.


.. py:function:: arccos(pda: arkouda.pdarrayclass.pdarray, where: Union[bool, arkouda.pdarrayclass.pdarray] = True) -> arkouda.pdarrayclass.pdarray

   Return the element-wise inverse cosine of the array. The result is between 0 and pi.

   :param pda:
   :type pda: pdarray
   :param where: This condition is broadcast over the input. At locations where the condition is True,
                 the inverse cosine will be applied to the corresponding value. Elsewhere, it will retain
                 its original value. Default set to True.
   :type where: bool or pdarray, default=True

   :returns: A pdarray containing inverse cosine for each element
             of the original pdarray
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray


.. py:function:: arccosh(pda: arkouda.pdarrayclass.pdarray, where: Union[bool, arkouda.pdarrayclass.pdarray] = True) -> arkouda.pdarrayclass.pdarray

   Return the element-wise inverse hyperbolic cosine of the array.

   :param pda:
   :type pda: pdarray
   :param where: This condition is broadcast over the input. At locations where the condition is True,
                 the inverse hyperbolic cosine will be applied to the corresponding value. Elsewhere, it will
                 retain its original value. Default set to True.
   :type where: bool or pdarray, default=True

   :returns: A pdarray containing inverse hyperbolic cosine for each element
             of the original pdarray
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray


.. py:function:: arcsin(pda: arkouda.pdarrayclass.pdarray, where: Union[bool, arkouda.pdarrayclass.pdarray] = True) -> arkouda.pdarrayclass.pdarray

   Return the element-wise inverse sine of the array. The result is between -pi/2 and pi/2.

   :param pda:
   :type pda: pdarray
   :param where: This condition is broadcast over the input. At locations where the condition is True,
                 the inverse sine will be applied to the corresponding value. Elsewhere, it will retain
                 its original value. Default set to True.
   :type where: bool or pdarray, default=True

   :returns: A pdarray containing inverse sine for each element
             of the original pdarray
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray


.. py:function:: arcsinh(pda: arkouda.pdarrayclass.pdarray, where: Union[bool, arkouda.pdarrayclass.pdarray] = True) -> arkouda.pdarrayclass.pdarray

   Return the element-wise inverse hyperbolic sine of the array.

   :param pda:
   :type pda: pdarray
   :param where: This condition is broadcast over the input. At locations where the condition is True,
                 the inverse hyperbolic sine will be applied to the corresponding value. Elsewhere, it will retain
                 its original value. Default set to True.
   :type where: bool or pdarray, default=True

   :returns: A pdarray containing inverse hyperbolic sine for each element
             of the original pdarray
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray


.. py:function:: arctan(pda: arkouda.pdarrayclass.pdarray, where: Union[bool, arkouda.pdarrayclass.pdarray] = True) -> arkouda.pdarrayclass.pdarray

   Return the element-wise inverse tangent of the array. The result is between -pi/2 and pi/2.

   :param pda:
   :type pda: pdarray
   :param where: This condition is broadcast over the input. At locations where the condition is True,
                 the inverse tangent will be applied to the corresponding value. Elsewhere, it will retain
                 its original value. Default set to True.
   :type where: bool or pdarray, default=True

   :returns: A pdarray containing inverse tangent for each element
             of the original pdarray
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray


.. py:function:: arctan2(num: Union[arkouda.pdarrayclass.pdarray, float, numpy.float64, numpy.float32, int, numpy.int8, numpy.int16, numpy.int32, numpy.int64, numpy.uint8, numpy.uint16, numpy.uint32, numpy.uint64], denom: Union[arkouda.pdarrayclass.pdarray, float, numpy.float64, numpy.float32, int, numpy.int8, numpy.int16, numpy.int32, numpy.int64, numpy.uint8, numpy.uint16, numpy.uint32, numpy.uint64], where: Union[bool, arkouda.pdarrayclass.pdarray] = True) -> arkouda.pdarrayclass.pdarray

   Return the element-wise inverse tangent of the array pair. The result chosen is the
   signed angle in radians between the ray ending at the origin and passing through the
   point (1,0), and the ray ending at the origin and passing through the point (denom, num).
   The result is between -pi and pi.

   :param num: Numerator of the arctan2 argument.
   :type num: pdarray or numeric_scalars
   :param denom: Denominator of the arctan2 argument.
   :type denom: pdarray or numeric_scalars
   :param where: This condition is broadcast over the input. At locations where the condition is True,
                 the inverse tangent will be applied to the corresponding values. Elsewhere, it will retain
                 its original value. Default set to True.
   :type where: bool or pdarray, default=True

   :returns: A pdarray containing inverse tangent for each corresponding element pair
             of the original pdarray, using the signed values or the numerator and
             denominator to get proper placement on unit circle.
   :rtype: pdarray

   :raises TypeError: | Raised if any parameter fails the typechecking
       | Raised if any element of pdarrays num and denom is not a supported type
       | Raised if both num and denom are scalars
       | Raised if where is neither boolean nor a pdarray of boolean


.. py:function:: arctanh(pda: arkouda.pdarrayclass.pdarray, where: Union[bool, arkouda.pdarrayclass.pdarray] = True) -> arkouda.pdarrayclass.pdarray

   Return the element-wise inverse hyperbolic tangent of the array.

   :param pda:
   :type pda: pdarray
   :param where: This condition is broadcast over the input. At locations where the condition is True,
                 the inverse hyperbolic tangent will be applied to the corresponding value. Elsewhere,
                 it will retain its original value. Default set to True.
   :type where: bool or pdarray, default=True

   :returns: A pdarray containing inverse hyperbolic tangent for each element
             of the original pdarray
   :rtype: pdarray

   :raises TypeError: Raised if the parameters are not a pdarray or numeric scalar.


.. py:function:: array_equal(pda_a: arkouda.pdarrayclass.pdarray, pda_b: arkouda.pdarrayclass.pdarray, equal_nan: bool = False) -> bool

   Compares two pdarrays for equality.
   If neither array has any nan elements, then if all elements are pairwise equal,
   it returns True.
   If equal_Nan is False, then any nan element in either array gives a False return.
   If equal_Nan is True, then pairwise-corresponding nans are considered equal.

   :param pda_a:
   :type pda_a: pdarray
   :param pda_b:
   :type pda_b: pdarray
   :param equal_nan: Determines how to handle nans
   :type equal_nan: bool, default=False

   :returns:

             With string data:
                False if one array is type ak.str_ & the other isn't, True if both are ak.str_ & they match.

             With numeric data:
                True if neither array has any nan elements, and all elements pairwise equal.

                True if equal_Nan True, all non-nans pairwise equal & nans in pda_a correspond to nans in pda_b

                False if equal_Nan False, & either array has any nan element.
   :rtype: boolean

   .. rubric:: Examples

   >>> a = ak.randint(0,10,10,dtype=ak.float64)
   >>> b = a
   >>> ak.array_equal(a,b)
   True
   >>> b[9] = np.nan
   >>> ak.array_equal(a,b)
   False
   >>> a[9] = np.nan
   >>> ak.array_equal(a,b)
   False
   >>> ak.array_equal(a,b,True)
   True


.. py:function:: base_repr(number, base=2, padding=0)

   Return a string representation of a number in the given base system.

   :param number: The value to convert. Positive and negative values are handled.
   :type number: int
   :param base: Convert `number` to the `base` number system. The valid range is 2-36,
                the default value is 2.
   :type base: int, optional
   :param padding: Number of zeros padded on the left. Default is 0 (no padding).
   :type padding: int, optional

   :returns: **out** -- String representation of `number` in `base` system.
   :rtype: str

   .. seealso::

      :obj:`binary_repr`
          Faster version of `base_repr` for base 2.

   .. rubric:: Examples

   >>> np.base_repr(5)
   '101'
   >>> np.base_repr(6, 5)
   '11'
   >>> np.base_repr(7, base=5, padding=3)
   '00012'

   >>> np.base_repr(10, base=16)
   'A'
   >>> np.base_repr(32, base=16)
   '20'


.. py:class:: bigint

   .. py:method:: itemsize(*args, **kwargs)

      int([x]) -> integer
      int(x, base=10) -> integer

      Convert a number or string to an integer, or return 0 if no arguments
      are given.  If x is a number, return x.__int__().  For floating point
      numbers, this truncates towards zero.

      If x is not a number or if base is given, then x must be a string,
      bytes, or bytearray instance representing an integer literal in the
      given base.  The literal can be preceded by '+' or '-' and be surrounded
      by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
      Base 0 means to interpret the base from the string as an integer literal.
      >>> int('0b100', base=0)
      4




   .. py:method:: name(*args, **kwargs)

      str(object='') -> str
      str(bytes_or_buffer[, encoding[, errors]]) -> str

      Create a new string object from the given object. If encoding or
      errors is specified, then the object must expose a data buffer
      that will be decoded using the given encoding and error handler.
      Otherwise, returns the result of object.__str__() (if defined)
      or repr(object).
      encoding defaults to sys.getdefaultencoding().
      errors defaults to 'strict'.




   .. py:method:: ndim(*args, **kwargs)

      int([x]) -> integer
      int(x, base=10) -> integer

      Convert a number or string to an integer, or return 0 if no arguments
      are given.  If x is a number, return x.__int__().  For floating point
      numbers, this truncates towards zero.

      If x is not a number or if base is given, then x must be a string,
      bytes, or bytearray instance representing an integer literal in the
      given base.  The literal can be preceded by '+' or '-' and be surrounded
      by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
      Base 0 means to interpret the base from the string as an integer literal.
      >>> int('0b100', base=0)
      4




   .. py:method:: shape(*args, **kwargs)

      Built-in immutable sequence.

      If no argument is given, the constructor returns an empty tuple.
      If iterable is specified the tuple is initialized from iterable's items.

      If the argument is a tuple, the return value is the same object.




   .. py:method:: type(x)


.. py:function:: binary_repr(num, width=None)

   Return the binary representation of the input number as a string.

   For negative numbers, if width is not given, a minus sign is added to the
   front. If width is given, the two's complement of the number is
   returned, with respect to that width.

   In a two's-complement system negative numbers are represented by the two's
   complement of the absolute value. This is the most common method of
   representing signed integers on computers [1]_. A N-bit two's-complement
   system can represent every integer in the range
   :math:`-2^{N-1}` to :math:`+2^{N-1}-1`.

   :param num: Only an integer decimal number can be used.
   :type num: int
   :param width: The length of the returned string if `num` is positive, or the length
                 of the two's complement if `num` is negative, provided that `width` is
                 at least a sufficient number of bits for `num` to be represented in the
                 designated form.

                 If the `width` value is insufficient, it will be ignored, and `num` will
                 be returned in binary (`num` > 0) or two's complement (`num` < 0) form
                 with its width equal to the minimum number of bits needed to represent
                 the number in the designated form. This behavior is deprecated and will
                 later raise an error.

                 .. deprecated:: 1.12.0
   :type width: int, optional

   :returns: **bin** -- Binary representation of `num` or two's complement of `num`.
   :rtype: str

   .. seealso::

      :obj:`base_repr`
          Return a string representation of a number in the given base system.

      :obj:`bin`
          Python's built-in binary representation generator of an integer.

   .. rubric:: Notes

   `binary_repr` is equivalent to using `base_repr` with base 2, but about 25x
   faster.

   .. rubric:: References

   .. [1] Wikipedia, "Two's complement",
       https://en.wikipedia.org/wiki/Two's_complement

   .. rubric:: Examples

   >>> np.binary_repr(3)
   '11'
   >>> np.binary_repr(-3)
   '-11'
   >>> np.binary_repr(3, width=4)
   '0011'

   The two's complement is returned when the input number is negative and
   width is specified:

   >>> np.binary_repr(-3, width=3)
   '101'
   >>> np.binary_repr(-3, width=5)
   '11101'


.. py:class:: bitType(value)

   Bases: :py:obj:`numpy.unsignedinteger`


   Unsigned integer type, compatible with C ``unsigned long``.

       :Character code: ``'L'``
       :Canonical name: `numpy.uint`
       :Alias on this platform (Linux x86_64): `numpy.uint64`: 64-bit unsigned integer (``0`` to ``18_446_744_073_709_551_615``).
       :Alias on this platform (Linux x86_64): `numpy.uintp`: Unsigned integer large enough to fit pointer, compatible with C ``uintptr_t``.



   .. py:method:: bit_count(*args, **kwargs)

      uint64.bit_count() -> int

              Computes the number of 1-bits in the absolute value of the input.
              Analogous to the builtin `int.bit_count` or ``popcount`` in C++.

              Examples
              --------
              >>> np.uint64(127).bit_count()
              7




.. py:class:: bool_(value)

   Bases: :py:obj:`numpy.generic`


   Boolean type (True or False), stored as a byte.

       .. warning::

          The :class:`bool_` type is not a subclass of the :class:`int_` type
          (the :class:`bool_` is not even a number type). This is different
          than Python's default implementation of :class:`bool` as a
          sub-class of :class:`int`.

       :Character code: ``'?'``



.. py:class:: bool_scalars(origin, params, *, inst=True, name=None)

   Bases: :py:obj:`_GenericAlias`


   The central part of internal API.

   This represents a generic version of type 'origin' with type arguments 'params'.
   There are two kind of these aliases: user defined and special. The special ones
   are wrappers around builtin collections and ABCs in collections.abc. These must
   have 'name' always set. If 'inst' is False, then the alias can't be instantiated,
   this is used by e.g. typing.List and typing.Dict.


.. py:class:: byte(value)

   Bases: :py:obj:`numpy.signedinteger`


   Signed integer type, compatible with C ``char``.

       :Character code: ``'b'``
       :Canonical name: `numpy.byte`
       :Alias on this platform (Linux x86_64): `numpy.int8`: 8-bit signed integer (``-128`` to ``127``).



   .. py:method:: bit_count(*args, **kwargs)

      int8.bit_count() -> int

              Computes the number of 1-bits in the absolute value of the input.
              Analogous to the builtin `int.bit_count` or ``popcount`` in C++.

              Examples
              --------
              >>> np.int8(127).bit_count()
              7
              >>> np.int8(-127).bit_count()
              7




.. py:class:: bytes_

   A byte string.

       When used in arrays, this type strips trailing null bytes.

       :Character code: ``'S'``
       :Alias: `numpy.string_`



   .. py:method:: T(*args, **kwargs)

      Scalar attribute identical to the corresponding array attribute.

          Please see `ndarray.T`.




   .. py:method:: all(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.all`.




   .. py:method:: any(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.any`.




   .. py:method:: argmax(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.argmax`.




   .. py:method:: argmin(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.argmin`.




   .. py:method:: argsort(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.argsort`.




   .. py:method:: astype(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.astype`.




   .. py:method:: base(*args, **kwargs)

      Scalar attribute identical to the corresponding array attribute.

          Please see `ndarray.base`.




   .. py:method:: byteswap(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.byteswap`.




   .. py:method:: choose(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.choose`.




   .. py:method:: clip(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.clip`.




   .. py:method:: compress(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.compress`.




   .. py:method:: conj(*args, **kwargs)


   .. py:method:: conjugate(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.conjugate`.




   .. py:method:: copy(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.copy`.




   .. py:method:: cumprod(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.cumprod`.




   .. py:method:: cumsum(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.cumsum`.




   .. py:method:: data(*args, **kwargs)

      Pointer to start of data.




   .. py:method:: diagonal(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.diagonal`.




   .. py:method:: dtype(*args, **kwargs)

      Get array data-descriptor.




   .. py:method:: dump(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.dump`.




   .. py:method:: dumps(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.dumps`.




   .. py:method:: fill(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.fill`.




   .. py:method:: flags(*args, **kwargs)

      The integer value of flags.




   .. py:method:: flat(*args, **kwargs)

      A 1-D view of the scalar.




   .. py:method:: flatten(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.flatten`.




   .. py:method:: getfield(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.getfield`.




   .. py:method:: imag(*args, **kwargs)

      The imaginary part of the scalar.




   .. py:method:: item(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.item`.




   .. py:method:: itemset(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.itemset`.




   .. py:method:: itemsize(*args, **kwargs)

      The length of one element in bytes.




   .. py:method:: max(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.max`.




   .. py:method:: mean(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.mean`.




   .. py:method:: min(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.min`.




   .. py:method:: nbytes(*args, **kwargs)

      The length of the scalar in bytes.




   .. py:method:: ndim(*args, **kwargs)

      The number of array dimensions.




   .. py:method:: newbyteorder(*args, **kwargs)

      newbyteorder(new_order='S', /)

          Return a new `dtype` with a different byte order.

          Changes are also made in all fields and sub-arrays of the data type.

          The `new_order` code can be any from the following:

          * 'S' - swap dtype from current to opposite endian
          * {'<', 'little'} - little endian
          * {'>', 'big'} - big endian
          * {'=', 'native'} - native order
          * {'|', 'I'} - ignore (no change to byte order)

          Parameters
          ----------
          new_order : str, optional
              Byte order to force; a value from the byte order specifications
              above.  The default value ('S') results in swapping the current
              byte order.


          Returns
          -------
          new_dtype : dtype
              New `dtype` object with the given change to the byte order.




   .. py:method:: nonzero(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.nonzero`.




   .. py:method:: prod(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.prod`.




   .. py:method:: ptp(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.ptp`.




   .. py:method:: put(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.put`.




   .. py:method:: ravel(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.ravel`.




   .. py:method:: real(*args, **kwargs)

      The real part of the scalar.




   .. py:method:: repeat(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.repeat`.




   .. py:method:: reshape(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.reshape`.




   .. py:method:: resize(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.resize`.




   .. py:method:: round(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.round`.




   .. py:method:: searchsorted(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.searchsorted`.




   .. py:method:: setfield(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.setfield`.




   .. py:method:: setflags(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.setflags`.




   .. py:method:: shape(*args, **kwargs)

      Tuple of array dimensions.




   .. py:method:: size(*args, **kwargs)

      The number of elements in the gentype.




   .. py:method:: sort(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.sort`.




   .. py:method:: squeeze(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.squeeze`.




   .. py:method:: std(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.std`.




   .. py:method:: strides(*args, **kwargs)

      Tuple of bytes steps in each dimension.




   .. py:method:: sum(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.sum`.




   .. py:method:: swapaxes(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.swapaxes`.




   .. py:method:: take(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.take`.




   .. py:method:: tobytes(*args, **kwargs)


   .. py:method:: tofile(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.tofile`.




   .. py:method:: tolist(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.tolist`.




   .. py:method:: tostring(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.tostring`.




   .. py:method:: trace(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.trace`.




   .. py:method:: transpose(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.transpose`.




   .. py:method:: var(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.var`.




   .. py:method:: view(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.view`.




.. py:function:: cast(pda: Union[arkouda.pdarrayclass.pdarray, arkouda.strings.Strings, ~Categorical], dt: Union[numpy.dtype, type, str, dtypes.dtypes.bigint], errors: _numeric.ErrorMode = ErrorMode.strict) -> Union[arkouda.pdarrayclass.pdarray, arkouda.strings.Strings, ~Categorical, Tuple[arkouda.pdarrayclass.pdarray, arkouda.pdarrayclass.pdarray]]

   Cast an array to another dtype.

   :param pda: The array of values to cast
   :type pda: pdarray, Strings, or Categorical
   :param dt: The target dtype to cast values to
   :type dt: np.dtype, type, str, or bigint
   :param errors: Controls how errors are handled when casting strings to a numeric type
                  (ignored for casts from numeric types).
                      - strict: raise RuntimeError if *any* string cannot be converted
                      - ignore: never raise an error. Uninterpretable strings get
                          converted to NaN (float64), -2**63 (int64), zero (uint64 and
                          uint8), or False (bool)
                      - return_validity: in addition to returning the same output as
                        "ignore", also return a bool array indicating where the cast
                        was successful.
                  Default set to strict.
   :type errors: {strict, ignore, return_validity}, default=ErrorMode.strict

   :returns: * *pdarray or Strings* -- Array of values cast to desired dtype
             * **[validity** (*pdarray(bool)]*) -- If errors="return_validity" and input is Strings, a second array is
               returned with True where the cast succeeded and False where it failed.

   .. rubric:: Notes

   The cast is performed according to Chapel's casting rules and is NOT safe
   from overflows or underflows. The user must ensure that the target dtype
   has the precision and capacity to hold the desired result.

   .. rubric:: Examples

   >>> ak.cast(ak.linspace(1.0,5.0,5), dt=ak.int64)
   array([1 2 3 4 5])

   >>> ak.cast(ak.arange(0,5), dt=ak.float64).dtype
   dtype('float64')

   >>> ak.cast(ak.arange(0,5), dt=ak.bool_)
   array([False True True True True])

   >>> ak.cast(ak.linspace(0,4,5), dt=ak.bool_)
   array([False True True True True])


.. py:class:: cdouble(value)

   Bases: :py:obj:`numpy.complexfloating`


   Complex number type composed of two double-precision floating-point
       numbers, compatible with Python `complex`.

       :Character code: ``'D'``
       :Canonical name: `numpy.cdouble`
       :Alias: `numpy.cfloat`
       :Alias: `numpy.complex_`
       :Alias on this platform (Linux x86_64): `numpy.complex128`: Complex number type composed of 2 64-bit-precision floating-point numbers.



.. py:function:: ceil(pda: arkouda.pdarrayclass.pdarray) -> arkouda.pdarrayclass.pdarray

   Return the element-wise ceiling of the array.

   :param pda:
   :type pda: pdarray

   :returns: A pdarray containing ceiling values of the input array elements
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray

   .. rubric:: Examples

   >>> ak.ceil(ak.linspace(1.1,5.5,5))
   array([2.00000000000000000 3.00000000000000000 4.00000000000000000
   5.00000000000000000 6.00000000000000000])


.. py:class:: cfloat(value)

   Bases: :py:obj:`numpy.complexfloating`


   Complex number type composed of two double-precision floating-point
       numbers, compatible with Python `complex`.

       :Character code: ``'D'``
       :Canonical name: `numpy.cdouble`
       :Alias: `numpy.cfloat`
       :Alias: `numpy.complex_`
       :Alias on this platform (Linux x86_64): `numpy.complex128`: Complex number type composed of 2 64-bit-precision floating-point numbers.



.. py:class:: character(value)

   Bases: :py:obj:`numpy.flexible`


   Abstract base class of all character string scalar types.



.. py:function:: clip(pda: arkouda.pdarrayclass.pdarray, lo: Union[float, numpy.float64, numpy.float32, int, numpy.int8, numpy.int16, numpy.int32, numpy.int64, numpy.uint8, numpy.uint16, numpy.uint32, numpy.uint64, arkouda.pdarrayclass.pdarray], hi: Union[float, numpy.float64, numpy.float32, int, numpy.int8, numpy.int16, numpy.int32, numpy.int64, numpy.uint8, numpy.uint16, numpy.uint32, numpy.uint64, arkouda.pdarrayclass.pdarray]) -> arkouda.pdarrayclass.pdarray

   Clip (limit) the values in an array to a given range [lo,hi]

   Given an array a, values outside the range are clipped to the
   range edges, such that all elements lie in the range.

   There is no check to enforce that lo < hi.  If lo > hi, the corresponding
   value of the array will be set to hi.

   If lo or hi (or both) are pdarrays, the check is by pairwise elements.
   See examples.

   :param pda: the array of values to clip
   :type pda: pdarray
   :param lo: the lower value of the clipping range
   :type lo: numeric_scalars or pdarray
   :param hi: the higher value of the clipping range
              If lo or hi (or both) are pdarrays, the check is by pairwise elements.
              See examples.
   :type hi: numeric_scalars or pdarray

   :returns:

             A pdarray matching pda, except that element x remains x if lo <= x <= hi,
                                                     or becomes lo if x < lo,
                                                     or becomes hi if x > hi.
   :rtype: arkouda.pdarrayclass.pdarray

   .. rubric:: Examples

   >>> a = ak.array([1,2,3,4,5,6,7,8,9,10])
   >>> ak.clip(a,3,8)
   array([3 3 3 4 5 6 7 8 8 8])
   >>> ak.clip(a,3,8.0)
   array([3.00000000000000000 3.00000000000000000 3.00000000000000000 4.00000000000000000
          5.00000000000000000 6.00000000000000000 7.00000000000000000 8.00000000000000000
          8.00000000000000000 8.00000000000000000])
   >>> ak.clip(a,None,7)
   array([1 2 3 4 5 6 7 7 7 7])
   >>> ak.clip(a,5,None)
   array([5 5 5 5 5 6 7 8 9 10])
   >>> ak.clip(a,None,None)
   ValueError: Either min or max must be supplied.
   >>> ak.clip(a,ak.array([2,2,3,3,8,8,5,5,6,6]),8)
   array([2 2 3 4 8 8 7 8 8 8])
   >>> ak.clip(a,4,ak.array([10,9,8,7,6,5,5,5,5,5]))
   array([4 4 4 4 5 5 5 5 5 5])

   .. rubric:: Notes

   Either lo or hi may be None, but not both.
   If lo > hi, all x = hi.
   If all inputs are int64, output is int64, but if any input is float64, output is float64.

   :raises ValueError: Raised if both lo and hi are None


.. py:class:: clongdouble(value)

   Bases: :py:obj:`numpy.complexfloating`


   Complex number type composed of two extended-precision floating-point
       numbers.

       :Character code: ``'G'``
       :Alias: `numpy.clongfloat`
       :Alias: `numpy.longcomplex`
       :Alias on this platform (Linux x86_64): `numpy.complex256`: Complex number type composed of 2 128-bit extended-precision floating-point numbers.



.. py:class:: clongfloat(value)

   Bases: :py:obj:`numpy.complexfloating`


   Complex number type composed of two extended-precision floating-point
       numbers.

       :Character code: ``'G'``
       :Alias: `numpy.clongfloat`
       :Alias: `numpy.longcomplex`
       :Alias on this platform (Linux x86_64): `numpy.complex256`: Complex number type composed of 2 128-bit extended-precision floating-point numbers.



.. py:class:: complex128(value)

   Bases: :py:obj:`numpy.complexfloating`


   Complex number type composed of two double-precision floating-point
       numbers, compatible with Python `complex`.

       :Character code: ``'D'``
       :Canonical name: `numpy.cdouble`
       :Alias: `numpy.cfloat`
       :Alias: `numpy.complex_`
       :Alias on this platform (Linux x86_64): `numpy.complex128`: Complex number type composed of 2 64-bit-precision floating-point numbers.



.. py:class:: complex64(value)

   Bases: :py:obj:`numpy.complexfloating`


   Complex number type composed of two single-precision floating-point
       numbers.

       :Character code: ``'F'``
       :Canonical name: `numpy.csingle`
       :Alias: `numpy.singlecomplex`
       :Alias on this platform (Linux x86_64): `numpy.complex64`: Complex number type composed of 2 32-bit-precision floating-point numbers.



.. py:function:: cos(pda: arkouda.pdarrayclass.pdarray, where: Union[bool, arkouda.pdarrayclass.pdarray] = True) -> arkouda.pdarrayclass.pdarray

   Return the element-wise cosine of the array.

   :param pda:
   :type pda: pdarray
   :param where: This condition is broadcast over the input. At locations where the condition is True,
                 the cosine will be applied to the corresponding value. Elsewhere, it will retain
                 its original value. Default set to True.
   :type where: bool or pdarray, default=True

   :returns: A pdarray containing cosine for each element
             of the original pdarray
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray


.. py:function:: cosh(pda: arkouda.pdarrayclass.pdarray, where: Union[bool, arkouda.pdarrayclass.pdarray] = True) -> arkouda.pdarrayclass.pdarray

   Return the element-wise hyperbolic cosine of the array.

   :param pda:
   :type pda: pdarray
   :param where: This condition is broadcast over the input. At locations where the condition is True,
                 the hyperbolic cosine will be applied to the corresponding value. Elsewhere, it will retain
                 its original value. Default set to True.
   :type where: bool or pdarray, default=True

   :returns: A pdarray containing hyperbolic cosine for each element
             of the original pdarray
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray


.. py:function:: count_nonzero(pda: arkouda.pdarrayclass.pdarray) -> numpy.int64

   Compute the nonzero count of a given array. 1D case only, for now.

   :param pda: The input data, in pdarray form, numeric, bool, or str
   :type pda: pdarray

   :returns: The nonzero count of the entire pdarray
   :rtype: np.int64

   :raises TypeError: Raised if the parameter is not a pdarray with numeric, bool, or str datatype
   :raises ValueError: Raised if sum applied to the pdarray doesn't come back with a scalar

   .. rubric:: Examples

   >>> pda = ak.array([0,4,7,8,1,3,5,2,-1])
   >>> ak.count_nonzero(pda)
   8
   >>> pda = ak.array([False,True,False,True,False])
   >>> ak.count_nonzero(pda)
   2
   >>> pda = ak.array(["hello","","there"])
   >>> ak.count_nonzero(pda)
   2


.. py:class:: csingle(value)

   Bases: :py:obj:`numpy.complexfloating`


   Complex number type composed of two single-precision floating-point
       numbers.

       :Character code: ``'F'``
       :Canonical name: `numpy.csingle`
       :Alias: `numpy.singlecomplex`
       :Alias on this platform (Linux x86_64): `numpy.complex64`: Complex number type composed of 2 32-bit-precision floating-point numbers.



.. py:function:: cumprod(pda: arkouda.pdarrayclass.pdarray) -> arkouda.pdarrayclass.pdarray

   Return the cumulative product over the array.

   The product is inclusive, such that the ``i`` th element of the
   result is the product of elements up to and including ``i``.

   :param pda:
   :type pda: pdarray

   :returns: A pdarray containing cumulative products for each element
             of the original pdarray
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray

   .. rubric:: Examples

   >>> ak.cumprod(ak.arange(1,5))
   array([1 2 6 24])

   >>> ak.cumprod(ak.uniform(5,1.0,5.0))
   array([1.5728783400481925 7.0472855509390593 33.78523998586553
          134.05309592737584 450.21589865655358])


.. py:function:: cumsum(pda: arkouda.pdarrayclass.pdarray) -> arkouda.pdarrayclass.pdarray

   Return the cumulative sum over the array.

   The sum is inclusive, such that the ``i`` th element of the
   result is the sum of elements up to and including ``i``.

   :param pda:
   :type pda: pdarray

   :returns: A pdarray containing cumulative sums for each element
             of the original pdarray
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray

   .. rubric:: Examples

   >>> ak.cumsum(ak.arange(1,5))
   array([1 3 6 10])

   >>> ak.cumsum(ak.uniform(5,1.0,5.0))
   array([3.1598310770203937 5.4110385860243131 9.1622479306453748
          12.710615785506533 13.945880905466208])

   >>> ak.cumsum(ak.randint(0, 1, 5, dtype=ak.bool_))
   array([0 1 1 2 3])


.. py:class:: datetime64(value)

   Bases: :py:obj:`numpy.generic`


   If created from a 64-bit integer, it represents an offset from
       ``1970-01-01T00:00:00``.
       If created from string, the string can be in ISO 8601 date
       or datetime format.

       >>> np.datetime64(10, 'Y')
       numpy.datetime64('1980')
       >>> np.datetime64('1980', 'Y')
       numpy.datetime64('1980')
       >>> np.datetime64(10, 'D')
       numpy.datetime64('1970-01-11')

       See :ref:`arrays.datetime` for more information.

       :Character code: ``'M'``



.. py:function:: deg2rad(pda: arkouda.pdarrayclass.pdarray, where: Union[bool, arkouda.pdarrayclass.pdarray] = True) -> arkouda.pdarrayclass.pdarray

   Converts angles element-wise from degrees to radians.

   :param pda:
   :type pda: pdarray
   :param where: This condition is broadcast over the input. At locations where the condition is True, the
                 corresponding value will be converted from degrees to radians. Elsewhere, it will retain its
                 original value. Default set to True.
   :type where: bool or pdarray, default=True

   :returns: A pdarray containing an angle converted to radians, from degrees, for each element
             of the original pdarray
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray


.. py:function:: deprecate(*args, **kwargs)

   Issues a DeprecationWarning, adds warning to `old_name`'s
   docstring, rebinds ``old_name.__name__`` and returns the new
   function object.

   This function may also be used as a decorator.

   :param func: The function to be deprecated.
   :type func: function
   :param old_name: The name of the function to be deprecated. Default is None, in
                    which case the name of `func` is used.
   :type old_name: str, optional
   :param new_name: The new name for the function. Default is None, in which case the
                    deprecation message is that `old_name` is deprecated. If given, the
                    deprecation message is that `old_name` is deprecated and `new_name`
                    should be used instead.
   :type new_name: str, optional
   :param message: Additional explanation of the deprecation.  Displayed in the
                   docstring after the warning.
   :type message: str, optional

   :returns: **old_func** -- The deprecated function.
   :rtype: function

   .. rubric:: Examples

   Note that ``olduint`` returns a value after printing Deprecation
   Warning:

   >>> olduint = np.deprecate(np.uint)
   DeprecationWarning: `uint64` is deprecated! # may vary
   >>> olduint(6)
   6


.. py:function:: deprecate_with_doc(msg)

   Deprecates a function and includes the deprecation in its docstring.

   This function is used as a decorator. It returns an object that can be
   used to issue a DeprecationWarning, by passing the to-be decorated
   function as argument, this adds warning to the to-be decorated function's
   docstring and returns the new function object.

   .. seealso::

      :obj:`deprecate`
          Decorate a function such that it issues a `DeprecationWarning`

   :param msg: Additional explanation of the deprecation. Displayed in the
               docstring after the warning.
   :type msg: str

   :returns: **obj**
   :rtype: object


.. py:function:: disp(mesg, device=None, linefeed=True)

   Display a message on a device.

   :param mesg: Message to display.
   :type mesg: str
   :param device: Device to write message. If None, defaults to ``sys.stdout`` which is
                  very similar to ``print``. `device` needs to have ``write()`` and
                  ``flush()`` methods.
   :type device: object
   :param linefeed: Option whether to print a line feed or not. Defaults to True.
   :type linefeed: bool, optional

   :raises AttributeError: If `device` does not have a ``write()`` or ``flush()`` method.

   .. rubric:: Examples

   Besides ``sys.stdout``, a file-like object can also be used as it has
   both required methods:

   >>> from io import StringIO
   >>> buf = StringIO()
   >>> np.disp(u'"Display" in a file', device=buf)
   >>> buf.getvalue()
   '"Display" in a file\n'


.. py:class:: double(value)

   Bases: :py:obj:`numpy.floating`


   Double-precision floating-point number type, compatible with Python `float`
       and C ``double``.

       :Character code: ``'d'``
       :Canonical name: `numpy.double`
       :Alias: `numpy.float_`
       :Alias on this platform (Linux x86_64): `numpy.float64`: 64-bit precision floating-point number type: sign bit, 11 bits exponent, 52 bits mantissa.



   .. py:method:: as_integer_ratio(*args, **kwargs)

      double.as_integer_ratio() -> (int, int)

              Return a pair of integers, whose ratio is exactly equal to the original
              floating point number, and with a positive denominator.
              Raise `OverflowError` on infinities and a `ValueError` on NaNs.

              >>> np.double(10.0).as_integer_ratio()
              (10, 1)
              >>> np.double(0.0).as_integer_ratio()
              (0, 1)
              >>> np.double(-.25).as_integer_ratio()
              (-1, 4)




   .. py:method:: fromhex(string, /)

      Create a floating-point number from a hexadecimal string.

      >>> float.fromhex('0x1.ffffp10')
      2047.984375
      >>> float.fromhex('-0x1p-1074')
      -5e-324




   .. py:method:: hex(/)

      Return a hexadecimal representation of a floating-point number.

      >>> (-0.1).hex()
      '-0x1.999999999999ap-4'
      >>> 3.14159.hex()
      '0x1.921f9f01b866ep+1'




   .. py:method:: is_integer(*args, **kwargs)

      double.is_integer() -> bool

              Return ``True`` if the floating point number is finite with integral
              value, and ``False`` otherwise.

              .. versionadded:: 1.22

              Examples
              --------
              >>> np.double(-2.0).is_integer()
              True
              >>> np.double(3.2).is_integer()
              False




.. py:function:: dtype(x)

.. py:data:: e
   :type:  float

.. py:data:: euler_gamma
   :type:  float

.. py:function:: exp(pda: arkouda.pdarrayclass.pdarray) -> arkouda.pdarrayclass.pdarray

   Return the element-wise exponential of the array.

   :param pda:
   :type pda: pdarray

   :returns: A pdarray containing exponential values of the input
             array elements
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray

   .. rubric:: Examples

   >>> ak.exp(ak.arange(1,5))
   array([2.7182818284590451 7.3890560989306504 20.085536923187668 54.598150033144236])

   >>> ak.exp(ak.uniform(5,1.0,5.0))
   array([11.84010843172504 46.454368507659211 5.5571769623557188
          33.494295836924771 13.478894913238722])


.. py:function:: expm1(pda: arkouda.pdarrayclass.pdarray) -> arkouda.pdarrayclass.pdarray

   Return the element-wise exponential of the array minus one.

   :param pda:
   :type pda: pdarray

   :returns: A pdarray containing e raised to each of the inputs,
             then subtracting one.
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray

   .. rubric:: Examples

   >>> ak.expm1(ak.arange(1,5))
   array([1.7182818284590451 6.3890560989306504 19.085536923187668 53.598150033144236])

   >>> ak.expm1(ak.uniform(5,1.0,5.0))
   array([10.84010843172504 45.454368507659211 4.5571769623557188
          32.494295836924771 12.478894913238722])


.. py:function:: eye(rows: Union[int, numpy.int8, numpy.int16, numpy.int32, numpy.int64, numpy.uint8, numpy.uint16, numpy.uint32, numpy.uint64], cols: Union[int, numpy.int8, numpy.int16, numpy.int32, numpy.int64, numpy.uint8, numpy.uint16, numpy.uint32, numpy.uint64], diag: Union[int, numpy.int8, numpy.int16, numpy.int32, numpy.int64, numpy.uint8, numpy.uint16, numpy.uint32, numpy.uint64] = 0, dt: type = numpy.int64) -> arkouda.pdarrayclass.pdarray

   Return a pdarray with zeros everywhere except along a diagonal, which is all ones.
   The matrix need not be square.

   :param rows:
   :type rows: int_scalars
   :param cols:
   :type cols: int_scalars
   :param diag: | if diag = 0, zeros start at element [0,0] and proceed along diagonal
                | if diag > 0, zeros start at element [0,diag] and proceed along diagonal
                | if diag < 0, zeros start at element [diag,0] and proceed along diagonal
                | etc. Default set to 0.
   :type diag: int_scalars, default=0
   :param dt: The data type of the elements in the matrix being returned. Default set to ak_int64
   :type dt: type, default=ak_int64

   :returns: an array of zeros with ones along the specified diagonal
   :rtype: pdarray

   .. rubric:: Examples

   >>> ak.eye(rows=4,cols=4,diag=0,dt=ak.int64)
   array([array([1 0 0 0]) array([0 1 0 0]) array([0 0 1 0]) array([0 0 0 1])])
   >>> ak.eye(rows=3,cols=3,diag=1,dt=ak.float64)
   array([array([0.00000000000000000 1.00000000000000000 0.00000000000000000])
   array([0.00000000000000000 0.00000000000000000 1.00000000000000000])
   array([0.00000000000000000 0.00000000000000000 0.00000000000000000])])
   >>> ak.eye(rows=4,cols=4,diag=-1,dt=ak.bool_)
   array([array([False False False False]) array([True False False False])
   array([False True False False]) array([False False True False])])

   .. rubric:: Notes

   if rows = cols and diag = 0, the result is an identity matrix
   Server returns an error if rank of pda < 2


.. py:class:: finfo

   finfo(dtype)

   Machine limits for floating point types.

   .. attribute:: bits

      The number of bits occupied by the type.

      :type: int

   .. attribute:: dtype

      Returns the dtype for which `finfo` returns information. For complex
      input, the returned dtype is the associated ``float*`` dtype for its
      real and complex components.

      :type: dtype

   .. attribute:: eps

      The difference between 1.0 and the next smallest representable float
      larger than 1.0. For example, for 64-bit binary floats in the IEEE-754
      standard, ``eps = 2**-52``, approximately 2.22e-16.

      :type: float

   .. attribute:: epsneg

      The difference between 1.0 and the next smallest representable float
      less than 1.0. For example, for 64-bit binary floats in the IEEE-754
      standard, ``epsneg = 2**-53``, approximately 1.11e-16.

      :type: float

   .. attribute:: iexp

      The number of bits in the exponent portion of the floating point
      representation.

      :type: int

   .. attribute:: machep

      The exponent that yields `eps`.

      :type: int

   .. attribute:: max

      The largest representable number.

      :type: floating point number of the appropriate type

   .. attribute:: maxexp

      The smallest positive power of the base (2) that causes overflow.

      :type: int

   .. attribute:: min

      The smallest representable number, typically ``-max``.

      :type: floating point number of the appropriate type

   .. attribute:: minexp

      The most negative power of the base (2) consistent with there
      being no leading 0's in the mantissa.

      :type: int

   .. attribute:: negep

      The exponent that yields `epsneg`.

      :type: int

   .. attribute:: nexp

      The number of bits in the exponent including its sign and bias.

      :type: int

   .. attribute:: nmant

      The number of bits in the mantissa.

      :type: int

   .. attribute:: precision

      The approximate number of decimal digits to which this kind of
      float is precise.

      :type: int

   .. attribute:: resolution

      The approximate decimal resolution of this type, i.e.,
      ``10**-precision``.

      :type: floating point number of the appropriate type

   .. attribute:: tiny

      An alias for `smallest_normal`, kept for backwards compatibility.

      :type: float

   .. attribute:: smallest_normal

      The smallest positive floating point number with 1 as leading bit in
      the mantissa following IEEE-754 (see Notes).

      :type: float

   .. attribute:: smallest_subnormal

      The smallest positive floating point number with 0 as leading bit in
      the mantissa following IEEE-754.

      :type: float

   :param dtype: Kind of floating point or complex floating point
                 data-type about which to get information.
   :type dtype: float, dtype, or instance

   .. seealso::

      :obj:`iinfo`
          The equivalent for integer data types.

      :obj:`spacing`
          The distance between a value and the nearest adjacent number

      :obj:`nextafter`
          The next floating point value after x1 towards x2

   .. rubric:: Notes

   For developers of NumPy: do not instantiate this at the module level.
   The initial calculation of these parameters is expensive and negatively
   impacts import times.  These objects are cached, so calling ``finfo()``
   repeatedly inside your functions is not a problem.

   Note that ``smallest_normal`` is not actually the smallest positive
   representable value in a NumPy floating point type. As in the IEEE-754
   standard [1]_, NumPy floating point types make use of subnormal numbers to
   fill the gap between 0 and ``smallest_normal``. However, subnormal numbers
   may have significantly reduced precision [2]_.

   This function can also be used for complex data types as well. If used,
   the output will be the same as the corresponding real float type
   (e.g. numpy.finfo(numpy.csingle) is the same as numpy.finfo(numpy.single)).
   However, the output is true for the real and imaginary components.

   .. rubric:: References

   .. [1] IEEE Standard for Floating-Point Arithmetic, IEEE Std 754-2008,
          pp.1-70, 2008, http://www.doi.org/10.1109/IEEESTD.2008.4610935
   .. [2] Wikipedia, "Denormal Numbers",
          https://en.wikipedia.org/wiki/Denormal_number

   .. rubric:: Examples

   >>> np.finfo(np.float64).dtype
   dtype('float64')
   >>> np.finfo(np.complex64).dtype
   dtype('float32')


   .. py:property:: smallest_normal

      Return the value for the smallest normal.

      :returns: **smallest_normal** -- Value for the smallest normal.
      :rtype: float

      :Warns: **UserWarning** -- If the calculated value for the smallest normal is requested for
              double-double.


   .. py:property:: tiny

      Return the value for tiny, alias of smallest_normal.

      :returns: **tiny** -- Value for the smallest normal, alias of smallest_normal.
      :rtype: float

      :Warns: **UserWarning** -- If the calculated value for the smallest normal is requested for
              double-double.


.. py:class:: flexible(value)

   Bases: :py:obj:`numpy.generic`


   Abstract base class of all scalar types without predefined length.
       The actual size of these types depends on the specific `np.dtype`
       instantiation.



.. py:function:: flip(x: Union[arkouda.pdarrayclass.pdarray, arkouda.strings.Strings, arkouda.categorical.Categorical], /, *, axis: Union[int, Tuple[int, Ellipsis], NoneType] = None) -> Union[arkouda.pdarrayclass.pdarray, arkouda.strings.Strings, arkouda.categorical.Categorical]

   Reverse an array's values along a particular axis or axes.

   :param x: Reverse the order of elements in an array along the given axis.

             The shape of the array is preserved, but the elements are reordered.
   :type x: pdarray, Strings, or Categorical
   :param axis: The axis or axes along which to flip the array. If None, flip the array along all axes.
   :type axis: int or Tuple[int, ...], optional

   :returns: An array with the entries of axis reversed.
   :rtype: pdarray, Strings, or Categorical

   .. note:: This differs from numpy as it actually reverses the data, rather than presenting a view.


.. py:class:: float16(value)

   Bases: :py:obj:`numpy.floating`


   Half-precision floating-point number type.

       :Character code: ``'e'``
       :Canonical name: `numpy.half`
       :Alias on this platform (Linux x86_64): `numpy.float16`: 16-bit-precision floating-point number type: sign bit, 5 bits exponent, 10 bits mantissa.



   .. py:method:: as_integer_ratio(*args, **kwargs)

      half.as_integer_ratio() -> (int, int)

              Return a pair of integers, whose ratio is exactly equal to the original
              floating point number, and with a positive denominator.
              Raise `OverflowError` on infinities and a `ValueError` on NaNs.

              >>> np.half(10.0).as_integer_ratio()
              (10, 1)
              >>> np.half(0.0).as_integer_ratio()
              (0, 1)
              >>> np.half(-.25).as_integer_ratio()
              (-1, 4)




   .. py:method:: is_integer(*args, **kwargs)

      half.is_integer() -> bool

              Return ``True`` if the floating point number is finite with integral
              value, and ``False`` otherwise.

              .. versionadded:: 1.22

              Examples
              --------
              >>> np.half(-2.0).is_integer()
              True
              >>> np.half(3.2).is_integer()
              False




.. py:class:: float32(value)

   Bases: :py:obj:`numpy.floating`


   Single-precision floating-point number type, compatible with C ``float``.

       :Character code: ``'f'``
       :Canonical name: `numpy.single`
       :Alias on this platform (Linux x86_64): `numpy.float32`: 32-bit-precision floating-point number type: sign bit, 8 bits exponent, 23 bits mantissa.



   .. py:method:: as_integer_ratio(*args, **kwargs)

      single.as_integer_ratio() -> (int, int)

              Return a pair of integers, whose ratio is exactly equal to the original
              floating point number, and with a positive denominator.
              Raise `OverflowError` on infinities and a `ValueError` on NaNs.

              >>> np.single(10.0).as_integer_ratio()
              (10, 1)
              >>> np.single(0.0).as_integer_ratio()
              (0, 1)
              >>> np.single(-.25).as_integer_ratio()
              (-1, 4)




   .. py:method:: is_integer(*args, **kwargs)

      single.is_integer() -> bool

              Return ``True`` if the floating point number is finite with integral
              value, and ``False`` otherwise.

              .. versionadded:: 1.22

              Examples
              --------
              >>> np.single(-2.0).is_integer()
              True
              >>> np.single(3.2).is_integer()
              False




.. py:class:: float64(value)

   Bases: :py:obj:`numpy.floating`


   Double-precision floating-point number type, compatible with Python `float`
       and C ``double``.

       :Character code: ``'d'``
       :Canonical name: `numpy.double`
       :Alias: `numpy.float_`
       :Alias on this platform (Linux x86_64): `numpy.float64`: 64-bit precision floating-point number type: sign bit, 11 bits exponent, 52 bits mantissa.



   .. py:method:: as_integer_ratio(*args, **kwargs)

      double.as_integer_ratio() -> (int, int)

              Return a pair of integers, whose ratio is exactly equal to the original
              floating point number, and with a positive denominator.
              Raise `OverflowError` on infinities and a `ValueError` on NaNs.

              >>> np.double(10.0).as_integer_ratio()
              (10, 1)
              >>> np.double(0.0).as_integer_ratio()
              (0, 1)
              >>> np.double(-.25).as_integer_ratio()
              (-1, 4)




   .. py:method:: fromhex(string, /)

      Create a floating-point number from a hexadecimal string.

      >>> float.fromhex('0x1.ffffp10')
      2047.984375
      >>> float.fromhex('-0x1p-1074')
      -5e-324




   .. py:method:: hex(/)

      Return a hexadecimal representation of a floating-point number.

      >>> (-0.1).hex()
      '-0x1.999999999999ap-4'
      >>> 3.14159.hex()
      '0x1.921f9f01b866ep+1'




   .. py:method:: is_integer(*args, **kwargs)

      double.is_integer() -> bool

              Return ``True`` if the floating point number is finite with integral
              value, and ``False`` otherwise.

              .. versionadded:: 1.22

              Examples
              --------
              >>> np.double(-2.0).is_integer()
              True
              >>> np.double(3.2).is_integer()
              False




.. py:class:: float_(value)

   Bases: :py:obj:`numpy.floating`


   Double-precision floating-point number type, compatible with Python `float`
       and C ``double``.

       :Character code: ``'d'``
       :Canonical name: `numpy.double`
       :Alias: `numpy.float_`
       :Alias on this platform (Linux x86_64): `numpy.float64`: 64-bit precision floating-point number type: sign bit, 11 bits exponent, 52 bits mantissa.



   .. py:method:: as_integer_ratio(*args, **kwargs)

      double.as_integer_ratio() -> (int, int)

              Return a pair of integers, whose ratio is exactly equal to the original
              floating point number, and with a positive denominator.
              Raise `OverflowError` on infinities and a `ValueError` on NaNs.

              >>> np.double(10.0).as_integer_ratio()
              (10, 1)
              >>> np.double(0.0).as_integer_ratio()
              (0, 1)
              >>> np.double(-.25).as_integer_ratio()
              (-1, 4)




   .. py:method:: fromhex(string, /)

      Create a floating-point number from a hexadecimal string.

      >>> float.fromhex('0x1.ffffp10')
      2047.984375
      >>> float.fromhex('-0x1p-1074')
      -5e-324




   .. py:method:: hex(/)

      Return a hexadecimal representation of a floating-point number.

      >>> (-0.1).hex()
      '-0x1.999999999999ap-4'
      >>> 3.14159.hex()
      '0x1.921f9f01b866ep+1'




   .. py:method:: is_integer(*args, **kwargs)

      double.is_integer() -> bool

              Return ``True`` if the floating point number is finite with integral
              value, and ``False`` otherwise.

              .. versionadded:: 1.22

              Examples
              --------
              >>> np.double(-2.0).is_integer()
              True
              >>> np.double(3.2).is_integer()
              False




.. py:class:: float_scalars(origin, params, *, inst=True, name=None)

   Bases: :py:obj:`_GenericAlias`


   The central part of internal API.

   This represents a generic version of type 'origin' with type arguments 'params'.
   There are two kind of these aliases: user defined and special. The special ones
   are wrappers around builtin collections and ABCs in collections.abc. These must
   have 'name' always set. If 'inst' is False, then the alias can't be instantiated,
   this is used by e.g. typing.List and typing.Dict.


.. py:class:: floating(value)

   Bases: :py:obj:`numpy.inexact`


   Abstract base class of all floating-point scalar types.



.. py:function:: floor(pda: arkouda.pdarrayclass.pdarray) -> arkouda.pdarrayclass.pdarray

   Return the element-wise floor of the array.

   :param pda:
   :type pda: pdarray

   :returns: A pdarray containing floor values of the input array elements
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray

   .. rubric:: Examples

   >>> ak.floor(ak.linspace(1.1,5.5,5))
   array([1.00000000000000000 2.00000000000000000 3.00000000000000000
   4.00000000000000000 5.00000000000000000])


.. py:function:: format_float_positional(x, precision=None, unique=True, fractional=True, trim='k', sign=False, pad_left=None, pad_right=None, min_digits=None)

   Format a floating-point scalar as a decimal string in positional notation.

   Provides control over rounding, trimming and padding. Uses and assumes
   IEEE unbiased rounding. Uses the "Dragon4" algorithm.

   :param x: Value to format.
   :type x: python float or numpy floating scalar
   :param precision: Maximum number of digits to print. May be None if `unique` is
                     `True`, but must be an integer if unique is `False`.
   :type precision: non-negative integer or None, optional
   :param unique: If `True`, use a digit-generation strategy which gives the shortest
                  representation which uniquely identifies the floating-point number from
                  other values of the same type, by judicious rounding. If `precision`
                  is given fewer digits than necessary can be printed, or if `min_digits`
                  is given more can be printed, in which cases the last digit is rounded
                  with unbiased rounding.
                  If `False`, digits are generated as if printing an infinite-precision
                  value and stopping after `precision` digits, rounding the remaining
                  value with unbiased rounding
   :type unique: boolean, optional
   :param fractional: If `True`, the cutoffs of `precision` and `min_digits` refer to the
                      total number of digits after the decimal point, including leading
                      zeros.
                      If `False`, `precision` and `min_digits` refer to the total number of
                      significant digits, before or after the decimal point, ignoring leading
                      zeros.
   :type fractional: boolean, optional
   :param trim: Controls post-processing trimming of trailing digits, as follows:

                * 'k' : keep trailing zeros, keep decimal point (no trimming)
                * '.' : trim all trailing zeros, leave decimal point
                * '0' : trim all but the zero before the decimal point. Insert the
                  zero if it is missing.
                * '-' : trim trailing zeros and any trailing decimal point
   :type trim: one of 'k', '.', '0', '-', optional
   :param sign: Whether to show the sign for positive values.
   :type sign: boolean, optional
   :param pad_left: Pad the left side of the string with whitespace until at least that
                    many characters are to the left of the decimal point.
   :type pad_left: non-negative integer, optional
   :param pad_right: Pad the right side of the string with whitespace until at least that
                     many characters are to the right of the decimal point.
   :type pad_right: non-negative integer, optional
   :param min_digits: Minimum number of digits to print. Only has an effect if `unique=True`
                      in which case additional digits past those necessary to uniquely
                      identify the value may be printed, rounding the last additional digit.

                      -- versionadded:: 1.21.0
   :type min_digits: non-negative integer or None, optional

   :returns: **rep** -- The string representation of the floating point value
   :rtype: string

   .. seealso:: :obj:`format_float_scientific`

   .. rubric:: Examples

   >>> np.format_float_positional(np.float32(np.pi))
   '3.1415927'
   >>> np.format_float_positional(np.float16(np.pi))
   '3.14'
   >>> np.format_float_positional(np.float16(0.3))
   '0.3'
   >>> np.format_float_positional(np.float16(0.3), unique=False, precision=10)
   '0.3000488281'


.. py:function:: format_float_scientific(x, precision=None, unique=True, trim='k', sign=False, pad_left=None, exp_digits=None, min_digits=None)

   Format a floating-point scalar as a decimal string in scientific notation.

   Provides control over rounding, trimming and padding. Uses and assumes
   IEEE unbiased rounding. Uses the "Dragon4" algorithm.

   :param x: Value to format.
   :type x: python float or numpy floating scalar
   :param precision: Maximum number of digits to print. May be None if `unique` is
                     `True`, but must be an integer if unique is `False`.
   :type precision: non-negative integer or None, optional
   :param unique: If `True`, use a digit-generation strategy which gives the shortest
                  representation which uniquely identifies the floating-point number from
                  other values of the same type, by judicious rounding. If `precision`
                  is given fewer digits than necessary can be printed. If `min_digits`
                  is given more can be printed, in which cases the last digit is rounded
                  with unbiased rounding.
                  If `False`, digits are generated as if printing an infinite-precision
                  value and stopping after `precision` digits, rounding the remaining
                  value with unbiased rounding
   :type unique: boolean, optional
   :param trim: Controls post-processing trimming of trailing digits, as follows:

                * 'k' : keep trailing zeros, keep decimal point (no trimming)
                * '.' : trim all trailing zeros, leave decimal point
                * '0' : trim all but the zero before the decimal point. Insert the
                  zero if it is missing.
                * '-' : trim trailing zeros and any trailing decimal point
   :type trim: one of 'k', '.', '0', '-', optional
   :param sign: Whether to show the sign for positive values.
   :type sign: boolean, optional
   :param pad_left: Pad the left side of the string with whitespace until at least that
                    many characters are to the left of the decimal point.
   :type pad_left: non-negative integer, optional
   :param exp_digits: Pad the exponent with zeros until it contains at least this many digits.
                      If omitted, the exponent will be at least 2 digits.
   :type exp_digits: non-negative integer, optional
   :param min_digits: Minimum number of digits to print. This only has an effect for
                      `unique=True`. In that case more digits than necessary to uniquely
                      identify the value may be printed and rounded unbiased.

                      -- versionadded:: 1.21.0
   :type min_digits: non-negative integer or None, optional

   :returns: **rep** -- The string representation of the floating point value
   :rtype: string

   .. seealso:: :obj:`format_float_positional`

   .. rubric:: Examples

   >>> np.format_float_scientific(np.float32(np.pi))
   '3.1415927e+00'
   >>> s = np.float32(1.23e24)
   >>> np.format_float_scientific(s, unique=False, precision=15)
   '1.230000071797338e+24'
   >>> np.format_float_scientific(s, exp_digits=4)
   '1.23e+0024'


.. py:class:: format_parser

   Class to convert formats, names, titles description to a dtype.

   After constructing the format_parser object, the dtype attribute is
   the converted data-type:
   ``dtype = format_parser(formats, names, titles).dtype``

   .. attribute:: dtype

      The converted data-type.

      :type: dtype

   :param formats: The format description, either specified as a string with
                   comma-separated format descriptions in the form ``'f8, i4, a5'``, or
                   a list of format description strings  in the form
                   ``['f8', 'i4', 'a5']``.
   :type formats: str or list of str
   :param names: The field names, either specified as a comma-separated string in the
                 form ``'col1, col2, col3'``, or as a list or tuple of strings in the
                 form ``['col1', 'col2', 'col3']``.
                 An empty list can be used, in that case default field names
                 ('f0', 'f1', ...) are used.
   :type names: str or list/tuple of str
   :param titles: Sequence of title strings. An empty list can be used to leave titles
                  out.
   :type titles: sequence
   :param aligned: If True, align the fields by padding as the C-compiler would.
                   Default is False.
   :type aligned: bool, optional
   :param byteorder: If specified, all the fields will be changed to the
                     provided byte-order.  Otherwise, the default byte-order is
                     used. For all available string specifiers, see `dtype.newbyteorder`.
   :type byteorder: str, optional

   .. seealso:: :obj:`dtype`, :obj:`typename`, :obj:`sctype2char`

   .. rubric:: Examples

   >>> np.format_parser(['<f8', '<i4', '<a5'], ['col1', 'col2', 'col3'],
   ...                  ['T1', 'T2', 'T3']).dtype
   dtype([(('T1', 'col1'), '<f8'), (('T2', 'col2'), '<i4'), (('T3', 'col3'), 'S5')])

   `names` and/or `titles` can be empty lists. If `titles` is an empty list,
   titles will simply not appear. If `names` is empty, default field names
   will be used.

   >>> np.format_parser(['f8', 'i4', 'a5'], ['col1', 'col2', 'col3'],
   ...                  []).dtype
   dtype([('col1', '<f8'), ('col2', '<i4'), ('col3', '<S5')])
   >>> np.format_parser(['<f8', '<i4', '<a5'], [], []).dtype
   dtype([('f0', '<f8'), ('f1', '<i4'), ('f2', 'S5')])


.. py:function:: get_byteorder(dt: np.dtype) -> str

   Get a concrete byteorder (turns '=' into '<' or '>')



.. py:function:: get_server_byteorder() -> str

   Get the server's byteorder



.. py:class:: half(value)

   Bases: :py:obj:`numpy.floating`


   Half-precision floating-point number type.

       :Character code: ``'e'``
       :Canonical name: `numpy.half`
       :Alias on this platform (Linux x86_64): `numpy.float16`: 16-bit-precision floating-point number type: sign bit, 5 bits exponent, 10 bits mantissa.



   .. py:method:: as_integer_ratio(*args, **kwargs)

      half.as_integer_ratio() -> (int, int)

              Return a pair of integers, whose ratio is exactly equal to the original
              floating point number, and with a positive denominator.
              Raise `OverflowError` on infinities and a `ValueError` on NaNs.

              >>> np.half(10.0).as_integer_ratio()
              (10, 1)
              >>> np.half(0.0).as_integer_ratio()
              (0, 1)
              >>> np.half(-.25).as_integer_ratio()
              (-1, 4)




   .. py:method:: is_integer(*args, **kwargs)

      half.is_integer() -> bool

              Return ``True`` if the floating point number is finite with integral
              value, and ``False`` otherwise.

              .. versionadded:: 1.22

              Examples
              --------
              >>> np.half(-2.0).is_integer()
              True
              >>> np.half(3.2).is_integer()
              False




.. py:function:: hash(pda: Union[arkouda.pdarrayclass.pdarray, arkouda.strings.Strings, ~SegArray, ~Categorical, List[Union[arkouda.pdarrayclass.pdarray, arkouda.strings.Strings, ~SegArray, ~Categorical]]], full: bool = True) -> Union[Tuple[arkouda.pdarrayclass.pdarray, arkouda.pdarrayclass.pdarray], arkouda.pdarrayclass.pdarray]

   Return an element-wise hash of the array or list of arrays.

   :param pda:
   :type pda: pdarray, Strings, SegArray, or Categorical     or List of pdarray, Strings, SegArray, or Categorical
   :param full: This is only used when a single pdarray is passed into hash
                By default, a 128-bit hash is computed and returned as
                two int64 arrays. If full=False, then a 64-bit hash
                is computed and returned as a single int64 array.
   :type full: bool, default=True

   :returns: If full=True or a list of pdarrays is passed,
             a 2-tuple of pdarrays containing the high
             and low 64 bits of each hash, respectively.
             If full=False and a single pdarray is passed,
             a single pdarray containing a 64-bit hash
   :rtype: hashes

   :raises TypeError: Raised if the parameter is not a pdarray

   .. rubric:: Notes

   In the case of a single pdarray being passed, this function
   uses the SIPhash algorithm, which can output either a 64-bit
   or 128-bit hash. However, the 64-bit hash runs a significant
   risk of collisions when applied to more than a few million
   unique values. Unless the number of unique values is known to
   be small, the 128-bit hash is strongly recommended.

   Note that this hash should not be used for security, or for
   any cryptographic application. Not only is SIPhash not
   intended for such uses, but this implementation employs a
   fixed key for the hash, which makes it possible for an
   adversary with control over input to engineer collisions.

   In the case of a list of pdrrays, Strings, Categoricals, or Segarrays
   being passed, a non-linear function must be applied to each
   array since hashes of subsequent arrays cannot be simply XORed
   because equivalent values will cancel each other out, hence we
   do a rotation by the ordinal of the array.


.. py:function:: histogram(pda: arkouda.pdarrayclass.pdarray, bins: Union[int, numpy.int8, numpy.int16, numpy.int32, numpy.int64, numpy.uint8, numpy.uint16, numpy.uint32, numpy.uint64] = 10) -> Tuple[arkouda.pdarrayclass.pdarray, arkouda.pdarrayclass.pdarray]

   Compute a histogram of evenly spaced bins over the range of an array.

   :param pda: The values to histogram
   :type pda: pdarray
   :param bins: The number of equal-size bins to use (default: 10)
   :type bins: int_scalars, default=10

   :returns: The number of values present in each bin and the bin edges
   :rtype: (pdarray, Union[pdarray, int64 or float64])

   :raises TypeError: Raised if the parameter is not a pdarray or if bins is
       not an int.
   :raises ValueError: Raised if bins < 1
   :raises NotImplementedError: Raised if pdarray dtype is bool or uint8

   .. seealso:: :obj:`value_counts`, :obj:`histogram2d`

   .. rubric:: Notes

   The bins are evenly spaced in the interval [pda.min(), pda.max()].

   .. rubric:: Examples

   >>> import matplotlib.pyplot as plt
   >>> A = ak.arange(0, 10, 1)
   >>> nbins = 3
   >>> h, b = ak.histogram(A, bins=nbins)
   >>> h
   array([3 3 4])
   >>> b
   array([0.00000000000000000 3.00000000000000000 6.00000000000000000 9.00000000000000000])
   # To plot, export the left edges and the histogram to NumPy
   >>> b_np = b.to_ndarray()
   >>> import numpy as np
   >>> b_widths = np.diff(b_np)
   >>> plt.bar(b_np[:-1], h.to_ndarray(), width=b_widths, align='edge', edgecolor='black')
   <BarContainer object of 3 artists>
   >>> plt.show()


.. py:function:: histogram2d(x: arkouda.pdarrayclass.pdarray, y: arkouda.pdarrayclass.pdarray, bins: Union[int, numpy.int8, numpy.int16, numpy.int32, numpy.int64, numpy.uint8, numpy.uint16, numpy.uint32, numpy.uint64, Sequence[Union[int, numpy.int8, numpy.int16, numpy.int32, numpy.int64, numpy.uint8, numpy.uint16, numpy.uint32, numpy.uint64]]] = 10) -> Tuple[arkouda.pdarrayclass.pdarray, arkouda.pdarrayclass.pdarray, arkouda.pdarrayclass.pdarray]

   Compute the bi-dimensional histogram of two data samples with evenly spaced bins

   :param x: A pdarray containing the x coordinates of the points to be histogrammed.
   :type x: pdarray
   :param y: A pdarray containing the y coordinates of the points to be histogrammed.
   :type y: pdarray
   :param bins: The number of equal-size bins to use.
                If int, the number of bins for the two dimensions (nx=ny=bins).
                If [int, int], the number of bins in each dimension (nx, ny = bins).
                Defaults to 10
   :type bins: int_scalars or [int, int], default=10

   :returns: * **hist** (*pdarray*) -- shape(nx, ny)
               The bi-dimensional histogram of samples x and y.
               Values in x are histogrammed along the first dimension and
               values in y are histogrammed along the second dimension.
             * **x_edges** (*pdarray*) -- The bin edges along the first dimension.
             * **y_edges** (*pdarray*) -- The bin edges along the second dimension.

   :raises TypeError: Raised if x or y parameters are not pdarrays or if bins is
       not an int or (int, int).
   :raises ValueError: Raised if bins < 1
   :raises NotImplementedError: Raised if pdarray dtype is bool or uint8

   .. seealso:: :obj:`histogram`

   .. rubric:: Notes

   The x bins are evenly spaced in the interval [x.min(), x.max()]
   and y bins are evenly spaced in the interval [y.min(), y.max()].

   .. rubric:: Examples

   >>> x = ak.arange(0, 10, 1)
   >>> y = ak.arange(9, -1, -1)
   >>> nbins = 3
   >>> h, x_edges, y_edges = ak.histogram2d(x, y, bins=nbins)
   >>> h
   array([array([0.00000000000000000 0.00000000000000000 3.00000000000000000])
          array([0.00000000000000000 2.00000000000000000 1.00000000000000000])
          array([3.00000000000000000 1.00000000000000000 0.00000000000000000])])
   >>> x_edges
   array([0.00000000000000000 3.00000000000000000 6.00000000000000000 9.00000000000000000])
   >>> y_edges
   array([0.00000000000000000 3.00000000000000000 6.00000000000000000 9.00000000000000000])


.. py:function:: histogramdd(sample: Sequence[arkouda.pdarrayclass.pdarray], bins: Union[int, numpy.int8, numpy.int16, numpy.int32, numpy.int64, numpy.uint8, numpy.uint16, numpy.uint32, numpy.uint64, Sequence[Union[int, numpy.int8, numpy.int16, numpy.int32, numpy.int64, numpy.uint8, numpy.uint16, numpy.uint32, numpy.uint64]]] = 10) -> Tuple[arkouda.pdarrayclass.pdarray, Sequence[arkouda.pdarrayclass.pdarray]]

   Compute the multidimensional histogram of data in sample with evenly spaced bins.

   :param sample: A sequence of pdarrays containing the coordinates of the points to be histogrammed.
   :type sample: Sequence of pdarray
   :param bins: The number of equal-size bins to use.
                If int, the number of bins for all dimensions (nx=ny=...=bins).
                If [int, int, ...], the number of bins in each dimension (nx, ny, ... = bins).
                Defaults to 10
   :type bins: int_scalars or Sequence of int_scalars, default=10

   :returns: * **hist** (*pdarray*) -- shape(nx, ny, ..., nd)
               The multidimensional histogram of pdarrays in sample.
               Values in first pdarray are histogrammed along the first dimension.
               Values in second pdarray are histogrammed along the second dimension and so on.
             * **edges** (*List[pdarray]*) -- A list of pdarrays containing the bin edges for each dimension.

   :raises ValueError: Raised if bins < 1
   :raises NotImplementedError: Raised if pdarray dtype is bool or uint8

   .. seealso:: :obj:`histogram`

   .. rubric:: Notes

   The bins for each dimension, m, are evenly spaced in the interval [m.min(), m.max()]

   .. rubric:: Examples

   >>> x = ak.arange(0, 10, 1)
   >>> y = ak.arange(9, -1, -1)
   >>> z = ak.where(x % 2 == 0, x, y)
   >>> h, edges = ak.histogramdd((x, y,z), bins=(2,2,5))
   >>> h
   array([array([array([0 0 0 0 0])
          array([1 1 1 1 1])])
          array([array([1 1 1 1 1])
          array([0 0 0 0 0])])])
   >>> edges
   [array([0.00000000000000000 4.5 9.00000000000000000]),
   array([0.00000000000000000 4.5 9.00000000000000000]),
   array([0.00000000000000000 1.6000000000000001 3.2000000000000002
   4.8000000000000007 6.4000000000000004 8.00000000000000000])]


.. py:class:: iinfo

   iinfo(type)

   Machine limits for integer types.

   .. attribute:: bits

      The number of bits occupied by the type.

      :type: int

   .. attribute:: dtype

      Returns the dtype for which `iinfo` returns information.

      :type: dtype

   .. attribute:: min

      The smallest integer expressible by the type.

      :type: int

   .. attribute:: max

      The largest integer expressible by the type.

      :type: int

   :param int_type: The kind of integer data type to get information about.
   :type int_type: integer type, dtype, or instance

   .. seealso::

      :obj:`finfo`
          The equivalent for floating point data types.

   .. rubric:: Examples

   With types:

   >>> ii16 = np.iinfo(np.int16)
   >>> ii16.min
   -32768
   >>> ii16.max
   32767
   >>> ii32 = np.iinfo(np.int32)
   >>> ii32.min
   -2147483648
   >>> ii32.max
   2147483647

   With instances:

   >>> ii32 = np.iinfo(np.int32(10))
   >>> ii32.min
   -2147483648
   >>> ii32.max
   2147483647


   .. py:property:: max

      Maximum value of given dtype.


   .. py:property:: min

      Minimum value of given dtype.


.. py:class:: inexact(value)

   Bases: :py:obj:`numpy.number`


   Abstract base class of all numeric scalar types with a (potentially)
       inexact representation of the values in its range, such as
       floating-point numbers.



.. py:data:: inf
   :type:  float

.. py:data:: infty
   :type:  float

.. py:class:: int16(value)

   Bases: :py:obj:`numpy.signedinteger`


   Signed integer type, compatible with C ``short``.

       :Character code: ``'h'``
       :Canonical name: `numpy.short`
       :Alias on this platform (Linux x86_64): `numpy.int16`: 16-bit signed integer (``-32_768`` to ``32_767``).



   .. py:method:: bit_count(*args, **kwargs)

      int16.bit_count() -> int

              Computes the number of 1-bits in the absolute value of the input.
              Analogous to the builtin `int.bit_count` or ``popcount`` in C++.

              Examples
              --------
              >>> np.int16(127).bit_count()
              7
              >>> np.int16(-127).bit_count()
              7




.. py:class:: int32(value)

   Bases: :py:obj:`numpy.signedinteger`


   Signed integer type, compatible with C ``int``.

       :Character code: ``'i'``
       :Canonical name: `numpy.intc`
       :Alias on this platform (Linux x86_64): `numpy.int32`: 32-bit signed integer (``-2_147_483_648`` to ``2_147_483_647``).



   .. py:method:: bit_count(*args, **kwargs)

      int32.bit_count() -> int

              Computes the number of 1-bits in the absolute value of the input.
              Analogous to the builtin `int.bit_count` or ``popcount`` in C++.

              Examples
              --------
              >>> np.int32(127).bit_count()
              7
              >>> np.int32(-127).bit_count()
              7




.. py:class:: int64(value)

   Bases: :py:obj:`numpy.signedinteger`


   Signed integer type, compatible with Python `int` and C ``long``.

       :Character code: ``'l'``
       :Canonical name: `numpy.int_`
       :Alias on this platform (Linux x86_64): `numpy.int64`: 64-bit signed integer (``-9_223_372_036_854_775_808`` to ``9_223_372_036_854_775_807``).
       :Alias on this platform (Linux x86_64): `numpy.intp`: Signed integer large enough to fit pointer, compatible with C ``intptr_t``.



   .. py:method:: bit_count(*args, **kwargs)

      int64.bit_count() -> int

              Computes the number of 1-bits in the absolute value of the input.
              Analogous to the builtin `int.bit_count` or ``popcount`` in C++.

              Examples
              --------
              >>> np.int64(127).bit_count()
              7
              >>> np.int64(-127).bit_count()
              7




.. py:class:: int8(value)

   Bases: :py:obj:`numpy.signedinteger`


   Signed integer type, compatible with C ``char``.

       :Character code: ``'b'``
       :Canonical name: `numpy.byte`
       :Alias on this platform (Linux x86_64): `numpy.int8`: 8-bit signed integer (``-128`` to ``127``).



   .. py:method:: bit_count(*args, **kwargs)

      int8.bit_count() -> int

              Computes the number of 1-bits in the absolute value of the input.
              Analogous to the builtin `int.bit_count` or ``popcount`` in C++.

              Examples
              --------
              >>> np.int8(127).bit_count()
              7
              >>> np.int8(-127).bit_count()
              7




.. py:class:: intTypes

   frozenset() -> empty frozenset object
   frozenset(iterable) -> frozenset object

   Build an immutable unordered collection of unique elements.



   .. py:method:: copy(*args, **kwargs)

      Return a shallow copy of a set.




   .. py:method:: difference(*args, **kwargs)

      Return the difference of two or more sets as a new set.

      (i.e. all elements that are in this set but not the others.)




   .. py:method:: intersection(*args, **kwargs)

      Return the intersection of two sets as a new set.

      (i.e. all elements that are in both sets.)




   .. py:method:: isdisjoint(*args, **kwargs)

      Return True if two sets have a null intersection.




   .. py:method:: issubset(*args, **kwargs)

      Report whether another set contains this set.




   .. py:method:: issuperset(*args, **kwargs)

      Report whether this set contains another set.




   .. py:method:: symmetric_difference(*args, **kwargs)

      Return the symmetric difference of two sets as a new set.

      (i.e. all elements that are in exactly one of the sets.)




   .. py:method:: union(*args, **kwargs)

      Return the union of sets as a new set.

      (i.e. all elements that are in either set.)




.. py:class:: int_(value)

   Bases: :py:obj:`numpy.signedinteger`


   Signed integer type, compatible with Python `int` and C ``long``.

       :Character code: ``'l'``
       :Canonical name: `numpy.int_`
       :Alias on this platform (Linux x86_64): `numpy.int64`: 64-bit signed integer (``-9_223_372_036_854_775_808`` to ``9_223_372_036_854_775_807``).
       :Alias on this platform (Linux x86_64): `numpy.intp`: Signed integer large enough to fit pointer, compatible with C ``intptr_t``.



   .. py:method:: bit_count(*args, **kwargs)

      int64.bit_count() -> int

              Computes the number of 1-bits in the absolute value of the input.
              Analogous to the builtin `int.bit_count` or ``popcount`` in C++.

              Examples
              --------
              >>> np.int64(127).bit_count()
              7
              >>> np.int64(-127).bit_count()
              7




.. py:class:: int_scalars(origin, params, *, inst=True, name=None)

   Bases: :py:obj:`_GenericAlias`


   The central part of internal API.

   This represents a generic version of type 'origin' with type arguments 'params'.
   There are two kind of these aliases: user defined and special. The special ones
   are wrappers around builtin collections and ABCs in collections.abc. These must
   have 'name' always set. If 'inst' is False, then the alias can't be instantiated,
   this is used by e.g. typing.List and typing.Dict.


.. py:class:: intc(value)

   Bases: :py:obj:`numpy.signedinteger`


   Signed integer type, compatible with C ``int``.

       :Character code: ``'i'``
       :Canonical name: `numpy.intc`
       :Alias on this platform (Linux x86_64): `numpy.int32`: 32-bit signed integer (``-2_147_483_648`` to ``2_147_483_647``).



   .. py:method:: bit_count(*args, **kwargs)

      int32.bit_count() -> int

              Computes the number of 1-bits in the absolute value of the input.
              Analogous to the builtin `int.bit_count` or ``popcount`` in C++.

              Examples
              --------
              >>> np.int32(127).bit_count()
              7
              >>> np.int32(-127).bit_count()
              7




.. py:class:: integer(value)

   Bases: :py:obj:`numpy.number`


   Abstract base class of all integer scalar types.



   .. py:method:: denominator(*args, **kwargs)

      denominator of value (1)




   .. py:method:: is_integer(*args, **kwargs)

      integer.is_integer() -> bool

          Return ``True`` if the number is finite with integral value.

          .. versionadded:: 1.22

          Examples
          --------
          >>> np.int64(-2).is_integer()
          True
          >>> np.uint32(5).is_integer()
          True




   .. py:method:: numerator(*args, **kwargs)

      numerator of value (the value itself)




.. py:class:: intp(value)

   Bases: :py:obj:`numpy.signedinteger`


   Signed integer type, compatible with Python `int` and C ``long``.

       :Character code: ``'l'``
       :Canonical name: `numpy.int_`
       :Alias on this platform (Linux x86_64): `numpy.int64`: 64-bit signed integer (``-9_223_372_036_854_775_808`` to ``9_223_372_036_854_775_807``).
       :Alias on this platform (Linux x86_64): `numpy.intp`: Signed integer large enough to fit pointer, compatible with C ``intptr_t``.



   .. py:method:: bit_count(*args, **kwargs)

      int64.bit_count() -> int

              Computes the number of 1-bits in the absolute value of the input.
              Analogous to the builtin `int.bit_count` or ``popcount`` in C++.

              Examples
              --------
              >>> np.int64(127).bit_count()
              7
              >>> np.int64(-127).bit_count()
              7




.. py:function:: isSupportedBool(num)

.. py:function:: isSupportedDType(scalar)

.. py:function:: isSupportedFloat(num)

.. py:function:: isSupportedInt(num)

.. py:function:: isSupportedNumber(num)

.. py:function:: isfinite(pda: arkouda.pdarrayclass.pdarray) -> arkouda.pdarrayclass.pdarray

   Return the element-wise isfinite check applied to the array.

   :param pda:
   :type pda: pdarray

   :returns: A pdarray containing boolean values indicating whether the
             input array elements are finite
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray
   :raises RuntimeError: if the underlying pdarray is not float-based

   .. rubric:: Examples

   >>> ak.isfinite(ak.array([1.0, 2.0, ak.inf]))
   array([True True False])


.. py:function:: isinf(pda: arkouda.pdarrayclass.pdarray) -> arkouda.pdarrayclass.pdarray

   Return the element-wise isinf check applied to the array.

   :param pda:
   :type pda: pdarray

   :returns: A pdarray containing boolean values indicating whether the
             input array elements are infinite (positive or negative)
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray
   :raises RuntimeError: if the underlying pdarray is not float-based

   .. rubric:: Examples

   >>> ak.isinf(ak.array([1.0, 2.0, ak.inf]))
   array([False False True])


.. py:function:: isnan(pda: arkouda.pdarrayclass.pdarray) -> arkouda.pdarrayclass.pdarray

   Return the element-wise isnan check applied to the array.

   :param pda:
   :type pda: pdarray

   :returns: A pdarray containing boolean values indicating whether the
             input array elements are NaN
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray
   :raises RuntimeError: if the underlying pdarray is not float-based

   .. rubric:: Examples

   >>> ak.isnan(ak.array([1.0, 2.0, np.log(-1)]))
   array([False False True])


.. py:function:: isscalar(element)

   Returns True if the type of `element` is a scalar type.

   :param element: Input argument, can be of any type and shape.
   :type element: any

   :returns: **val** -- True if `element` is a scalar type, False if it is not.
   :rtype: bool

   .. seealso::

      :obj:`ndim`
          Get the number of dimensions of an array

   .. rubric:: Notes

   If you need a stricter way to identify a *numerical* scalar, use
   ``isinstance(x, numbers.Number)``, as that returns ``False`` for most
   non-numerical elements such as strings.

   In most cases ``np.ndim(x) == 0`` should be used instead of this function,
   as that will also return true for 0d arrays. This is how numpy overloads
   functions in the style of the ``dx`` arguments to `gradient` and the ``bins``
   argument to `histogram`. Some key differences:

   +--------------------------------------+---------------+-------------------+
   | x                                    |``isscalar(x)``|``np.ndim(x) == 0``|
   +======================================+===============+===================+
   | PEP 3141 numeric objects (including  | ``True``      | ``True``          |
   | builtins)                            |               |                   |
   +--------------------------------------+---------------+-------------------+
   | builtin string and buffer objects    | ``True``      | ``True``          |
   +--------------------------------------+---------------+-------------------+
   | other builtin objects, like          | ``False``     | ``True``          |
   | `pathlib.Path`, `Exception`,         |               |                   |
   | the result of `re.compile`           |               |                   |
   +--------------------------------------+---------------+-------------------+
   | third-party objects like             | ``False``     | ``True``          |
   | `matplotlib.figure.Figure`           |               |                   |
   +--------------------------------------+---------------+-------------------+
   | zero-dimensional numpy arrays        | ``False``     | ``True``          |
   +--------------------------------------+---------------+-------------------+
   | other numpy arrays                   | ``False``     | ``False``         |
   +--------------------------------------+---------------+-------------------+
   | `list`, `tuple`, and other sequence  | ``False``     | ``False``         |
   | objects                              |               |                   |
   +--------------------------------------+---------------+-------------------+

   .. rubric:: Examples

   >>> np.isscalar(3.1)
   True
   >>> np.isscalar(np.array(3.1))
   False
   >>> np.isscalar([3.1])
   False
   >>> np.isscalar(False)
   True
   >>> np.isscalar('numpy')
   True

   NumPy supports PEP 3141 numbers:

   >>> from fractions import Fraction
   >>> np.isscalar(Fraction(5, 17))
   True
   >>> from numbers import Number
   >>> np.isscalar(Number())
   True


.. py:function:: issctype(rep)

   Determines whether the given object represents a scalar data-type.

   :param rep: If `rep` is an instance of a scalar dtype, True is returned. If not,
               False is returned.
   :type rep: any

   :returns: **out** -- Boolean result of check whether `rep` is a scalar dtype.
   :rtype: bool

   .. seealso:: :obj:`issubsctype`, :obj:`issubdtype`, :obj:`obj2sctype`, :obj:`sctype2char`

   .. rubric:: Examples

   >>> np.issctype(np.int32)
   True
   >>> np.issctype(list)
   False
   >>> np.issctype(1.1)
   False

   Strings are also a scalar type:

   >>> np.issctype(np.dtype('str'))
   True


.. py:function:: issubclass_(arg1, arg2)

   Determine if a class is a subclass of a second class.

   `issubclass_` is equivalent to the Python built-in ``issubclass``,
   except that it returns False instead of raising a TypeError if one
   of the arguments is not a class.

   :param arg1: Input class. True is returned if `arg1` is a subclass of `arg2`.
   :type arg1: class
   :param arg2: Input class. If a tuple of classes, True is returned if `arg1` is a
                subclass of any of the tuple elements.
   :type arg2: class or tuple of classes.

   :returns: **out** -- Whether `arg1` is a subclass of `arg2` or not.
   :rtype: bool

   .. seealso:: :obj:`issubsctype`, :obj:`issubdtype`, :obj:`issctype`

   .. rubric:: Examples

   >>> np.issubclass_(np.int32, int)
   False
   >>> np.issubclass_(np.int32, float)
   False
   >>> np.issubclass_(np.float64, float)
   True


.. py:function:: issubdtype(arg1, arg2)

   Returns True if first argument is a typecode lower/equal in type hierarchy.

   This is like the builtin :func:`issubclass`, but for `dtype`\ s.

   :param arg1: `dtype` or object coercible to one
   :type arg1: dtype_like
   :param arg2: `dtype` or object coercible to one
   :type arg2: dtype_like

   :returns: **out**
   :rtype: bool

   .. seealso::

      :ref:`arrays.scalars`
          Overview of the numpy type hierarchy.

      :obj:`issubsctype`, :obj:`issubclass_`

   .. rubric:: Examples

   `issubdtype` can be used to check the type of arrays:

   >>> ints = np.array([1, 2, 3], dtype=np.int32)
   >>> np.issubdtype(ints.dtype, np.integer)
   True
   >>> np.issubdtype(ints.dtype, np.floating)
   False

   >>> floats = np.array([1, 2, 3], dtype=np.float32)
   >>> np.issubdtype(floats.dtype, np.integer)
   False
   >>> np.issubdtype(floats.dtype, np.floating)
   True

   Similar types of different sizes are not subdtypes of each other:

   >>> np.issubdtype(np.float64, np.float32)
   False
   >>> np.issubdtype(np.float32, np.float64)
   False

   but both are subtypes of `floating`:

   >>> np.issubdtype(np.float64, np.floating)
   True
   >>> np.issubdtype(np.float32, np.floating)
   True

   For convenience, dtype-like objects are allowed too:

   >>> np.issubdtype('S1', np.string_)
   True
   >>> np.issubdtype('i4', np.signedinteger)
   True


.. py:function:: log(pda: arkouda.pdarrayclass.pdarray) -> arkouda.pdarrayclass.pdarray

   Return the element-wise natural log of the array.

   :param pda:
   :type pda: pdarray

   :returns: A pdarray containing natural log values of the input
             array elements
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray

   .. rubric:: Notes

   Logarithms with other bases can be computed as follows:

   .. rubric:: Examples

   >>> A = ak.array([1, 10, 100])
   # Natural log
   >>> ak.log(A)
   array([0.00000000000000000 2.3025850929940459 4.6051701859880918])
   # Log base 10
   >>> ak.log(A) / np.log(10)
   array([0.00000000000000000 1.00000000000000000 2.00000000000000000])
   # Log base 2
   >>> ak.log(A) / np.log(2)
   array([0.00000000000000000 3.3219280948873626 6.6438561897747253])


.. py:function:: log10(pda: arkouda.pdarrayclass.pdarray) -> arkouda.pdarrayclass.pdarray

   Return the element-wise base 10 log of the array.

   :param pda: array to compute on
   :type pda: pdarray

   :returns: pdarray containing base 10 log values of the input array elements
   :rtype: pdarray


.. py:function:: log1p(pda: arkouda.pdarrayclass.pdarray) -> arkouda.pdarrayclass.pdarray

   Return the element-wise natural log of one plus the array.

   :param pda: array to compute on
   :type pda: pdarray

   :returns: pdarray containing natural log values of the input array elements,
             adding one before taking the log
   :rtype: pdarray

   .. rubric:: Examples

   >>> ak.log1p(ak.arange(1,5))
   array([0.69314718055994529 1.0986122886681098 1.3862943611198906 1.6094379124341003])


.. py:function:: log2(pda: arkouda.pdarrayclass.pdarray) -> arkouda.pdarrayclass.pdarray

   Return the element-wise base 2 log of the array.

   :param pda: array to compute on
   :type pda: pdarray

   :returns: pdarray containing base 2 log values of the input array elements
   :rtype: pdarray


.. py:class:: longdouble(value)

   Bases: :py:obj:`numpy.floating`


   Extended-precision floating-point number type, compatible with C
       ``long double`` but not necessarily with IEEE 754 quadruple-precision.

       :Character code: ``'g'``
       :Alias: `numpy.longfloat`
       :Alias on this platform (Linux x86_64): `numpy.float128`: 128-bit extended-precision floating-point number type.



   .. py:method:: as_integer_ratio(*args, **kwargs)

      longdouble.as_integer_ratio() -> (int, int)

              Return a pair of integers, whose ratio is exactly equal to the original
              floating point number, and with a positive denominator.
              Raise `OverflowError` on infinities and a `ValueError` on NaNs.

              >>> np.longdouble(10.0).as_integer_ratio()
              (10, 1)
              >>> np.longdouble(0.0).as_integer_ratio()
              (0, 1)
              >>> np.longdouble(-.25).as_integer_ratio()
              (-1, 4)




   .. py:method:: is_integer(*args, **kwargs)

      longdouble.is_integer() -> bool

              Return ``True`` if the floating point number is finite with integral
              value, and ``False`` otherwise.

              .. versionadded:: 1.22

              Examples
              --------
              >>> np.longdouble(-2.0).is_integer()
              True
              >>> np.longdouble(3.2).is_integer()
              False




.. py:class:: longfloat(value)

   Bases: :py:obj:`numpy.floating`


   Extended-precision floating-point number type, compatible with C
       ``long double`` but not necessarily with IEEE 754 quadruple-precision.

       :Character code: ``'g'``
       :Alias: `numpy.longfloat`
       :Alias on this platform (Linux x86_64): `numpy.float128`: 128-bit extended-precision floating-point number type.



   .. py:method:: as_integer_ratio(*args, **kwargs)

      longdouble.as_integer_ratio() -> (int, int)

              Return a pair of integers, whose ratio is exactly equal to the original
              floating point number, and with a positive denominator.
              Raise `OverflowError` on infinities and a `ValueError` on NaNs.

              >>> np.longdouble(10.0).as_integer_ratio()
              (10, 1)
              >>> np.longdouble(0.0).as_integer_ratio()
              (0, 1)
              >>> np.longdouble(-.25).as_integer_ratio()
              (-1, 4)




   .. py:method:: is_integer(*args, **kwargs)

      longdouble.is_integer() -> bool

              Return ``True`` if the floating point number is finite with integral
              value, and ``False`` otherwise.

              .. versionadded:: 1.22

              Examples
              --------
              >>> np.longdouble(-2.0).is_integer()
              True
              >>> np.longdouble(3.2).is_integer()
              False




.. py:class:: longlong(value)

   Bases: :py:obj:`numpy.signedinteger`


   Signed integer type, compatible with C ``long long``.

       :Character code: ``'q'``



   .. py:method:: bit_count(*args, **kwargs)


.. py:function:: matmul(pdaLeft: arkouda.pdarrayclass.pdarray, pdaRight: arkouda.pdarrayclass.pdarray) -> arkouda.pdarrayclass.pdarray

   Compute the product of two matrices.

   :param pdaLeft:
   :type pdaLeft: pdarray
   :param pdaRight:
   :type pdaRight: pdarray

   :returns: the matrix product pdaLeft x pdaRight
   :rtype: pdarray

   .. rubric:: Examples

   >>> a = ak.array([[1,2,3,4,5],[1,2,3,4,5]])
   >>> b = ak.array([[1,1],[2,2],[3,3],[4,4],[5,5]])
   >>> ak.matmul(a,b)
   array([array([55 55]) array([55 55])])

   >>> x = ak.array([[1,2,3],[1.1,2.1,3.1]])
   >>> y = ak.array([[1,1,1],[0,2,2],[0,0,3]])
   >>> ak.matmul(x,y)
   array([array([1.00000000000000000 5.00000000000000000 14.00000000000000000])
   array([1.1000000000000001 5.3000000000000007 14.600000000000001])])

   .. rubric:: Notes

   Server returns an error if shapes of pdaLeft and pdaRight
   are incompatible with matrix multiplication.


.. py:function:: maximum_sctype(t)

   Return the scalar type of highest precision of the same kind as the input.

   :param t: The input data type. This can be a `dtype` object or an object that
             is convertible to a `dtype`.
   :type t: dtype or dtype specifier

   :returns: **out** -- The highest precision data type of the same kind (`dtype.kind`) as `t`.
   :rtype: dtype

   .. seealso:: :obj:`obj2sctype`, :obj:`mintypecode`, :obj:`sctype2char`, :obj:`dtype`

   .. rubric:: Examples

   >>> np.maximum_sctype(int)
   <class 'numpy.int64'>
   >>> np.maximum_sctype(np.uint8)
   <class 'numpy.uint64'>
   >>> np.maximum_sctype(complex)
   <class 'numpy.complex256'> # may vary

   >>> np.maximum_sctype(str)
   <class 'numpy.str_'>

   >>> np.maximum_sctype('i2')
   <class 'numpy.int64'>
   >>> np.maximum_sctype('f4')
   <class 'numpy.float128'> # may vary


.. py:function:: median(pda: arkouda.pdarrayclass.pdarray) -> numpy.float64

   Compute the median of a given array.  1d case only, for now.

   :param pda: The input data, in pdarray form, numeric type or boolean
   :type pda: pdarray

   :returns: | The median of the entire pdarray
             | The array is sorted, and then if the number of elements is odd,
                 the return value is the middle element.  If even, then the
                 mean of the two middle elements.
   :rtype: np.float64

   .. rubric:: Examples

   >>> pda = ak.array([0,4,7,8,1,3,5,2,-1])
   >>> ak.median(pda)
   3.0
   >>> pda = ak.array([0,1,3,3,1,2,3,4,2,3])
   >>> ak.median(pda)
   2.5


.. py:data:: nan
   :type:  float

.. py:class:: number(value)

   Bases: :py:obj:`numpy.generic`


   Abstract base class of all numeric scalar types.



.. py:class:: numeric_and_bool_scalars(origin, params, *, inst=True, name=None)

   Bases: :py:obj:`_GenericAlias`


   The central part of internal API.

   This represents a generic version of type 'origin' with type arguments 'params'.
   There are two kind of these aliases: user defined and special. The special ones
   are wrappers around builtin collections and ABCs in collections.abc. These must
   have 'name' always set. If 'inst' is False, then the alias can't be instantiated,
   this is used by e.g. typing.List and typing.Dict.


.. py:class:: numeric_scalars(origin, params, *, inst=True, name=None)

   Bases: :py:obj:`_GenericAlias`


   The central part of internal API.

   This represents a generic version of type 'origin' with type arguments 'params'.
   There are two kind of these aliases: user defined and special. The special ones
   are wrappers around builtin collections and ABCs in collections.abc. These must
   have 'name' always set. If 'inst' is False, then the alias can't be instantiated,
   this is used by e.g. typing.List and typing.Dict.


.. py:class:: numpy_scalars(origin, params, *, inst=True, name=None)

   Bases: :py:obj:`_GenericAlias`


   The central part of internal API.

   This represents a generic version of type 'origin' with type arguments 'params'.
   There are two kind of these aliases: user defined and special. The special ones
   are wrappers around builtin collections and ABCs in collections.abc. These must
   have 'name' always set. If 'inst' is False, then the alias can't be instantiated,
   this is used by e.g. typing.List and typing.Dict.


.. py:class:: object_(value)

   Bases: :py:obj:`numpy.generic`


   Any Python object.

       :Character code: ``'O'``



.. py:data:: pi
   :type:  float

.. py:function:: putmask(A: arkouda.pdarrayclass.pdarray, mask: arkouda.pdarrayclass.pdarray, Values: arkouda.pdarrayclass.pdarray) -> None

   Overwrites elements of A with elements from B based upon a mask array.
   Similar to numpy.putmask, where mask = False, A retains its original value,
   but where mask = True, A is overwritten with the corresponding entry from Values.

   This is similar to ak.where, except that (1) no new pdarray is created, and
   (2) Values does not have to be the same size as A and mask.

   :param A: Value(s) used when mask is False (see Notes for allowed dtypes)
   :type A: pdarray
   :param mask: Used to choose values from A or B, must be same size as A, and of type ak.bool_
   :type mask: pdarray
   :param Values: Value(s) used when mask is False (see Notes for allowed dtypes)
   :type Values: pdarray

   .. rubric:: Examples

   >>> a = ak.array(np.arange(10))
   >>> ak.putmask (a,a>2,a**2)
   >>> a
   array([0 1 2 9 16 25 36 49 64 81])

   >>> a = ak.array(np.arange(10))
   >>> values = ak.array([3,2])
   >>> ak.putmask (a,a>2,values)
   >>> a
   array([0 1 2 2 3 2 3 2 3 2])

   :raises RuntimeError: Raised if mask is not same size as A, or if A.dtype and Values.dtype are not
       an allowed pair (see Notes for details).

   .. rubric:: Notes

   | A and mask must be the same size.  Values can be any size.
   | Allowed dtypes for A and Values conform to types accepted by numpy putmask.
   | If A is ak.float64, Values can be ak.float64, ak.int64, ak.uint64, ak.bool_.
   | If A is ak.int64, Values can be ak.int64 or ak.bool_.
   | If A is ak.uint64, Values can be ak.uint64, or ak.bool_.
   | If A is ak.bool_, Values must be ak.bool_.

   Only one conditional clause is supported e.g., n < 5, n > 1.

   multi-dim pdarrays are now implemented.


.. py:function:: rad2deg(pda: arkouda.pdarrayclass.pdarray, where: Union[bool, arkouda.pdarrayclass.pdarray] = True) -> arkouda.pdarrayclass.pdarray

   Converts angles element-wise from radians to degrees.

   :param pda:
   :type pda: pdarray
   :param where: This condition is broadcast over the input. At locations where the condition is True, the
                 corresponding value will be converted from radians to degrees. Elsewhere, it will retain its
                 original value. Default set to True.
   :type where: bool or pdarray, default=True

   :returns: A pdarray containing an angle converted to degrees, from radians, for each element
             of the original pdarray
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray


.. py:function:: resolve_scalar_dtype(val: object) -> str

   Try to infer what dtype arkouda_server should treat val as.



.. py:function:: round(pda: arkouda.pdarrayclass.pdarray) -> arkouda.pdarrayclass.pdarray

   Return the element-wise rounding of the array.

   :param pda:
   :type pda: pdarray

   :returns: A pdarray containing input array elements rounded to the nearest integer
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray

   .. rubric:: Examples

   >>> ak.round(ak.array([1.1, 2.5, 3.14159]))
   array([1.00000000000000000 3.00000000000000000 3.00000000000000000])


.. py:class:: sctypeDict

   dict() -> new empty dictionary
   dict(mapping) -> new dictionary initialized from a mapping object's
       (key, value) pairs
   dict(iterable) -> new dictionary initialized as if via:
       d = {}
       for k, v in iterable:
           d[k] = v
   dict(**kwargs) -> new dictionary initialized with the name=value pairs
       in the keyword argument list.  For example:  dict(one=1, two=2)



   .. py:method:: clear(*args, **kwargs)

      D.clear() -> None.  Remove all items from D.




   .. py:method:: copy(*args, **kwargs)

      D.copy() -> a shallow copy of D




   .. py:method:: fromkeys(iterable, value=None, /)

      Create a new dictionary with keys from iterable and values set to value.




   .. py:method:: get(key, default=None, /)

      Return the value for key if key is in the dictionary, else default.




   .. py:method:: items(*args, **kwargs)

      D.items() -> a set-like object providing a view on D's items




   .. py:method:: keys(*args, **kwargs)

      D.keys() -> a set-like object providing a view on D's keys




   .. py:method:: pop(*args, **kwargs)

      D.pop(k[,d]) -> v, remove specified key and return the corresponding value.

      If key is not found, default is returned if given, otherwise KeyError is raised




   .. py:method:: popitem()

      Remove and return a (key, value) pair as a 2-tuple.

      Pairs are returned in LIFO (last-in, first-out) order.
      Raises KeyError if the dict is empty.




   .. py:method:: setdefault(key, default=None, /)

      Insert key with a value of default if key is not in the dictionary.

      Return the value for key if key is in the dictionary, else default.




   .. py:method:: update(*args, **kwargs)

      D.update([E, ]**F) -> None.  Update D from dict/iterable E and F.
      If E is present and has a .keys() method, then does:  for k in E: D[k] = E[k]
      If E is present and lacks a .keys() method, then does:  for k, v in E: D[k] = v
      In either case, this is followed by: for k in F:  D[k] = F[k]




   .. py:method:: values(*args, **kwargs)

      D.values() -> an object providing a view on D's values




.. py:class:: sctypes

   dict() -> new empty dictionary
   dict(mapping) -> new dictionary initialized from a mapping object's
       (key, value) pairs
   dict(iterable) -> new dictionary initialized as if via:
       d = {}
       for k, v in iterable:
           d[k] = v
   dict(**kwargs) -> new dictionary initialized with the name=value pairs
       in the keyword argument list.  For example:  dict(one=1, two=2)



   .. py:method:: clear(*args, **kwargs)

      D.clear() -> None.  Remove all items from D.




   .. py:method:: copy(*args, **kwargs)

      D.copy() -> a shallow copy of D




   .. py:method:: fromkeys(iterable, value=None, /)

      Create a new dictionary with keys from iterable and values set to value.




   .. py:method:: get(key, default=None, /)

      Return the value for key if key is in the dictionary, else default.




   .. py:method:: items(*args, **kwargs)

      D.items() -> a set-like object providing a view on D's items




   .. py:method:: keys(*args, **kwargs)

      D.keys() -> a set-like object providing a view on D's keys




   .. py:method:: pop(*args, **kwargs)

      D.pop(k[,d]) -> v, remove specified key and return the corresponding value.

      If key is not found, default is returned if given, otherwise KeyError is raised




   .. py:method:: popitem()

      Remove and return a (key, value) pair as a 2-tuple.

      Pairs are returned in LIFO (last-in, first-out) order.
      Raises KeyError if the dict is empty.




   .. py:method:: setdefault(key, default=None, /)

      Insert key with a value of default if key is not in the dictionary.

      Return the value for key if key is in the dictionary, else default.




   .. py:method:: update(*args, **kwargs)

      D.update([E, ]**F) -> None.  Update D from dict/iterable E and F.
      If E is present and has a .keys() method, then does:  for k in E: D[k] = E[k]
      If E is present and lacks a .keys() method, then does:  for k, v in E: D[k] = v
      In either case, this is followed by: for k in F:  D[k] = F[k]




   .. py:method:: values(*args, **kwargs)

      D.values() -> an object providing a view on D's values




.. py:function:: shape(a: Union[arkouda.pdarrayclass.pdarray, arkouda.strings.Strings, bool, numpy.bool_, float, numpy.float64, numpy.float32, int, numpy.int8, numpy.int16, numpy.int32, numpy.int64, numpy.uint8, numpy.uint16, numpy.uint32, numpy.uint64, numpy.str_, str]) -> Tuple

   Return the shape of an array.

   :param a: Input array.
   :type a: pdarray

   :returns: **shape** -- The elements of the shape tuple give the lengths of the
             corresponding array dimensions.
   :rtype: tuple of ints

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.shape(ak.eye(3,2))
   (3, 2)
   >>> ak.shape([[1, 3]])
   (1, 2)
   >>> ak.shape([0])
   (1,)
   >>> ak.shape(0)
   ()


.. py:class:: short(value)

   Bases: :py:obj:`numpy.signedinteger`


   Signed integer type, compatible with C ``short``.

       :Character code: ``'h'``
       :Canonical name: `numpy.short`
       :Alias on this platform (Linux x86_64): `numpy.int16`: 16-bit signed integer (``-32_768`` to ``32_767``).



   .. py:method:: bit_count(*args, **kwargs)

      int16.bit_count() -> int

              Computes the number of 1-bits in the absolute value of the input.
              Analogous to the builtin `int.bit_count` or ``popcount`` in C++.

              Examples
              --------
              >>> np.int16(127).bit_count()
              7
              >>> np.int16(-127).bit_count()
              7




.. py:function:: sign(pda: arkouda.pdarrayclass.pdarray) -> arkouda.pdarrayclass.pdarray

   Return the element-wise sign of the array.

   :param pda:
   :type pda: pdarray

   :returns: A pdarray containing sign values of the input array elements
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray

   .. rubric:: Examples

   >>> ak.sign(ak.array([-10, -5, 0, 5, 10]))
   array([-1 -1 0 1 1])


.. py:class:: signedinteger(value)

   Bases: :py:obj:`numpy.integer`


   Abstract base class of all signed integer scalar types.



.. py:function:: sin(pda: arkouda.pdarrayclass.pdarray, where: Union[bool, arkouda.pdarrayclass.pdarray] = True) -> arkouda.pdarrayclass.pdarray

   Return the element-wise sine of the array.

   :param pda:
   :type pda: pdarray
   :param where: This condition is broadcast over the input. At locations where the condition is True,
                 the sine will be applied to the corresponding value. Elsewhere, it will retain
                 its original value. Default set to True.
   :type where: bool or pdarray, default=True

   :returns: A pdarray containing sin for each element
             of the original pdarray
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray


.. py:class:: single(value)

   Bases: :py:obj:`numpy.floating`


   Single-precision floating-point number type, compatible with C ``float``.

       :Character code: ``'f'``
       :Canonical name: `numpy.single`
       :Alias on this platform (Linux x86_64): `numpy.float32`: 32-bit-precision floating-point number type: sign bit, 8 bits exponent, 23 bits mantissa.



   .. py:method:: as_integer_ratio(*args, **kwargs)

      single.as_integer_ratio() -> (int, int)

              Return a pair of integers, whose ratio is exactly equal to the original
              floating point number, and with a positive denominator.
              Raise `OverflowError` on infinities and a `ValueError` on NaNs.

              >>> np.single(10.0).as_integer_ratio()
              (10, 1)
              >>> np.single(0.0).as_integer_ratio()
              (0, 1)
              >>> np.single(-.25).as_integer_ratio()
              (-1, 4)




   .. py:method:: is_integer(*args, **kwargs)

      single.is_integer() -> bool

              Return ``True`` if the floating point number is finite with integral
              value, and ``False`` otherwise.

              .. versionadded:: 1.22

              Examples
              --------
              >>> np.single(-2.0).is_integer()
              True
              >>> np.single(3.2).is_integer()
              False




.. py:function:: sinh(pda: arkouda.pdarrayclass.pdarray, where: Union[bool, arkouda.pdarrayclass.pdarray] = True) -> arkouda.pdarrayclass.pdarray

   Return the element-wise hyperbolic sine of the array.

   :param pda:
   :type pda: pdarray
   :param where: This condition is broadcast over the input. At locations where the condition is True,
                 the hyperbolic sine will be applied to the corresponding value. Elsewhere, it will retain
                 its original value. Default set to True.
   :type where: bool or pdarray, default=True

   :returns: A pdarray containing hyperbolic sine for each element
             of the original pdarray
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray


.. py:function:: square(pda: arkouda.pdarrayclass.pdarray) -> arkouda.pdarrayclass.pdarray

   Return the element-wise square of the array.

   :param pda:
   :type pda: pdarray

   :returns: A pdarray containing square values of the input
             array elements
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray

   .. rubric:: Examples

   >>> ak.square(ak.arange(1,5))
   array([1 4 9 16])


.. py:function:: squeeze(x: Union[arkouda.pdarrayclass.pdarray, float, numpy.float64, numpy.float32, int, numpy.int8, numpy.int16, numpy.int32, numpy.int64, numpy.uint8, numpy.uint16, numpy.uint32, numpy.uint64, bool, numpy.bool_], /, axis: Union[NoneType, int, Tuple[int, Ellipsis]] = None) -> arkouda.pdarrayclass.pdarray

   Remove degenerate (size one) dimensions from an array.

   :param x: The array to squeeze
   :type x: pdarray
   :param axis: The axis or axes to squeeze (must have a size of one).
                If axis = None, all dimensions of size 1 will be squeezed.
   :type axis: int or Tuple[int, ...]

   :returns: A copy of x with the dimensions specified in the axis argument removed.
   :rtype: pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.connect()
   >>> x = ak.arange(10).reshape((1, 10, 1))
   >>> x
   array([array([array([0]) array([1]) array([2]) array([3])....
    array([4]) array([5]) array([6]) array([7]) array([8]) array([9])])])
   >>> x.shape
   (1, 10, 1)
   >>> ak.squeeze(x,axis=None)
   array([0 1 2 3 4 5 6 7 8 9])
   >>> ak.squeeze(x,axis=None).shape
   (10,)
   >>> ak.squeeze(x,axis=2)
   array([array([0 1 2 3 4 5 6 7 8 9])])
   >>> ak.squeeze(x,axis=2).shape
   (1, 10)
   >>> ak.squeeze(x,axis=(0,2))
   array([0 1 2 3 4 5 6 7 8 9])
   >>> ak.squeeze(x,axis=(0,2)).shape
   (10,)


.. py:class:: str_

   A unicode string.

       This type strips trailing null codepoints.

       >>> s = np.str_("abc\x00")
       >>> s
       'abc'

       Unlike the builtin `str`, this supports the :ref:`python:bufferobjects`, exposing its
       contents as UCS4:

       >>> m = memoryview(np.str_("abc"))
       >>> m.format
       '3w'
       >>> m.tobytes()
       b'a\x00\x00\x00b\x00\x00\x00c\x00\x00\x00'

       :Character code: ``'U'``
       :Alias: `numpy.unicode_`



   .. py:method:: T(*args, **kwargs)

      Scalar attribute identical to the corresponding array attribute.

          Please see `ndarray.T`.




   .. py:method:: all(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.all`.




   .. py:method:: any(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.any`.




   .. py:method:: argmax(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.argmax`.




   .. py:method:: argmin(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.argmin`.




   .. py:method:: argsort(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.argsort`.




   .. py:method:: astype(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.astype`.




   .. py:method:: base(*args, **kwargs)

      Scalar attribute identical to the corresponding array attribute.

          Please see `ndarray.base`.




   .. py:method:: byteswap(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.byteswap`.




   .. py:method:: choose(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.choose`.




   .. py:method:: clip(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.clip`.




   .. py:method:: compress(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.compress`.




   .. py:method:: conj(*args, **kwargs)


   .. py:method:: conjugate(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.conjugate`.




   .. py:method:: copy(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.copy`.




   .. py:method:: cumprod(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.cumprod`.




   .. py:method:: cumsum(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.cumsum`.




   .. py:method:: data(*args, **kwargs)

      Pointer to start of data.




   .. py:method:: diagonal(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.diagonal`.




   .. py:method:: dtype(*args, **kwargs)

      Get array data-descriptor.




   .. py:method:: dump(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.dump`.




   .. py:method:: dumps(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.dumps`.




   .. py:method:: fill(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.fill`.




   .. py:method:: flags(*args, **kwargs)

      The integer value of flags.




   .. py:method:: flat(*args, **kwargs)

      A 1-D view of the scalar.




   .. py:method:: flatten(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.flatten`.




   .. py:method:: getfield(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.getfield`.




   .. py:method:: imag(*args, **kwargs)

      The imaginary part of the scalar.




   .. py:method:: item(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.item`.




   .. py:method:: itemset(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.itemset`.




   .. py:method:: itemsize(*args, **kwargs)

      The length of one element in bytes.




   .. py:method:: max(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.max`.




   .. py:method:: mean(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.mean`.




   .. py:method:: min(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.min`.




   .. py:method:: nbytes(*args, **kwargs)

      The length of the scalar in bytes.




   .. py:method:: ndim(*args, **kwargs)

      The number of array dimensions.




   .. py:method:: newbyteorder(*args, **kwargs)

      newbyteorder(new_order='S', /)

          Return a new `dtype` with a different byte order.

          Changes are also made in all fields and sub-arrays of the data type.

          The `new_order` code can be any from the following:

          * 'S' - swap dtype from current to opposite endian
          * {'<', 'little'} - little endian
          * {'>', 'big'} - big endian
          * {'=', 'native'} - native order
          * {'|', 'I'} - ignore (no change to byte order)

          Parameters
          ----------
          new_order : str, optional
              Byte order to force; a value from the byte order specifications
              above.  The default value ('S') results in swapping the current
              byte order.


          Returns
          -------
          new_dtype : dtype
              New `dtype` object with the given change to the byte order.




   .. py:method:: nonzero(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.nonzero`.




   .. py:method:: prod(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.prod`.




   .. py:method:: ptp(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.ptp`.




   .. py:method:: put(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.put`.




   .. py:method:: ravel(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.ravel`.




   .. py:method:: real(*args, **kwargs)

      The real part of the scalar.




   .. py:method:: repeat(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.repeat`.




   .. py:method:: reshape(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.reshape`.




   .. py:method:: resize(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.resize`.




   .. py:method:: round(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.round`.




   .. py:method:: searchsorted(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.searchsorted`.




   .. py:method:: setfield(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.setfield`.




   .. py:method:: setflags(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.setflags`.




   .. py:method:: shape(*args, **kwargs)

      Tuple of array dimensions.




   .. py:method:: size(*args, **kwargs)

      The number of elements in the gentype.




   .. py:method:: sort(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.sort`.




   .. py:method:: squeeze(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.squeeze`.




   .. py:method:: std(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.std`.




   .. py:method:: strides(*args, **kwargs)

      Tuple of bytes steps in each dimension.




   .. py:method:: sum(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.sum`.




   .. py:method:: swapaxes(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.swapaxes`.




   .. py:method:: take(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.take`.




   .. py:method:: tobytes(*args, **kwargs)


   .. py:method:: tofile(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.tofile`.




   .. py:method:: tolist(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.tolist`.




   .. py:method:: tostring(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.tostring`.




   .. py:method:: trace(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.trace`.




   .. py:method:: transpose(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.transpose`.




   .. py:method:: var(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.var`.




   .. py:method:: view(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.view`.




.. py:class:: str_scalars(origin, params, *, inst=True, name=None)

   Bases: :py:obj:`_GenericAlias`


   The central part of internal API.

   This represents a generic version of type 'origin' with type arguments 'params'.
   There are two kind of these aliases: user defined and special. The special ones
   are wrappers around builtin collections and ABCs in collections.abc. These must
   have 'name' always set. If 'inst' is False, then the alias can't be instantiated,
   this is used by e.g. typing.List and typing.Dict.


.. py:function:: tan(pda: arkouda.pdarrayclass.pdarray, where: Union[bool, arkouda.pdarrayclass.pdarray] = True) -> arkouda.pdarrayclass.pdarray

   Return the element-wise tangent of the array.

   :param pda:
   :type pda: pdarray
   :param where: This condition is broadcast over the input. At locations where the condition is True,
                 the tangent will be applied to the corresponding value. Elsewhere, it will retain
                 its original value. Default set to True.
   :type where: bool or pdarray, default=True

   :returns: A pdarray containing tangent for each element
             of the original pdarray
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray


.. py:function:: tanh(pda: arkouda.pdarrayclass.pdarray, where: Union[bool, arkouda.pdarrayclass.pdarray] = True) -> arkouda.pdarrayclass.pdarray

   Return the element-wise hyperbolic tangent of the array.

   :param pda:
   :type pda: pdarray
   :param where: This condition is broadcast over the input. At locations where the condition is True,
                 the hyperbolic tangent will be applied to the corresponding value. Elsewhere, it will retain
                 its original value. Default set to True.
   :type where: bool or pdarray, default=True

   :returns: A pdarray containing hyperbolic tangent for each element
             of the original pdarray
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray


.. py:function:: tile(A: arkouda.pdarrayclass.pdarray, /, reps: Union[int, Tuple[int, Ellipsis]]) -> arkouda.pdarrayclass.pdarray

   Construct an array by repeating A the number of times given by reps.

   If reps has length ``d``, the result will have dimension of ``max(d, A.ndim)``.

   If ``A.ndim < d``, A is promoted to be d-dimensional by prepending new axes. So a shape (3,) array is promoted to (1, 3) for 2-D replication, or shape (1, 1, 3) for 3-D replication. If this is not the desired behavior, promote A to d-dimensions manually before calling this function.

   If ``A.ndim > d``, reps is promoted to A.ndim by prepending 1s to it. Thus for an A of shape (2, 3, 4, 5), a reps of (2, 2) is treated as (1, 1, 2, 2).

   :param A: The input pdarray to be tiled
   :type A: pdarray
   :param reps: The number of repetitions of A along each axis.
   :type reps: int or Tuple of int

   :returns: A new pdarray with the tiled data.
   :rtype: pdarray

   .. rubric:: Examples

   >>> a = ak.array([0, 1, 2])
   >>> ak.tile(a, 2)
   array([0 1 2 0 1 2])
   >>> ak.tile(a, (2, 2))
   array([array([0 1 2 0 1 2]) array([0 1 2 0 1 2])])
   >>> ak.tile(a, (2, 1, 2))
   array([array([array([0 1 2 0 1 2])]) array([array([0 1 2 0 1 2])])])

   >>> b = ak.array([[1, 2], [3, 4]])
   >>> ak.tile(b, 2)
   array([array([1 2 1 2]) array([3 4 3 4])])
   >>> ak.tile(b, (2, 1))
   array([array([1 2]) array([3 4]) array([1 2]) array([3 4])])

   >>> c = ak.array([1, 2, 3, 4])
   >>> ak.tile(c, (4, 1))
   array([array([1 2 3 4]) array([1 2 3 4]) array([1 2 3 4]) array([1 2 3 4])])


.. py:class:: timedelta64(value)

   Bases: :py:obj:`numpy.signedinteger`


   A timedelta stored as a 64-bit integer.

       See :ref:`arrays.datetime` for more information.

       :Character code: ``'m'``



.. py:function:: transpose(pda: arkouda.pdarrayclass.pdarray) -> arkouda.pdarrayclass.pdarray

   Compute the transpose of a matrix.

   :param pda:
   :type pda: pdarray

   :returns: the transpose of the input matrix
   :rtype: pdarray

   .. rubric:: Examples

   >>> a = ak.array([[1,2,3,4,5],[1,2,3,4,5]])
   >>> ak.transpose(a)
   array([array([1 1]) array([2 2]) array([3 3]) array([4 4]) array([5 5])])

   .. rubric:: Notes

   Server returns an error if rank of pda < 2


.. py:function:: tril(pda: arkouda.pdarrayclass.pdarray, diag: Union[int, numpy.int8, numpy.int16, numpy.int32, numpy.int64, numpy.uint8, numpy.uint16, numpy.uint32, numpy.uint64] = 0) -> arkouda.pdarrayclass.pdarray

   Return a copy of the pda with the upper triangle zeroed out

   :param pda:
   :type pda: pdarray
   :param diag: | if diag = 0, zeros start just above the main diagonal
                | if diag = 1, zeros start at the main diagonal
                | if diag = 2, zeros start just below the main diagonal
                | etc. Default set to 0.
   :type diag: int_scalars, optional

   :returns: a copy of pda with zeros in the upper triangle
   :rtype: pdarray

   .. rubric:: Examples

   >>> a = ak.array([[1,2,3,4,5],[2,3,4,5,6],[3,4,5,6,7],[4,5,6,7,8],[5,6,7,8,9]])
   >>> ak.tril(a,diag=4)
   array([array([1 2 3 4 5]) array([2 3 4 5 6]) array([3 4 5 6 7])
   array([4 5 6 7 8]) array([5 6 7 8 9])])
   >>> ak.tril(a,diag=3)
   array([array([1 2 3 4 0]) array([2 3 4 5 6]) array([3 4 5 6 7])
   array([4 5 6 7 8]) array([5 6 7 8 9])])
   >>> ak.tril(a,diag=2)
   array([array([1 2 3 0 0]) array([2 3 4 5 0]) array([3 4 5 6 7])
   array([4 5 6 7 8]) array([5 6 7 8 9])])
   >>> ak.tril(a,diag=1)
   array([array([1 2 0 0 0]) array([2 3 4 0 0]) array([3 4 5 6 0])
   array([4 5 6 7 8]) array([5 6 7 8 9])])
   >>> ak.tril(a,diag=0)
   array([array([1 0 0 0 0]) array([2 3 0 0 0]) array([3 4 5 0 0])
   array([4 5 6 7 0]) array([5 6 7 8 9])])

   .. rubric:: Notes

   Server returns an error if rank of pda < 2


.. py:function:: triu(pda: arkouda.pdarrayclass.pdarray, diag: Union[int, numpy.int8, numpy.int16, numpy.int32, numpy.int64, numpy.uint8, numpy.uint16, numpy.uint32, numpy.uint64] = 0) -> arkouda.pdarrayclass.pdarray

   Return a copy of the pda with the lower triangle zeroed out

   :param pda:
   :type pda: pdarray
   :param diag: | if diag = 0, zeros start just below the main diagonal
                | if diag = 1, zeros start at the main diagonal
                | if diag = 2, zeros start just above the main diagonal
                | etc. Default set to 0.
   :type diag: int_scalars, default=0

   :returns: a copy of pda with zeros in the lower triangle
   :rtype: pdarray

   .. rubric:: Examples

   >>> a = ak.array([[1,2,3,4,5],[2,3,4,5,6],[3,4,5,6,7],[4,5,6,7,8],[5,6,7,8,9]])
   >>> ak.triu(a,diag=0)
   array([array([1 2 3 4 5]) array([0 3 4 5 6]) array([0 0 5 6 7])
   array([0 0 0 7 8]) array([0 0 0 0 9])])
   >>> ak.triu(a,diag=1)
   array([array([0 2 3 4 5]) array([0 0 4 5 6]) array([0 0 0 6 7])
   array([0 0 0 0 8]) array([0 0 0 0 0])])
   >>> ak.triu(a,diag=2)
   array([array([0 0 3 4 5]) array([0 0 0 5 6]) array([0 0 0 0 7])
   array([0 0 0 0 0]) array([0 0 0 0 0])])
   >>> ak.triu(a,diag=3)
   array([array([0 0 0 4 5]) array([0 0 0 0 6]) array([0 0 0 0 0])
   array([0 0 0 0 0]) array([0 0 0 0 0])])
   >>> ak.triu(a,diag=4)
   array([array([0 0 0 0 5]) array([0 0 0 0 0]) array([0 0 0 0 0])
   array([0 0 0 0 0]) array([0 0 0 0 0])])

   .. rubric:: Notes

   Server returns an error if rank of pda < 2


.. py:function:: trunc(pda: arkouda.pdarrayclass.pdarray) -> arkouda.pdarrayclass.pdarray

   Return the element-wise truncation of the array.

   :param pda:
   :type pda: pdarray

   :returns: A pdarray containing input array elements truncated to the nearest integer
   :rtype: pdarray

   :raises TypeError: Raised if the parameter is not a pdarray

   .. rubric:: Examples

   >>> ak.trunc(ak.array([1.1, 2.5, 3.14159]))
   array([1.00000000000000000 2.00000000000000000 3.00000000000000000])


.. py:function:: typename(char)

   Return a description for the given data type code.

   :param char: Data type code.
   :type char: str

   :returns: **out** -- Description of the input data type code.
   :rtype: str

   .. seealso:: :obj:`dtype`, :obj:`typecodes`

   .. rubric:: Examples

   >>> typechars = ['S1', '?', 'B', 'D', 'G', 'F', 'I', 'H', 'L', 'O', 'Q',
   ...              'S', 'U', 'V', 'b', 'd', 'g', 'f', 'i', 'h', 'l', 'q']
   >>> for typechar in typechars:
   ...     print(typechar, ' : ', np.typename(typechar))
   ...
   S1  :  character
   ?  :  bool
   B  :  unsigned char
   D  :  complex double precision
   G  :  complex long double precision
   F  :  complex single precision
   I  :  unsigned integer
   H  :  unsigned short
   L  :  unsigned long integer
   O  :  object
   Q  :  unsigned long long integer
   S  :  string
   U  :  unicode
   V  :  void
   b  :  signed char
   d  :  double precision
   g  :  long precision
   f  :  single precision
   i  :  integer
   h  :  short
   l  :  long integer
   q  :  long long integer


.. py:class:: ubyte(value)

   Bases: :py:obj:`numpy.unsignedinteger`


   Unsigned integer type, compatible with C ``unsigned char``.

       :Character code: ``'B'``
       :Canonical name: `numpy.ubyte`
       :Alias on this platform (Linux x86_64): `numpy.uint8`: 8-bit unsigned integer (``0`` to ``255``).



   .. py:method:: bit_count(*args, **kwargs)

      uint8.bit_count() -> int

              Computes the number of 1-bits in the absolute value of the input.
              Analogous to the builtin `int.bit_count` or ``popcount`` in C++.

              Examples
              --------
              >>> np.uint8(127).bit_count()
              7




.. py:class:: uint(value)

   Bases: :py:obj:`numpy.unsignedinteger`


   Unsigned integer type, compatible with C ``unsigned long``.

       :Character code: ``'L'``
       :Canonical name: `numpy.uint`
       :Alias on this platform (Linux x86_64): `numpy.uint64`: 64-bit unsigned integer (``0`` to ``18_446_744_073_709_551_615``).
       :Alias on this platform (Linux x86_64): `numpy.uintp`: Unsigned integer large enough to fit pointer, compatible with C ``uintptr_t``.



   .. py:method:: bit_count(*args, **kwargs)

      uint64.bit_count() -> int

              Computes the number of 1-bits in the absolute value of the input.
              Analogous to the builtin `int.bit_count` or ``popcount`` in C++.

              Examples
              --------
              >>> np.uint64(127).bit_count()
              7




.. py:class:: uint16(value)

   Bases: :py:obj:`numpy.unsignedinteger`


   Unsigned integer type, compatible with C ``unsigned short``.

       :Character code: ``'H'``
       :Canonical name: `numpy.ushort`
       :Alias on this platform (Linux x86_64): `numpy.uint16`: 16-bit unsigned integer (``0`` to ``65_535``).



   .. py:method:: bit_count(*args, **kwargs)

      uint16.bit_count() -> int

              Computes the number of 1-bits in the absolute value of the input.
              Analogous to the builtin `int.bit_count` or ``popcount`` in C++.

              Examples
              --------
              >>> np.uint16(127).bit_count()
              7




.. py:class:: uint32(value)

   Bases: :py:obj:`numpy.unsignedinteger`


   Unsigned integer type, compatible with C ``unsigned int``.

       :Character code: ``'I'``
       :Canonical name: `numpy.uintc`
       :Alias on this platform (Linux x86_64): `numpy.uint32`: 32-bit unsigned integer (``0`` to ``4_294_967_295``).



   .. py:method:: bit_count(*args, **kwargs)

      uint32.bit_count() -> int

              Computes the number of 1-bits in the absolute value of the input.
              Analogous to the builtin `int.bit_count` or ``popcount`` in C++.

              Examples
              --------
              >>> np.uint32(127).bit_count()
              7




.. py:class:: uint64(value)

   Bases: :py:obj:`numpy.unsignedinteger`


   Unsigned integer type, compatible with C ``unsigned long``.

       :Character code: ``'L'``
       :Canonical name: `numpy.uint`
       :Alias on this platform (Linux x86_64): `numpy.uint64`: 64-bit unsigned integer (``0`` to ``18_446_744_073_709_551_615``).
       :Alias on this platform (Linux x86_64): `numpy.uintp`: Unsigned integer large enough to fit pointer, compatible with C ``uintptr_t``.



   .. py:method:: bit_count(*args, **kwargs)

      uint64.bit_count() -> int

              Computes the number of 1-bits in the absolute value of the input.
              Analogous to the builtin `int.bit_count` or ``popcount`` in C++.

              Examples
              --------
              >>> np.uint64(127).bit_count()
              7




.. py:class:: uint8(value)

   Bases: :py:obj:`numpy.unsignedinteger`


   Unsigned integer type, compatible with C ``unsigned char``.

       :Character code: ``'B'``
       :Canonical name: `numpy.ubyte`
       :Alias on this platform (Linux x86_64): `numpy.uint8`: 8-bit unsigned integer (``0`` to ``255``).



   .. py:method:: bit_count(*args, **kwargs)

      uint8.bit_count() -> int

              Computes the number of 1-bits in the absolute value of the input.
              Analogous to the builtin `int.bit_count` or ``popcount`` in C++.

              Examples
              --------
              >>> np.uint8(127).bit_count()
              7




.. py:class:: uintc(value)

   Bases: :py:obj:`numpy.unsignedinteger`


   Unsigned integer type, compatible with C ``unsigned int``.

       :Character code: ``'I'``
       :Canonical name: `numpy.uintc`
       :Alias on this platform (Linux x86_64): `numpy.uint32`: 32-bit unsigned integer (``0`` to ``4_294_967_295``).



   .. py:method:: bit_count(*args, **kwargs)

      uint32.bit_count() -> int

              Computes the number of 1-bits in the absolute value of the input.
              Analogous to the builtin `int.bit_count` or ``popcount`` in C++.

              Examples
              --------
              >>> np.uint32(127).bit_count()
              7




.. py:class:: uintp(value)

   Bases: :py:obj:`numpy.unsignedinteger`


   Unsigned integer type, compatible with C ``unsigned long``.

       :Character code: ``'L'``
       :Canonical name: `numpy.uint`
       :Alias on this platform (Linux x86_64): `numpy.uint64`: 64-bit unsigned integer (``0`` to ``18_446_744_073_709_551_615``).
       :Alias on this platform (Linux x86_64): `numpy.uintp`: Unsigned integer large enough to fit pointer, compatible with C ``uintptr_t``.



   .. py:method:: bit_count(*args, **kwargs)

      uint64.bit_count() -> int

              Computes the number of 1-bits in the absolute value of the input.
              Analogous to the builtin `int.bit_count` or ``popcount`` in C++.

              Examples
              --------
              >>> np.uint64(127).bit_count()
              7




.. py:class:: ulonglong(value)

   Bases: :py:obj:`numpy.unsignedinteger`


   Signed integer type, compatible with C ``unsigned long long``.

       :Character code: ``'Q'``



   .. py:method:: bit_count(*args, **kwargs)


.. py:class:: unsignedinteger(value)

   Bases: :py:obj:`numpy.integer`


   Abstract base class of all unsigned integer scalar types.



.. py:class:: ushort(value)

   Bases: :py:obj:`numpy.unsignedinteger`


   Unsigned integer type, compatible with C ``unsigned short``.

       :Character code: ``'H'``
       :Canonical name: `numpy.ushort`
       :Alias on this platform (Linux x86_64): `numpy.uint16`: 16-bit unsigned integer (``0`` to ``65_535``).



   .. py:method:: bit_count(*args, **kwargs)

      uint16.bit_count() -> int

              Computes the number of 1-bits in the absolute value of the input.
              Analogous to the builtin `int.bit_count` or ``popcount`` in C++.

              Examples
              --------
              >>> np.uint16(127).bit_count()
              7




.. py:function:: value_counts(pda: arkouda.pdarrayclass.pdarray) -> tuple

   Count the occurrences of the unique values of an array.

   :param pda: The array of values to count
   :type pda: pdarray

   :returns: * **unique_values** (*pdarray, int64 or Strings*) -- The unique values, sorted in ascending order
             * **counts** (*pdarray, int64*) -- The number of times the corresponding unique value occurs

   :raises TypeError: Raised if the parameter is not a pdarray

   .. seealso:: :obj:`unique`, :obj:`histogram`

   .. rubric:: Notes

   This function differs from ``histogram()`` in that it only returns
   counts for values that are present, leaving out empty "bins". This
   function delegates all logic to the unique() method where the
   return_counts parameter is set to True.

   .. rubric:: Examples

   >>> A = ak.array([2, 0, 2, 4, 0, 0])
   >>> ak.value_counts(A)
   (array([0 2 4]), array([3 2 1]))


.. py:function:: vecdot(x1: arkouda.pdarrayclass.pdarray, x2: arkouda.pdarrayclass.pdarray) -> arkouda.pdarrayclass.pdarray

   Compute the generalized dot product of two vectors along the given axis.
   Assumes that both tensors have already been broadcast to the same shape.

   :param x1:
   :type x1: pdarray
   :param x2:
   :type x2: pdarray

   :returns: x1 vecdot x2
   :rtype: pdarray

   .. rubric:: Examples

   >>> a = ak.array([[1,2,3,4,5],[1,2,3,4,5]])
   >>> b = ak.array([[2,2,2,2,2],[2,2,2,2,2]])
   >>> ak.vecdot(a,b)
   array([4 8 12 16 20])
   >>> ak.vecdot(b,a)
   array([4 8 12 16 20])

   :raises ValueTypeError: Raised if x1 and x2 are not of matching shape or if rank of x1 < 2


.. py:class:: void(value)

   Bases: :py:obj:`numpy.flexible`


   np.void(length_or_data, /, dtype=None)

       Create a new structured or unstructured void scalar.

       Parameters
       ----------
       length_or_data : int, array-like, bytes-like, object
          One of multiple meanings (see notes).  The length or
          bytes data of an unstructured void.  Or alternatively,
          the data to be stored in the new scalar when `dtype`
          is provided.
          This can be an array-like, in which case an array may
          be returned.
       dtype : dtype, optional
           If provided the dtype of the new scalar.  This dtype must
           be "void" dtype (i.e. a structured or unstructured void,
           see also :ref:`defining-structured-types`).

          ..versionadded:: 1.24

       Notes
       -----
       For historical reasons and because void scalars can represent both
       arbitrary byte data and structured dtypes, the void constructor
       has three calling conventions:

       1. ``np.void(5)`` creates a ``dtype="V5"`` scalar filled with five
          ``\0`` bytes.  The 5 can be a Python or NumPy integer.
       2. ``np.void(b"bytes-like")`` creates a void scalar from the byte string.
          The dtype itemsize will match the byte string length, here ``"V10"``.
       3. When a ``dtype=`` is passed the call is roughly the same as an
          array creation.  However, a void scalar rather than array is returned.

       Please see the examples which show all three different conventions.

       Examples
       --------
       >>> np.void(5)
       void(b'\x00\x00\x00\x00\x00')
       >>> np.void(b'abcd')
       void(b'\x61\x62\x63\x64')
       >>> np.void((5, 3.2, "eggs"), dtype="i,d,S5")
       (5, 3.2, b'eggs')  # looks like a tuple, but is `np.void`
       >>> np.void(3, dtype=[('x', np.int8), ('y', np.int8)])
       (3, 3)  # looks like a tuple, but is `np.void`

       :Character code: ``'V'``



.. py:function:: where(condition: arkouda.pdarrayclass.pdarray, A: Union[str, float, numpy.float64, numpy.float32, int, numpy.int8, numpy.int16, numpy.int32, numpy.int64, numpy.uint8, numpy.uint16, numpy.uint32, numpy.uint64, arkouda.pdarrayclass.pdarray, arkouda.strings.Strings, ~Categorical], B: Union[str, float, numpy.float64, numpy.float32, int, numpy.int8, numpy.int16, numpy.int32, numpy.int64, numpy.uint8, numpy.uint16, numpy.uint32, numpy.uint64, arkouda.pdarrayclass.pdarray, arkouda.strings.Strings, ~Categorical]) -> Union[arkouda.pdarrayclass.pdarray, arkouda.strings.Strings, ~Categorical]

   Returns an array with elements chosen from A and B based upon a
   conditioning array. As is the case with numpy.where, the return array
   consists of values from the first array (A) where the conditioning array
   elements are True and from the second array (B) where the conditioning
   array elements are False.

   :param condition: Used to choose values from A or B
   :type condition: pdarray
   :param A: Value(s) used when condition is True
   :type A: str, numeric_scalars, pdarray, Strings, or Categorical
   :param B: Value(s) used when condition is False
   :type B: str, numeric_scalars, pdarray, Strings, or Categorical

   :returns: Values chosen from A where the condition is True and B where
             the condition is False
   :rtype: pdarray

   :raises TypeError: Raised if the condition object is not a pdarray, if A or B is not
       an int, np.int64, float, np.float64, bool, pdarray, str, Strings, Categorical
       if pdarray dtypes are not supported or do not match, or multiple
       condition clauses (see Notes section) are applied
   :raises ValueError: Raised if the shapes of the condition, A, and B pdarrays are unequal

   .. rubric:: Examples

   >>> a1 = ak.arange(1,10)
   >>> a2 = ak.ones(9, dtype=np.int64)
   >>> cond = a1 < 5
   >>> ak.where(cond,a1,a2)
   array([1 2 3 4 1 1 1 1 1])

   >>> a1 = ak.arange(1,10)
   >>> a2 = ak.ones(9, dtype=np.int64)
   >>> cond = a1 == 5
   >>> ak.where(cond,a1,a2)
   array([1 1 1 1 5 1 1 1 1])

   >>> a1 = ak.arange(1,10)
   >>> a2 = 10
   >>> cond = a1 < 5
   >>> ak.where(cond,a1,a2)
   array([1 2 3 4 10 10 10 10 10])

   >>> s1 = ak.array([f'str {i}' for i in range(10)])
   >>> s2 = 'str 21'
   >>> cond = (ak.arange(10) % 2 == 0)
   >>> ak.where(cond,s1,s2)
   array(['str 0', 'str 21', 'str 2', 'str 21', 'str 4',
   'str 21', 'str 6', 'str 21', 'str 8', 'str 21'])

   >>> c1 = ak.Categorical(ak.array([f'str {i}' for i in range(10)]))
   >>> c2 = ak.Categorical(ak.array([f'str {i}' for i in range(9, -1, -1)]))
   >>> cond = (ak.arange(10) % 2 == 0)
   >>> ak.where(cond,c1,c2)
   array(['str 0', 'str 8', 'str 2', 'str 6', 'str 4',
   'str 4', 'str 6', 'str 2', 'str 8', 'str 0'])

   .. rubric:: Notes

   A and B must have the same dtype and only one conditional clause
   is supported e.g., n < 5, n > 1, which is supported in numpy
   is not currently supported in Arkouda


