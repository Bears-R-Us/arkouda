arkouda.numpy.random.generator
==============================

.. py:module:: arkouda.numpy.random.generator


Classes
-------

.. autoapisummary::

   arkouda.numpy.random.generator.Generator


Functions
---------

.. autoapisummary::

   arkouda.numpy.random.generator.default_rng
   arkouda.numpy.random.generator.float_array_or_scalar_helper


Module Contents
---------------

.. py:class:: Generator(name_dict=None, seed=None, state=1)

   ``Generator`` exposes a number of methods for generating random
   numbers drawn from a variety of probability distributions. In addition to
   the distribution-specific arguments, each method takes a keyword argument
   `size` that defaults to ``None``. If `size` is ``None``, then a single
   value is generated and returned. If `size` is an integer, then a 1-D
   array filled with generated values is returned.

   :param name_dict: Dictionary mapping the server side names associated with
                     the generators for each dtype.
   :type name_dict: dict
   :param seed: Seed to allow for reproducible random number generation.
   :type seed: int
   :param state: The current state we are in the random number generation stream.
                 This information makes it so calls to any dtype generator
                 function affects the stream of random numbers for the other generators.
                 This mimics the behavior we see in numpy
   :type state: int

   .. seealso::

      :py:obj:`default_rng`
          Recommended constructor for `Generator`.


   .. py:method:: choice(a, size=None, replace=True, p=None)

      Generate a randomly sample from a.

      :param a: If a is an integer, randomly sample from ak.arange(a).
                If a is a pdarray, randomly sample from a.
      :type a: int or pdarray
      :param size: Number of elements to be sampled
      :type size: int, optional
      :param replace: If True, sample with replacement. Otherwise sample without replacement.
                      Defaults to True
      :type replace: bool, optional
      :param p: p is the probabilities or weights associated with each element of a
      :type p: pdarray, optional

      :returns: A pdarray containing the sampled values or a single random value if size not provided.
      :rtype: pdarray, numeric_scalar



   .. py:method:: destructor()


   .. py:method:: exponential(scale=1.0, size=None, method='zig')

      Draw samples from an exponential distribution.

      Its probability density function is

      .. math::
          f(x; \frac{1}{\beta}) = \frac{1}{\beta} \exp(-\frac{x}{\beta}),

      for ``x > 0`` and 0 elsewhere. :math:`\beta` is the scale parameter,
      which is the inverse of the rate parameter :math:`\lambda = 1/\beta`.
      The rate parameter is an alternative, widely used parameterization
      of the exponential distribution.

      :param scale: The scale parameter, :math:`\beta = 1/\lambda`. Must be
                    non-negative. An array must have the same size as the size argument.
      :type scale: float or pdarray
      :param size: Output shape. Default is None, in which case a single value is returned.
      :type size: numeric_scalars, optional
      :param method: Either 'inv' or 'zig'. 'inv' uses the default inverse CDF method.
                     'zig' uses the Ziggurat method.
      :type method: str, optional

      :returns: Drawn samples from the parameterized exponential distribution.
      :rtype: pdarray



   .. py:method:: integers(low, high=None, size=None, dtype=akint64, endpoint=False)

      Return random integers from low (inclusive) to high (exclusive),
      or if endpoint=True, low (inclusive) to high (inclusive).

      Return random integers from the “discrete uniform” distribution of the specified dtype.
      If high is None (the default), then results are from 0 to low.

      :param low: Lowest (signed) integers to be drawn from the distribution (unless high=None,
                  in which case this parameter is 0 and this value is used for high).
      :type low: numeric_scalars
      :param high: If provided, one above the largest (signed) integer to be drawn from the distribution
                   (see above for behavior if high=None)
      :type high: numeric_scalars
      :param size: Output shape. Default is None, in which case a single value is returned.
      :type size: numeric_scalars
      :param dtype: Desired dtype of the result. The default value is ak.int64.
      :type dtype: dtype, optional
      :param endpoint: If true, sample from the interval [low, high] instead of the default [low, high).
                       Defaults to False
      :type endpoint: bool, optional

      :returns: Values drawn uniformly from the specified range having the desired dtype,
                or a single such random int if size not provided.
      :rtype: pdarray, numeric_scalar

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> rng = ak.random.default_rng(seed=1)
      >>> rng.integers(5, 20, 10)
      array([7 19 5 16 19 11 18 15 10 5])
      >>> rng.integers(5, size=10)
      array([4 2 5 5 3 5 5 2 2 2])



   .. py:method:: logistic(loc=0.0, scale=1.0, size=None)

      Draw samples from a logistic distribution.

      Samples are drawn from a logistic distribution with specified parameters,
      loc (location or mean, also median), and scale (>0).

      :param loc: Parameter of the distribution. Default of 0.
      :type loc: float or pdarray of floats, optional
      :param scale: Parameter of the distribution. Must be non-negative. Default is 1.
      :type scale: float or pdarray of floats, optional
      :param size: Output shape. Default is None, in which case a single value is returned.
      :type size: numeric_scalars, optional

      .. rubric:: Notes

      The probability density for the Logistic distribution is

      .. math::
         P(x) = \frac{e^{-(x - \mu)/s}}{s( 1 + e^{-(x - \mu)/s})^2}

      where :math:`\mu` is the location and :math:`s` is the scale.

      The Logistic distribution is used in Extreme Value problems where it can act
      as a mixture of Gumbel distributions, in Epidemiology, and by the World Chess Federation (FIDE)
      where it is used in the Elo ranking system, assuming the performance of each player
      is a logistically distributed random variable.

      :returns: Pdarray of floats (unless size=None, in which case a single float is returned).
      :rtype: pdarray

      .. seealso:: :py:obj:`normal`

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> ak.random.default_rng(17).logistic(3, 2.5, 3)
      array([1.1319566682702642 -7.1665150633720014 7.7208667145173608])



   .. py:method:: lognormal(mean=0.0, sigma=1.0, size=None, method='zig')

      Draw samples from a log-normal distribution with specified mean,
      standard deviation, and array shape.

      Note that the mean and standard deviation are not the values for the distribution itself,
      but of the underlying normal distribution it is derived from.

      :param mean: Mean of the distribution. Default of 0.
      :type mean: float or pdarray of floats, optional
      :param sigma: Standard deviation of the distribution. Must be non-negative. Default of 1.
      :type sigma: float or pdarray of floats, optional
      :param size: Output shape. Default is None, in which case a single value is returned.
      :type size: numeric_scalars, optional
      :param method: Either 'box' or 'zig'. 'box' uses the Box–Muller transform
                     'zig' uses the Ziggurat method.
      :type method: str, optional

      .. rubric:: Notes

      A variable `x` has a log-normal distribution if `log(x)` is normally distributed.
      The probability density for the log-normal distribution is:

      .. math::
         p(x) = \frac{1}{\sigma x \sqrt{2\pi}} e^{-\frac{(\ln(x)-\mu)^2}{2\sigma^2}}

      where :math:`\mu` is the mean and :math:`\sigma` the standard deviation of the normally
      distributed logarithm of the variable.
      A log-normal distribution results if a random variable is the product of a
      large number of independent, identically-distributed variables in the same
      way that a normal distribution results if the variable is
      the sum of a large number of independent, identically-distributed variables.

      :returns: Pdarray of floats (unless size=None, in which case a single float is returned).
      :rtype: pdarray

      .. seealso:: :py:obj:`normal`

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> ak.random.default_rng(17).lognormal(3, 2.5, 3)
      array([75.587346973566639 9.4194790331678568 1.0996120079897966])



   .. py:method:: normal(loc=0.0, scale=1.0, size=None, method='zig')

      Draw samples from a normal (Gaussian) distribution.

      :param loc: Mean of the distribution. Default of 0.
      :type loc: float or pdarray of floats, optional
      :param scale: Standard deviation of the distribution. Must be non-negative. Default of 1.
      :type scale: float or pdarray of floats, optional
      :param size: Output shape. Default is None, in which case a single value is returned.
      :type size: numeric_scalars, optional
      :param method: Either 'box' or 'zig'. 'box' uses the Box–Muller transform
                     'zig' uses the Ziggurat method.
      :type method: str, optional

      .. rubric:: Notes

      The probability density for the Gaussian distribution is:

      .. math::
         p(x) = \frac{1}{\sqrt{2\pi \sigma^2}} e^{-\frac{(x-\mu)^2}{2\sigma^2}}

      where :math:`\mu` is the mean and :math:`\sigma` the standard deviation.
      The square of the standard deviation, :math:`\sigma^2`, is called the variance.

      :returns: Pdarray of floats (unless size=None, in which case a single float is returned).
      :rtype: pdarray

      .. seealso:: :py:obj:`standard_normal`, :py:obj:`uniform`

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> ak.random.default_rng(17).normal(3, 2.5, 3)
      array([4.3252889011033728 2.2427797827243081 0.09495739757471533])



   .. py:method:: permutation(x, method='Argsort')

      Randomly permute a sequence, or return a permuted range.

      :param x: If x is an integer, randomly permute ak.arange(x). If x is an array,
                make a copy and shuffle the elements randomly.
      :type x: int or pdarray
      :param method: The method for generating the permutation.
                     Allowed values: 'FisherYates', 'Argsort'

                     If 'Argsort' is selected, the permutation will be generated by
                     an argsort performed on randomly generated floats.
      :type method: str = 'Argsort'

      :returns: pdarray of permuted elements
      :rtype: pdarray

      :raises ValueError: Raised if method is not an allowed value.
      :raises TypeError: Raised if x is not of type int or pdarray.



   .. py:method:: poisson(lam=1.0, size=None)

      Draw samples from a Poisson distribution.

      The Poisson distribution is the limit of the binomial distribution for large N.

      :param lam: Expected number of events occurring in a fixed-time interval, must be >= 0.
                  An array must have the same size as the size argument.
      :type lam: float or pdarray
      :param size: Output shape. Default is None, in which case a single value is returned.
      :type size: numeric_scalars, optional

      .. rubric:: Notes

      The probability mass function for the Poisson distribution is:

      .. math::
         f(k; \lambda) = \frac{\lambda^k e^{-\lambda}}{k!}

      For events with an expected separation :math:`\lambda`, the Poisson distribution
      :math:`f(k; \lambda)` describes the probability of :math:`k` events occurring
      within the observed interval :math:`\lambda`

      :returns: Pdarray of ints (unless size=None, in which case a single int is returned).
      :rtype: pdarray

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> rng = ak.random.default_rng(seed=17)
      >>> rng.poisson(lam=3, size=5)
      array([1 2 3 2 5])



   .. py:method:: random(size=None)

      Return random floats in the half-open interval [0.0, 1.0).

      Results are from the uniform distribution over the stated interval.

      :param size: Output shape. Default is None, in which case a single value is returned.
      :type size: numeric_scalars, optional

      :returns: Pdarray of random floats (unless size=None, in which case a single float is returned).
      :rtype: pdarray

      .. rubric:: Notes

      To sample over `[a,b)`, use uniform or multiply the output of random by `(b - a)` and add `a`:

       ``(b - a) * random() + a``

      .. seealso:: :py:obj:`uniform`

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> rng = ak.random.default_rng(seed=17)
      >>> rng.random()
      0.8450747927979015
      >>> rng.random(3)
      array([0.8059711747202466 0.71958748004486961 0.72539618972095954])



   .. py:method:: shuffle(x, method: str = 'FisherYates', *, feistel_rounds: int = 16, feistel_key: int | None = None)

      Randomly shuffle the elements of a `pdarray` in place.

      This method performs a reproducible in-place shuffle of the array `x`
      using the specified strategy. Three methods are available:

      :param x: The array to be shuffled in place. Must be a one-dimensional Arkouda array.
      :type x: pdarray
      :param method:
                     - "FisherYates": A **serial, global** Fisher–Yates shuffle implemented in Chapel.
                       Simple and fast for small/medium arrays, but **not distributed** — the entire
                       array must fit on one locale.
                     - "MergeShuffle": A **fully distributed** shuffle that combines local randomization
                       and cross-locale probabilistic merging. Scales to large datasets and maintains
                       good statistical uniformity across locales.
                     - "Feistel": A **keyed permutation** of indices via a Feistel PRP over [0, N),
                       then applies that permutation to `x`. Works for any `N` (uses cycle-walking
                       when N is not a power of two). **Distributed-friendly** and reproducible.
                       Not intended for cryptographic security.

                     Default is "FisherYates".
      :type method: {"FisherYates","MergeShuffle","Feistel"}, optional
      :param feistel_rounds: Number of Feistel rounds (default 16). Higher may cost more time.
      :type feistel_rounds: int, optional (keyword-only)
      :param feistel_key: 64-bit key for the Feistel permutation. If None, the backend should derive
                          a key from the RNG stream so results remain deterministic given the client RNG state.
      :type feistel_key: int or None, optional (keyword-only)

      :raises TypeError: If `x` is not a `pdarray`.
      :raises ValueError: If an unsupported shuffle method is specified, or if `feistel_key` is not a 64-bit integer.

      .. rubric:: Notes

      - The shuffle modifies `x` in place.
      - The result is deterministic given the client RNG state.
      - For `"MergeShuffle"`, reproducibility is guaranteed **only if the number of locales
        remains fixed** between runs. Changing locale count will yield different permutations.
      - Use `"FisherYates"` only for small arrays or testing.
      - Use `"MergeShuffle"` for production-scale distributed shuffling.
      - Use `"Feistel"` when you need a keyed, reproducible permutation of indices that
        also scales in distributed settings.

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> rng = ak.random.default_rng(18)
      >>> pda = ak.arange(10)
      >>> pda
      array([0 1 2 3 4 5 6 7 8 9])
      >>> rng.shuffle(pda, method="FisherYates")
      >>> pda
      array([0 8 2 7 9 4 6 3 5 1])
      >>> rng.shuffle(pda, method="MergeShuffle")
      >>> pda
      array([5 6 9 3 8 2 7 0 4 1])
      >>> rng.shuffle(pda, method="Feistel", feistel_rounds=18)
      >>> pda
      array([8 7 3 2 4 9 0 1 5 6])
      >>> rng.shuffle(pda, method="Feistel", feistel_key=0x1234_5678_9ABC_DEF0, feistel_rounds=18)
      >>> pda
      array([6 1 7 3 4 9 2 0 5 8])



   .. py:method:: standard_exponential(size=None, method='zig')

      Draw samples from the standard exponential distribution.

      `standard_exponential` is identical to the exponential distribution
      with a scale parameter of 1.

      :param size: Output shape. Default is None, in which case a single value is returned.
      :type size: numeric_scalars, optional
      :param method: Either 'inv' or 'zig'. 'inv' uses the default inverse CDF method.
                     'zig' uses the Ziggurat method.
      :type method: str, optional

      :returns: Drawn samples from the standard exponential distribution.
      :rtype: pdarray



   .. py:method:: standard_gamma(shape, size=None)

      Draw samples from a standard gamma distribution.

      Samples are drawn from a Gamma distribution with specified parameters,
      shape (sometimes designated “k”) and scale (sometimes designated “theta”),
      where both parameters are > 0.

      :param shape: specified parameter (sometimes designated “k”)
      :type shape: numeric_scalars
      :param size: Output shape. Default is None, in which case a single value is returned.
      :type size: numeric_scalars, optional

      :returns: Pdarray of floats (unless size=None, in which case a single float is returned).
      :rtype: pdarray

      .. rubric:: Notes

      The probability density function for the Gamma distribution is

      .. math::
          p(x) = x^{k-1}\frac{e^{\frac{-x}{\theta}}}{\theta^k\Gamma(k)}

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> rng = ak.random.default_rng(seed=17)
      >>> rng.standard_gamma(1)
      1.5654448696305245
      >>> rng.standard_gamma(1, size=3)
      array([0.016990291286171716 0.21612542775489499 0.49600147238356695])



   .. py:method:: standard_normal(size=None, method='zig')

      Draw samples from a standard Normal distribution (mean=0, stdev=1).

      :param size: Output shape. Default is None, in which case a single value is returned.
      :type size: numeric_scalars, optional
      :param method: Either 'box' or 'zig'. 'box' uses the Box–Muller transform
                     'zig' uses the Ziggurat method.
      :type method: str, optional

      :returns: Pdarray of floats (unless size=None, in which case a single float is returned).
      :rtype: pdarray

      .. rubric:: Notes

      For random samples from :math:`N(\mu, \sigma^2)`, either call `normal` or do:

      .. math::
          (\sigma \cdot \texttt{standard_normal}(size)) + \mu

      .. seealso:: :py:obj:`normal`

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> rng = ak.random.default_rng(seed=17)
      >>> rng.standard_normal()
      1.101262453505847
      >>> rng.standard_normal(3)
      array([0.53011556044134911 -0.30288808691027669 -1.1620170409701138])



   .. py:method:: uniform(low=0.0, high=1.0, size=None)

      Draw samples from a uniform distribution.

      Samples are uniformly distributed over the half-open interval [low, high).
      In other words, any value within the given interval is equally likely to be drawn by uniform.

      :param low: Lower boundary of the output interval. All values generated will be greater than or
                  equal to low. The default value is 0.
      :type low: float, optional
      :param high: Upper boundary of the output interval. All values generated will be less than high.
                   high must be greater than or equal to low. The default value is 1.0.
      :type high: float, optional
      :param size: Output size or shape. Default is None, in which case a single value is returned.
      :type size: int, tuple(int), None, optional

      :returns: Pdarray of floats (unless size=None, in which case a single float is returned).
      :rtype: pdarray

      .. seealso:: :py:obj:`integers`, :py:obj:`random`

      .. rubric:: Examples

      >>> import arkouda as ak
      >>> rng = ak.random.default_rng(seed=17)
      >>> rng.uniform(-1, 1, 3)
      array([0.61194234944049319 0.43917496008973922 0.45079237944191908])



.. py:function:: default_rng(seed=None)

   Construct a new Generator.

   Right now we only support PCG64, since this is what is available in chapel.

   :param seed: A seed to initialize the `Generator`. If None, then the seed will
                be generated by chapel in an implementation specific manner based on the current time.
                This behavior is currently unstable and may change in the future. If an int,
                then the value must be non-negative. If passed a `Generator`, it will be returned unaltered.
   :type seed: {None, int, Generator}, optional

   :returns: The initialized generator object.
   :rtype: Generator


.. py:function:: float_array_or_scalar_helper(func_name, var_name, var, size)

