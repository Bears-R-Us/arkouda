arkouda.numpy.dtypes
====================

.. py:module:: arkouda.numpy.dtypes


Classes
-------

.. autoapisummary::

   arkouda.numpy.dtypes.ARKOUDA_SUPPORTED_BOOLS
   arkouda.numpy.dtypes.ARKOUDA_SUPPORTED_DTYPES
   arkouda.numpy.dtypes.ARKOUDA_SUPPORTED_FLOATS
   arkouda.numpy.dtypes.ARKOUDA_SUPPORTED_INTS
   arkouda.numpy.dtypes.ARKOUDA_SUPPORTED_NUMBERS
   arkouda.numpy.dtypes.BoolDType
   arkouda.numpy.dtypes.ByteDType
   arkouda.numpy.dtypes.BytesDType
   arkouda.numpy.dtypes.CLongDoubleDType
   arkouda.numpy.dtypes.CastingKind
   arkouda.numpy.dtypes.Complex128DType
   arkouda.numpy.dtypes.Complex64DType
   arkouda.numpy.dtypes.DType
   arkouda.numpy.dtypes.DTypeObjects
   arkouda.numpy.dtypes.DTypes
   arkouda.numpy.dtypes.DateTime64DType
   arkouda.numpy.dtypes.Enum
   arkouda.numpy.dtypes.Float16DType
   arkouda.numpy.dtypes.Float32DType
   arkouda.numpy.dtypes.Float64DType
   arkouda.numpy.dtypes.Int16DType
   arkouda.numpy.dtypes.Int32DType
   arkouda.numpy.dtypes.Int64DType
   arkouda.numpy.dtypes.Int8DType
   arkouda.numpy.dtypes.IntDType
   arkouda.numpy.dtypes.Literal
   arkouda.numpy.dtypes.LongDType
   arkouda.numpy.dtypes.LongDoubleDType
   arkouda.numpy.dtypes.LongLongDType
   arkouda.numpy.dtypes.NUMBER_FORMAT_STRINGS
   arkouda.numpy.dtypes.NumericDTypes
   arkouda.numpy.dtypes.ObjectDType
   arkouda.numpy.dtypes.Optional
   arkouda.numpy.dtypes.ScalarDTypes
   arkouda.numpy.dtypes.SeriesDTypes
   arkouda.numpy.dtypes.ShortDType
   arkouda.numpy.dtypes.StrDType
   arkouda.numpy.dtypes.TimeDelta64DType
   arkouda.numpy.dtypes.TypeAlias
   arkouda.numpy.dtypes.TypeGuard
   arkouda.numpy.dtypes.UByteDType
   arkouda.numpy.dtypes.UInt16DType
   arkouda.numpy.dtypes.UInt32DType
   arkouda.numpy.dtypes.UInt64DType
   arkouda.numpy.dtypes.UInt8DType
   arkouda.numpy.dtypes.UIntDType
   arkouda.numpy.dtypes.ULongDType
   arkouda.numpy.dtypes.ULongLongDType
   arkouda.numpy.dtypes.UShortDType
   arkouda.numpy.dtypes.Union
   arkouda.numpy.dtypes.VoidDType
   arkouda.numpy.dtypes.all_scalars
   arkouda.numpy.dtypes.annotations
   arkouda.numpy.dtypes.bigint
   arkouda.numpy.dtypes.bigint_
   arkouda.numpy.dtypes.bitType
   arkouda.numpy.dtypes.bool
   arkouda.numpy.dtypes.bool_
   arkouda.numpy.dtypes.bool_scalars
   arkouda.numpy.dtypes.complex128
   arkouda.numpy.dtypes.complex64
   arkouda.numpy.dtypes.float16
   arkouda.numpy.dtypes.float32
   arkouda.numpy.dtypes.float64
   arkouda.numpy.dtypes.float_scalars
   arkouda.numpy.dtypes.int16
   arkouda.numpy.dtypes.int32
   arkouda.numpy.dtypes.int64
   arkouda.numpy.dtypes.int8
   arkouda.numpy.dtypes.intTypes
   arkouda.numpy.dtypes.int_scalars
   arkouda.numpy.dtypes.numeric_and_bool_scalars
   arkouda.numpy.dtypes.numeric_scalars
   arkouda.numpy.dtypes.numpy_scalars
   arkouda.numpy.dtypes.str_
   arkouda.numpy.dtypes.str_scalars
   arkouda.numpy.dtypes.uint16
   arkouda.numpy.dtypes.uint32
   arkouda.numpy.dtypes.uint64
   arkouda.numpy.dtypes.uint8


Functions
---------

.. autoapisummary::

   arkouda.numpy.dtypes.can_cast
   arkouda.numpy.dtypes.cast
   arkouda.numpy.dtypes.dtype
   arkouda.numpy.dtypes.dtype_for_chapel
   arkouda.numpy.dtypes.get_byteorder
   arkouda.numpy.dtypes.get_server_byteorder
   arkouda.numpy.dtypes.isSupportedBool
   arkouda.numpy.dtypes.isSupportedDType
   arkouda.numpy.dtypes.isSupportedFloat
   arkouda.numpy.dtypes.isSupportedInt
   arkouda.numpy.dtypes.isSupportedNumber
   arkouda.numpy.dtypes.is_supported_bool
   arkouda.numpy.dtypes.is_supported_dtype
   arkouda.numpy.dtypes.is_supported_float
   arkouda.numpy.dtypes.is_supported_int
   arkouda.numpy.dtypes.is_supported_number
   arkouda.numpy.dtypes.resolve_scalar_dtype
   arkouda.numpy.dtypes.result_type


Module Contents
---------------

.. py:class:: ARKOUDA_SUPPORTED_BOOLS

   Built-in immutable sequence.

   If no argument is given, the constructor returns an empty tuple.
   If iterable is specified the tuple is initialized from iterable's items.

   If the argument is a tuple, the return value is the same object.


   .. py:method:: count(value, /)

      Return number of occurrences of value.



   .. py:method:: index(value, start=0, stop=9223372036854775807, /)

      Return first index of value.

      Raises ValueError if the value is not present.



.. py:class:: ARKOUDA_SUPPORTED_DTYPES

   Built-in immutable sequence.

   If no argument is given, the constructor returns an empty tuple.
   If iterable is specified the tuple is initialized from iterable's items.

   If the argument is a tuple, the return value is the same object.


   .. py:method:: count(value, /)

      Return number of occurrences of value.



   .. py:method:: index(value, start=0, stop=9223372036854775807, /)

      Return first index of value.

      Raises ValueError if the value is not present.



.. py:class:: ARKOUDA_SUPPORTED_FLOATS

   Built-in immutable sequence.

   If no argument is given, the constructor returns an empty tuple.
   If iterable is specified the tuple is initialized from iterable's items.

   If the argument is a tuple, the return value is the same object.


   .. py:method:: count(value, /)

      Return number of occurrences of value.



   .. py:method:: index(value, start=0, stop=9223372036854775807, /)

      Return first index of value.

      Raises ValueError if the value is not present.



.. py:class:: ARKOUDA_SUPPORTED_INTS

   Built-in immutable sequence.

   If no argument is given, the constructor returns an empty tuple.
   If iterable is specified the tuple is initialized from iterable's items.

   If the argument is a tuple, the return value is the same object.


   .. py:method:: count(value, /)

      Return number of occurrences of value.



   .. py:method:: index(value, start=0, stop=9223372036854775807, /)

      Return first index of value.

      Raises ValueError if the value is not present.



.. py:class:: ARKOUDA_SUPPORTED_NUMBERS

   Built-in immutable sequence.

   If no argument is given, the constructor returns an empty tuple.
   If iterable is specified the tuple is initialized from iterable's items.

   If the argument is a tuple, the return value is the same object.


   .. py:method:: count(value, /)

      Return number of occurrences of value.



   .. py:method:: index(value, start=0, stop=9223372036854775807, /)

      Return first index of value.

      Raises ValueError if the value is not present.



.. py:class:: BoolDType

   Bases: :py:obj:`numpy.dtype`


   BoolDType()
   --

   DType class corresponding to the `numpy.bool` scalar type.

   See `numpy.dtype` for the typical way to create dtype instances
   and :ref:`arrays.dtypes` for additional information.


.. py:class:: ByteDType

   Bases: :py:obj:`numpy.dtypes._IntegerAbstractDType`


   Int8DType()
   --

   DType class corresponding to the `numpy.int8` scalar type.

   See `numpy.dtype` for the typical way to create dtype instances
   and :ref:`arrays.dtypes` for additional information.


.. py:class:: BytesDType

   Bases: :py:obj:`numpy.dtype`


   BytesDType(size, /)
   --

   DType class corresponding to the `numpy.bytes_` scalar type.

   See `numpy.dtype` for the typical way to create dtype instances
   and :ref:`arrays.dtypes` for additional information.


.. py:class:: CLongDoubleDType

   Bases: :py:obj:`numpy.dtypes._ComplexAbstractDType`


   CLongDoubleDType()
   --

   DType class corresponding to the `numpy.clongdouble` scalar type.

   See `numpy.dtype` for the typical way to create dtype instances
   and :ref:`arrays.dtypes` for additional information.


.. py:class:: CastingKind(origin, args, *, inst=True, name=None)

   Bases: :py:obj:`_GenericAlias`


   The central part of the internal API.

   This represents a generic version of type 'origin' with type arguments 'params'.
   There are two kind of these aliases: user defined and special. The special ones
   are wrappers around builtin collections and ABCs in collections.abc. These must
   have 'name' always set. If 'inst' is False, then the alias can't be instantiated;
   this is used by e.g. typing.List and typing.Dict.


.. py:class:: Complex128DType

   Bases: :py:obj:`numpy.dtypes._ComplexAbstractDType`


   Complex128DType()
   --

   DType class corresponding to the `numpy.complex128` scalar type.

   See `numpy.dtype` for the typical way to create dtype instances
   and :ref:`arrays.dtypes` for additional information.


.. py:class:: Complex64DType

   Bases: :py:obj:`numpy.dtypes._ComplexAbstractDType`


   Complex64DType()
   --

   DType class corresponding to the `numpy.complex64` scalar type.

   See `numpy.dtype` for the typical way to create dtype instances
   and :ref:`arrays.dtypes` for additional information.


.. py:class:: DType

   .. py:method:: BIGINT(*args, **kwargs)


   .. py:method:: BOOL(*args, **kwargs)


   .. py:method:: COMPLEX128(*args, **kwargs)


   .. py:method:: COMPLEX64(*args, **kwargs)


   .. py:method:: FLOAT(*args, **kwargs)


   .. py:method:: FLOAT32(*args, **kwargs)


   .. py:method:: FLOAT64(*args, **kwargs)


   .. py:method:: INT(*args, **kwargs)


   .. py:method:: INT16(*args, **kwargs)


   .. py:method:: INT32(*args, **kwargs)


   .. py:method:: INT64(*args, **kwargs)


   .. py:method:: INT8(*args, **kwargs)


   .. py:method:: STR(*args, **kwargs)


   .. py:method:: UINT(*args, **kwargs)


   .. py:method:: UINT16(*args, **kwargs)


   .. py:method:: UINT32(*args, **kwargs)


   .. py:method:: UINT64(*args, **kwargs)


   .. py:method:: UINT8(*args, **kwargs)


   .. py:method:: name(*args, **kwargs)

      The name of the Enum member.



   .. py:method:: value(*args, **kwargs)

      The value of the Enum member.



.. py:class:: DTypeObjects

   Build an immutable unordered collection of unique elements.


   .. py:method:: copy()

      Return a shallow copy of a set.



   .. py:method:: difference(*others)

      Return a new set with elements in the set that are not in the others.



   .. py:method:: intersection(*others)

      Return a new set with elements common to the set and all others.



   .. py:method:: isdisjoint(other, /)

      Return True if two sets have a null intersection.



   .. py:method:: issubset(other, /)

      Report whether another set contains this set.



   .. py:method:: issuperset(other, /)

      Report whether this set contains another set.



   .. py:method:: symmetric_difference(other, /)

      Return a new set with elements in either the set or other but not both.



   .. py:method:: union(*others)

      Return a new set with elements from the set and all others.



.. py:class:: DTypes

   Build an immutable unordered collection of unique elements.


   .. py:method:: copy()

      Return a shallow copy of a set.



   .. py:method:: difference(*others)

      Return a new set with elements in the set that are not in the others.



   .. py:method:: intersection(*others)

      Return a new set with elements common to the set and all others.



   .. py:method:: isdisjoint(other, /)

      Return True if two sets have a null intersection.



   .. py:method:: issubset(other, /)

      Report whether another set contains this set.



   .. py:method:: issuperset(other, /)

      Report whether this set contains another set.



   .. py:method:: symmetric_difference(other, /)

      Return a new set with elements in either the set or other but not both.



   .. py:method:: union(*others)

      Return a new set with elements from the set and all others.



.. py:class:: DateTime64DType

   Bases: :py:obj:`numpy.dtype`


   DateTime64DType(unit, /)
   --

   DType class corresponding to the `numpy.datetime64` scalar type.

   .. warning::
       ``np.dtypes.DateTime64DType`` cannot be instantiated directly.
       Use ``np.dtype("datetime64[{unit}]")`` instead.

   See `numpy.dtype` for the typical way to create dtype instances
   and :ref:`arrays.dtypes` for additional information.


.. py:class:: Enum

   Create a collection of name/value pairs.

   Example enumeration:

   >>> class Color(Enum):
   ...     RED = 1
   ...     BLUE = 2
   ...     GREEN = 3

   Access them by:

   - attribute access:

     >>> Color.RED
     <Color.RED: 1>

   - value lookup:

     >>> Color(1)
     <Color.RED: 1>

   - name lookup:

     >>> Color['RED']
     <Color.RED: 1>

   Enumerations can be iterated over, and know how many members they have:

   >>> len(Color)
   3

   >>> list(Color)
   [<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]

   Methods can be added to enumerations, and members can have their own
   attributes -- see the documentation for details.



.. py:class:: Float16DType

   Bases: :py:obj:`numpy.dtypes._FloatAbstractDType`


   Float16DType()
   --

   DType class corresponding to the `numpy.float16` scalar type.

   See `numpy.dtype` for the typical way to create dtype instances
   and :ref:`arrays.dtypes` for additional information.


.. py:class:: Float32DType

   Bases: :py:obj:`numpy.dtypes._FloatAbstractDType`


   Float32DType()
   --

   DType class corresponding to the `numpy.float32` scalar type.

   See `numpy.dtype` for the typical way to create dtype instances
   and :ref:`arrays.dtypes` for additional information.


.. py:class:: Float64DType

   Bases: :py:obj:`numpy.dtypes._FloatAbstractDType`


   Float64DType()
   --

   DType class corresponding to the `numpy.float64` scalar type.

   See `numpy.dtype` for the typical way to create dtype instances
   and :ref:`arrays.dtypes` for additional information.


.. py:class:: Int16DType

   Bases: :py:obj:`numpy.dtypes._IntegerAbstractDType`


   Int16DType()
   --

   DType class corresponding to the `numpy.int16` scalar type.

   See `numpy.dtype` for the typical way to create dtype instances
   and :ref:`arrays.dtypes` for additional information.


.. py:class:: Int32DType

   Bases: :py:obj:`numpy.dtypes._IntegerAbstractDType`


   Int32DType()
   --

   DType class corresponding to the `numpy.int32` scalar type.

   See `numpy.dtype` for the typical way to create dtype instances
   and :ref:`arrays.dtypes` for additional information.


.. py:class:: Int64DType

   Bases: :py:obj:`numpy.dtypes._IntegerAbstractDType`


   Int64DType()
   --

   DType class corresponding to the `numpy.int64` scalar type.

   See `numpy.dtype` for the typical way to create dtype instances
   and :ref:`arrays.dtypes` for additional information.


.. py:class:: Int8DType

   Bases: :py:obj:`numpy.dtypes._IntegerAbstractDType`


   Int8DType()
   --

   DType class corresponding to the `numpy.int8` scalar type.

   See `numpy.dtype` for the typical way to create dtype instances
   and :ref:`arrays.dtypes` for additional information.


.. py:class:: IntDType

   Bases: :py:obj:`numpy.dtypes._IntegerAbstractDType`


   Int32DType()
   --

   DType class corresponding to the `numpy.int32` scalar type.

   See `numpy.dtype` for the typical way to create dtype instances
   and :ref:`arrays.dtypes` for additional information.


.. py:class:: Literal(getitem)

   Bases: :py:obj:`_SpecialForm`


   Special typing form to define literal types (a.k.a. value types).

   This form can be used to indicate to type checkers that the corresponding
   variable or function parameter has a value equivalent to the provided
   literal (or one of several literals)::

       def\ validate_simple(data: Any) -> Literal[True]:  # always returns True
           ...

       MODE = Literal['r', 'rb', 'w', 'wb']
       def\ open_helper(file: str, mode: MODE) -> str:
           ...

       open_helper('/some/path', 'r')  # Passes type check
       open_helper('/other/path', 'typo')  # Error in type checker

   Literal[...] cannot be subclassed. At runtime, an arbitrary value
   is allowed as type argument to Literal[...], but type checkers may
   impose restrictions.



.. py:class:: LongDType

   Bases: :py:obj:`numpy.dtypes._IntegerAbstractDType`


   Int64DType()
   --

   DType class corresponding to the `numpy.int64` scalar type.

   See `numpy.dtype` for the typical way to create dtype instances
   and :ref:`arrays.dtypes` for additional information.


.. py:class:: LongDoubleDType

   Bases: :py:obj:`numpy.dtypes._FloatAbstractDType`


   LongDoubleDType()
   --

   DType class corresponding to the `numpy.longdouble` scalar type.

   See `numpy.dtype` for the typical way to create dtype instances
   and :ref:`arrays.dtypes` for additional information.


.. py:class:: LongLongDType

   Bases: :py:obj:`numpy.dtypes._IntegerAbstractDType`


   LongLongDType()
   --

   DType class corresponding to the `numpy.longlong` scalar type.

   See `numpy.dtype` for the typical way to create dtype instances
   and :ref:`arrays.dtypes` for additional information.


.. py:class:: NUMBER_FORMAT_STRINGS

   dict() -> new empty dictionary
   dict(mapping) -> new dictionary initialized from a mapping object's
       (key, value) pairs
   dict(iterable) -> new dictionary initialized as if via:
       d = {}
       for k, v in iterable:
           d[k] = v
   dict(**kwargs) -> new dictionary initialized with the name=value pairs
       in the keyword argument list.  For example:  dict(one=1, two=2)


   .. py:method:: clear()

      Remove all items from the dict.



   .. py:method:: copy()

      Return a shallow copy of the dict.



   .. py:method:: fromkeys(iterable, value=None, /)

      Create a new dictionary with keys from iterable and values set to value.



   .. py:method:: get(key, default=None, /)

      Return the value for key if key is in the dictionary, else default.



   .. py:method:: items()

      Return a set-like object providing a view on the dict's items.



   .. py:method:: keys()

      Return a set-like object providing a view on the dict's keys.



   .. py:method:: pop(*args, **kwargs)

      D.pop(k[,d]) -> v, remove specified key and return the corresponding value.

      If the key is not found, return the default if given; otherwise,
      raise a KeyError.



   .. py:method:: popitem()

      Remove and return a (key, value) pair as a 2-tuple.

      Pairs are returned in LIFO (last-in, first-out) order.
      Raises KeyError if the dict is empty.



   .. py:method:: setdefault(key, default=None, /)

      Insert key with a value of default if key is not in the dictionary.

      Return the value for key if key is in the dictionary, else default.



   .. py:method:: update(*args, **kwargs)

      D.update([E, ]**F) -> None.  Update D from mapping/iterable E and F.
      If E is present and has a .keys() method, then does:  for k in E.keys(): D[k] = E[k]
      If E is present and lacks a .keys() method, then does:  for k, v in E: D[k] = v
      In either case, this is followed by: for k in F:  D[k] = F[k]



   .. py:method:: values()

      Return an object providing a view on the dict's values.



.. py:class:: NumericDTypes

   Build an immutable unordered collection of unique elements.


   .. py:method:: copy()

      Return a shallow copy of a set.



   .. py:method:: difference(*others)

      Return a new set with elements in the set that are not in the others.



   .. py:method:: intersection(*others)

      Return a new set with elements common to the set and all others.



   .. py:method:: isdisjoint(other, /)

      Return True if two sets have a null intersection.



   .. py:method:: issubset(other, /)

      Report whether another set contains this set.



   .. py:method:: issuperset(other, /)

      Report whether this set contains another set.



   .. py:method:: symmetric_difference(other, /)

      Return a new set with elements in either the set or other but not both.



   .. py:method:: union(*others)

      Return a new set with elements from the set and all others.



.. py:class:: ObjectDType

   Bases: :py:obj:`numpy.dtype`


   ObjectDType()
   --

   DType class corresponding to the `numpy.object` scalar type.

   See `numpy.dtype` for the typical way to create dtype instances
   and :ref:`arrays.dtypes` for additional information.


.. py:class:: Optional

   Bases: :py:obj:`_Final`


   Optional[X] is equivalent to Union[X, None].


.. py:class:: ScalarDTypes

   Build an immutable unordered collection of unique elements.


   .. py:method:: copy()

      Return a shallow copy of a set.



   .. py:method:: difference(*others)

      Return a new set with elements in the set that are not in the others.



   .. py:method:: intersection(*others)

      Return a new set with elements common to the set and all others.



   .. py:method:: isdisjoint(other, /)

      Return True if two sets have a null intersection.



   .. py:method:: issubset(other, /)

      Report whether another set contains this set.



   .. py:method:: issuperset(other, /)

      Report whether this set contains another set.



   .. py:method:: symmetric_difference(other, /)

      Return a new set with elements in either the set or other but not both.



   .. py:method:: union(*others)

      Return a new set with elements from the set and all others.



.. py:class:: SeriesDTypes

   dict() -> new empty dictionary
   dict(mapping) -> new dictionary initialized from a mapping object's
       (key, value) pairs
   dict(iterable) -> new dictionary initialized as if via:
       d = {}
       for k, v in iterable:
           d[k] = v
   dict(**kwargs) -> new dictionary initialized with the name=value pairs
       in the keyword argument list.  For example:  dict(one=1, two=2)


   .. py:method:: clear()

      Remove all items from the dict.



   .. py:method:: copy()

      Return a shallow copy of the dict.



   .. py:method:: fromkeys(iterable, value=None, /)

      Create a new dictionary with keys from iterable and values set to value.



   .. py:method:: get(key, default=None, /)

      Return the value for key if key is in the dictionary, else default.



   .. py:method:: items()

      Return a set-like object providing a view on the dict's items.



   .. py:method:: keys()

      Return a set-like object providing a view on the dict's keys.



   .. py:method:: pop(*args, **kwargs)

      D.pop(k[,d]) -> v, remove specified key and return the corresponding value.

      If the key is not found, return the default if given; otherwise,
      raise a KeyError.



   .. py:method:: popitem()

      Remove and return a (key, value) pair as a 2-tuple.

      Pairs are returned in LIFO (last-in, first-out) order.
      Raises KeyError if the dict is empty.



   .. py:method:: setdefault(key, default=None, /)

      Insert key with a value of default if key is not in the dictionary.

      Return the value for key if key is in the dictionary, else default.



   .. py:method:: update(*args, **kwargs)

      D.update([E, ]**F) -> None.  Update D from mapping/iterable E and F.
      If E is present and has a .keys() method, then does:  for k in E.keys(): D[k] = E[k]
      If E is present and lacks a .keys() method, then does:  for k, v in E: D[k] = v
      In either case, this is followed by: for k in F:  D[k] = F[k]



   .. py:method:: values()

      Return an object providing a view on the dict's values.



.. py:class:: ShortDType

   Bases: :py:obj:`numpy.dtypes._IntegerAbstractDType`


   Int16DType()
   --

   DType class corresponding to the `numpy.int16` scalar type.

   See `numpy.dtype` for the typical way to create dtype instances
   and :ref:`arrays.dtypes` for additional information.


.. py:class:: StrDType

   Bases: :py:obj:`numpy.dtype`


   StrDType(size, /)
   --

   DType class corresponding to the `numpy.str_` scalar type.

   See `numpy.dtype` for the typical way to create dtype instances
   and :ref:`arrays.dtypes` for additional information.


.. py:class:: TimeDelta64DType

   Bases: :py:obj:`numpy.dtype`


   TimeDelta64DType(unit, /)
   --

   DType class corresponding to the `numpy.timedelta64` scalar type.

   .. warning::
       ``np.dtypes.TimeDelta64DType`` cannot be instantiated directly.
       Use ``np.dtype("timedelta64[{unit}]")`` instead.

   See `numpy.dtype` for the typical way to create dtype instances
   and :ref:`arrays.dtypes` for additional information.


.. py:class:: TypeAlias

   Bases: :py:obj:`_Final`


   Special form for marking type aliases.

   Use TypeAlias to indicate that an assignment should
   be recognized as a proper type alias definition by type
   checkers.

   For example::

       Predicate: TypeAlias = Callable[..., bool]

   It's invalid when used anywhere except as in the example above.



.. py:class:: TypeGuard

   Bases: :py:obj:`_Final`


   Special typing construct for marking user-defined type predicate functions.

   ``TypeGuard`` can be used to annotate the return type of a user-defined
   type predicate function.  ``TypeGuard`` only accepts a single type argument.
   At runtime, functions marked this way should return a boolean.

   ``TypeGuard`` aims to benefit *type narrowing* -- a technique used by static
   type checkers to determine a more precise type of an expression within a
   program's code flow.  Usually type narrowing is done by analyzing
   conditional code flow and applying the narrowing to a block of code.  The
   conditional expression here is sometimes referred to as a "type predicate".

   Sometimes it would be convenient to use a user-defined boolean function
   as a type predicate.  Such a function should use ``TypeGuard[...]`` or
   ``TypeIs[...]`` as its return type to alert static type checkers to
   this intention. ``TypeGuard`` should be used over ``TypeIs`` when narrowing
   from an incompatible type (e.g., ``list[object]`` to ``list[int]``) or when
   the function does not return ``True`` for all instances of the narrowed type.

   Using  ``-> TypeGuard[NarrowedType]`` tells the static type checker that
   for a given function:

   1. The return value is a boolean.
   2. If the return value is ``True``, the type of its argument
      is ``NarrowedType``.

   For example::

        def\ is_str_list(val: list[object]) -> TypeGuard[list[str]]:
            '''Determines whether all objects in the list are strings'''
            return all(isinstance(x, str) for x in val)

        def\ func1(val: list[object]):
            if is_str_list(val):
                # Type of ``val`` is narrowed to ``list[str]``.
                print(" ".join(val))
            else:
                # Type of ``val`` remains as ``list[object]``.
                print("Not a list of strings!")

   Strict type narrowing is not enforced -- ``TypeB`` need not be a narrower
   form of ``TypeA`` (it can even be a wider form) and this may lead to
   type-unsafe results.  The main reason is to allow for things like
   narrowing ``list[object]`` to ``list[str]`` even though the latter is not
   a subtype of the former, since ``list`` is invariant.  The responsibility of
   writing type-safe type predicates is left to the user.

   ``TypeGuard`` also works with type variables.  For more information, see
   PEP 647 (User-Defined Type Guards).



.. py:class:: UByteDType

   Bases: :py:obj:`numpy.dtypes._IntegerAbstractDType`


   UInt8DType()
   --

   DType class corresponding to the `numpy.uint8` scalar type.

   See `numpy.dtype` for the typical way to create dtype instances
   and :ref:`arrays.dtypes` for additional information.


.. py:class:: UInt16DType

   Bases: :py:obj:`numpy.dtypes._IntegerAbstractDType`


   UInt16DType()
   --

   DType class corresponding to the `numpy.uint16` scalar type.

   See `numpy.dtype` for the typical way to create dtype instances
   and :ref:`arrays.dtypes` for additional information.


.. py:class:: UInt32DType

   Bases: :py:obj:`numpy.dtypes._IntegerAbstractDType`


   UInt32DType()
   --

   DType class corresponding to the `numpy.uint32` scalar type.

   See `numpy.dtype` for the typical way to create dtype instances
   and :ref:`arrays.dtypes` for additional information.


.. py:class:: UInt64DType

   Bases: :py:obj:`numpy.dtypes._IntegerAbstractDType`


   UInt64DType()
   --

   DType class corresponding to the `numpy.uint64` scalar type.

   See `numpy.dtype` for the typical way to create dtype instances
   and :ref:`arrays.dtypes` for additional information.


.. py:class:: UInt8DType

   Bases: :py:obj:`numpy.dtypes._IntegerAbstractDType`


   UInt8DType()
   --

   DType class corresponding to the `numpy.uint8` scalar type.

   See `numpy.dtype` for the typical way to create dtype instances
   and :ref:`arrays.dtypes` for additional information.


.. py:class:: UIntDType

   Bases: :py:obj:`numpy.dtypes._IntegerAbstractDType`


   UInt32DType()
   --

   DType class corresponding to the `numpy.uint32` scalar type.

   See `numpy.dtype` for the typical way to create dtype instances
   and :ref:`arrays.dtypes` for additional information.


.. py:class:: ULongDType

   Bases: :py:obj:`numpy.dtypes._IntegerAbstractDType`


   UInt64DType()
   --

   DType class corresponding to the `numpy.uint64` scalar type.

   See `numpy.dtype` for the typical way to create dtype instances
   and :ref:`arrays.dtypes` for additional information.


.. py:class:: ULongLongDType

   Bases: :py:obj:`numpy.dtypes._IntegerAbstractDType`


   ULongLongDType()
   --

   DType class corresponding to the `numpy.ulonglong` scalar type.

   See `numpy.dtype` for the typical way to create dtype instances
   and :ref:`arrays.dtypes` for additional information.


.. py:class:: UShortDType

   Bases: :py:obj:`numpy.dtypes._IntegerAbstractDType`


   UInt16DType()
   --

   DType class corresponding to the `numpy.uint16` scalar type.

   See `numpy.dtype` for the typical way to create dtype instances
   and :ref:`arrays.dtypes` for additional information.


.. py:class:: Union

   Bases: :py:obj:`_Final`


   Union type; Union[X, Y] means either X or Y.

   On Python 3.10 and higher, the | operator
   can also be used to denote unions;
   X | Y means the same thing to the type checker as Union[X, Y].

   To define a union, use e.g. Union[int, str]. Details:
   - The arguments must be types and there must be at least one.
   - None as an argument is a special case and is replaced by
     type(None).
   - Unions of unions are flattened, e.g.::

       assert Union[Union[int, str], float] == Union[int, str, float]

   - Unions of a single argument vanish, e.g.::

       assert Union[int] == int  # The constructor actually returns int

   - Redundant arguments are skipped, e.g.::

       assert Union[int, str, int] == Union[int, str]

   - When comparing unions, the argument order is ignored, e.g.::

       assert Union[int, str] == Union[str, int]

   - You cannot subclass or instantiate a union.
   - You can use Optional[X] as a shorthand for Union[X, None].



.. py:class:: VoidDType

   Bases: :py:obj:`numpy.dtype`


   VoidDType(length, /)
   --

   DType class corresponding to the `numpy.void` scalar type.

   .. warning::
       ``np.dtypes.VoidDType`` cannot be instantiated directly.
       Use ``np.dtype("void[{unit}]")`` instead.

   See `numpy.dtype` for the typical way to create dtype instances
   and :ref:`arrays.dtypes` for additional information.


.. py:class:: all_scalars

   Bases: :py:obj:`_NotIterable`


   Mixin to prevent iteration, without being compatible with Iterable.

   That is, we could do::

       def __iter__(self): raise TypeError()

   But this would make users of this mixin duck type-compatible with
   collections.abc.Iterable - isinstance(foo, Iterable) would be True.

   Luckily, we can instead prevent iteration by setting __iter__ to None, which
   is treated specially.


   .. py:method:: copy_with(params)


.. py:class:: annotations

   .. py:method:: compiler_flag(*args, **kwargs)

      int([x]) -> integer
      int(x, base=10) -> integer

      Convert a number or string to an integer, or return 0 if no arguments
      are given.  If x is a number, return x.__int__().  For floating-point
      numbers, this truncates towards zero.

      If x is not a number or if base is given, then x must be a string,
      bytes, or bytearray instance representing an integer literal in the
      given base.  The literal can be preceded by '+' or '-' and be surrounded
      by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
      Base 0 means to interpret the base from the string as an integer literal.
      >>> int('0b100', base=0)
      4



   .. py:method:: getMandatoryRelease()

      Return release in which this feature will become mandatory.

      This is a 5-tuple, of the same form as sys.version_info, or, if
      the feature was dropped, or the release date is undetermined, is None.




   .. py:method:: getOptionalRelease()

      Return first release in which this feature was recognized.

      This is a 5-tuple, of the same form as sys.version_info.




   .. py:method:: mandatory(*args, **kwargs)

      The type of the None singleton.



   .. py:method:: optional(*args, **kwargs)

      Built-in immutable sequence.

      If no argument is given, the constructor returns an empty tuple.
      If iterable is specified the tuple is initialized from iterable's items.

      If the argument is a tuple, the return value is the same object.



.. py:class:: bigint

   Dtype sentinel for Arkouda's variable-width (arbitrary-precision) integers.

   This class represents the dtype object used by Arkouda arrays storing
   arbitrary-precision integers. It behaves similarly to NumPy’s dtype
   objects (such as ``np.int64``), but corresponds to an unbounded,
   variable-width integer type. Instances of :class:`bigint` are singletons
   created through ``__new__`` so that all dtype references share the same
   object.

   Construction semantics follow NumPy’s pattern: calling ``ak.bigint()``
   returns the dtype sentinel, and calling ``ak.bigint(value)`` returns a
   :class:`bigint_` scalar constructed from ``value``.

   bigint instances compare equal to the ``bigint`` class, to themselves,
   to strings such as ``"bigint"``, and to other dtype-like objects whose
   ``name`` attribute equals ``"bigint"``. This allows interoperability
   across Arkouda’s dtype-resolution system.

   .. rubric:: Notes

   This class represents only the dtype. Scalar values use :class:`bigint_`,
   which inherits from :class:`int`.

   .. attribute:: name

      Canonical dtype name (``"bigint"``).

      :type: str

   .. attribute:: kind

      Dtype category code (``"ui"``).

      :type: str

   .. attribute:: itemsize

      Nominal bit-width (128). Actual precision is unbounded.

      :type: int

   .. attribute:: ndim

      Number of dimensions for the dtype object (always 0).

      :type: int

   .. attribute:: shape

      Empty tuple, following NumPy's dtype API.

      :type: tuple

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.bigint()
   dtype(bigint)

   >>> ak.bigint(42)
   ak.bigint_(42)

   >>> dtype = ak.bigint()
   >>> dtype.name
   'bigint'


   .. py:property:: is_signed


   .. py:property:: is_variable_width


   .. py:method:: itemsize(*args, **kwargs)

      int([x]) -> integer
      int(x, base=10) -> integer

      Convert a number or string to an integer, or return 0 if no arguments
      are given.  If x is a number, return x.__int__().  For floating-point
      numbers, this truncates towards zero.

      If x is not a number or if base is given, then x must be a string,
      bytes, or bytearray instance representing an integer literal in the
      given base.  The literal can be preceded by '+' or '-' and be surrounded
      by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
      Base 0 means to interpret the base from the string as an integer literal.
      >>> int('0b100', base=0)
      4



   .. py:method:: kind(*args, **kwargs)

      str(object='') -> str
      str(bytes_or_buffer[, encoding[, errors]]) -> str

      Create a new string object from the given object. If encoding or
      errors is specified, then the object must expose a data buffer
      that will be decoded using the given encoding and error handler.
      Otherwise, returns the result of object.__str__() (if defined)
      or repr(object).
      encoding defaults to 'utf-8'.
      errors defaults to 'strict'.



   .. py:method:: name(*args, **kwargs)

      str(object='') -> str
      str(bytes_or_buffer[, encoding[, errors]]) -> str

      Create a new string object from the given object. If encoding or
      errors is specified, then the object must expose a data buffer
      that will be decoded using the given encoding and error handler.
      Otherwise, returns the result of object.__str__() (if defined)
      or repr(object).
      encoding defaults to 'utf-8'.
      errors defaults to 'strict'.



   .. py:method:: ndim(*args, **kwargs)

      int([x]) -> integer
      int(x, base=10) -> integer

      Convert a number or string to an integer, or return 0 if no arguments
      are given.  If x is a number, return x.__int__().  For floating-point
      numbers, this truncates towards zero.

      If x is not a number or if base is given, then x must be a string,
      bytes, or bytearray instance representing an integer literal in the
      given base.  The literal can be preceded by '+' or '-' and be surrounded
      by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
      Base 0 means to interpret the base from the string as an integer literal.
      >>> int('0b100', base=0)
      4



   .. py:method:: shape(*args, **kwargs)

      Built-in immutable sequence.

      If no argument is given, the constructor returns an empty tuple.
      If iterable is specified the tuple is initialized from iterable's items.

      If the argument is a tuple, the return value is the same object.



   .. py:method:: type(x)


.. py:class:: bigint_

   Scalar type for Arkouda's variable-width integer dtype.

   ``bigint_`` represents an individual arbitrary-precision integer value within
   Arkouda arrays that use the :class:`bigint` dtype. It inherits directly from
   Python's built-in :class:`int`, ensuring full arbitrary-precision semantics
   while providing dtype metadata compatible with Arkouda.

   This class is typically constructed indirectly via ``ak.bigint(value)``,
   which invokes the :class:`_BigIntMeta` metaclass. Direct instantiation is
   also supported.

   Construction
   ------------
   ``bigint_(x)`` converts ``x`` to an integer using Python's ``int``:

   * If ``x`` is ``str`` or ``bytes``, it is interpreted using ``int(x, 0)``,
     allowing hexadecimal (``"0xff"``), binary (``"0b1010"``), and other
     literal forms.
   * Otherwise, ``x`` is passed directly to ``int(x)``.

   Properties
   ----------
   dtype : bigint
       Returns the corresponding dtype sentinel, ``ak.bigint()``.
       This mirrors NumPy scalar behavior (e.g., ``np.int64(1).dtype``).

   .. method:: item()

      Return the underlying Python ``int`` value, matching NumPy scalar
      semantics.


   .. rubric:: Notes

   ``bigint_`` values behave exactly like Python ``int`` objects in arithmetic,
   hashing, comparison, and formatting. Arkouda arrays wrap and distribute many
   such scalars but do not impose fixed-width limits.

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> x = ak.bigint(123)
   >>> x
   ak.bigint_(123)

   >>> x + 10
   133

   >>> ak.bigint_("0xff")
   ak.bigint_(255)

   >>> x.dtype
   dtype(bigint)

   >>> x.item()
   123


   .. py:property:: dtype


   .. py:method:: item()


.. py:class:: bitType

   Bases: :py:obj:`numpy.unsignedinteger`


   Unsigned signed integer type, 64bit on 64bit systems and 32bit on 32bit systems.

   :Character code: ``'L'``
   :Canonical name: `numpy.uint`
   :Alias on this platform (Linux x86_64): `numpy.uint64`: 64-bit unsigned integer (``0`` to ``18_446_744_073_709_551_615``).
   :Alias on this platform (Linux x86_64): `numpy.uintp`: Unsigned integer large enough to fit pointer, compatible with C ``uintptr_t``.


   .. py:method:: bit_count(/)

      uint64.bit_count() -> int

      Computes the number of 1-bits in the absolute value of the input.
      Analogous to the builtin `int.bit_count` or ``popcount`` in C++.

      .. rubric:: Examples

      >>> np.uint64(127).bit_count()
      7



.. py:class:: bool

   Bases: :py:obj:`numpy.generic`


   Boolean type (True or False), stored as a byte.

   .. warning::

       The :class:`bool` type is not a subclass of the :class:`int_` type
       (the :class:`bool` is not even a number type). This is different
       than Python's default implementation of :class:`bool` as a
       sub-class of :class:`int`.

   :Character code: ``'?'``


.. py:class:: bool_

   Bases: :py:obj:`numpy.generic`


   Boolean type (True or False), stored as a byte.

   .. warning::

       The :class:`bool` type is not a subclass of the :class:`int_` type
       (the :class:`bool` is not even a number type). This is different
       than Python's default implementation of :class:`bool` as a
       sub-class of :class:`int`.

   :Character code: ``'?'``


.. py:class:: bool_scalars

   Bases: :py:obj:`_NotIterable`


   Mixin to prevent iteration, without being compatible with Iterable.

   That is, we could do::

       def __iter__(self): raise TypeError()

   But this would make users of this mixin duck type-compatible with
   collections.abc.Iterable - isinstance(foo, Iterable) would be True.

   Luckily, we can instead prevent iteration by setting __iter__ to None, which
   is treated specially.


   .. py:method:: copy_with(params)


.. py:function:: can_cast(from_dt, to_dt, casting: Literal['safe',] | None = 'safe') -> bool

   Determine whether a value of one dtype can be safely cast to another,
   following NumPy-like rules but including Arkouda-specific handling for
   ``bigint`` and ``bigint_``.

   The default ``"safe"`` mode uses the following logic:

   * ``bigint`` → ``bigint``: always allowed.
   * ``bigint`` → float dtypes: allowed (may lose precision, but magnitude fits).
   * ``bigint`` → fixed-width signed/unsigned integers: not allowed, due to
     potential overflow.
   * int64 / uint64 → ``bigint``: allowed (widening).
   * float → ``bigint``: not allowed (information loss).
   * All other cases fall back to ``numpy.can_cast`` semantics.

   :param from_dt: Source dtype or scalar-like object.
   :type from_dt: Any
   :param to_dt: Target dtype or scalar-like object.
   :type to_dt: Any
   :param casting: Casting rule, matching NumPy’s ``can_cast`` API. Only ``"safe"``
                   is currently implemented. Other values are accepted for API
                   compatibility but routed through the same logic.
   :type casting: str, optional

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> from arkouda.numpy import can_cast, dtype

   # bigint → bigint
   >>> can_cast(dtype("bigint"), dtype("bigint"))
   True

   # bigint → float64
   >>> can_cast(dtype("bigint"), dtype("float64"))
   True

   # bigint → int64 (unsafe)
   >>> can_cast(dtype("bigint"), dtype("int64"))
   False

   # int64 → bigint (widening)
   >>> can_cast(dtype("int64"), dtype("bigint"))
   True

   # float → bigint (lossy)
   >>> can_cast(dtype("float64"), dtype("bigint"))
   False

   # Standard NumPy cases
   >>> can_cast(dtype("int64"), dtype("float64"))
   True
   >>> can_cast(dtype("float64"), dtype("int64"))
   False


.. py:function:: cast(typ, val)

   Cast a value to a type.

   This returns the value unchanged.  To the type checker this
   signals that the return value has the designated type, but at
   runtime we intentionally don't check anything (we want this
   to be as fast as possible).



.. py:class:: complex128

   Bases: :py:obj:`numpy.complexfloating`


   Complex number type composed of two double-precision floating-point numbers,
   compatible with Python :class:`complex`.

   :Character code: ``'D'``
   :Canonical name: `numpy.cdouble`
   :Alias on this platform (Linux x86_64): `numpy.complex128`: Complex number type composed of 2 64-bit-precision floating-point numbers.


.. py:class:: complex64

   Bases: :py:obj:`numpy.complexfloating`


   Complex number type composed of two single-precision floating-point numbers.

   :Character code: ``'F'``
   :Canonical name: `numpy.csingle`
   :Alias on this platform (Linux x86_64): `numpy.complex64`: Complex number type composed of 2 32-bit-precision floating-point numbers.


.. py:function:: dtype(x)

   Normalize a dtype-like input into an Arkouda dtype sentinel or a NumPy dtype.

   This function accepts many dtype-like forms—including Python scalars,
   NumPy scalar types, Arkouda ``bigint`` sentinels, and strings—and resolves
   them to the canonical Arkouda/NumPy dtype object. The resolution rules
   include special handling of the ``bigint`` family and magnitude-aware routing
   for Python integers.

   :param x: The dtype-like object to normalize. May be a Python scalar, a NumPy
             dtype or scalar, the ``bigint`` sentinel or scalar, a dtype-specifying
             string, or any object accepted by ``numpy.dtype``.
   :type x: Any

   :raises TypeError: If ``x`` cannot be interpreted as either an Arkouda dtype or a NumPy
       dtype. This includes cases where ``numpy.dtype(x)`` itself fails.

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> from arkouda.numpy import dtype

   # bigint family
   >>> dtype("bigint")
   dtype(bigint)
   >>> dtype(ak.bigint(10_000_000_000_000_000_000))
   dtype(bigint)

   # magnitude-based routing for Python ints
   >>> dtype(10)
   dtype('int64')
   >>> dtype(2**63 - 1)
   dtype('int64')
   >>> dtype(2**63)
   dtype('uint64')
   >>> dtype(2**100)
   dtype(bigint)

   # floats and bools
   >>> dtype(1.0)
   dtype('float64')
   >>> dtype(True)
   dtype('bool')

   # string dtypes
   >>> dtype("str")
   dtype('<U')

   # fallback to numpy.dtype
   >>> dtype("int32")
   dtype('int32')


.. py:function:: dtype_for_chapel(type_name: str)

   Returns dtype() for the given Chapel type.

   :param type_name: The name of the Chapel type, with or without the bit width
   :type type_name: str

   :returns: The corresponding Arkouda dtype object
   :rtype: dtype

   :raises TypeError: Raised if Arkouda does not have a type that corresponds to `type_name`


.. py:class:: float16

   Bases: :py:obj:`numpy.floating`


   Half-precision floating-point number type.

   :Character code: ``'e'``
   :Canonical name: `numpy.half`
   :Alias on this platform (Linux x86_64): `numpy.float16`: 16-bit-precision floating-point number type: sign bit, 5 bits exponent, 10 bits mantissa.


   .. py:method:: as_integer_ratio(/)

      half.as_integer_ratio() -> (int, int)

      Return a pair of integers, whose ratio is exactly equal to the original
      floating point number, and with a positive denominator.
      Raise `OverflowError` on infinities and a `ValueError` on NaNs.

      >>> np.half(10.0).as_integer_ratio()
      (10, 1)
      >>> np.half(0.0).as_integer_ratio()
      (0, 1)
      >>> np.half(-.25).as_integer_ratio()
      (-1, 4)



   .. py:method:: is_integer(/)

      half.is_integer() -> bool

      Return ``True`` if the floating point number is finite with integral
      value, and ``False`` otherwise.

      .. versionadded:: 1.22

      .. rubric:: Examples

      >>> np.half(-2.0).is_integer()
      True
      >>> np.half(3.2).is_integer()
      False



.. py:class:: float32

   Bases: :py:obj:`numpy.floating`


   Single-precision floating-point number type, compatible with C ``float``.

   :Character code: ``'f'``
   :Canonical name: `numpy.single`
   :Alias on this platform (Linux x86_64): `numpy.float32`: 32-bit-precision floating-point number type: sign bit, 8 bits exponent, 23 bits mantissa.


   .. py:method:: as_integer_ratio(/)

      single.as_integer_ratio() -> (int, int)

      Return a pair of integers, whose ratio is exactly equal to the original
      floating point number, and with a positive denominator.
      Raise `OverflowError` on infinities and a `ValueError` on NaNs.

      >>> np.single(10.0).as_integer_ratio()
      (10, 1)
      >>> np.single(0.0).as_integer_ratio()
      (0, 1)
      >>> np.single(-.25).as_integer_ratio()
      (-1, 4)



   .. py:method:: is_integer(/)

      single.is_integer() -> bool

      Return ``True`` if the floating point number is finite with integral
      value, and ``False`` otherwise.

      .. versionadded:: 1.22

      .. rubric:: Examples

      >>> np.single(-2.0).is_integer()
      True
      >>> np.single(3.2).is_integer()
      False



.. py:class:: float64

   Bases: :py:obj:`numpy.floating`


   Double-precision floating-point number type, compatible with Python :class:`float` and C ``double``.

   :Character code: ``'d'``
   :Canonical name: `numpy.double`
   :Alias on this platform (Linux x86_64): `numpy.float64`: 64-bit precision floating-point number type: sign bit, 11 bits exponent, 52 bits mantissa.


   .. py:method:: as_integer_ratio(/)

      double.as_integer_ratio() -> (int, int)

      Return a pair of integers, whose ratio is exactly equal to the original
      floating point number, and with a positive denominator.
      Raise `OverflowError` on infinities and a `ValueError` on NaNs.

      >>> np.double(10.0).as_integer_ratio()
      (10, 1)
      >>> np.double(0.0).as_integer_ratio()
      (0, 1)
      >>> np.double(-.25).as_integer_ratio()
      (-1, 4)



   .. py:method:: fromhex(string, /)

      Create a floating-point number from a hexadecimal string.

      >>> float.fromhex('0x1.ffffp10')
      2047.984375
      >>> float.fromhex('-0x1p-1074')
      -5e-324



   .. py:method:: hex(/)

      Return a hexadecimal representation of a floating-point number.

      >>> (-0.1).hex()
      '-0x1.999999999999ap-4'
      >>> 3.14159.hex()
      '0x1.921f9f01b866ep+1'



   .. py:method:: is_integer(/)

      double.is_integer() -> bool

      Return ``True`` if the floating point number is finite with integral
      value, and ``False`` otherwise.

      .. versionadded:: 1.22

      .. rubric:: Examples

      >>> np.double(-2.0).is_integer()
      True
      >>> np.double(3.2).is_integer()
      False



.. py:class:: float_scalars

   Bases: :py:obj:`_NotIterable`


   Mixin to prevent iteration, without being compatible with Iterable.

   That is, we could do::

       def __iter__(self): raise TypeError()

   But this would make users of this mixin duck type-compatible with
   collections.abc.Iterable - isinstance(foo, Iterable) would be True.

   Luckily, we can instead prevent iteration by setting __iter__ to None, which
   is treated specially.


   .. py:method:: copy_with(params)


.. py:function:: get_byteorder(dt: np.dtype) -> str

   Get a concrete byteorder (turns '=' into '<' or '>') on the client.

   :param dt: The numpy dtype to determine the byteorder of.
   :type dt: np.dtype

   :returns: Returns "<" for little endian and ">" for big endian.
   :rtype: str

   :raises ValueError: Returned if sys.byteorder is not "little" or "big"

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.get_byteorder(ak.dtype(ak.int64))
   '<'


.. py:function:: get_server_byteorder() -> str

   Get the server's byteorder.

   :returns: Returns "little" for little endian and "big" for big endian.
   :rtype: str

   :raises ValueError: Raised if Server byteorder is not 'little' or 'big'

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.get_server_byteorder()
   'little'


.. py:class:: int16

   Bases: :py:obj:`numpy.signedinteger`


   Signed integer type, compatible with C ``short``.

   :Character code: ``'h'``
   :Canonical name: `numpy.short`
   :Alias on this platform (Linux x86_64): `numpy.int16`: 16-bit signed integer (``-32_768`` to ``32_767``).


   .. py:method:: bit_count(/)

      int16.bit_count() -> int

      Computes the number of 1-bits in the absolute value of the input.
      Analogous to the builtin `int.bit_count` or ``popcount`` in C++.

      .. rubric:: Examples

      >>> np.int16(127).bit_count()
      7
      >>> np.int16(-127).bit_count()
      7



.. py:class:: int32

   Bases: :py:obj:`numpy.signedinteger`


   Signed integer type, compatible with C ``int``.

   :Character code: ``'i'``
   :Canonical name: `numpy.intc`
   :Alias on this platform (Linux x86_64): `numpy.int32`: 32-bit signed integer (``-2_147_483_648`` to ``2_147_483_647``).


   .. py:method:: bit_count(/)

      int32.bit_count() -> int

      Computes the number of 1-bits in the absolute value of the input.
      Analogous to the builtin `int.bit_count` or ``popcount`` in C++.

      .. rubric:: Examples

      >>> np.int32(127).bit_count()
      7
      >>> np.int32(-127).bit_count()
      7



.. py:class:: int64

   Bases: :py:obj:`numpy.signedinteger`


   Signed integer type, compatible with C ``long``.

   :Character code: ``'l'``
   :Canonical name: `numpy.long`
   :Alias on this platform (Linux x86_64): `numpy.int64`: 64-bit signed integer (``-9_223_372_036_854_775_808`` to ``9_223_372_036_854_775_807``).
   :Alias on this platform (Linux x86_64): `numpy.intp`: Signed integer large enough to fit pointer, compatible with C ``intptr_t``.


   .. py:method:: bit_count(/)

      int64.bit_count() -> int

      Computes the number of 1-bits in the absolute value of the input.
      Analogous to the builtin `int.bit_count` or ``popcount`` in C++.

      .. rubric:: Examples

      >>> np.int64(127).bit_count()
      7
      >>> np.int64(-127).bit_count()
      7



.. py:class:: int8

   Bases: :py:obj:`numpy.signedinteger`


   Signed integer type, compatible with C ``char``.

   :Character code: ``'b'``
   :Canonical name: `numpy.byte`
   :Alias on this platform (Linux x86_64): `numpy.int8`: 8-bit signed integer (``-128`` to ``127``).


   .. py:method:: bit_count(/)

      int8.bit_count() -> int

      Computes the number of 1-bits in the absolute value of the input.
      Analogous to the builtin `int.bit_count` or ``popcount`` in C++.

      .. rubric:: Examples

      >>> np.int8(127).bit_count()
      7
      >>> np.int8(-127).bit_count()
      7



.. py:class:: intTypes

   Build an immutable unordered collection of unique elements.


   .. py:method:: copy()

      Return a shallow copy of a set.



   .. py:method:: difference(*others)

      Return a new set with elements in the set that are not in the others.



   .. py:method:: intersection(*others)

      Return a new set with elements common to the set and all others.



   .. py:method:: isdisjoint(other, /)

      Return True if two sets have a null intersection.



   .. py:method:: issubset(other, /)

      Report whether another set contains this set.



   .. py:method:: issuperset(other, /)

      Report whether this set contains another set.



   .. py:method:: symmetric_difference(other, /)

      Return a new set with elements in either the set or other but not both.



   .. py:method:: union(*others)

      Return a new set with elements from the set and all others.



.. py:class:: int_scalars

   Bases: :py:obj:`_NotIterable`


   Mixin to prevent iteration, without being compatible with Iterable.

   That is, we could do::

       def __iter__(self): raise TypeError()

   But this would make users of this mixin duck type-compatible with
   collections.abc.Iterable - isinstance(foo, Iterable) would be True.

   Luckily, we can instead prevent iteration by setting __iter__ to None, which
   is treated specially.


   .. py:method:: copy_with(params)


.. py:function:: isSupportedBool(num)

   Deprecated alias for :func:`is_supported_bool`.

   This function exists for backward compatibility only. Use
   :func:`is_supported_bool` instead.

   :param num: A scalar value to test.
   :type num: object

   :returns: True if ``num`` is an arkouda-supported boolean dtype,
             otherwise False.
   :rtype: bool

   .. seealso::

      :py:obj:`is_supported_bool`
          Preferred replacement.


.. py:function:: isSupportedDType(num)

   Deprecated alias for :func:`is_supported_dtype`.

   This function exists for backward compatibility only. Use
   :func:`is_supported_dtype` instead.

   :param num: A scalar value to test.
   :type num: object

   :returns: True if ``num`` is an arkouda-supported dtype,
             otherwise False.
   :rtype: bool

   .. seealso::

      :py:obj:`is_supported_dtype`
          Preferred replacement.


.. py:function:: isSupportedFloat(num)

   Deprecated alias for :func:`is_supported_float`.

   This function exists for backward compatibility only. Use
   :func:`is_supported_float` instead.

   :param num: A scalar value to test.
   :type num: object

   :returns: True if ``num`` is an arkouda-supported float dtype,
             otherwise False.
   :rtype: bool

   .. seealso::

      :py:obj:`is_supported_float`
          Preferred replacement.


.. py:function:: isSupportedInt(num)

   Deprecated alias for :func:`is_supported_int`.

   This function exists for backward compatibility only. Use
   :func:`is_supported_int` instead.

   :param num: A scalar value to test.
   :type num: object

   :returns: True if ``num`` is an arkouda-supported integer dtype,
             otherwise False.
   :rtype: bool

   .. seealso::

      :py:obj:`is_supported_int`
          Preferred replacement.


.. py:function:: isSupportedNumber(num)

   Deprecated alias for :func:`is_supported_number`.

   This function exists for backward compatibility only. Use
   :func:`is_supported_number` instead.

   :param num: A scalar value to test.
   :type num: object

   :returns: True if ``num`` is an arkouda-supported numeric dtype,
             otherwise False.
   :rtype: bool

   .. seealso::

      :py:obj:`is_supported_number`
          Preferred replacement.


.. py:function:: is_supported_bool(num) -> TypeGuard[bool_scalars]

   Whether a scalar is an arkouda supported boolean dtype.

   :param num: A scalar.
   :type num: object

   :returns: True if scalar is an instance of an arkouda supported boolean dtype, else False.
   :rtype: bool

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.is_supported_bool("True")
   False
   >>> ak.is_supported_bool(True)
   True


.. py:function:: is_supported_dtype(scalar: object) -> bool

   Whether a scalar is an arkouda supported dtype.

   :param scalar:
   :type scalar: object

   :returns: True if scalar is an instance of an arkouda supported dtype, else False.
   :rtype: builtins.bool

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.is_supported_dtype(ak.int64(64))
   True
   >>> ak.is_supported_dtype(np.complex128(1+2j))
   False


.. py:function:: is_supported_float(num) -> TypeGuard[float_scalars]

   Whether a scalar is an arkouda supported float dtype.

   :param num: A scalar.
   :type num: object

   :returns: True if scalar is an instance of an arkouda supported float dtype, else False.
   :rtype: bool

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.is_supported_float(56)
   False
   >>> ak.is_supported_float(56.7)
   True


.. py:function:: is_supported_int(num) -> TypeGuard[int_scalars]

   Whether a scalar is an arkouda supported integer dtype.

   :param num: A scalar.
   :type num: object

   :returns: True if scalar is an instance of an arkouda supported integer dtype, else False.
   :rtype: bool

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.is_supported_int(79)
   True
   >>> ak.is_supported_int(54.9)
   False


.. py:function:: is_supported_number(num) -> TypeGuard[numeric_scalars]

   Whether a scalar is an arkouda supported numeric dtype.

   :param num: A scalar.
   :type num: object

   :returns: True if scalar is an instance of an arkouda supported numeric dtype, else False.
   :rtype: bool

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.is_supported_number(45.9)
   True
   >>> ak.is_supported_number("string")
   False


.. py:class:: numeric_and_bool_scalars

   Bases: :py:obj:`_NotIterable`


   Mixin to prevent iteration, without being compatible with Iterable.

   That is, we could do::

       def __iter__(self): raise TypeError()

   But this would make users of this mixin duck type-compatible with
   collections.abc.Iterable - isinstance(foo, Iterable) would be True.

   Luckily, we can instead prevent iteration by setting __iter__ to None, which
   is treated specially.


   .. py:method:: copy_with(params)


.. py:class:: numeric_scalars

   Bases: :py:obj:`_NotIterable`


   Mixin to prevent iteration, without being compatible with Iterable.

   That is, we could do::

       def __iter__(self): raise TypeError()

   But this would make users of this mixin duck type-compatible with
   collections.abc.Iterable - isinstance(foo, Iterable) would be True.

   Luckily, we can instead prevent iteration by setting __iter__ to None, which
   is treated specially.


   .. py:method:: copy_with(params)


.. py:class:: numpy_scalars

   Bases: :py:obj:`_NotIterable`


   Mixin to prevent iteration, without being compatible with Iterable.

   That is, we could do::

       def __iter__(self): raise TypeError()

   But this would make users of this mixin duck type-compatible with
   collections.abc.Iterable - isinstance(foo, Iterable) would be True.

   Luckily, we can instead prevent iteration by setting __iter__ to None, which
   is treated specially.


   .. py:method:: copy_with(params)


.. py:function:: resolve_scalar_dtype(val: object) -> str

   Try to infer what dtype arkouda_server should treat val as.


.. py:function:: result_type(*args)

   Determine the result dtype from one or more inputs, following NumPy’s
   promotion rules but extended to support Arkouda ``bigint`` semantics.

   This function mirrors ``numpy.result_type`` for standard NumPy dtypes,
   scalars, and arrays, but additionally recognizes Arkouda ``bigint`` and
   ``bigint_`` values, promoting them according to Arkouda-specific rules.

   In mixed-type expressions, the following logic is applied:

   * Any presence of ``bigint`` or ``bigint_`` promotes the result to:
       - ``float64`` if any float is also present,
       - otherwise ``bigint``.
   * Python integers first pass through Arkouda's magnitude-aware ``dtype()``
     routing, so extremely large integers may promote to ``bigint``.
   * Booleans promote to ``bool`` as in NumPy.
   * Mixed signed/unsigned integers follow NumPy rules, except that a
     non-negative signed scalar combined with unsigned scalars promotes to
     the widest unsigned dtype.
   * All remaining cases defer to ``numpy.result_type``.

   :param \*args: One or more dtype-like objects, scalars, NumPy arrays, Arkouda arrays,
                  or any value accepted by ``numpy.result_type`` or Arkouda’s
                  ``dtype()`` conversion.
   :type \*args: Any

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> from arkouda.numpy import result_type, dtype

   # bigint wins unless floats appear
   >>> result_type(dtype("bigint"), dtype("int64"))
   dtype(bigint)

   >>> result_type(dtype("bigint"), dtype("float64"))
   dtype('float64')

   # magnitude-aware routing: this becomes bigint, so result is bigint
   >>> result_type(2**100, 5)
   dtype(bigint)

   # standard NumPy integer promotions
   >>> result_type(dtype("int32"), dtype("int64"))
   dtype('int64')

   # unsigned with non-negative signed scalar → largest unsigned
   >>> result_type(np.uint32(3), 7)   # 7 is non-negative signed scalar
   dtype('uint32')

   # float promotion
   >>> result_type(1.0, 5)
   dtype('float64')

   # boolean stays boolean
   >>> result_type(True, False)
   dtype('bool')


.. py:class:: str_

   A unicode string.

   This type strips trailing null codepoints.

   >>> s = np.str_("abc\x00")
   >>> s
   'abc'

   Unlike the builtin :class:`str`, this supports the
   :ref:`python:bufferobjects`, exposing its contents as UCS4:

   >>> m = memoryview(np.str_("abc"))
   >>> m.format
   '3w'
   >>> m.tobytes()
   b'a\x00\x00\x00b\x00\x00\x00c\x00\x00\x00'

   :Character code: ``'U'``


   .. py:method:: T(*args, **kwargs)

      Scalar attribute identical to `ndarray.T`.



   .. py:method:: all(/, axis=None, out=None, keepdims=False, *, where=True)

      Scalar method identical to `ndarray.all`.



   .. py:method:: any(/, axis=None, out=None, keepdims=False, *, where=True)

      Scalar method identical to `ndarray.any`.



   .. py:method:: argmax(/, axis=None, out=None, *, keepdims=False)

      Scalar method identical to `ndarray.argmax`.



   .. py:method:: argmin(/, axis=None, out=None, *, keepdims=False)

      Scalar method identical to `ndarray.argmin`.



   .. py:method:: argsort(/, axis=-1, kind=None, order=None, *, stable=None)

      Scalar method identical to `ndarray.argsort`.



   .. py:method:: astype(/, dtype, order='K', casting='unsafe', subok=True, copy=True)

      Scalar method identical to `ndarray.astype`.



   .. py:method:: base(*args, **kwargs)

      Scalar attribute identical to `ndarray.base`.



   .. py:method:: byteswap(/, inplace=False)

      Scalar method identical to `ndarray.byteswap`.



   .. py:method:: choose(/, choices, out=None, mode='raise')

      Scalar method identical to `ndarray.choose`.



   .. py:method:: clip(/, min=None, max=None, out=None, **kwargs)

      Scalar method identical to `ndarray.clip`.



   .. py:method:: compress(/, condition, axis=None, out=None)

      Scalar method identical to `ndarray.compress`.



   .. py:method:: conj(/)

      Scalar method identical to `ndarray.conj`.



   .. py:method:: conjugate(/)

      Scalar method identical to `ndarray.conjugate`.



   .. py:method:: copy(/, order='C')

      Scalar method identical to `ndarray.copy`.



   .. py:method:: cumprod(/, axis=None, dtype=None, out=None)

      Scalar method identical to `ndarray.cumprod`.



   .. py:method:: cumsum(/, axis=None, dtype=None, out=None)

      Scalar method identical to `ndarray.cumsum`.



   .. py:method:: data(*args, **kwargs)

      Pointer to start of data.



   .. py:method:: device(*args, **kwargs)


   .. py:method:: diagonal(/, offset=0, axis1=0, axis2=1)

      Scalar method identical to `ndarray.diagonal`.



   .. py:method:: dtype(*args, **kwargs)

      Get array data-descriptor.



   .. py:method:: dump(/, file)

      Scalar method identical to `ndarray.dump`.



   .. py:method:: dumps(/)

      Scalar method identical to `ndarray.dumps`.



   .. py:method:: fill(/, value)

      Scalar method identical to `ndarray.fill`.



   .. py:method:: flags(*args, **kwargs)

      The integer value of flags.



   .. py:method:: flat(*args, **kwargs)

      A 1-D view of the scalar.



   .. py:method:: flatten(/, order='C')

      Scalar method identical to `ndarray.flatten`.



   .. py:method:: getfield(/, dtype, offset=0)

      Scalar method identical to `ndarray.getfield`.



   .. py:method:: imag(*args, **kwargs)

      The imaginary part of the scalar.



   .. py:method:: item(/, *args)

      Scalar method identical to `ndarray.item`.



   .. py:method:: itemsize(*args, **kwargs)

      The length of one element in bytes.



   .. py:method:: max(/, axis=None, out=None, **kwargs)

      Scalar method identical to `ndarray.max`.



   .. py:method:: mean(/, axis=None, dtype=None, out=None, **kwargs)

      Scalar method identical to `ndarray.mean`.



   .. py:method:: min(/, axis=None, out=None, **kwargs)

      Scalar method identical to `ndarray.min`.



   .. py:method:: nbytes(*args, **kwargs)


   .. py:method:: ndim(*args, **kwargs)

      The number of array dimensions.



   .. py:method:: nonzero(/)

      Scalar method identical to `ndarray.nonzero`.



   .. py:method:: prod(/, axis=None, dtype=None, out=None, **kwargs)

      Scalar method identical to `ndarray.prod`.



   .. py:method:: put(indices, values, /, mode='raise')

      Scalar method identical to `ndarray.put`.



   .. py:method:: ravel(/, order='C')

      Scalar method identical to `ndarray.ravel`.



   .. py:method:: real(*args, **kwargs)

      The real part of the scalar.



   .. py:method:: repeat(repeats, /, axis=None)

      Scalar method identical to `ndarray.repeat`.



   .. py:method:: reshape(/, *shape, order='C', copy=None)

      Scalar method identical to `ndarray.reshape`.



   .. py:method:: resize(/, *new_shape, refcheck=True)

      Scalar method identical to `ndarray.resize`.



   .. py:method:: round(/, decimals=0, out=None)

      Scalar method identical to `ndarray.round`.



   .. py:method:: searchsorted(v, /, side='left', sorter=None)

      Scalar method identical to `ndarray.searchsorted`.



   .. py:method:: setfield(val, /, dtype, offset=0)

      Scalar method identical to `ndarray.setfield`.



   .. py:method:: setflags(/, *, write=None, align=None, uic=None)

      Scalar method identical to `ndarray.setflags`.



   .. py:method:: shape(*args, **kwargs)

      Tuple of array dimensions.



   .. py:method:: size(*args, **kwargs)

      The number of elements in the gentype.



   .. py:method:: sort(/, axis=-1, kind=None, order=None, *, stable=None)

      Scalar method identical to `ndarray.sort`.



   .. py:method:: squeeze(/, axis=None)

      Scalar method identical to `ndarray.squeeze`.



   .. py:method:: std(/, axis=None, dtype=None, out=None, ddof=0, **kwargs)

      Scalar method identical to `ndarray.std`.



   .. py:method:: strides(*args, **kwargs)

      Tuple of bytes steps in each dimension.



   .. py:method:: sum(/, axis=None, dtype=None, out=None, **kwargs)

      Scalar method identical to `ndarray.sum`.



   .. py:method:: swapaxes(axis1, axis2, /)

      Scalar method identical to `ndarray.swapaxes`.



   .. py:method:: take(indices, /, axis=None, out=None, mode='raise')

      Scalar method identical to `ndarray.take`.



   .. py:method:: to_device(device, /, *, stream=None)

      Scalar method identical to `ndarray.to_device`.



   .. py:method:: tobytes(/, order='C')

      Scalar method identical to `ndarray.tobytes`.



   .. py:method:: tofile(fid, /, sep='', format='%s')

      Scalar method identical to `ndarray.tofile`.



   .. py:method:: tolist(/)

      Scalar method identical to `ndarray.tolist`.



   .. py:method:: trace(/, offset=0, axis1=0, axis2=1, dtype=None, out=None)

      Scalar method identical to `ndarray.trace`.



   .. py:method:: transpose(/, *axes)

      Scalar method identical to `ndarray.transpose`.



   .. py:method:: var(/, axis=None, dtype=None, out=None, ddof=0, **kwargs)

      Scalar method identical to `ndarray.var`.



   .. py:method:: view(/, *args, **kwargs)

      Scalar method identical to `ndarray.view`.



.. py:class:: str_scalars

   Bases: :py:obj:`_NotIterable`


   Mixin to prevent iteration, without being compatible with Iterable.

   That is, we could do::

       def __iter__(self): raise TypeError()

   But this would make users of this mixin duck type-compatible with
   collections.abc.Iterable - isinstance(foo, Iterable) would be True.

   Luckily, we can instead prevent iteration by setting __iter__ to None, which
   is treated specially.


   .. py:method:: copy_with(params)


.. py:class:: uint16

   Bases: :py:obj:`numpy.unsignedinteger`


   Unsigned integer type, compatible with C ``unsigned short``.

   :Character code: ``'H'``
   :Canonical name: `numpy.ushort`
   :Alias on this platform (Linux x86_64): `numpy.uint16`: 16-bit unsigned integer (``0`` to ``65_535``).


   .. py:method:: bit_count(/)

      uint16.bit_count() -> int

      Computes the number of 1-bits in the absolute value of the input.
      Analogous to the builtin `int.bit_count` or ``popcount`` in C++.

      .. rubric:: Examples

      >>> np.uint16(127).bit_count()
      7



.. py:class:: uint32

   Bases: :py:obj:`numpy.unsignedinteger`


   Unsigned integer type, compatible with C ``unsigned int``.

   :Character code: ``'I'``
   :Canonical name: `numpy.uintc`
   :Alias on this platform (Linux x86_64): `numpy.uint32`: 32-bit unsigned integer (``0`` to ``4_294_967_295``).


   .. py:method:: bit_count(/)

      uint32.bit_count() -> int

      Computes the number of 1-bits in the absolute value of the input.
      Analogous to the builtin `int.bit_count` or ``popcount`` in C++.

      .. rubric:: Examples

      >>> np.uint32(127).bit_count()
      7



.. py:class:: uint64

   Bases: :py:obj:`numpy.unsignedinteger`


   Unsigned signed integer type, 64bit on 64bit systems and 32bit on 32bit systems.

   :Character code: ``'L'``
   :Canonical name: `numpy.uint`
   :Alias on this platform (Linux x86_64): `numpy.uint64`: 64-bit unsigned integer (``0`` to ``18_446_744_073_709_551_615``).
   :Alias on this platform (Linux x86_64): `numpy.uintp`: Unsigned integer large enough to fit pointer, compatible with C ``uintptr_t``.


   .. py:method:: bit_count(/)

      uint64.bit_count() -> int

      Computes the number of 1-bits in the absolute value of the input.
      Analogous to the builtin `int.bit_count` or ``popcount`` in C++.

      .. rubric:: Examples

      >>> np.uint64(127).bit_count()
      7



.. py:class:: uint8

   Bases: :py:obj:`numpy.unsignedinteger`


   Unsigned integer type, compatible with C ``unsigned char``.

   :Character code: ``'B'``
   :Canonical name: `numpy.ubyte`
   :Alias on this platform (Linux x86_64): `numpy.uint8`: 8-bit unsigned integer (``0`` to ``255``).


   .. py:method:: bit_count(/)

      uint8.bit_count() -> int

      Computes the number of 1-bits in the absolute value of the input.
      Analogous to the builtin `int.bit_count` or ``popcount`` in C++.

      .. rubric:: Examples

      >>> np.uint8(127).bit_count()
      7



