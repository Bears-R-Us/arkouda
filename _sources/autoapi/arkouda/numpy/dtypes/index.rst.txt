arkouda.numpy.dtypes
====================

.. py:module:: arkouda.numpy.dtypes


Attributes
----------

.. autoapisummary::

   arkouda.numpy.dtypes.TYPE_CHECKING


Classes
-------

.. autoapisummary::

   arkouda.numpy.dtypes.ARKOUDA_SUPPORTED_BOOLS
   arkouda.numpy.dtypes.ARKOUDA_SUPPORTED_DTYPES
   arkouda.numpy.dtypes.ARKOUDA_SUPPORTED_FLOATS
   arkouda.numpy.dtypes.ARKOUDA_SUPPORTED_INTS
   arkouda.numpy.dtypes.ARKOUDA_SUPPORTED_NUMBERS
   arkouda.numpy.dtypes.BoolDType
   arkouda.numpy.dtypes.ByteDType
   arkouda.numpy.dtypes.BytesDType
   arkouda.numpy.dtypes.CLongDoubleDType
   arkouda.numpy.dtypes.Complex128DType
   arkouda.numpy.dtypes.Complex64DType
   arkouda.numpy.dtypes.DType
   arkouda.numpy.dtypes.DTypeObjects
   arkouda.numpy.dtypes.DTypes
   arkouda.numpy.dtypes.DateTime64DType
   arkouda.numpy.dtypes.Enum
   arkouda.numpy.dtypes.Float16DType
   arkouda.numpy.dtypes.Float32DType
   arkouda.numpy.dtypes.Float64DType
   arkouda.numpy.dtypes.Int16DType
   arkouda.numpy.dtypes.Int32DType
   arkouda.numpy.dtypes.Int64DType
   arkouda.numpy.dtypes.Int8DType
   arkouda.numpy.dtypes.IntDType
   arkouda.numpy.dtypes.List
   arkouda.numpy.dtypes.LongDType
   arkouda.numpy.dtypes.LongDoubleDType
   arkouda.numpy.dtypes.LongLongDType
   arkouda.numpy.dtypes.NUMBER_FORMAT_STRINGS
   arkouda.numpy.dtypes.NumericDTypes
   arkouda.numpy.dtypes.ObjectDType
   arkouda.numpy.dtypes.ScalarDTypes
   arkouda.numpy.dtypes.SeriesDTypes
   arkouda.numpy.dtypes.ShortDType
   arkouda.numpy.dtypes.StrDType
   arkouda.numpy.dtypes.TimeDelta64DType
   arkouda.numpy.dtypes.UByteDType
   arkouda.numpy.dtypes.UInt16DType
   arkouda.numpy.dtypes.UInt32DType
   arkouda.numpy.dtypes.UInt64DType
   arkouda.numpy.dtypes.UInt8DType
   arkouda.numpy.dtypes.UIntDType
   arkouda.numpy.dtypes.ULongDType
   arkouda.numpy.dtypes.ULongLongDType
   arkouda.numpy.dtypes.UShortDType
   arkouda.numpy.dtypes.Union
   arkouda.numpy.dtypes.VoidDType
   arkouda.numpy.dtypes.all_scalars
   arkouda.numpy.dtypes.annotations
   arkouda.numpy.dtypes.bigint
   arkouda.numpy.dtypes.bitType
   arkouda.numpy.dtypes.bool_
   arkouda.numpy.dtypes.bool_scalars
   arkouda.numpy.dtypes.complex128
   arkouda.numpy.dtypes.complex64
   arkouda.numpy.dtypes.float16
   arkouda.numpy.dtypes.float32
   arkouda.numpy.dtypes.float64
   arkouda.numpy.dtypes.float_scalars
   arkouda.numpy.dtypes.int16
   arkouda.numpy.dtypes.int32
   arkouda.numpy.dtypes.int64
   arkouda.numpy.dtypes.int8
   arkouda.numpy.dtypes.intTypes
   arkouda.numpy.dtypes.int_scalars
   arkouda.numpy.dtypes.numeric_and_bool_scalars
   arkouda.numpy.dtypes.numeric_scalars
   arkouda.numpy.dtypes.numpy_scalars
   arkouda.numpy.dtypes.str_
   arkouda.numpy.dtypes.str_scalars
   arkouda.numpy.dtypes.uint16
   arkouda.numpy.dtypes.uint32
   arkouda.numpy.dtypes.uint64
   arkouda.numpy.dtypes.uint8


Functions
---------

.. autoapisummary::

   arkouda.numpy.dtypes.can_cast
   arkouda.numpy.dtypes.cast
   arkouda.numpy.dtypes.dtype
   arkouda.numpy.dtypes.get_byteorder
   arkouda.numpy.dtypes.get_server_byteorder
   arkouda.numpy.dtypes.isSupportedBool
   arkouda.numpy.dtypes.isSupportedDType
   arkouda.numpy.dtypes.isSupportedFloat
   arkouda.numpy.dtypes.isSupportedInt
   arkouda.numpy.dtypes.isSupportedNumber
   arkouda.numpy.dtypes.resolve_scalar_dtype
   arkouda.numpy.dtypes.result_type


Module Contents
---------------

.. py:class:: ARKOUDA_SUPPORTED_BOOLS

   Built-in immutable sequence.

   If no argument is given, the constructor returns an empty tuple.
   If iterable is specified the tuple is initialized from iterable's items.

   If the argument is a tuple, the return value is the same object.


   .. py:method:: count(value, /)

      Return number of occurrences of value.



   .. py:method:: index(value, start=0, stop=9223372036854775807, /)

      Return first index of value.

      Raises ValueError if the value is not present.



.. py:class:: ARKOUDA_SUPPORTED_DTYPES

   Built-in immutable sequence.

   If no argument is given, the constructor returns an empty tuple.
   If iterable is specified the tuple is initialized from iterable's items.

   If the argument is a tuple, the return value is the same object.


   .. py:method:: count(value, /)

      Return number of occurrences of value.



   .. py:method:: index(value, start=0, stop=9223372036854775807, /)

      Return first index of value.

      Raises ValueError if the value is not present.



.. py:class:: ARKOUDA_SUPPORTED_FLOATS

   Built-in immutable sequence.

   If no argument is given, the constructor returns an empty tuple.
   If iterable is specified the tuple is initialized from iterable's items.

   If the argument is a tuple, the return value is the same object.


   .. py:method:: count(value, /)

      Return number of occurrences of value.



   .. py:method:: index(value, start=0, stop=9223372036854775807, /)

      Return first index of value.

      Raises ValueError if the value is not present.



.. py:class:: ARKOUDA_SUPPORTED_INTS

   Built-in immutable sequence.

   If no argument is given, the constructor returns an empty tuple.
   If iterable is specified the tuple is initialized from iterable's items.

   If the argument is a tuple, the return value is the same object.


   .. py:method:: count(value, /)

      Return number of occurrences of value.



   .. py:method:: index(value, start=0, stop=9223372036854775807, /)

      Return first index of value.

      Raises ValueError if the value is not present.



.. py:class:: ARKOUDA_SUPPORTED_NUMBERS

   Built-in immutable sequence.

   If no argument is given, the constructor returns an empty tuple.
   If iterable is specified the tuple is initialized from iterable's items.

   If the argument is a tuple, the return value is the same object.


   .. py:method:: count(value, /)

      Return number of occurrences of value.



   .. py:method:: index(value, start=0, stop=9223372036854775807, /)

      Return first index of value.

      Raises ValueError if the value is not present.



.. py:class:: BoolDType

   Bases: :py:obj:`numpy.dtype`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.


.. py:class:: ByteDType

   Bases: :py:obj:`numpy.dtypes._IntegerAbstractDType`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.


.. py:class:: BytesDType

   Bases: :py:obj:`numpy.dtype`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.


.. py:class:: CLongDoubleDType

   Bases: :py:obj:`numpy.dtypes._ComplexAbstractDType`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.


.. py:class:: Complex128DType

   Bases: :py:obj:`numpy.dtypes._ComplexAbstractDType`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.


.. py:class:: Complex64DType

   Bases: :py:obj:`numpy.dtypes._ComplexAbstractDType`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.


.. py:class:: DType

   .. py:method:: BIGINT(*args, **kwargs)


   .. py:method:: BOOL(*args, **kwargs)


   .. py:method:: COMPLEX128(*args, **kwargs)


   .. py:method:: COMPLEX64(*args, **kwargs)


   .. py:method:: FLOAT(*args, **kwargs)


   .. py:method:: FLOAT32(*args, **kwargs)


   .. py:method:: FLOAT64(*args, **kwargs)


   .. py:method:: INT(*args, **kwargs)


   .. py:method:: INT16(*args, **kwargs)


   .. py:method:: INT32(*args, **kwargs)


   .. py:method:: INT64(*args, **kwargs)


   .. py:method:: INT8(*args, **kwargs)


   .. py:method:: STR(*args, **kwargs)


   .. py:method:: UINT(*args, **kwargs)


   .. py:method:: UINT16(*args, **kwargs)


   .. py:method:: UINT32(*args, **kwargs)


   .. py:method:: UINT64(*args, **kwargs)


   .. py:method:: UINT8(*args, **kwargs)


   .. py:method:: name(*args, **kwargs)

      The name of the Enum member.



   .. py:method:: value(*args, **kwargs)

      The value of the Enum member.



.. py:class:: DTypeObjects

   Build an immutable unordered collection of unique elements.


   .. py:method:: copy()

      Return a shallow copy of a set.



   .. py:method:: difference(*others)

      Return a new set with elements in the set that are not in the others.



   .. py:method:: intersection(*others)

      Return a new set with elements common to the set and all others.



   .. py:method:: isdisjoint(other, /)

      Return True if two sets have a null intersection.



   .. py:method:: issubset(other, /)

      Report whether another set contains this set.



   .. py:method:: issuperset(other, /)

      Report whether this set contains another set.



   .. py:method:: symmetric_difference(other, /)

      Return a new set with elements in either the set or other but not both.



   .. py:method:: union(*others)

      Return a new set with elements from the set and all others.



.. py:class:: DTypes

   Build an immutable unordered collection of unique elements.


   .. py:method:: copy()

      Return a shallow copy of a set.



   .. py:method:: difference(*others)

      Return a new set with elements in the set that are not in the others.



   .. py:method:: intersection(*others)

      Return a new set with elements common to the set and all others.



   .. py:method:: isdisjoint(other, /)

      Return True if two sets have a null intersection.



   .. py:method:: issubset(other, /)

      Report whether another set contains this set.



   .. py:method:: issuperset(other, /)

      Report whether this set contains another set.



   .. py:method:: symmetric_difference(other, /)

      Return a new set with elements in either the set or other but not both.



   .. py:method:: union(*others)

      Return a new set with elements from the set and all others.



.. py:class:: DateTime64DType

   Bases: :py:obj:`numpy.dtype`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.


.. py:class:: Enum

   Create a collection of name/value pairs.

   Example enumeration:

   >>> class Color(Enum):
   ...     RED = 1
   ...     BLUE = 2
   ...     GREEN = 3

   Access them by:

   - attribute access:

     >>> Color.RED
     <Color.RED: 1>

   - value lookup:

     >>> Color(1)
     <Color.RED: 1>

   - name lookup:

     >>> Color['RED']
     <Color.RED: 1>

   Enumerations can be iterated over, and know how many members they have:

   >>> len(Color)
   3

   >>> list(Color)
   [<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]

   Methods can be added to enumerations, and members can have their own
   attributes -- see the documentation for details.



.. py:class:: Float16DType

   Bases: :py:obj:`numpy.dtypes._FloatAbstractDType`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.


.. py:class:: Float32DType

   Bases: :py:obj:`numpy.dtypes._FloatAbstractDType`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.


.. py:class:: Float64DType

   Bases: :py:obj:`numpy.dtypes._FloatAbstractDType`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.


.. py:class:: Int16DType

   Bases: :py:obj:`numpy.dtypes._IntegerAbstractDType`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.


.. py:class:: Int32DType

   Bases: :py:obj:`numpy.dtypes._IntegerAbstractDType`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.


.. py:class:: Int64DType

   Bases: :py:obj:`numpy.dtypes._IntegerAbstractDType`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.


.. py:class:: Int8DType

   Bases: :py:obj:`numpy.dtypes._IntegerAbstractDType`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.


.. py:class:: IntDType

   Bases: :py:obj:`numpy.dtypes._IntegerAbstractDType`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.


.. py:class:: List

   Bases: :py:obj:`_NotIterable`


   A generic version of list.


   .. py:method:: append(object, /)

      Append object to the end of the list.



   .. py:method:: clear(/)

      Remove all items from list.



   .. py:method:: copy(/)

      Return a shallow copy of the list.



   .. py:method:: copy_with(params)


   .. py:method:: count(value, /)

      Return number of occurrences of value.



   .. py:method:: extend(iterable, /)

      Extend list by appending elements from the iterable.



   .. py:method:: index(value, start=0, stop=9223372036854775807, /)

      Return first index of value.

      Raises ValueError if the value is not present.



   .. py:method:: insert(index, object, /)

      Insert object before index.



   .. py:method:: pop(index=-1, /)

      Remove and return item at index (default last).

      Raises IndexError if list is empty or index is out of range.



   .. py:method:: remove(value, /)

      Remove first occurrence of value.

      Raises ValueError if the value is not present.



   .. py:method:: reverse(/)

      Reverse *IN PLACE*.



   .. py:method:: sort(/, *, key=None, reverse=False)

      Sort the list in ascending order and return None.

      The sort is in-place (i.e. the list itself is modified) and stable (i.e. the
      order of two equal elements is maintained).

      If a key function is given, apply it once to each list item and sort them,
      ascending or descending, according to their function values.

      The reverse flag can be set to sort in descending order.



.. py:class:: LongDType

   Bases: :py:obj:`numpy.dtypes._IntegerAbstractDType`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.


.. py:class:: LongDoubleDType

   Bases: :py:obj:`numpy.dtypes._FloatAbstractDType`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.


.. py:class:: LongLongDType

   Bases: :py:obj:`numpy.dtypes._IntegerAbstractDType`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.


.. py:class:: NUMBER_FORMAT_STRINGS

   dict() -> new empty dictionary
   dict(mapping) -> new dictionary initialized from a mapping object's
       (key, value) pairs
   dict(iterable) -> new dictionary initialized as if via:
       d = {}
       for k, v in iterable:
           d[k] = v
   dict(**kwargs) -> new dictionary initialized with the name=value pairs
       in the keyword argument list.  For example:  dict(one=1, two=2)


   .. py:method:: clear()

      Remove all items from the dict.



   .. py:method:: copy()

      Return a shallow copy of the dict.



   .. py:method:: fromkeys(iterable, value=None, /)

      Create a new dictionary with keys from iterable and values set to value.



   .. py:method:: get(key, default=None, /)

      Return the value for key if key is in the dictionary, else default.



   .. py:method:: items()

      Return a set-like object providing a view on the dict's items.



   .. py:method:: keys()

      Return a set-like object providing a view on the dict's keys.



   .. py:method:: pop(*args, **kwargs)

      D.pop(k[,d]) -> v, remove specified key and return the corresponding value.

      If the key is not found, return the default if given; otherwise,
      raise a KeyError.



   .. py:method:: popitem()

      Remove and return a (key, value) pair as a 2-tuple.

      Pairs are returned in LIFO (last-in, first-out) order.
      Raises KeyError if the dict is empty.



   .. py:method:: setdefault(key, default=None, /)

      Insert key with a value of default if key is not in the dictionary.

      Return the value for key if key is in the dictionary, else default.



   .. py:method:: update(*args, **kwargs)

      D.update([E, ]**F) -> None.  Update D from mapping/iterable E and F.
      If E is present and has a .keys() method, then does:  for k in E.keys(): D[k] = E[k]
      If E is present and lacks a .keys() method, then does:  for k, v in E: D[k] = v
      In either case, this is followed by: for k in F:  D[k] = F[k]



   .. py:method:: values()

      Return an object providing a view on the dict's values.



.. py:class:: NumericDTypes

   Build an immutable unordered collection of unique elements.


   .. py:method:: copy()

      Return a shallow copy of a set.



   .. py:method:: difference(*others)

      Return a new set with elements in the set that are not in the others.



   .. py:method:: intersection(*others)

      Return a new set with elements common to the set and all others.



   .. py:method:: isdisjoint(other, /)

      Return True if two sets have a null intersection.



   .. py:method:: issubset(other, /)

      Report whether another set contains this set.



   .. py:method:: issuperset(other, /)

      Report whether this set contains another set.



   .. py:method:: symmetric_difference(other, /)

      Return a new set with elements in either the set or other but not both.



   .. py:method:: union(*others)

      Return a new set with elements from the set and all others.



.. py:class:: ObjectDType

   Bases: :py:obj:`numpy.dtype`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.


.. py:class:: ScalarDTypes

   Build an immutable unordered collection of unique elements.


   .. py:method:: copy()

      Return a shallow copy of a set.



   .. py:method:: difference(*others)

      Return a new set with elements in the set that are not in the others.



   .. py:method:: intersection(*others)

      Return a new set with elements common to the set and all others.



   .. py:method:: isdisjoint(other, /)

      Return True if two sets have a null intersection.



   .. py:method:: issubset(other, /)

      Report whether another set contains this set.



   .. py:method:: issuperset(other, /)

      Report whether this set contains another set.



   .. py:method:: symmetric_difference(other, /)

      Return a new set with elements in either the set or other but not both.



   .. py:method:: union(*others)

      Return a new set with elements from the set and all others.



.. py:class:: SeriesDTypes

   dict() -> new empty dictionary
   dict(mapping) -> new dictionary initialized from a mapping object's
       (key, value) pairs
   dict(iterable) -> new dictionary initialized as if via:
       d = {}
       for k, v in iterable:
           d[k] = v
   dict(**kwargs) -> new dictionary initialized with the name=value pairs
       in the keyword argument list.  For example:  dict(one=1, two=2)


   .. py:method:: clear()

      Remove all items from the dict.



   .. py:method:: copy()

      Return a shallow copy of the dict.



   .. py:method:: fromkeys(iterable, value=None, /)

      Create a new dictionary with keys from iterable and values set to value.



   .. py:method:: get(key, default=None, /)

      Return the value for key if key is in the dictionary, else default.



   .. py:method:: items()

      Return a set-like object providing a view on the dict's items.



   .. py:method:: keys()

      Return a set-like object providing a view on the dict's keys.



   .. py:method:: pop(*args, **kwargs)

      D.pop(k[,d]) -> v, remove specified key and return the corresponding value.

      If the key is not found, return the default if given; otherwise,
      raise a KeyError.



   .. py:method:: popitem()

      Remove and return a (key, value) pair as a 2-tuple.

      Pairs are returned in LIFO (last-in, first-out) order.
      Raises KeyError if the dict is empty.



   .. py:method:: setdefault(key, default=None, /)

      Insert key with a value of default if key is not in the dictionary.

      Return the value for key if key is in the dictionary, else default.



   .. py:method:: update(*args, **kwargs)

      D.update([E, ]**F) -> None.  Update D from mapping/iterable E and F.
      If E is present and has a .keys() method, then does:  for k in E.keys(): D[k] = E[k]
      If E is present and lacks a .keys() method, then does:  for k, v in E: D[k] = v
      In either case, this is followed by: for k in F:  D[k] = F[k]



   .. py:method:: values()

      Return an object providing a view on the dict's values.



.. py:class:: ShortDType

   Bases: :py:obj:`numpy.dtypes._IntegerAbstractDType`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.


.. py:class:: StrDType

   Bases: :py:obj:`numpy.dtype`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.


.. py:data:: TYPE_CHECKING
   :type:  int

.. py:class:: TimeDelta64DType

   Bases: :py:obj:`numpy.dtype`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.


.. py:class:: UByteDType

   Bases: :py:obj:`numpy.dtypes._IntegerAbstractDType`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.


.. py:class:: UInt16DType

   Bases: :py:obj:`numpy.dtypes._IntegerAbstractDType`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.


.. py:class:: UInt32DType

   Bases: :py:obj:`numpy.dtypes._IntegerAbstractDType`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.


.. py:class:: UInt64DType

   Bases: :py:obj:`numpy.dtypes._IntegerAbstractDType`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.


.. py:class:: UInt8DType

   Bases: :py:obj:`numpy.dtypes._IntegerAbstractDType`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.


.. py:class:: UIntDType

   Bases: :py:obj:`numpy.dtypes._IntegerAbstractDType`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.


.. py:class:: ULongDType

   Bases: :py:obj:`numpy.dtypes._IntegerAbstractDType`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.


.. py:class:: ULongLongDType

   Bases: :py:obj:`numpy.dtypes._IntegerAbstractDType`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.


.. py:class:: UShortDType

   Bases: :py:obj:`numpy.dtypes._IntegerAbstractDType`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.


.. py:class:: Union

   Bases: :py:obj:`_Final`


   Union type; Union[X, Y] means either X or Y.

   On Python 3.10 and higher, the | operator
   can also be used to denote unions;
   X | Y means the same thing to the type checker as Union[X, Y].

   To define a union, use e.g. Union[int, str]. Details:
   - The arguments must be types and there must be at least one.
   - None as an argument is a special case and is replaced by
     type(None).
   - Unions of unions are flattened, e.g.::

       assert Union[Union[int, str], float] == Union[int, str, float]

   - Unions of a single argument vanish, e.g.::

       assert Union[int] == int  # The constructor actually returns int

   - Redundant arguments are skipped, e.g.::

       assert Union[int, str, int] == Union[int, str]

   - When comparing unions, the argument order is ignored, e.g.::

       assert Union[int, str] == Union[str, int]

   - You cannot subclass or instantiate a union.
   - You can use Optional[X] as a shorthand for Union[X, None].



.. py:class:: VoidDType

   Bases: :py:obj:`numpy.dtype`


   DType class corresponding to the scalar type and dtype of the same name.

   Please see `numpy.dtype` for the typical way to create
   dtype instances and :ref:`arrays.dtypes` for additional
   information.


.. py:class:: all_scalars

   Bases: :py:obj:`_NotIterable`


   Mixin to prevent iteration, without being compatible with Iterable.

   That is, we could do::

       def __iter__(self): raise TypeError()

   But this would make users of this mixin duck type-compatible with
   collections.abc.Iterable - isinstance(foo, Iterable) would be True.

   Luckily, we can instead prevent iteration by setting __iter__ to None, which
   is treated specially.


   .. py:method:: copy_with(params)


.. py:class:: annotations

   .. py:method:: compiler_flag(*args, **kwargs)

      int([x]) -> integer
      int(x, base=10) -> integer

      Convert a number or string to an integer, or return 0 if no arguments
      are given.  If x is a number, return x.__int__().  For floating-point
      numbers, this truncates towards zero.

      If x is not a number or if base is given, then x must be a string,
      bytes, or bytearray instance representing an integer literal in the
      given base.  The literal can be preceded by '+' or '-' and be surrounded
      by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
      Base 0 means to interpret the base from the string as an integer literal.
      >>> int('0b100', base=0)
      4



   .. py:method:: getMandatoryRelease()

      Return release in which this feature will become mandatory.

      This is a 5-tuple, of the same form as sys.version_info, or, if
      the feature was dropped, or the release date is undetermined, is None.




   .. py:method:: getOptionalRelease()

      Return first release in which this feature was recognized.

      This is a 5-tuple, of the same form as sys.version_info.




   .. py:method:: mandatory(*args, **kwargs)

      The type of the None singleton.



   .. py:method:: optional(*args, **kwargs)

      Built-in immutable sequence.

      If no argument is given, the constructor returns an empty tuple.
      If iterable is specified the tuple is initialized from iterable's items.

      If the argument is a tuple, the return value is the same object.



.. py:class:: bigint

   Datatype for representing integers of variable size.

   May be used for integers that exceed 64 bits.



   .. py:method:: itemsize(*args, **kwargs)

      int([x]) -> integer
      int(x, base=10) -> integer

      Convert a number or string to an integer, or return 0 if no arguments
      are given.  If x is a number, return x.__int__().  For floating-point
      numbers, this truncates towards zero.

      If x is not a number or if base is given, then x must be a string,
      bytes, or bytearray instance representing an integer literal in the
      given base.  The literal can be preceded by '+' or '-' and be surrounded
      by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
      Base 0 means to interpret the base from the string as an integer literal.
      >>> int('0b100', base=0)
      4



   .. py:method:: name(*args, **kwargs)

      str(object='') -> str
      str(bytes_or_buffer[, encoding[, errors]]) -> str

      Create a new string object from the given object. If encoding or
      errors is specified, then the object must expose a data buffer
      that will be decoded using the given encoding and error handler.
      Otherwise, returns the result of object.__str__() (if defined)
      or repr(object).
      encoding defaults to 'utf-8'.
      errors defaults to 'strict'.



   .. py:method:: ndim(*args, **kwargs)

      int([x]) -> integer
      int(x, base=10) -> integer

      Convert a number or string to an integer, or return 0 if no arguments
      are given.  If x is a number, return x.__int__().  For floating-point
      numbers, this truncates towards zero.

      If x is not a number or if base is given, then x must be a string,
      bytes, or bytearray instance representing an integer literal in the
      given base.  The literal can be preceded by '+' or '-' and be surrounded
      by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
      Base 0 means to interpret the base from the string as an integer literal.
      >>> int('0b100', base=0)
      4



   .. py:method:: shape(*args, **kwargs)

      Built-in immutable sequence.

      If no argument is given, the constructor returns an empty tuple.
      If iterable is specified the tuple is initialized from iterable's items.

      If the argument is a tuple, the return value is the same object.



   .. py:method:: type(x)


.. py:class:: bitType

   Bases: :py:obj:`numpy.unsignedinteger`


   Unsigned signed integer type, 64bit on 64bit systems and 32bit on 32bit
       systems.

       :Character code: ``'L'``
       :Canonical name: `numpy.uint`
       :Alias on this platform (Linux x86_64): `numpy.uint64`: 64-bit unsigned integer (``0`` to ``18_446_744_073_709_551_615``).
       :Alias on this platform (Linux x86_64): `numpy.uintp`: Unsigned integer large enough to fit pointer, compatible with C ``uintptr_t``.


   .. py:method:: bit_count(/)

      uint64.bit_count() -> int

              Computes the number of 1-bits in the absolute value of the input.
              Analogous to the builtin `int.bit_count` or ``popcount`` in C++.

              Examples
              --------
              >>> np.uint64(127).bit_count()
              7



.. py:class:: bool_

   Bases: :py:obj:`numpy.generic`


   Boolean type (True or False), stored as a byte.

       .. warning::

          The :class:`bool` type is not a subclass of the :class:`int_` type
          (the :class:`bool` is not even a number type). This is different
          than Python's default implementation of :class:`bool` as a
          sub-class of :class:`int`.

       :Character code: ``'?'``


.. py:class:: bool_scalars

   Bases: :py:obj:`_NotIterable`


   Mixin to prevent iteration, without being compatible with Iterable.

   That is, we could do::

       def __iter__(self): raise TypeError()

   But this would make users of this mixin duck type-compatible with
   collections.abc.Iterable - isinstance(foo, Iterable) would be True.

   Luckily, we can instead prevent iteration by setting __iter__ to None, which
   is treated specially.


   .. py:method:: copy_with(params)


.. py:function:: can_cast(from_, to) -> bool

   Returns True if cast between data types can occur according to the casting rule.

   :param from_: Data type, NumPy scalar, or array to cast from.
   :type from_: dtype, dtype specifier, NumPy scalar, or pdarray
   :param to: Data type to cast to.
   :type to: dtype or dtype specifier

   :returns: True if cast can occur according to the casting rule.
   :rtype: bool


.. py:function:: cast(typ, val)

   Cast a value to a type.

   This returns the value unchanged.  To the type checker this
   signals that the return value has the designated type, but at
   runtime we intentionally don't check anything (we want this
   to be as fast as possible).



.. py:class:: complex128

   Bases: :py:obj:`numpy.complexfloating`


   Complex number type composed of two double-precision floating-point
       numbers, compatible with Python :class:`complex`.

       :Character code: ``'D'``
       :Canonical name: `numpy.cdouble`
       :Alias on this platform (Linux x86_64): `numpy.complex128`: Complex number type composed of 2 64-bit-precision floating-point numbers.


.. py:class:: complex64

   Bases: :py:obj:`numpy.complexfloating`


   Complex number type composed of two single-precision floating-point
       numbers.

       :Character code: ``'F'``
       :Canonical name: `numpy.csingle`
       :Alias on this platform (Linux x86_64): `numpy.complex64`: Complex number type composed of 2 32-bit-precision floating-point numbers.


.. py:function:: dtype(dtype)

   Create a data type object.

   :param dtype: Object to be converted to a data type object.
   :type dtype: object

   :rtype: type


.. py:class:: float16

   Bases: :py:obj:`numpy.floating`


   Half-precision floating-point number type.

       :Character code: ``'e'``
       :Canonical name: `numpy.half`
       :Alias on this platform (Linux x86_64): `numpy.float16`: 16-bit-precision floating-point number type: sign bit, 5 bits exponent, 10 bits mantissa.


   .. py:method:: as_integer_ratio(/)

      half.as_integer_ratio() -> (int, int)

              Return a pair of integers, whose ratio is exactly equal to the original
              floating point number, and with a positive denominator.
              Raise `OverflowError` on infinities and a `ValueError` on NaNs.

              >>> np.half(10.0).as_integer_ratio()
              (10, 1)
              >>> np.half(0.0).as_integer_ratio()
              (0, 1)
              >>> np.half(-.25).as_integer_ratio()
              (-1, 4)



   .. py:method:: is_integer(/)

      half.is_integer() -> bool

              Return ``True`` if the floating point number is finite with integral
              value, and ``False`` otherwise.

              .. versionadded:: 1.22

              Examples
              --------
              >>> np.half(-2.0).is_integer()
              True
              >>> np.half(3.2).is_integer()
              False



.. py:class:: float32

   Bases: :py:obj:`numpy.floating`


   Single-precision floating-point number type, compatible with C ``float``.

       :Character code: ``'f'``
       :Canonical name: `numpy.single`
       :Alias on this platform (Linux x86_64): `numpy.float32`: 32-bit-precision floating-point number type: sign bit, 8 bits exponent, 23 bits mantissa.


   .. py:method:: as_integer_ratio(/)

      single.as_integer_ratio() -> (int, int)

              Return a pair of integers, whose ratio is exactly equal to the original
              floating point number, and with a positive denominator.
              Raise `OverflowError` on infinities and a `ValueError` on NaNs.

              >>> np.single(10.0).as_integer_ratio()
              (10, 1)
              >>> np.single(0.0).as_integer_ratio()
              (0, 1)
              >>> np.single(-.25).as_integer_ratio()
              (-1, 4)



   .. py:method:: is_integer(/)

      single.is_integer() -> bool

              Return ``True`` if the floating point number is finite with integral
              value, and ``False`` otherwise.

              .. versionadded:: 1.22

              Examples
              --------
              >>> np.single(-2.0).is_integer()
              True
              >>> np.single(3.2).is_integer()
              False



.. py:class:: float64

   Bases: :py:obj:`numpy.floating`


   Double-precision floating-point number type, compatible with Python
       :class:`float` and C ``double``.

       :Character code: ``'d'``
       :Canonical name: `numpy.double`
       :Alias on this platform (Linux x86_64): `numpy.float64`: 64-bit precision floating-point number type: sign bit, 11 bits exponent, 52 bits mantissa.


   .. py:method:: as_integer_ratio(/)

      double.as_integer_ratio() -> (int, int)

              Return a pair of integers, whose ratio is exactly equal to the original
              floating point number, and with a positive denominator.
              Raise `OverflowError` on infinities and a `ValueError` on NaNs.

              >>> np.double(10.0).as_integer_ratio()
              (10, 1)
              >>> np.double(0.0).as_integer_ratio()
              (0, 1)
              >>> np.double(-.25).as_integer_ratio()
              (-1, 4)



   .. py:method:: fromhex(string, /)

      Create a floating-point number from a hexadecimal string.

      >>> float.fromhex('0x1.ffffp10')
      2047.984375
      >>> float.fromhex('-0x1p-1074')
      -5e-324



   .. py:method:: hex(/)

      Return a hexadecimal representation of a floating-point number.

      >>> (-0.1).hex()
      '-0x1.999999999999ap-4'
      >>> 3.14159.hex()
      '0x1.921f9f01b866ep+1'



   .. py:method:: is_integer(/)

      double.is_integer() -> bool

              Return ``True`` if the floating point number is finite with integral
              value, and ``False`` otherwise.

              .. versionadded:: 1.22

              Examples
              --------
              >>> np.double(-2.0).is_integer()
              True
              >>> np.double(3.2).is_integer()
              False



.. py:class:: float_scalars

   Bases: :py:obj:`_NotIterable`


   Mixin to prevent iteration, without being compatible with Iterable.

   That is, we could do::

       def __iter__(self): raise TypeError()

   But this would make users of this mixin duck type-compatible with
   collections.abc.Iterable - isinstance(foo, Iterable) would be True.

   Luckily, we can instead prevent iteration by setting __iter__ to None, which
   is treated specially.


   .. py:method:: copy_with(params)


.. py:function:: get_byteorder(dt: np.dtype) -> str

   Get a concrete byteorder (turns '=' into '<' or '>') on the client.

   :param dt: The numpy dtype to determine the byteorder of.
   :type dt: np.dtype

   :returns: Returns "<" for little endian and ">" for big endian.
   :rtype: str

   :raises ValueError: Returned if sys.byteorder is not "little" or "big"

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.get_byteorder(ak.dtype(ak.int64))
   '<'


.. py:function:: get_server_byteorder() -> str

   Get the server's byteorder

   :returns: Returns "little" for little endian and "big" for big endian.
   :rtype: str

   :raises ValueError: Raised if Server byteorder is not 'little' or 'big'

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.get_server_byteorder()
   'little'


.. py:class:: int16

   Bases: :py:obj:`numpy.signedinteger`


   Signed integer type, compatible with C ``short``.

       :Character code: ``'h'``
       :Canonical name: `numpy.short`
       :Alias on this platform (Linux x86_64): `numpy.int16`: 16-bit signed integer (``-32_768`` to ``32_767``).


   .. py:method:: bit_count(/)

      int16.bit_count() -> int

              Computes the number of 1-bits in the absolute value of the input.
              Analogous to the builtin `int.bit_count` or ``popcount`` in C++.

              Examples
              --------
              >>> np.int16(127).bit_count()
              7
              >>> np.int16(-127).bit_count()
              7



.. py:class:: int32

   Bases: :py:obj:`numpy.signedinteger`


   Signed integer type, compatible with C ``int``.

       :Character code: ``'i'``
       :Canonical name: `numpy.intc`
       :Alias on this platform (Linux x86_64): `numpy.int32`: 32-bit signed integer (``-2_147_483_648`` to ``2_147_483_647``).


   .. py:method:: bit_count(/)

      int32.bit_count() -> int

              Computes the number of 1-bits in the absolute value of the input.
              Analogous to the builtin `int.bit_count` or ``popcount`` in C++.

              Examples
              --------
              >>> np.int32(127).bit_count()
              7
              >>> np.int32(-127).bit_count()
              7



.. py:class:: int64

   Bases: :py:obj:`numpy.signedinteger`


   Default signed integer type, 64bit on 64bit systems and 32bit on 32bit
       systems.

       :Character code: ``'l'``
       :Canonical name: `numpy.int_`
       :Alias on this platform (Linux x86_64): `numpy.int64`: 64-bit signed integer (``-9_223_372_036_854_775_808`` to ``9_223_372_036_854_775_807``).
       :Alias on this platform (Linux x86_64): `numpy.intp`: Signed integer large enough to fit pointer, compatible with C ``intptr_t``.


   .. py:method:: bit_count(/)

      int64.bit_count() -> int

              Computes the number of 1-bits in the absolute value of the input.
              Analogous to the builtin `int.bit_count` or ``popcount`` in C++.

              Examples
              --------
              >>> np.int64(127).bit_count()
              7
              >>> np.int64(-127).bit_count()
              7



.. py:class:: int8

   Bases: :py:obj:`numpy.signedinteger`


   Signed integer type, compatible with C ``char``.

       :Character code: ``'b'``
       :Canonical name: `numpy.byte`
       :Alias on this platform (Linux x86_64): `numpy.int8`: 8-bit signed integer (``-128`` to ``127``).


   .. py:method:: bit_count(/)

      int8.bit_count() -> int

              Computes the number of 1-bits in the absolute value of the input.
              Analogous to the builtin `int.bit_count` or ``popcount`` in C++.

              Examples
              --------
              >>> np.int8(127).bit_count()
              7
              >>> np.int8(-127).bit_count()
              7



.. py:class:: intTypes

   Build an immutable unordered collection of unique elements.


   .. py:method:: copy()

      Return a shallow copy of a set.



   .. py:method:: difference(*others)

      Return a new set with elements in the set that are not in the others.



   .. py:method:: intersection(*others)

      Return a new set with elements common to the set and all others.



   .. py:method:: isdisjoint(other, /)

      Return True if two sets have a null intersection.



   .. py:method:: issubset(other, /)

      Report whether another set contains this set.



   .. py:method:: issuperset(other, /)

      Report whether this set contains another set.



   .. py:method:: symmetric_difference(other, /)

      Return a new set with elements in either the set or other but not both.



   .. py:method:: union(*others)

      Return a new set with elements from the set and all others.



.. py:class:: int_scalars

   Bases: :py:obj:`_NotIterable`


   Mixin to prevent iteration, without being compatible with Iterable.

   That is, we could do::

       def __iter__(self): raise TypeError()

   But this would make users of this mixin duck type-compatible with
   collections.abc.Iterable - isinstance(foo, Iterable) would be True.

   Luckily, we can instead prevent iteration by setting __iter__ to None, which
   is treated specially.


   .. py:method:: copy_with(params)


.. py:function:: isSupportedBool(num)

   Whether a scalar is an arkouda supported boolean dtype.

   :param num: A scalar.
   :type num: object

   :returns: True if scalar is an instance of an arkouda supported boolean dtype, else False.
   :rtype: bool

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.isSupportedBool("True")
   False
   >>> ak.isSupportedBool(True)
   True


.. py:function:: isSupportedDType(scalar: object) -> bool

   Whether a scalar is an arkouda supported dtype.

   :param scalar:
   :type scalar: object

   :returns: True if scalar is an instance of an arkouda supported dtype, else False.
   :rtype: bool

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.isSupportedDType(ak.int64(64))
   True
   >>> ak.isSupportedDType(np.complex128(1+2j))
   False


.. py:function:: isSupportedFloat(num)

   Whether a scalar is an arkouda supported float dtype.

   :param num: A scalar.
   :type num: object

   :returns: True if scalar is an instance of an arkouda supported float dtype, else False.
   :rtype: bool

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.isSupportedFloat(56)
   False
   >>> ak.isSupportedFloat(56.7)
   True


.. py:function:: isSupportedInt(num)

   Whether a scalar is an arkouda supported integer dtype.

   :param num: A scalar.
   :type num: object

   :returns: True if scalar is an instance of an arkouda supported integer dtype, else False.
   :rtype: bool

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.isSupportedInt(79)
   True
   >>> ak.isSupportedInt(54.9)
   False


.. py:function:: isSupportedNumber(num)

   Whether a scalar is an arkouda supported numeric dtype.

   :param num: A scalar.
   :type num: object

   :returns: True if scalar is an instance of an arkouda supported numeric dtype, else False.
   :rtype: bool

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.isSupportedNumber(45.9)
   True
   >>> ak.isSupportedNumber("string")
   False


.. py:class:: numeric_and_bool_scalars

   Bases: :py:obj:`_NotIterable`


   Mixin to prevent iteration, without being compatible with Iterable.

   That is, we could do::

       def __iter__(self): raise TypeError()

   But this would make users of this mixin duck type-compatible with
   collections.abc.Iterable - isinstance(foo, Iterable) would be True.

   Luckily, we can instead prevent iteration by setting __iter__ to None, which
   is treated specially.


   .. py:method:: copy_with(params)


.. py:class:: numeric_scalars

   Bases: :py:obj:`_NotIterable`


   Mixin to prevent iteration, without being compatible with Iterable.

   That is, we could do::

       def __iter__(self): raise TypeError()

   But this would make users of this mixin duck type-compatible with
   collections.abc.Iterable - isinstance(foo, Iterable) would be True.

   Luckily, we can instead prevent iteration by setting __iter__ to None, which
   is treated specially.


   .. py:method:: copy_with(params)


.. py:class:: numpy_scalars

   Bases: :py:obj:`_NotIterable`


   Mixin to prevent iteration, without being compatible with Iterable.

   That is, we could do::

       def __iter__(self): raise TypeError()

   But this would make users of this mixin duck type-compatible with
   collections.abc.Iterable - isinstance(foo, Iterable) would be True.

   Luckily, we can instead prevent iteration by setting __iter__ to None, which
   is treated specially.


   .. py:method:: copy_with(params)


.. py:function:: resolve_scalar_dtype(val: object) -> str

   Try to infer what dtype arkouda_server should treat val as.

   :param val: The object to determine the dtype of.
   :type val: object

   :returns: The dtype name, if it can be resolved, otherwise the type (as str).
   :rtype: str

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> ak.resolve_scalar_dtype(1)
   'int64'
   >>> ak.resolve_scalar_dtype(2.0)
   'float64'


.. py:function:: result_type(*args: Union[pdarray, np.dtype, type]) -> Union[np.dtype, type]

   Determine the promoted result dtype of inputs, including support for Arkouda's bigint.

   Determine the result dtype that would be returned by a NumPy-like operation
   on the provided input arguments, accounting for Arkouda's extended types
   such as ak.bigint.

   This function mimics numpy.result_type, with support for Arkouda types.

   :param \*args: One or more input objects. These can be NumPy arrays, dtypes, Python
                  scalar types, or Arkouda pdarrays.
   :type \*args: Union[pdarray, np.dtype, type]

   :returns: The dtype (or equivalent Arkouda type) that results from applying
             type promotion rules to the inputs.
   :rtype: Union[np.dtype, type]

   .. rubric:: Notes

   This function is meant to be a drop-in replacement for numpy.result_type
   but includes logic to support Arkouda's bigint type.


.. py:class:: str_

   A unicode string.

       This type strips trailing null codepoints.

       >>> s = np.str_("abc\x00")
       >>> s
       'abc'

       Unlike the builtin :class:`str`, this supports the
       :ref:`python:bufferobjects`, exposing its contents as UCS4:

       >>> m = memoryview(np.str_("abc"))
       >>> m.format
       '3w'
       >>> m.tobytes()
       b'a\x00\x00\x00b\x00\x00\x00c\x00\x00\x00'

       :Character code: ``'U'``


   .. py:method:: T(*args, **kwargs)

      Scalar attribute identical to the corresponding array attribute.

          Please see `ndarray.T`.



   .. py:method:: all(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.all`.



   .. py:method:: any(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.any`.



   .. py:method:: argmax(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.argmax`.



   .. py:method:: argmin(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.argmin`.



   .. py:method:: argsort(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.argsort`.



   .. py:method:: astype(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.astype`.



   .. py:method:: base(*args, **kwargs)

      Scalar attribute identical to the corresponding array attribute.

          Please see `ndarray.base`.



   .. py:method:: byteswap(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.byteswap`.



   .. py:method:: choose(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.choose`.



   .. py:method:: clip(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.clip`.



   .. py:method:: compress(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.compress`.



   .. py:method:: conj(*args, **kwargs)


   .. py:method:: conjugate(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.conjugate`.



   .. py:method:: copy(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.copy`.



   .. py:method:: cumprod(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.cumprod`.



   .. py:method:: cumsum(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.cumsum`.



   .. py:method:: data(*args, **kwargs)

      Pointer to start of data.



   .. py:method:: device(*args, **kwargs)


   .. py:method:: diagonal(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.diagonal`.



   .. py:method:: dtype(*args, **kwargs)

      Get array data-descriptor.



   .. py:method:: dump(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.dump`.



   .. py:method:: dumps(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.dumps`.



   .. py:method:: fill(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.fill`.



   .. py:method:: flags(*args, **kwargs)

      The integer value of flags.



   .. py:method:: flat(*args, **kwargs)

      A 1-D view of the scalar.



   .. py:method:: flatten(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.flatten`.



   .. py:method:: getfield(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.getfield`.



   .. py:method:: imag(*args, **kwargs)

      The imaginary part of the scalar.



   .. py:method:: item(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.item`.



   .. py:method:: itemset(*args, **kwargs)


   .. py:method:: itemsize(*args, **kwargs)

      The length of one element in bytes.



   .. py:method:: max(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.max`.



   .. py:method:: mean(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.mean`.



   .. py:method:: min(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.min`.



   .. py:method:: nbytes(*args, **kwargs)


   .. py:method:: ndim(*args, **kwargs)

      The number of array dimensions.



   .. py:method:: newbyteorder(*args, **kwargs)


   .. py:method:: nonzero(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.nonzero`.



   .. py:method:: prod(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.prod`.



   .. py:method:: ptp(*args, **kwargs)


   .. py:method:: put(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.put`.



   .. py:method:: ravel(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.ravel`.



   .. py:method:: real(*args, **kwargs)

      The real part of the scalar.



   .. py:method:: repeat(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.repeat`.



   .. py:method:: reshape(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.reshape`.



   .. py:method:: resize(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.resize`.



   .. py:method:: round(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.round`.



   .. py:method:: searchsorted(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.searchsorted`.



   .. py:method:: setfield(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.setfield`.



   .. py:method:: setflags(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.setflags`.



   .. py:method:: shape(*args, **kwargs)

      Tuple of array dimensions.



   .. py:method:: size(*args, **kwargs)

      The number of elements in the gentype.



   .. py:method:: sort(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.sort`.



   .. py:method:: squeeze(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.squeeze`.



   .. py:method:: std(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.std`.



   .. py:method:: strides(*args, **kwargs)

      Tuple of bytes steps in each dimension.



   .. py:method:: sum(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.sum`.



   .. py:method:: swapaxes(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.swapaxes`.



   .. py:method:: take(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.take`.



   .. py:method:: to_device(*args, **kwargs)


   .. py:method:: tobytes(*args, **kwargs)


   .. py:method:: tofile(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.tofile`.



   .. py:method:: tolist(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.tolist`.



   .. py:method:: tostring(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.tostring`.



   .. py:method:: trace(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.trace`.



   .. py:method:: transpose(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.transpose`.



   .. py:method:: var(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.var`.



   .. py:method:: view(*args, **kwargs)

      Scalar method identical to the corresponding array attribute.

          Please see `ndarray.view`.



.. py:class:: str_scalars

   Bases: :py:obj:`_NotIterable`


   Mixin to prevent iteration, without being compatible with Iterable.

   That is, we could do::

       def __iter__(self): raise TypeError()

   But this would make users of this mixin duck type-compatible with
   collections.abc.Iterable - isinstance(foo, Iterable) would be True.

   Luckily, we can instead prevent iteration by setting __iter__ to None, which
   is treated specially.


   .. py:method:: copy_with(params)


.. py:class:: uint16

   Bases: :py:obj:`numpy.unsignedinteger`


   Unsigned integer type, compatible with C ``unsigned short``.

       :Character code: ``'H'``
       :Canonical name: `numpy.ushort`
       :Alias on this platform (Linux x86_64): `numpy.uint16`: 16-bit unsigned integer (``0`` to ``65_535``).


   .. py:method:: bit_count(/)

      uint16.bit_count() -> int

              Computes the number of 1-bits in the absolute value of the input.
              Analogous to the builtin `int.bit_count` or ``popcount`` in C++.

              Examples
              --------
              >>> np.uint16(127).bit_count()
              7



.. py:class:: uint32

   Bases: :py:obj:`numpy.unsignedinteger`


   Unsigned integer type, compatible with C ``unsigned int``.

       :Character code: ``'I'``
       :Canonical name: `numpy.uintc`
       :Alias on this platform (Linux x86_64): `numpy.uint32`: 32-bit unsigned integer (``0`` to ``4_294_967_295``).


   .. py:method:: bit_count(/)

      uint32.bit_count() -> int

              Computes the number of 1-bits in the absolute value of the input.
              Analogous to the builtin `int.bit_count` or ``popcount`` in C++.

              Examples
              --------
              >>> np.uint32(127).bit_count()
              7



.. py:class:: uint64

   Bases: :py:obj:`numpy.unsignedinteger`


   Unsigned signed integer type, 64bit on 64bit systems and 32bit on 32bit
       systems.

       :Character code: ``'L'``
       :Canonical name: `numpy.uint`
       :Alias on this platform (Linux x86_64): `numpy.uint64`: 64-bit unsigned integer (``0`` to ``18_446_744_073_709_551_615``).
       :Alias on this platform (Linux x86_64): `numpy.uintp`: Unsigned integer large enough to fit pointer, compatible with C ``uintptr_t``.


   .. py:method:: bit_count(/)

      uint64.bit_count() -> int

              Computes the number of 1-bits in the absolute value of the input.
              Analogous to the builtin `int.bit_count` or ``popcount`` in C++.

              Examples
              --------
              >>> np.uint64(127).bit_count()
              7



.. py:class:: uint8

   Bases: :py:obj:`numpy.unsignedinteger`


   Unsigned integer type, compatible with C ``unsigned char``.

       :Character code: ``'B'``
       :Canonical name: `numpy.ubyte`
       :Alias on this platform (Linux x86_64): `numpy.uint8`: 8-bit unsigned integer (``0`` to ``255``).


   .. py:method:: bit_count(/)

      uint8.bit_count() -> int

              Computes the number of 1-bits in the absolute value of the input.
              Analogous to the builtin `int.bit_count` or ``popcount`` in C++.

              Examples
              --------
              >>> np.uint8(127).bit_count()
              7



