arkouda.numpy.sorting
=====================

.. py:module:: arkouda.numpy.sorting


Attributes
----------

.. autoapisummary::

   arkouda.numpy.sorting.SortingAlgorithm


Functions
---------

.. autoapisummary::

   arkouda.numpy.sorting.argsort
   arkouda.numpy.sorting.coargsort
   arkouda.numpy.sorting.searchsorted
   arkouda.numpy.sorting.sort


Module Contents
---------------

.. py:data:: SortingAlgorithm

.. py:function:: argsort(pda: Union[arkouda.numpy.pdarrayclass.pdarray, arkouda.numpy.strings.Strings, arkouda.categorical.Categorical], algorithm: SortingAlgorithm = SortingAlgorithm.RadixSortLSD, axis: arkouda.numpy.dtypes.int_scalars = 0) -> arkouda.numpy.pdarrayclass.pdarray

   Return the permutation that sorts the array.

   :param pda: The array to sort (int64, uint64, or float64)
   :type pda: pdarray, Strings, or Categorical
   :param algorithm: The algorithm to be used for sorting the array.
   :type algorithm: SortingAlgorithm, default=SortingAlgorithm.RadixSortLSD
   :param axis: The axis to sort over.
   :type axis: int_scalars, default=0

   :returns: The indices such that ``pda[indices]`` is sorted
   :rtype: pdarray of int64

   :raises TypeError: Raised if the parameter is other than a pdarray, Strings or Categorical

   .. seealso:: :obj:`coargsort`

   .. rubric:: Notes

   Uses a least-significant-digit radix sort, which is stable and
   resilient to non-uniformity in data but communication intensive.

   .. rubric:: Examples

   >>> a = ak.randint(0, 10, 10)
   >>> perm = ak.argsort(a)
   >>> a[perm]
   array([0 1 3 3 5 5 5 6 6 6])

   >>> ak.argsort(a, ak.sorting.SortingAlgorithm["RadixSortLSD"])
   array([0 2 9 6 8 1 3 5 7 4])

   >>> ak.argsort(a, ak.sorting.SortingAlgorithm["TwoArrayRadixSort"])
   array([0 2 9 6 8 1 3 5 7 4])


.. py:function:: coargsort(arrays: Sequence[Union[arkouda.numpy.strings.Strings, arkouda.numpy.pdarrayclass.pdarray, arkouda.categorical.Categorical]], algorithm: SortingAlgorithm = SortingAlgorithm.RadixSortLSD) -> arkouda.numpy.pdarrayclass.pdarray

   Return the permutation that groups the rows (left-to-right), if the
   input arrays are treated as columns. The permutation sorts numeric
   columns, but not strings/Categoricals -- strings/Categoricals are grouped, but not ordered.

   :param arrays: The columns (int64, uint64, float64, Strings, or Categorical) to sort by row
   :type arrays: Sequence of Strings, pdarray, or Categorical
   :param algorithm: The algorithm to be used for sorting the arrays.
   :type algorithm: SortingAlgorithm, default=SortingAlgorithm.RadixSortLSD

   :returns: The indices that permute the rows to grouped order
   :rtype: pdarray of int64

   :raises ValueError: Raised if the pdarrays are not of the same size or if the parameter
       is not an Iterable containing pdarrays, Strings, or Categoricals

   .. seealso:: :obj:`argsort`

   .. rubric:: Notes

   Uses a least-significant-digit radix sort, which is stable and resilient
   to non-uniformity in data but communication intensive. Starts with the
   last array and moves forward. This sort operates directly on numeric types,
   but for Strings, it operates on a hash. Thus, while grouping of equivalent
   strings is guaranteed, lexicographic ordering of the groups is not. For Categoricals,
   coargsort sorts based on Categorical.codes which guarantees grouping of equivalent categories
   but not lexicographic ordering of those groups.

   .. rubric:: Examples

   >>> a = ak.array([0, 1, 0, 1])
   >>> b = ak.array([1, 1, 0, 0])
   >>> perm = ak.coargsort([a, b])
   >>> perm
   array([2 0 3 1])
   >>> a[perm]
   array([0 0 1 1])
   >>> b[perm]
   array([0 1 0 1])


.. py:function:: searchsorted(a: arkouda.numpy.pdarrayclass.pdarray, v: Union[arkouda.numpy.dtypes.int_scalars, arkouda.numpy.dtypes.float64, arkouda.numpy.dtypes.bigint, arkouda.numpy.pdarrayclass.pdarray], side: Literal['left', 'right'] = 'left') -> Union[int, arkouda.numpy.pdarrayclass.pdarray]

   Find indices where elements should be inserted to maintain order.

   Find the indices into a sorted array `a` such that, if the corresponding
   elements in `v` were inserted before the indices, the order of `a` would be preserved.

   :param a: 1-D input array. Must be sorted in ascending order. `sorter` is not currently supported.
   :type a: pdarray
   :param v: Values to insert into `a`. Can be a scalar or array-like.
   :type v: int_scalars, float64, bigint, or pdarray
   :param side: If 'left', the index of the first suitable location found is given.
                If 'right', return the last such index.
   :type side: {'left', 'right'}, default='left'

   :returns: **indices** -- If `v` is an array, returns an array of insertion points with the same shape.
             If `v` is a scalar, returns a single integer index.
   :rtype: int or pdarray

   :raises ValueError: If `a` has more than one dimension.
   :raises TypeError: If `a` has an unsupported dtype (i.e., not int64, uint64, bigint, or float64).

   .. rubric:: Examples

   >>> a = ak.array([11, 12, 13, 14, 15])
   >>> ak.searchsorted(a, 13)
   2
   >>> ak.searchsorted(a, 13, side='right')
   3
   >>> v = ak.array([-10, 20, 12, 13])
   >>> ak.searchsorted(a, v)
   array([0 5 1 2])


.. py:function:: sort(pda: arkouda.numpy.pdarrayclass.pdarray, algorithm: SortingAlgorithm = SortingAlgorithm.RadixSortLSD, axis: arkouda.numpy.dtypes.int_scalars = -1) -> arkouda.numpy.pdarrayclass.pdarray

   Return a sorted copy of the array. Only sorts numeric arrays;
   for Strings, use argsort.

   :param pda: The array to sort (int64, uint64, or float64)
   :type pda: pdarray
   :param algorithm: The algorithm to be used for sorting the arrays.
   :type algorithm: SortingAlgorithm, default=SortingAlgorithm.RadixSortLSD
   :param axis: The axis to sort over. Setting to -1 means that it will sort over axis = ndim - 1.
   :type axis: int_scalars, default=-1

   :returns: The sorted copy of pda
   :rtype: pdarray of int64, uint64, or float64

   :raises TypeError: Raised if the parameter is not a pdarray
   :raises ValueError: Raised if sort attempted on a pdarray with an unsupported dtype
       such as bool

   .. seealso:: :obj:`argsort`

   .. rubric:: Notes

   Uses a least-significant-digit radix sort, which is stable and resilient
   to non-uniformity in data but communication intensive.

   .. rubric:: Examples

   >>> a = ak.randint(0, 10, 10)
   >>> sorted = ak.sort(a)
   >>> sorted
   array([0 1 1 3 4 5 7 8 8 9])


