arkouda.numpy.pdarraymanipulation
=================================

.. py:module:: arkouda.numpy.pdarraymanipulation


Functions
---------

.. autoapisummary::

   arkouda.numpy.pdarraymanipulation.delete
   arkouda.numpy.pdarraymanipulation.hstack
   arkouda.numpy.pdarraymanipulation.vstack


Module Contents
---------------

.. py:function:: delete(arr: arkouda.numpy.pdarrayclass.pdarray, obj: Union[slice, int, Sequence[int], Sequence[bool], arkouda.numpy.pdarrayclass.pdarray], axis: Optional[int] = None) -> arkouda.numpy.pdarrayclass.pdarray

   Return a copy of 'arr' with elements along the specified axis removed.

   :param arr: The array to remove elements from
   :type arr: pdarray
   :param obj: The indices to remove from 'arr'. If obj is a pdarray, it must
               have an integer or bool dtype.
   :type obj: slice, int, Sequence of int, Sequence of bool, or pdarray
   :param axis: The axis along which to remove elements. If None, the array will
                be flattened before removing elements. Defaults to None.
   :type axis: Optional[int], optional

   :returns: A copy of 'arr' with elements removed
   :rtype: pdarray

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> arr = ak.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])
   >>> arr
   array([array([1 2 3 4]) array([5 6 7 8]) array([9 10 11 12])])
   >>> ak.delete(arr, 1, 0)
   array([array([1 2 3 4]) array([9 10 11 12])])

   >>> ak.delete(arr, slice(0, 4, 2), 1)
   array([array([2 4]) array([6 8]) array([10 12])])
   >>> ak.delete(arr, [1, 3, 5], None)
   array([1 3 5 7 8 9 10 11 12])


.. py:function:: hstack(tup: Sequence[arkouda.numpy.pdarrayclass.pdarray], *, dtype: Optional[Union[str, type]] = None, casting: Literal['no', 'equiv', 'safe', 'same_kind', 'unsafe'] = 'same_kind') -> arkouda.numpy.pdarrayclass.pdarray

   Stack arrays in sequence horizontally (column wise).

   This is equivalent to concatenation along the second axis, except for 1-D arrays
   where it concatenates along the first axis. Rebuilds arrays divided by ``hsplit``.

   This function makes most sense for arrays with up to 3 dimensions. For instance, for pixel-data
   with a height (first axis), width (second axis), and r/g/b channels (third axis). The functions
   ``concatenate``, ``stack`` and ``block`` provide more general stacking and concatenation operations.

   :param tup: The arrays must have the same shape along all but the second axis, except 1-D arrays which
               can be any length. In the case of a single array_like input, it will be treated as a sequence of
               arrays; i.e., each element along the zeroth axis is treated as a separate array.
   :type tup: sequence of pdarray
   :param dtype: If provided, the destination array will have this type.
   :type dtype: str or type, optional
   :param casting: Controls what kind of data casting may occur. Defaults to ‘same_kind’. Currently unused.
   :type casting: {‘no’, ‘equiv’, ‘safe’, ‘same_kind’, ‘unsafe’}, optional

   :returns: The array formed by stacking the given arrays.
   :rtype: pdarray

   .. seealso:: :py:obj:`concatenate`, :py:obj:`stack`, :py:obj:`block`, :py:obj:`vstack`, :py:obj:`dstack`, :py:obj:`column_stack`, :py:obj:`hsplit`, :py:obj:`unstack`

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.array([1, 2, 3])
   >>> b = ak.array([4, 5, 6])
   >>> ak.hstack((a, b))
   array([1 2 3 4 5 6])
   >>> a = ak.array([[1],[2],[3]])
   >>> b = ak.array([[4],[5],[6]])
   >>> ak.hstack((a, b))
   array([array([1 4]) array([2 5]) array([3 6])])


.. py:function:: vstack(tup: Sequence[arkouda.numpy.pdarrayclass.pdarray], *, dtype: Optional[Union[str, type]] = None, casting: Literal['no', 'equiv', 'safe', 'same_kind', 'unsafe'] = 'same_kind') -> arkouda.numpy.pdarrayclass.pdarray

   Stack arrays in sequence vertically (row wise).

   This is equivalent to concatenation along the first axis after
   1-D arrays of shape `(N,)` have been reshaped to `(1,N)`. Rebuilds arrays divided by ``vsplit``.

   This function makes most sense for arrays with up to 3 dimensions.
   For instance, for pixel-data with a height (first axis), width (second axis),
   and r/g/b channels (third axis). The functions ``concatenate``, ``stack`` and ``block``
   provide more general stacking and concatenation operations.

   :param tup: The arrays must have the same shape along all but the first axis. 1-D arrays
               must have the same length. In the case of a single array_like input, it will be
               treated as a sequence of arrays; i.e., each element along the zeroth axis is treated
               as a separate array.
   :type tup: sequence of pdarray
   :param dtype: If provided, the destination array will have this dtype.
   :type dtype: str or type, optional
   :param casting: Controls what kind of data casting may occur. Defaults to ‘same_kind’. Currently unused.
   :type casting: {"no", "equiv", "safe", "same_kind", "unsafe"], optional

   :returns: The array formed by stacking the given arrays, will be at least 2-D.
   :rtype: pdarray

   .. seealso:: :py:obj:`concatenate`, :py:obj:`stack`, :py:obj:`block`, :py:obj:`hstack`, :py:obj:`dstack`, :py:obj:`column_stack`, :py:obj:`hsplit`, :py:obj:`unstack`

   .. rubric:: Examples

   >>> import arkouda as ak
   >>> a = ak.array([1, 2, 3])
   >>> b = ak.array([4, 5, 6])
   >>> ak.vstack((a, b))
   array([array([1 2 3]) array([4 5 6])])

   >>> a = ak.array([[1],[2],[3]])
   >>> b = ak.array([[4],[5],[6]])
   >>> ak.vstack((a, b))
   array([array([1]) array([2]) array([3]) array([4]) array([5]) array([6])])


