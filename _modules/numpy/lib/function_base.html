<!doctype html>
<html class="no-js" lang="en" data-content_root="../../../">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><link rel="index" title="Index" href="../../../genindex.html" /><link rel="search" title="Search" href="../../../search.html" />

    <!-- Generated with Sphinx 7.4.7 and Furo 2024.08.06 -->
        <title>numpy.lib.function_base - arkouda documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=a746c00c" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo.css?v=354aac6f" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=fd3f3429" />
    <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo-extensions.css?v=302659d7" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-with-moon" viewBox="0 0 24 24">
    <title>Auto light/dark, in light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path style="opacity: 50%" d="M 5.411 14.504 C 5.471 14.504 5.532 14.504 5.591 14.504 C 3.639 16.319 4.383 19.569 6.931 20.352 C 7.693 20.586 8.512 20.551 9.25 20.252 C 8.023 23.207 4.056 23.725 2.11 21.184 C 0.166 18.642 1.702 14.949 4.874 14.536 C 5.051 14.512 5.231 14.5 5.411 14.5 L 5.411 14.504 Z"/>
      <line x1="14.5" y1="3.25" x2="14.5" y2="1.25"/>
      <line x1="14.5" y1="15.85" x2="14.5" y2="17.85"/>
      <line x1="10.044" y1="5.094" x2="8.63" y2="3.68"/>
      <line x1="19" y1="14.05" x2="20.414" y2="15.464"/>
      <line x1="8.2" y1="9.55" x2="6.2" y2="9.55"/>
      <line x1="20.8" y1="9.55" x2="22.8" y2="9.55"/>
      <line x1="10.044" y1="14.006" x2="8.63" y2="15.42"/>
      <line x1="19" y1="5.05" x2="20.414" y2="3.636"/>
      <circle cx="14.5" cy="9.55" r="3.6"/>
    </svg>
  </symbol>
  <symbol id="svg-moon-with-sun" viewBox="0 0 24 24">
    <title>Auto light/dark, in dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path d="M 8.282 7.007 C 8.385 7.007 8.494 7.007 8.595 7.007 C 5.18 10.184 6.481 15.869 10.942 17.24 C 12.275 17.648 13.706 17.589 15 17.066 C 12.851 22.236 5.91 23.143 2.505 18.696 C -0.897 14.249 1.791 7.786 7.342 7.063 C 7.652 7.021 7.965 7 8.282 7 L 8.282 7.007 Z"/>
      <line style="opacity: 50%" x1="18" y1="3.705" x2="18" y2="2.5"/>
      <line style="opacity: 50%" x1="18" y1="11.295" x2="18" y2="12.5"/>
      <line style="opacity: 50%" x1="15.316" y1="4.816" x2="14.464" y2="3.964"/>
      <line style="opacity: 50%" x1="20.711" y1="10.212" x2="21.563" y2="11.063"/>
      <line style="opacity: 50%" x1="14.205" y1="7.5" x2="13.001" y2="7.5"/>
      <line style="opacity: 50%" x1="21.795" y1="7.5" x2="23" y2="7.5"/>
      <line style="opacity: 50%" x1="15.316" y1="10.184" x2="14.464" y2="11.036"/>
      <line style="opacity: 50%" x1="20.711" y1="4.789" x2="21.563" y2="3.937"/>
      <circle style="opacity: 50%" cx="18" cy="7.5" r="2.169"/>
    </svg>
  </symbol>
  <symbol id="svg-pencil" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-pencil-code">
      <path d="M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4" />
      <path d="M13.5 6.5l4 4" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
  <symbol id="svg-eye" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-eye-code">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" />
      <path
        d="M11.11 17.958c-3.209 -.307 -5.91 -2.293 -8.11 -5.958c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6c-.21 .352 -.427 .688 -.647 1.008" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>

<a class="skip-to-content muted-link" href="#furo-main-content">Skip to content</a>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../../index.html"><div class="brand">arkouda  documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
          <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon no-toc" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../../../index.html">
  
  
  <span class="sidebar-brand-text">arkouda  documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../../../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../quickstart.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../setup/REQUIREMENTS.html">Requirements</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../setup/install_menu.html">Installation</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle navigation of Installation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../setup/LINUX_INSTALL.html">Linux</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../setup/WINDOWS_INSTALL.html">Windows (WSL2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../setup/MAC_INSTALL.html">MacOS</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../setup/BUILD.html">Building the Server</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../setup/MODULAR.html">Modular Server Builds</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../setup/testing.html">Performance Testing</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../file_io/io_menu.html">File I/O</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle navigation of File I/O</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../file_io/HDF5.html">HDF5</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../file_io/PARQUET.html">Parquet</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../file_io/CSV.html">CSV</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../file_io/IMPORT_EXPORT.html">Import/Export</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../usage.html">Usage Guide</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" role="switch" type="checkbox"/><label for="toctree-checkbox-3"><div class="visually-hidden">Toggle navigation of Usage Guide</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/startup.html">Startup</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/pdarray.html">The <code class="docutils literal notranslate"><span class="pre">pdarray</span></code> class</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/creation.html">Creating Arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/arithmetic.html">Arithmetic and Numeric Operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/indexing.html">Indexing and Assignment</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/histogram.html">Summarizing Data</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/argsort.html">Sorting</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/setops.html">Array Set Operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/groupby.html">GroupBy</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/strings.html">Strings in Arkouda</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/categorical.html">Categoricals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/random.html">Random in Arkouda</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/segarray.html">SegArrays in Arkouda</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../usage/arrayview.html">ArrayView in Arkouda</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../CONTRIBUTING_LINK.html">Contributing</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../autoapi/index.html">API Reference</a><input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" role="switch" type="checkbox"/><label for="toctree-checkbox-4"><div class="visually-hidden">Toggle navigation of API Reference</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../../autoapi/arkouda/index.html">arkouda</a><input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" role="switch" type="checkbox"/><label for="toctree-checkbox-5"><div class="visually-hidden">Toggle navigation of arkouda</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../../autoapi/arkouda/array_api/index.html">arkouda.array_api</a><input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" role="switch" type="checkbox"/><label for="toctree-checkbox-6"><div class="visually-hidden">Toggle navigation of arkouda.array_api</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/arkouda/array_api/array_object/index.html">arkouda.array_api.array_object</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/arkouda/array_api/creation_functions/index.html">arkouda.array_api.creation_functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/arkouda/array_api/data_type_functions/index.html">arkouda.array_api.data_type_functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/arkouda/array_api/elementwise_functions/index.html">arkouda.array_api.elementwise_functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/arkouda/array_api/indexing_functions/index.html">arkouda.array_api.indexing_functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/arkouda/array_api/linalg/index.html">arkouda.array_api.linalg</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/arkouda/array_api/manipulation_functions/index.html">arkouda.array_api.manipulation_functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/arkouda/array_api/searching_functions/index.html">arkouda.array_api.searching_functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/arkouda/array_api/set_functions/index.html">arkouda.array_api.set_functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/arkouda/array_api/sorting_functions/index.html">arkouda.array_api.sorting_functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/arkouda/array_api/statistical_functions/index.html">arkouda.array_api.statistical_functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/arkouda/array_api/utility_functions/index.html">arkouda.array_api.utility_functions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../autoapi/arkouda/random/index.html">arkouda.random</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../autoapi/arkouda/testing/index.html">arkouda.testing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../autoapi/arkouda/accessor/index.html">arkouda.accessor</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../autoapi/arkouda/alignment/index.html">arkouda.alignment</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../autoapi/arkouda/array_view/index.html">arkouda.array_view</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../autoapi/arkouda/categorical/index.html">arkouda.categorical</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../autoapi/arkouda/client/index.html">arkouda.client</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../autoapi/arkouda/client_dtypes/index.html">arkouda.client_dtypes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../autoapi/arkouda/dataframe/index.html">arkouda.dataframe</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../autoapi/arkouda/dtypes/index.html">arkouda.dtypes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../autoapi/arkouda/groupbyclass/index.html">arkouda.groupbyclass</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../autoapi/arkouda/history/index.html">arkouda.history</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../autoapi/arkouda/index/index.html">arkouda.index</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../autoapi/arkouda/infoclass/index.html">arkouda.infoclass</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../autoapi/arkouda/io/index.html">arkouda.io</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../autoapi/arkouda/io_util/index.html">arkouda.io_util</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../autoapi/arkouda/join/index.html">arkouda.join</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../autoapi/arkouda/logger/index.html">arkouda.logger</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../autoapi/arkouda/match/index.html">arkouda.match</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../autoapi/arkouda/matcher/index.html">arkouda.matcher</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../autoapi/arkouda/numeric/index.html">arkouda.numeric</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../autoapi/arkouda/numpy/index.html">arkouda.numpy</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../autoapi/arkouda/pdarrayclass/index.html">arkouda.pdarrayclass</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../autoapi/arkouda/pdarraycreation/index.html">arkouda.pdarraycreation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../autoapi/arkouda/pdarraymanipulation/index.html">arkouda.pdarraymanipulation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../autoapi/arkouda/pdarraysetops/index.html">arkouda.pdarraysetops</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../autoapi/arkouda/plotting/index.html">arkouda.plotting</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../autoapi/arkouda/row/index.html">arkouda.row</a></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../../autoapi/arkouda/scipy/index.html">arkouda.scipy</a><input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" role="switch" type="checkbox"/><label for="toctree-checkbox-7"><div class="visually-hidden">Toggle navigation of arkouda.scipy</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/arkouda/scipy/special/index.html">arkouda.scipy.special</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../autoapi/arkouda/scipy/stats/index.html">arkouda.scipy.stats</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../autoapi/arkouda/security/index.html">arkouda.security</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../autoapi/arkouda/segarray/index.html">arkouda.segarray</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../autoapi/arkouda/series/index.html">arkouda.series</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../autoapi/arkouda/sorting/index.html">arkouda.sorting</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../autoapi/arkouda/sparrayclass/index.html">arkouda.sparrayclass</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../autoapi/arkouda/sparsematrix/index.html">arkouda.sparsematrix</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../autoapi/arkouda/strings/index.html">arkouda.strings</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../autoapi/arkouda/timeclass/index.html">arkouda.timeclass</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../autoapi/arkouda/util/index.html">arkouda.util</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../server/index.html">Chapel API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../genindex.html">Index</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../../developer/dev_menu.html">Developer Documentation</a><input class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" role="switch" type="checkbox"/><label for="toctree-checkbox-8"><div class="visually-hidden">Toggle navigation of Developer Documentation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../developer/TIPS.html">Speeding up Arkouda Compilation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../developer/USER_BUGS.html">Tips for Reproducing User Bugs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../developer/MEMORY.html">Reducing Memory Usage of Arkouda Builds</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../developer/GASNET.html">GASNet Development</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../developer/RELEASE_PROCESS.html">Release Process</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../developer/BENCHMARK.html">PyTest Benchmarks</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../developer/ADDING_FEATURES.html">Adding Your First Feature</a></li>
</ul>
</li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
              <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon no-toc" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main" id="furo-main-content">
          <h1>Source code for numpy.lib.function_base</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">collections.abc</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">from</span> <span class="nn">.._utils</span> <span class="kn">import</span> <span class="n">set_module</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">numpy.core.numeric</span> <span class="k">as</span> <span class="nn">_nx</span>
<span class="kn">from</span> <span class="nn">numpy.core</span> <span class="kn">import</span> <span class="n">transpose</span>
<span class="kn">from</span> <span class="nn">numpy.core.numeric</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">ones</span><span class="p">,</span> <span class="n">zeros_like</span><span class="p">,</span> <span class="n">arange</span><span class="p">,</span> <span class="n">concatenate</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">asarray</span><span class="p">,</span> <span class="n">asanyarray</span><span class="p">,</span> <span class="n">empty</span><span class="p">,</span>
    <span class="n">ndarray</span><span class="p">,</span> <span class="n">take</span><span class="p">,</span> <span class="n">dot</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="n">intp</span><span class="p">,</span> <span class="n">integer</span><span class="p">,</span> <span class="n">isscalar</span><span class="p">,</span> <span class="n">absolute</span>
    <span class="p">)</span>
<span class="kn">from</span> <span class="nn">numpy.core.umath</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">pi</span><span class="p">,</span> <span class="n">add</span><span class="p">,</span> <span class="n">arctan2</span><span class="p">,</span> <span class="n">frompyfunc</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">less_equal</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span>
    <span class="n">mod</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">not_equal</span><span class="p">,</span> <span class="n">subtract</span>
    <span class="p">)</span>
<span class="kn">from</span> <span class="nn">numpy.core.fromnumeric</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">ravel</span><span class="p">,</span> <span class="n">nonzero</span><span class="p">,</span> <span class="n">partition</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="nb">any</span><span class="p">,</span> <span class="nb">sum</span>
    <span class="p">)</span>
<span class="kn">from</span> <span class="nn">numpy.core.numerictypes</span> <span class="kn">import</span> <span class="n">typecodes</span>
<span class="kn">from</span> <span class="nn">numpy.core</span> <span class="kn">import</span> <span class="n">overrides</span>
<span class="kn">from</span> <span class="nn">numpy.core.function_base</span> <span class="kn">import</span> <span class="n">add_newdoc</span>
<span class="kn">from</span> <span class="nn">numpy.lib.twodim_base</span> <span class="kn">import</span> <span class="n">diag</span>
<span class="kn">from</span> <span class="nn">numpy.core.multiarray</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">_place</span><span class="p">,</span> <span class="n">add_docstring</span><span class="p">,</span> <span class="n">bincount</span><span class="p">,</span> <span class="n">normalize_axis_index</span><span class="p">,</span> <span class="n">_monotonicity</span><span class="p">,</span>
    <span class="n">interp</span> <span class="k">as</span> <span class="n">compiled_interp</span><span class="p">,</span> <span class="n">interp_complex</span> <span class="k">as</span> <span class="n">compiled_interp_complex</span>
    <span class="p">)</span>
<span class="kn">from</span> <span class="nn">numpy.core.umath</span> <span class="kn">import</span> <span class="n">_add_newdoc_ufunc</span> <span class="k">as</span> <span class="n">add_newdoc_ufunc</span>

<span class="kn">import</span> <span class="nn">builtins</span>

<span class="c1"># needed in this module for compatibility</span>
<span class="kn">from</span> <span class="nn">numpy.lib.histograms</span> <span class="kn">import</span> <span class="n">histogram</span><span class="p">,</span> <span class="n">histogramdd</span>  <span class="c1"># noqa: F401</span>


<span class="n">array_function_dispatch</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span>
    <span class="n">overrides</span><span class="o">.</span><span class="n">array_function_dispatch</span><span class="p">,</span> <span class="n">module</span><span class="o">=</span><span class="s1">&#39;numpy&#39;</span><span class="p">)</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;select&#39;</span><span class="p">,</span> <span class="s1">&#39;piecewise&#39;</span><span class="p">,</span> <span class="s1">&#39;trim_zeros&#39;</span><span class="p">,</span> <span class="s1">&#39;copy&#39;</span><span class="p">,</span> <span class="s1">&#39;iterable&#39;</span><span class="p">,</span> <span class="s1">&#39;percentile&#39;</span><span class="p">,</span>
    <span class="s1">&#39;diff&#39;</span><span class="p">,</span> <span class="s1">&#39;gradient&#39;</span><span class="p">,</span> <span class="s1">&#39;angle&#39;</span><span class="p">,</span> <span class="s1">&#39;unwrap&#39;</span><span class="p">,</span> <span class="s1">&#39;sort_complex&#39;</span><span class="p">,</span> <span class="s1">&#39;disp&#39;</span><span class="p">,</span> <span class="s1">&#39;flip&#39;</span><span class="p">,</span>
    <span class="s1">&#39;rot90&#39;</span><span class="p">,</span> <span class="s1">&#39;extract&#39;</span><span class="p">,</span> <span class="s1">&#39;place&#39;</span><span class="p">,</span> <span class="s1">&#39;vectorize&#39;</span><span class="p">,</span> <span class="s1">&#39;asarray_chkfinite&#39;</span><span class="p">,</span> <span class="s1">&#39;average&#39;</span><span class="p">,</span>
    <span class="s1">&#39;bincount&#39;</span><span class="p">,</span> <span class="s1">&#39;digitize&#39;</span><span class="p">,</span> <span class="s1">&#39;cov&#39;</span><span class="p">,</span> <span class="s1">&#39;corrcoef&#39;</span><span class="p">,</span>
    <span class="s1">&#39;msort&#39;</span><span class="p">,</span> <span class="s1">&#39;median&#39;</span><span class="p">,</span> <span class="s1">&#39;sinc&#39;</span><span class="p">,</span> <span class="s1">&#39;hamming&#39;</span><span class="p">,</span> <span class="s1">&#39;hanning&#39;</span><span class="p">,</span> <span class="s1">&#39;bartlett&#39;</span><span class="p">,</span>
    <span class="s1">&#39;blackman&#39;</span><span class="p">,</span> <span class="s1">&#39;kaiser&#39;</span><span class="p">,</span> <span class="s1">&#39;trapz&#39;</span><span class="p">,</span> <span class="s1">&#39;i0&#39;</span><span class="p">,</span> <span class="s1">&#39;add_newdoc&#39;</span><span class="p">,</span> <span class="s1">&#39;add_docstring&#39;</span><span class="p">,</span>
    <span class="s1">&#39;meshgrid&#39;</span><span class="p">,</span> <span class="s1">&#39;delete&#39;</span><span class="p">,</span> <span class="s1">&#39;insert&#39;</span><span class="p">,</span> <span class="s1">&#39;append&#39;</span><span class="p">,</span> <span class="s1">&#39;interp&#39;</span><span class="p">,</span> <span class="s1">&#39;add_newdoc_ufunc&#39;</span><span class="p">,</span>
    <span class="s1">&#39;quantile&#39;</span>
    <span class="p">]</span>

<span class="c1"># _QuantileMethods is a dictionary listing all the supported methods to</span>
<span class="c1"># compute quantile/percentile.</span>
<span class="c1">#</span>
<span class="c1"># Below virtual_index refer to the index of the element where the percentile</span>
<span class="c1"># would be found in the sorted sample.</span>
<span class="c1"># When the sample contains exactly the percentile wanted, the virtual_index is</span>
<span class="c1"># an integer to the index of this element.</span>
<span class="c1"># When the percentile wanted is in between two elements, the virtual_index</span>
<span class="c1"># is made of a integer part (a.k.a &#39;i&#39; or &#39;left&#39;) and a fractional part</span>
<span class="c1"># (a.k.a &#39;g&#39; or &#39;gamma&#39;)</span>
<span class="c1">#</span>
<span class="c1"># Each method in _QuantileMethods has two properties</span>
<span class="c1"># get_virtual_index : Callable</span>
<span class="c1">#   The function used to compute the virtual_index.</span>
<span class="c1"># fix_gamma : Callable</span>
<span class="c1">#   A function used for discret methods to force the index to a specific value.</span>
<span class="n">_QuantileMethods</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="c1"># --- HYNDMAN and FAN METHODS</span>
    <span class="c1"># Discrete methods</span>
    <span class="n">inverted_cdf</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
        <span class="n">get_virtual_index</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">quantiles</span><span class="p">:</span> <span class="n">_inverted_cdf</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">quantiles</span><span class="p">),</span>
        <span class="n">fix_gamma</span><span class="o">=</span><span class="k">lambda</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">gamma</span><span class="p">,</span>  <span class="c1"># should never be called</span>
    <span class="p">),</span>
    <span class="n">averaged_inverted_cdf</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
        <span class="n">get_virtual_index</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">quantiles</span><span class="p">:</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">quantiles</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">fix_gamma</span><span class="o">=</span><span class="k">lambda</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">_get_gamma_mask</span><span class="p">(</span>
            <span class="n">shape</span><span class="o">=</span><span class="n">gamma</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
            <span class="n">default_value</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span>
            <span class="n">conditioned_value</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
            <span class="n">where</span><span class="o">=</span><span class="n">gamma</span> <span class="o">==</span> <span class="mi">0</span><span class="p">),</span>
    <span class="p">),</span>
    <span class="n">closest_observation</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
        <span class="n">get_virtual_index</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">quantiles</span><span class="p">:</span> <span class="n">_closest_observation</span><span class="p">(</span><span class="n">n</span><span class="p">,</span>
                                                                    <span class="n">quantiles</span><span class="p">),</span>
        <span class="n">fix_gamma</span><span class="o">=</span><span class="k">lambda</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">gamma</span><span class="p">,</span>  <span class="c1"># should never be called</span>
    <span class="p">),</span>
    <span class="c1"># Continuous methods</span>
    <span class="n">interpolated_inverted_cdf</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
        <span class="n">get_virtual_index</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">quantiles</span><span class="p">:</span>
        <span class="n">_compute_virtual_index</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">quantiles</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
        <span class="n">fix_gamma</span><span class="o">=</span><span class="k">lambda</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">gamma</span><span class="p">,</span>
    <span class="p">),</span>
    <span class="n">hazen</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
        <span class="n">get_virtual_index</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">quantiles</span><span class="p">:</span>
        <span class="n">_compute_virtual_index</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">quantiles</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">),</span>
        <span class="n">fix_gamma</span><span class="o">=</span><span class="k">lambda</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">gamma</span><span class="p">,</span>
    <span class="p">),</span>
    <span class="n">weibull</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
        <span class="n">get_virtual_index</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">quantiles</span><span class="p">:</span>
        <span class="n">_compute_virtual_index</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">quantiles</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
        <span class="n">fix_gamma</span><span class="o">=</span><span class="k">lambda</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">gamma</span><span class="p">,</span>
    <span class="p">),</span>
    <span class="c1"># Default method.</span>
    <span class="c1"># To avoid some rounding issues, `(n-1) * quantiles` is preferred to</span>
    <span class="c1"># `_compute_virtual_index(n, quantiles, 1, 1)`.</span>
    <span class="c1"># They are mathematically equivalent.</span>
    <span class="n">linear</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
        <span class="n">get_virtual_index</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">quantiles</span><span class="p">:</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">quantiles</span><span class="p">,</span>
        <span class="n">fix_gamma</span><span class="o">=</span><span class="k">lambda</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">gamma</span><span class="p">,</span>
    <span class="p">),</span>
    <span class="n">median_unbiased</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
        <span class="n">get_virtual_index</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">quantiles</span><span class="p">:</span>
        <span class="n">_compute_virtual_index</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">quantiles</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="mf">3.0</span><span class="p">),</span>
        <span class="n">fix_gamma</span><span class="o">=</span><span class="k">lambda</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">gamma</span><span class="p">,</span>
    <span class="p">),</span>
    <span class="n">normal_unbiased</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
        <span class="n">get_virtual_index</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">quantiles</span><span class="p">:</span>
        <span class="n">_compute_virtual_index</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">quantiles</span><span class="p">,</span> <span class="mi">3</span> <span class="o">/</span> <span class="mf">8.0</span><span class="p">,</span> <span class="mi">3</span> <span class="o">/</span> <span class="mf">8.0</span><span class="p">),</span>
        <span class="n">fix_gamma</span><span class="o">=</span><span class="k">lambda</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">gamma</span><span class="p">,</span>
    <span class="p">),</span>
    <span class="c1"># --- OTHER METHODS</span>
    <span class="n">lower</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
        <span class="n">get_virtual_index</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">quantiles</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span>
            <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">quantiles</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">),</span>
        <span class="n">fix_gamma</span><span class="o">=</span><span class="k">lambda</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">gamma</span><span class="p">,</span>
        <span class="c1"># should never be called, index dtype is int</span>
    <span class="p">),</span>
    <span class="n">higher</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
        <span class="n">get_virtual_index</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">quantiles</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span>
            <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">quantiles</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">),</span>
        <span class="n">fix_gamma</span><span class="o">=</span><span class="k">lambda</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">gamma</span><span class="p">,</span>
        <span class="c1"># should never be called, index dtype is int</span>
    <span class="p">),</span>
    <span class="n">midpoint</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
        <span class="n">get_virtual_index</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">quantiles</span><span class="p">:</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">((</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">quantiles</span><span class="p">)</span>
                <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">quantiles</span><span class="p">)),</span>
        <span class="n">fix_gamma</span><span class="o">=</span><span class="k">lambda</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="n">_get_gamma_mask</span><span class="p">(</span>
            <span class="n">shape</span><span class="o">=</span><span class="n">gamma</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
            <span class="n">default_value</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
            <span class="n">conditioned_value</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span>
            <span class="n">where</span><span class="o">=</span><span class="n">index</span> <span class="o">%</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">),</span>
    <span class="p">),</span>
    <span class="n">nearest</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
        <span class="n">get_virtual_index</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">quantiles</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span>
            <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">quantiles</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">),</span>
        <span class="n">fix_gamma</span><span class="o">=</span><span class="k">lambda</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">gamma</span><span class="p">,</span>
        <span class="c1"># should never be called, index dtype is int</span>
    <span class="p">))</span>


<span class="k">def</span> <span class="nf">_rot90_dispatcher</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">m</span><span class="p">,)</span>


<span class="nd">@array_function_dispatch</span><span class="p">(</span><span class="n">_rot90_dispatcher</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">rot90</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Rotate an array by 90 degrees in the plane specified by axes.</span>

<span class="sd">    Rotation direction is from the first towards the second axis.</span>
<span class="sd">    This means for a 2D array with the default `k` and `axes`, the</span>
<span class="sd">    rotation will be counterclockwise.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    m : array_like</span>
<span class="sd">        Array of two or more dimensions.</span>
<span class="sd">    k : integer</span>
<span class="sd">        Number of times the array is rotated by 90 degrees.</span>
<span class="sd">    axes : (2,) array_like</span>
<span class="sd">        The array is rotated in the plane defined by the axes.</span>
<span class="sd">        Axes must be different.</span>

<span class="sd">        .. versionadded:: 1.12.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : ndarray</span>
<span class="sd">        A rotated view of `m`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    flip : Reverse the order of elements in an array along the given axis.</span>
<span class="sd">    fliplr : Flip an array horizontally.</span>
<span class="sd">    flipud : Flip an array vertically.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    ``rot90(m, k=1, axes=(1,0))``  is the reverse of</span>
<span class="sd">    ``rot90(m, k=1, axes=(0,1))``</span>

<span class="sd">    ``rot90(m, k=1, axes=(1,0))`` is equivalent to</span>
<span class="sd">    ``rot90(m, k=-1, axes=(0,1))``</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; m = np.array([[1,2],[3,4]], int)</span>
<span class="sd">    &gt;&gt;&gt; m</span>
<span class="sd">    array([[1, 2],</span>
<span class="sd">           [3, 4]])</span>
<span class="sd">    &gt;&gt;&gt; np.rot90(m)</span>
<span class="sd">    array([[2, 4],</span>
<span class="sd">           [1, 3]])</span>
<span class="sd">    &gt;&gt;&gt; np.rot90(m, 2)</span>
<span class="sd">    array([[4, 3],</span>
<span class="sd">           [2, 1]])</span>
<span class="sd">    &gt;&gt;&gt; m = np.arange(8).reshape((2,2,2))</span>
<span class="sd">    &gt;&gt;&gt; np.rot90(m, 1, (1,2))</span>
<span class="sd">    array([[[1, 3],</span>
<span class="sd">            [0, 2]],</span>
<span class="sd">           [[5, 7],</span>
<span class="sd">            [4, 6]]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">axes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;len(axes) must be 2.&quot;</span><span class="p">)</span>

    <span class="n">m</span> <span class="o">=</span> <span class="n">asanyarray</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">or</span> <span class="n">absolute</span><span class="p">(</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Axes must be different.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">m</span><span class="o">.</span><span class="n">ndim</span> <span class="ow">or</span> <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">m</span><span class="o">.</span><span class="n">ndim</span>
        <span class="ow">or</span> <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">m</span><span class="o">.</span><span class="n">ndim</span> <span class="ow">or</span> <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">m</span><span class="o">.</span><span class="n">ndim</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Axes=</span><span class="si">{}</span><span class="s2"> out of range for array of ndim=</span><span class="si">{}</span><span class="s2">.&quot;</span>
            <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>

    <span class="n">k</span> <span class="o">%=</span> <span class="mi">4</span>

    <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">m</span><span class="p">[:]</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">flip</span><span class="p">(</span><span class="n">flip</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="n">axes_list</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
    <span class="p">(</span><span class="n">axes_list</span><span class="p">[</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">axes_list</span><span class="p">[</span><span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span> <span class="o">=</span> <span class="p">(</span><span class="n">axes_list</span><span class="p">[</span><span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
                                                <span class="n">axes_list</span><span class="p">[</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>

    <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">transpose</span><span class="p">(</span><span class="n">flip</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">axes_list</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># k == 3</span>
        <span class="k">return</span> <span class="n">flip</span><span class="p">(</span><span class="n">transpose</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">axes_list</span><span class="p">),</span> <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">_flip_dispatcher</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">m</span><span class="p">,)</span>


<span class="nd">@array_function_dispatch</span><span class="p">(</span><span class="n">_flip_dispatcher</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">flip</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reverse the order of elements in an array along the given axis.</span>

<span class="sd">    The shape of the array is preserved, but the elements are reordered.</span>

<span class="sd">    .. versionadded:: 1.12.0</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    m : array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    axis : None or int or tuple of ints, optional</span>
<span class="sd">         Axis or axes along which to flip over. The default,</span>
<span class="sd">         axis=None, will flip over all of the axes of the input array.</span>
<span class="sd">         If axis is negative it counts from the last to the first axis.</span>

<span class="sd">         If axis is a tuple of ints, flipping is performed on all of the axes</span>
<span class="sd">         specified in the tuple.</span>

<span class="sd">         .. versionchanged:: 1.15.0</span>
<span class="sd">            None and tuples of axes are supported</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : array_like</span>
<span class="sd">        A view of `m` with the entries of axis reversed.  Since a view is</span>
<span class="sd">        returned, this operation is done in constant time.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    flipud : Flip an array vertically (axis=0).</span>
<span class="sd">    fliplr : Flip an array horizontally (axis=1).</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    flip(m, 0) is equivalent to flipud(m).</span>

<span class="sd">    flip(m, 1) is equivalent to fliplr(m).</span>

<span class="sd">    flip(m, n) corresponds to ``m[...,::-1,...]`` with ``::-1`` at position n.</span>

<span class="sd">    flip(m) corresponds to ``m[::-1,::-1,...,::-1]`` with ``::-1`` at all</span>
<span class="sd">    positions.</span>

<span class="sd">    flip(m, (0, 1)) corresponds to ``m[::-1,::-1,...]`` with ``::-1`` at</span>
<span class="sd">    position 0 and position 1.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; A = np.arange(8).reshape((2,2,2))</span>
<span class="sd">    &gt;&gt;&gt; A</span>
<span class="sd">    array([[[0, 1],</span>
<span class="sd">            [2, 3]],</span>
<span class="sd">           [[4, 5],</span>
<span class="sd">            [6, 7]]])</span>
<span class="sd">    &gt;&gt;&gt; np.flip(A, 0)</span>
<span class="sd">    array([[[4, 5],</span>
<span class="sd">            [6, 7]],</span>
<span class="sd">           [[0, 1],</span>
<span class="sd">            [2, 3]]])</span>
<span class="sd">    &gt;&gt;&gt; np.flip(A, 1)</span>
<span class="sd">    array([[[2, 3],</span>
<span class="sd">            [0, 1]],</span>
<span class="sd">           [[6, 7],</span>
<span class="sd">            [4, 5]]])</span>
<span class="sd">    &gt;&gt;&gt; np.flip(A)</span>
<span class="sd">    array([[[7, 6],</span>
<span class="sd">            [5, 4]],</span>
<span class="sd">           [[3, 2],</span>
<span class="sd">            [1, 0]]])</span>
<span class="sd">    &gt;&gt;&gt; np.flip(A, (0, 2))</span>
<span class="sd">    array([[[5, 4],</span>
<span class="sd">            [7, 6]],</span>
<span class="sd">           [[1, 0],</span>
<span class="sd">            [3, 2]]])</span>
<span class="sd">    &gt;&gt;&gt; A = np.random.randn(3,4,5)</span>
<span class="sd">    &gt;&gt;&gt; np.all(np.flip(A,2) == A[:,:,::-1,...])</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s1">&#39;ndim&#39;</span><span class="p">):</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">indexer</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],)</span> <span class="o">*</span> <span class="n">m</span><span class="o">.</span><span class="n">ndim</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">_nx</span><span class="o">.</span><span class="n">normalize_axis_tuple</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
        <span class="n">indexer</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[:]]</span> <span class="o">*</span> <span class="n">m</span><span class="o">.</span><span class="n">ndim</span>
        <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axis</span><span class="p">:</span>
            <span class="n">indexer</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">indexer</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">indexer</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">m</span><span class="p">[</span><span class="n">indexer</span><span class="p">]</span>


<span class="nd">@set_module</span><span class="p">(</span><span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">iterable</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check whether or not an object can be iterated over.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : object</span>
<span class="sd">      Input object.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    b : bool</span>
<span class="sd">      Return ``True`` if the object has an iterator method or is a</span>
<span class="sd">      sequence and ``False`` otherwise.</span>


<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.iterable([1, 2, 3])</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; np.iterable(2)</span>
<span class="sd">    False</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    In most cases, the results of ``np.iterable(obj)`` are consistent with</span>
<span class="sd">    ``isinstance(obj, collections.abc.Iterable)``. One notable exception is</span>
<span class="sd">    the treatment of 0-dimensional arrays::</span>

<span class="sd">        &gt;&gt;&gt; from collections.abc import Iterable</span>
<span class="sd">        &gt;&gt;&gt; a = np.array(1.0)  # 0-dimensional numpy array</span>
<span class="sd">        &gt;&gt;&gt; isinstance(a, Iterable)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; np.iterable(a)</span>
<span class="sd">        False</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="nb">iter</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span>


<span class="k">def</span> <span class="nf">_average_dispatcher</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">returned</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
                        <span class="n">keepdims</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>


<span class="nd">@array_function_dispatch</span><span class="p">(</span><span class="n">_average_dispatcher</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">average</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">returned</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
            <span class="n">keepdims</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the weighted average along the specified axis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Array containing data to be averaged. If `a` is not an array, a</span>
<span class="sd">        conversion is attempted.</span>
<span class="sd">    axis : None or int or tuple of ints, optional</span>
<span class="sd">        Axis or axes along which to average `a`.  The default,</span>
<span class="sd">        axis=None, will average over all of the elements of the input array.</span>
<span class="sd">        If axis is negative it counts from the last to the first axis.</span>

<span class="sd">        .. versionadded:: 1.7.0</span>

<span class="sd">        If axis is a tuple of ints, averaging is performed on all of the axes</span>
<span class="sd">        specified in the tuple instead of a single axis or all the axes as</span>
<span class="sd">        before.</span>
<span class="sd">    weights : array_like, optional</span>
<span class="sd">        An array of weights associated with the values in `a`. Each value in</span>
<span class="sd">        `a` contributes to the average according to its associated weight.</span>
<span class="sd">        The weights array can either be 1-D (in which case its length must be</span>
<span class="sd">        the size of `a` along the given axis) or of the same shape as `a`.</span>
<span class="sd">        If `weights=None`, then all data in `a` are assumed to have a</span>
<span class="sd">        weight equal to one.  The 1-D calculation is::</span>

<span class="sd">            avg = sum(a * weights) / sum(weights)</span>

<span class="sd">        The only constraint on `weights` is that `sum(weights)` must not be 0.</span>
<span class="sd">    returned : bool, optional</span>
<span class="sd">        Default is `False`. If `True`, the tuple (`average`, `sum_of_weights`)</span>
<span class="sd">        is returned, otherwise only the average is returned.</span>
<span class="sd">        If `weights=None`, `sum_of_weights` is equivalent to the number of</span>
<span class="sd">        elements over which the average is taken.</span>
<span class="sd">    keepdims : bool, optional</span>
<span class="sd">        If this is set to True, the axes which are reduced are left</span>
<span class="sd">        in the result as dimensions with size one. With this option,</span>
<span class="sd">        the result will broadcast correctly against the original `a`.</span>
<span class="sd">        *Note:* `keepdims` will not work with instances of `numpy.matrix`</span>
<span class="sd">        or other classes whose methods do not support `keepdims`.</span>

<span class="sd">        .. versionadded:: 1.23.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    retval, [sum_of_weights] : array_type or double</span>
<span class="sd">        Return the average along the specified axis. When `returned` is `True`,</span>
<span class="sd">        return a tuple with the average as the first element and the sum</span>
<span class="sd">        of the weights as the second element. `sum_of_weights` is of the</span>
<span class="sd">        same type as `retval`. The result dtype follows a genereal pattern.</span>
<span class="sd">        If `weights` is None, the result dtype will be that of `a` , or ``float64``</span>
<span class="sd">        if `a` is integral. Otherwise, if `weights` is not None and `a` is non-</span>
<span class="sd">        integral, the result type will be the type of lowest precision capable of</span>
<span class="sd">        representing values of both `a` and `weights`. If `a` happens to be</span>
<span class="sd">        integral, the previous rules still applies but the result dtype will</span>
<span class="sd">        at least be ``float64``.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ZeroDivisionError</span>
<span class="sd">        When all weights along axis are zero. See `numpy.ma.average` for a</span>
<span class="sd">        version robust to this type of error.</span>
<span class="sd">    TypeError</span>
<span class="sd">        When the length of 1D `weights` is not the same as the shape of `a`</span>
<span class="sd">        along axis.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    mean</span>

<span class="sd">    ma.average : average for masked arrays -- useful if your data contains</span>
<span class="sd">                 &quot;missing&quot; values</span>
<span class="sd">    numpy.result_type : Returns the type that results from applying the</span>
<span class="sd">                        numpy type promotion rules to the arguments.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; data = np.arange(1, 5)</span>
<span class="sd">    &gt;&gt;&gt; data</span>
<span class="sd">    array([1, 2, 3, 4])</span>
<span class="sd">    &gt;&gt;&gt; np.average(data)</span>
<span class="sd">    2.5</span>
<span class="sd">    &gt;&gt;&gt; np.average(np.arange(1, 11), weights=np.arange(10, 0, -1))</span>
<span class="sd">    4.0</span>

<span class="sd">    &gt;&gt;&gt; data = np.arange(6).reshape((3, 2))</span>
<span class="sd">    &gt;&gt;&gt; data</span>
<span class="sd">    array([[0, 1],</span>
<span class="sd">           [2, 3],</span>
<span class="sd">           [4, 5]])</span>
<span class="sd">    &gt;&gt;&gt; np.average(data, axis=1, weights=[1./4, 3./4])</span>
<span class="sd">    array([0.75, 2.75, 4.75])</span>
<span class="sd">    &gt;&gt;&gt; np.average(data, weights=[1./4, 3./4])</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">    TypeError: Axis must be specified when shapes of a and weights differ.</span>

<span class="sd">    &gt;&gt;&gt; a = np.ones(5, dtype=np.float128)</span>
<span class="sd">    &gt;&gt;&gt; w = np.ones(5, dtype=np.complex64)</span>
<span class="sd">    &gt;&gt;&gt; avg = np.average(a, weights=w)</span>
<span class="sd">    &gt;&gt;&gt; print(avg.dtype)</span>
<span class="sd">    complex256</span>

<span class="sd">    With ``keepdims=True``, the following result has shape (3, 1).</span>

<span class="sd">    &gt;&gt;&gt; np.average(data, axis=1, keepdims=True)</span>
<span class="sd">    array([[0.5],</span>
<span class="sd">           [2.5],</span>
<span class="sd">           [4.5]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">keepdims</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">:</span>
        <span class="c1"># Don&#39;t pass on the keepdims argument if one wasn&#39;t given.</span>
        <span class="n">keepdims_kw</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">keepdims_kw</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;keepdims&#39;</span><span class="p">:</span> <span class="n">keepdims</span><span class="p">}</span>

    <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">avg</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="o">**</span><span class="n">keepdims_kw</span><span class="p">)</span>
        <span class="n">avg_as_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">avg</span><span class="p">)</span>
        <span class="n">scl</span> <span class="o">=</span> <span class="n">avg_as_array</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">size</span><span class="o">/</span><span class="n">avg_as_array</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">wgt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)):</span>
            <span class="n">result_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">wgt</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="s1">&#39;f8&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">wgt</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># Sanity checks</span>
        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">wgt</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;Axis must be specified when shapes of a and weights &quot;</span>
                    <span class="s2">&quot;differ.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">wgt</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;1D weights expected when shapes of a and weights differ.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">wgt</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Length of weights not compatible with specified axis.&quot;</span><span class="p">)</span>

            <span class="c1"># setup wgt to broadcast along axis</span>
            <span class="n">wgt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">wgt</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">+</span> <span class="n">wgt</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">wgt</span> <span class="o">=</span> <span class="n">wgt</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

        <span class="n">scl</span> <span class="o">=</span> <span class="n">wgt</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">result_dtype</span><span class="p">,</span> <span class="o">**</span><span class="n">keepdims_kw</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">scl</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ZeroDivisionError</span><span class="p">(</span>
                <span class="s2">&quot;Weights sum to zero, can&#39;t be normalized&quot;</span><span class="p">)</span>

        <span class="n">avg</span> <span class="o">=</span> <span class="n">avg_as_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">wgt</span><span class="p">,</span>
                          <span class="n">dtype</span><span class="o">=</span><span class="n">result_dtype</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="o">**</span><span class="n">keepdims_kw</span><span class="p">)</span> <span class="o">/</span> <span class="n">scl</span>

    <span class="k">if</span> <span class="n">returned</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">scl</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">avg_as_array</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="n">scl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">scl</span><span class="p">,</span> <span class="n">avg_as_array</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">avg</span><span class="p">,</span> <span class="n">scl</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">avg</span>


<span class="nd">@set_module</span><span class="p">(</span><span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">asarray_chkfinite</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert the input to an array, checking for NaNs or Infs.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input data, in any form that can be converted to an array.  This</span>
<span class="sd">        includes lists, lists of tuples, tuples, tuples of tuples, tuples</span>
<span class="sd">        of lists and ndarrays.  Success requires no NaNs or Infs.</span>
<span class="sd">    dtype : data-type, optional</span>
<span class="sd">        By default, the data-type is inferred from the input data.</span>
<span class="sd">    order : {&#39;C&#39;, &#39;F&#39;, &#39;A&#39;, &#39;K&#39;}, optional</span>
<span class="sd">        Memory layout.  &#39;A&#39; and &#39;K&#39; depend on the order of input array a.</span>
<span class="sd">        &#39;C&#39; row-major (C-style),</span>
<span class="sd">        &#39;F&#39; column-major (Fortran-style) memory representation.</span>
<span class="sd">        &#39;A&#39; (any) means &#39;F&#39; if `a` is Fortran contiguous, &#39;C&#39; otherwise</span>
<span class="sd">        &#39;K&#39; (keep) preserve input order</span>
<span class="sd">        Defaults to &#39;C&#39;.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : ndarray</span>
<span class="sd">        Array interpretation of `a`.  No copy is performed if the input</span>
<span class="sd">        is already an ndarray.  If `a` is a subclass of ndarray, a base</span>
<span class="sd">        class ndarray is returned.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        Raises ValueError if `a` contains NaN (Not a Number) or Inf (Infinity).</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    asarray : Create and array.</span>
<span class="sd">    asanyarray : Similar function which passes through subclasses.</span>
<span class="sd">    ascontiguousarray : Convert input to a contiguous array.</span>
<span class="sd">    asfarray : Convert input to a floating point ndarray.</span>
<span class="sd">    asfortranarray : Convert input to an ndarray with column-major</span>
<span class="sd">                     memory order.</span>
<span class="sd">    fromiter : Create an array from an iterator.</span>
<span class="sd">    fromfunction : Construct an array by executing a function on grid</span>
<span class="sd">                   positions.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Convert a list into an array.  If all elements are finite</span>
<span class="sd">    ``asarray_chkfinite`` is identical to ``asarray``.</span>

<span class="sd">    &gt;&gt;&gt; a = [1, 2]</span>
<span class="sd">    &gt;&gt;&gt; np.asarray_chkfinite(a, dtype=float)</span>
<span class="sd">    array([1., 2.])</span>

<span class="sd">    Raises ValueError if array_like contains Nans or Infs.</span>

<span class="sd">    &gt;&gt;&gt; a = [1, 2, np.inf]</span>
<span class="sd">    &gt;&gt;&gt; try:</span>
<span class="sd">    ...     np.asarray_chkfinite(a)</span>
<span class="sd">    ... except ValueError:</span>
<span class="sd">    ...     print(&#39;ValueError&#39;)</span>
<span class="sd">    ...</span>
<span class="sd">    ValueError</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">char</span> <span class="ow">in</span> <span class="n">typecodes</span><span class="p">[</span><span class="s1">&#39;AllFloat&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;array must not contain infs or NaNs&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a</span>


<span class="k">def</span> <span class="nf">_piecewise_dispatcher</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">condlist</span><span class="p">,</span> <span class="n">funclist</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
    <span class="k">yield</span> <span class="n">x</span>
    <span class="c1"># support the undocumented behavior of allowing scalars</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">condlist</span><span class="p">):</span>
        <span class="k">yield from</span> <span class="n">condlist</span>


<span class="nd">@array_function_dispatch</span><span class="p">(</span><span class="n">_piecewise_dispatcher</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">piecewise</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">condlist</span><span class="p">,</span> <span class="n">funclist</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluate a piecewise-defined function.</span>

<span class="sd">    Given a set of conditions and corresponding functions, evaluate each</span>
<span class="sd">    function on the input data wherever its condition is true.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : ndarray or scalar</span>
<span class="sd">        The input domain.</span>
<span class="sd">    condlist : list of bool arrays or bool scalars</span>
<span class="sd">        Each boolean array corresponds to a function in `funclist`.  Wherever</span>
<span class="sd">        `condlist[i]` is True, `funclist[i](x)` is used as the output value.</span>

<span class="sd">        Each boolean array in `condlist` selects a piece of `x`,</span>
<span class="sd">        and should therefore be of the same shape as `x`.</span>

<span class="sd">        The length of `condlist` must correspond to that of `funclist`.</span>
<span class="sd">        If one extra function is given, i.e. if</span>
<span class="sd">        ``len(funclist) == len(condlist) + 1``, then that extra function</span>
<span class="sd">        is the default value, used wherever all conditions are false.</span>
<span class="sd">    funclist : list of callables, f(x,*args,**kw), or scalars</span>
<span class="sd">        Each function is evaluated over `x` wherever its corresponding</span>
<span class="sd">        condition is True.  It should take a 1d array as input and give an 1d</span>
<span class="sd">        array or a scalar value as output.  If, instead of a callable,</span>
<span class="sd">        a scalar is provided then a constant function (``lambda x: scalar``) is</span>
<span class="sd">        assumed.</span>
<span class="sd">    args : tuple, optional</span>
<span class="sd">        Any further arguments given to `piecewise` are passed to the functions</span>
<span class="sd">        upon execution, i.e., if called ``piecewise(..., ..., 1, &#39;a&#39;)``, then</span>
<span class="sd">        each function is called as ``f(x, 1, &#39;a&#39;)``.</span>
<span class="sd">    kw : dict, optional</span>
<span class="sd">        Keyword arguments used in calling `piecewise` are passed to the</span>
<span class="sd">        functions upon execution, i.e., if called</span>
<span class="sd">        ``piecewise(..., ..., alpha=1)``, then each function is called as</span>
<span class="sd">        ``f(x, alpha=1)``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : ndarray</span>
<span class="sd">        The output is the same shape and type as x and is found by</span>
<span class="sd">        calling the functions in `funclist` on the appropriate portions of `x`,</span>
<span class="sd">        as defined by the boolean arrays in `condlist`.  Portions not covered</span>
<span class="sd">        by any condition have a default value of 0.</span>


<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    choose, select, where</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This is similar to choose or select, except that functions are</span>
<span class="sd">    evaluated on elements of `x` that satisfy the corresponding condition from</span>
<span class="sd">    `condlist`.</span>

<span class="sd">    The result is::</span>

<span class="sd">            |--</span>
<span class="sd">            |funclist[0](x[condlist[0]])</span>
<span class="sd">      out = |funclist[1](x[condlist[1]])</span>
<span class="sd">            |...</span>
<span class="sd">            |funclist[n2](x[condlist[n2]])</span>
<span class="sd">            |--</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Define the sigma function, which is -1 for ``x &lt; 0`` and +1 for ``x &gt;= 0``.</span>

<span class="sd">    &gt;&gt;&gt; x = np.linspace(-2.5, 2.5, 6)</span>
<span class="sd">    &gt;&gt;&gt; np.piecewise(x, [x &lt; 0, x &gt;= 0], [-1, 1])</span>
<span class="sd">    array([-1., -1., -1.,  1.,  1.,  1.])</span>

<span class="sd">    Define the absolute value, which is ``-x`` for ``x &lt;0`` and ``x`` for</span>
<span class="sd">    ``x &gt;= 0``.</span>

<span class="sd">    &gt;&gt;&gt; np.piecewise(x, [x &lt; 0, x &gt;= 0], [lambda x: -x, lambda x: x])</span>
<span class="sd">    array([2.5,  1.5,  0.5,  0.5,  1.5,  2.5])</span>

<span class="sd">    Apply the same function to a scalar value.</span>

<span class="sd">    &gt;&gt;&gt; y = -2</span>
<span class="sd">    &gt;&gt;&gt; np.piecewise(y, [y &lt; 0, y &gt;= 0], [lambda x: -x, lambda x: x])</span>
<span class="sd">    array(2)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">asanyarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">n2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">funclist</span><span class="p">)</span>

    <span class="c1"># undocumented: single condition is promoted to a list of one condition</span>
    <span class="k">if</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">condlist</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">condlist</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">))</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">condlist</span> <span class="o">=</span> <span class="p">[</span><span class="n">condlist</span><span class="p">]</span>

    <span class="n">condlist</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">condlist</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">condlist</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="n">n2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># compute the &quot;otherwise&quot; condition.</span>
        <span class="n">condelse</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">condlist</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">condlist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">condlist</span><span class="p">,</span> <span class="n">condelse</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="n">n</span> <span class="o">!=</span> <span class="n">n2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;with </span><span class="si">{}</span><span class="s2"> condition(s), either </span><span class="si">{}</span><span class="s2"> or </span><span class="si">{}</span><span class="s2"> functions are expected&quot;</span>
            <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="n">y</span> <span class="o">=</span> <span class="n">zeros_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">cond</span><span class="p">,</span> <span class="n">func</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">condlist</span><span class="p">,</span> <span class="n">funclist</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Callable</span><span class="p">):</span>
            <span class="n">y</span><span class="p">[</span><span class="n">cond</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">cond</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">vals</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">y</span><span class="p">[</span><span class="n">cond</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">y</span>


<span class="k">def</span> <span class="nf">_select_dispatcher</span><span class="p">(</span><span class="n">condlist</span><span class="p">,</span> <span class="n">choicelist</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">yield from</span> <span class="n">condlist</span>
    <span class="k">yield from</span> <span class="n">choicelist</span>


<span class="nd">@array_function_dispatch</span><span class="p">(</span><span class="n">_select_dispatcher</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">select</span><span class="p">(</span><span class="n">condlist</span><span class="p">,</span> <span class="n">choicelist</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return an array drawn from elements in choicelist, depending on conditions.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    condlist : list of bool ndarrays</span>
<span class="sd">        The list of conditions which determine from which array in `choicelist`</span>
<span class="sd">        the output elements are taken. When multiple conditions are satisfied,</span>
<span class="sd">        the first one encountered in `condlist` is used.</span>
<span class="sd">    choicelist : list of ndarrays</span>
<span class="sd">        The list of arrays from which the output elements are taken. It has</span>
<span class="sd">        to be of the same length as `condlist`.</span>
<span class="sd">    default : scalar, optional</span>
<span class="sd">        The element inserted in `output` when all conditions evaluate to False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    output : ndarray</span>
<span class="sd">        The output at position m is the m-th element of the array in</span>
<span class="sd">        `choicelist` where the m-th element of the corresponding array in</span>
<span class="sd">        `condlist` is True.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    where : Return elements from one of two arrays depending on condition.</span>
<span class="sd">    take, choose, compress, diag, diagonal</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = np.arange(6)</span>
<span class="sd">    &gt;&gt;&gt; condlist = [x&lt;3, x&gt;3]</span>
<span class="sd">    &gt;&gt;&gt; choicelist = [x, x**2]</span>
<span class="sd">    &gt;&gt;&gt; np.select(condlist, choicelist, 42)</span>
<span class="sd">    array([ 0,  1,  2, 42, 16, 25])</span>

<span class="sd">    &gt;&gt;&gt; condlist = [x&lt;=4, x&gt;3]</span>
<span class="sd">    &gt;&gt;&gt; choicelist = [x, x**2]</span>
<span class="sd">    &gt;&gt;&gt; np.select(condlist, choicelist, 55)</span>
<span class="sd">    array([ 0,  1,  2,  3,  4, 25])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check the size of condlist and choicelist are the same, or abort.</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">condlist</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">choicelist</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;list of cases must be same length as list of conditions&#39;</span><span class="p">)</span>

    <span class="c1"># Now that the dtype is known, handle the deprecated select([], []) case</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">condlist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;select with an empty condition list is not possible&quot;</span><span class="p">)</span>

    <span class="n">choicelist</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">choice</span><span class="p">)</span> <span class="k">for</span> <span class="n">choice</span> <span class="ow">in</span> <span class="n">choicelist</span><span class="p">]</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">intermediate_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="o">*</span><span class="n">choicelist</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;Choicelist elements do not have a common dtype: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="kn">from</span> <span class="kc">None</span>
    <span class="n">default_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">default</span><span class="p">)</span>
    <span class="n">choicelist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">default_array</span><span class="p">)</span>

    <span class="c1"># need to get the result type before broadcasting for correct scalar</span>
    <span class="c1"># behaviour</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="n">intermediate_dtype</span><span class="p">,</span> <span class="n">default_array</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;Choicelists and default value do not have a common dtype: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="kn">from</span> <span class="kc">None</span>

    <span class="c1"># Convert conditions to arrays and broadcast conditions and choices</span>
    <span class="c1"># as the shape is needed for the result. Doing it separately optimizes</span>
    <span class="c1"># for example when all choices are scalars.</span>
    <span class="n">condlist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_arrays</span><span class="p">(</span><span class="o">*</span><span class="n">condlist</span><span class="p">)</span>
    <span class="n">choicelist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_arrays</span><span class="p">(</span><span class="o">*</span><span class="n">choicelist</span><span class="p">)</span>

    <span class="c1"># If cond array is not an ndarray in boolean format or scalar bool, abort.</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">cond</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">condlist</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cond</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s1">&#39;invalid entry </span><span class="si">{}</span><span class="s1"> in condlist: should be boolean ndarray&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">choicelist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># This may be common, so avoid the call.</span>
        <span class="n">result_shape</span> <span class="o">=</span> <span class="n">condlist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">result_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_arrays</span><span class="p">(</span><span class="n">condlist</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">choicelist</span><span class="p">[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">result_shape</span><span class="p">,</span> <span class="n">choicelist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="p">)</span>

    <span class="c1"># Use np.copyto to burn each choicelist array onto result, using the</span>
    <span class="c1"># corresponding condlist as a boolean mask. This is done in reverse</span>
    <span class="c1"># order since the first choice should take precedence.</span>
    <span class="n">choicelist</span> <span class="o">=</span> <span class="n">choicelist</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">condlist</span> <span class="o">=</span> <span class="n">condlist</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">choice</span><span class="p">,</span> <span class="n">cond</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">choicelist</span><span class="p">,</span> <span class="n">condlist</span><span class="p">):</span>
        <span class="n">np</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">choice</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="n">cond</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">_copy_dispatcher</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">a</span><span class="p">,)</span>


<span class="nd">@array_function_dispatch</span><span class="p">(</span><span class="n">_copy_dispatcher</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;K&#39;</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return an array copy of the given object.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input data.</span>
<span class="sd">    order : {&#39;C&#39;, &#39;F&#39;, &#39;A&#39;, &#39;K&#39;}, optional</span>
<span class="sd">        Controls the memory layout of the copy. &#39;C&#39; means C-order,</span>
<span class="sd">        &#39;F&#39; means F-order, &#39;A&#39; means &#39;F&#39; if `a` is Fortran contiguous,</span>
<span class="sd">        &#39;C&#39; otherwise. &#39;K&#39; means match the layout of `a` as closely</span>
<span class="sd">        as possible. (Note that this function and :meth:`ndarray.copy` are very</span>
<span class="sd">        similar, but have different default values for their order=</span>
<span class="sd">        arguments.)</span>
<span class="sd">    subok : bool, optional</span>
<span class="sd">        If True, then sub-classes will be passed-through, otherwise the</span>
<span class="sd">        returned array will be forced to be a base-class array (defaults to False).</span>

<span class="sd">        .. versionadded:: 1.19.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    arr : ndarray</span>
<span class="sd">        Array interpretation of `a`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ndarray.copy : Preferred method for creating an array copy</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This is equivalent to:</span>

<span class="sd">    &gt;&gt;&gt; np.array(a, copy=True)  #doctest: +SKIP</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Create an array x, with a reference y and a copy z:</span>

<span class="sd">    &gt;&gt;&gt; x = np.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; y = x</span>
<span class="sd">    &gt;&gt;&gt; z = np.copy(x)</span>

<span class="sd">    Note that, when we modify x, y changes, but not z:</span>

<span class="sd">    &gt;&gt;&gt; x[0] = 10</span>
<span class="sd">    &gt;&gt;&gt; x[0] == y[0]</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; x[0] == z[0]</span>
<span class="sd">    False</span>

<span class="sd">    Note that, np.copy clears previously set WRITEABLE=False flag.</span>

<span class="sd">    &gt;&gt;&gt; a = np.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; a.flags[&quot;WRITEABLE&quot;] = False</span>
<span class="sd">    &gt;&gt;&gt; b = np.copy(a)</span>
<span class="sd">    &gt;&gt;&gt; b.flags[&quot;WRITEABLE&quot;]</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; b[0] = 3</span>
<span class="sd">    &gt;&gt;&gt; b</span>
<span class="sd">    array([3, 2, 3])</span>

<span class="sd">    Note that np.copy is a shallow copy and will not copy object</span>
<span class="sd">    elements within arrays. This is mainly important for arrays</span>
<span class="sd">    containing Python objects. The new array will contain the</span>
<span class="sd">    same object which may lead to surprises if that object can</span>
<span class="sd">    be modified (is mutable):</span>

<span class="sd">    &gt;&gt;&gt; a = np.array([1, &#39;m&#39;, [2, 3, 4]], dtype=object)</span>
<span class="sd">    &gt;&gt;&gt; b = np.copy(a)</span>
<span class="sd">    &gt;&gt;&gt; b[2][0] = 10</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([1, &#39;m&#39;, list([10, 3, 4])], dtype=object)</span>

<span class="sd">    To ensure all elements within an ``object`` array are copied,</span>
<span class="sd">    use `copy.deepcopy`:</span>

<span class="sd">    &gt;&gt;&gt; import copy</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([1, &#39;m&#39;, [2, 3, 4]], dtype=object)</span>
<span class="sd">    &gt;&gt;&gt; c = copy.deepcopy(a)</span>
<span class="sd">    &gt;&gt;&gt; c[2][0] = 10</span>
<span class="sd">    &gt;&gt;&gt; c</span>
<span class="sd">    array([1, &#39;m&#39;, list([10, 3, 4])], dtype=object)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([1, &#39;m&#39;, list([2, 3, 4])], dtype=object)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="n">subok</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># Basic operations</span>


<span class="k">def</span> <span class="nf">_gradient_dispatcher</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">varargs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">edge_order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">yield</span> <span class="n">f</span>
    <span class="k">yield from</span> <span class="n">varargs</span>


<span class="nd">@array_function_dispatch</span><span class="p">(</span><span class="n">_gradient_dispatcher</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">gradient</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">varargs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">edge_order</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the gradient of an N-dimensional array.</span>

<span class="sd">    The gradient is computed using second order accurate central differences</span>
<span class="sd">    in the interior points and either first or second order accurate one-sides</span>
<span class="sd">    (forward or backwards) differences at the boundaries.</span>
<span class="sd">    The returned gradient hence has the same shape as the input array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    f : array_like</span>
<span class="sd">        An N-dimensional array containing samples of a scalar function.</span>
<span class="sd">    varargs : list of scalar or array, optional</span>
<span class="sd">        Spacing between f values. Default unitary spacing for all dimensions.</span>
<span class="sd">        Spacing can be specified using:</span>

<span class="sd">        1. single scalar to specify a sample distance for all dimensions.</span>
<span class="sd">        2. N scalars to specify a constant sample distance for each dimension.</span>
<span class="sd">           i.e. `dx`, `dy`, `dz`, ...</span>
<span class="sd">        3. N arrays to specify the coordinates of the values along each</span>
<span class="sd">           dimension of F. The length of the array must match the size of</span>
<span class="sd">           the corresponding dimension</span>
<span class="sd">        4. Any combination of N scalars/arrays with the meaning of 2. and 3.</span>

<span class="sd">        If `axis` is given, the number of varargs must equal the number of axes.</span>
<span class="sd">        Default: 1.</span>

<span class="sd">    edge_order : {1, 2}, optional</span>
<span class="sd">        Gradient is calculated using N-th order accurate differences</span>
<span class="sd">        at the boundaries. Default: 1.</span>

<span class="sd">        .. versionadded:: 1.9.1</span>

<span class="sd">    axis : None or int or tuple of ints, optional</span>
<span class="sd">        Gradient is calculated only along the given axis or axes</span>
<span class="sd">        The default (axis = None) is to calculate the gradient for all the axes</span>
<span class="sd">        of the input array. axis may be negative, in which case it counts from</span>
<span class="sd">        the last to the first axis.</span>

<span class="sd">        .. versionadded:: 1.11.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    gradient : ndarray or list of ndarray</span>
<span class="sd">        A list of ndarrays (or a single ndarray if there is only one dimension)</span>
<span class="sd">        corresponding to the derivatives of f with respect to each dimension.</span>
<span class="sd">        Each derivative has the same shape as f.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; f = np.array([1, 2, 4, 7, 11, 16], dtype=float)</span>
<span class="sd">    &gt;&gt;&gt; np.gradient(f)</span>
<span class="sd">    array([1. , 1.5, 2.5, 3.5, 4.5, 5. ])</span>
<span class="sd">    &gt;&gt;&gt; np.gradient(f, 2)</span>
<span class="sd">    array([0.5 ,  0.75,  1.25,  1.75,  2.25,  2.5 ])</span>

<span class="sd">    Spacing can be also specified with an array that represents the coordinates</span>
<span class="sd">    of the values F along the dimensions.</span>
<span class="sd">    For instance a uniform spacing:</span>

<span class="sd">    &gt;&gt;&gt; x = np.arange(f.size)</span>
<span class="sd">    &gt;&gt;&gt; np.gradient(f, x)</span>
<span class="sd">    array([1. ,  1.5,  2.5,  3.5,  4.5,  5. ])</span>

<span class="sd">    Or a non uniform one:</span>

<span class="sd">    &gt;&gt;&gt; x = np.array([0., 1., 1.5, 3.5, 4., 6.], dtype=float)</span>
<span class="sd">    &gt;&gt;&gt; np.gradient(f, x)</span>
<span class="sd">    array([1. ,  3. ,  3.5,  6.7,  6.9,  2.5])</span>

<span class="sd">    For two dimensional arrays, the return will be two arrays ordered by</span>
<span class="sd">    axis. In this example the first array stands for the gradient in</span>
<span class="sd">    rows and the second one in columns direction:</span>

<span class="sd">    &gt;&gt;&gt; np.gradient(np.array([[1, 2, 6], [3, 4, 5]], dtype=float))</span>
<span class="sd">    [array([[ 2.,  2., -1.],</span>
<span class="sd">           [ 2.,  2., -1.]]), array([[1. , 2.5, 4. ],</span>
<span class="sd">           [1. , 1. , 1. ]])]</span>

<span class="sd">    In this example the spacing is also specified:</span>
<span class="sd">    uniform for axis=0 and non uniform for axis=1</span>

<span class="sd">    &gt;&gt;&gt; dx = 2.</span>
<span class="sd">    &gt;&gt;&gt; y = [1., 1.5, 3.5]</span>
<span class="sd">    &gt;&gt;&gt; np.gradient(np.array([[1, 2, 6], [3, 4, 5]], dtype=float), dx, y)</span>
<span class="sd">    [array([[ 1. ,  1. , -0.5],</span>
<span class="sd">           [ 1. ,  1. , -0.5]]), array([[2. , 2. , 2. ],</span>
<span class="sd">           [2. , 1.7, 0.5]])]</span>

<span class="sd">    It is possible to specify how boundaries are treated using `edge_order`</span>

<span class="sd">    &gt;&gt;&gt; x = np.array([0, 1, 2, 3, 4])</span>
<span class="sd">    &gt;&gt;&gt; f = x**2</span>
<span class="sd">    &gt;&gt;&gt; np.gradient(f, edge_order=1)</span>
<span class="sd">    array([1.,  2.,  4.,  6.,  7.])</span>
<span class="sd">    &gt;&gt;&gt; np.gradient(f, edge_order=2)</span>
<span class="sd">    array([0., 2., 4., 6., 8.])</span>

<span class="sd">    The `axis` keyword can be used to specify a subset of axes of which the</span>
<span class="sd">    gradient is calculated</span>

<span class="sd">    &gt;&gt;&gt; np.gradient(np.array([[1, 2, 6], [3, 4, 5]], dtype=float), axis=0)</span>
<span class="sd">    array([[ 2.,  2., -1.],</span>
<span class="sd">           [ 2.,  2., -1.]])</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Assuming that :math:`f\\in C^{3}` (i.e., :math:`f` has at least 3 continuous</span>
<span class="sd">    derivatives) and let :math:`h_{*}` be a non-homogeneous stepsize, we</span>
<span class="sd">    minimize the &quot;consistency error&quot; :math:`\\eta_{i}` between the true gradient</span>
<span class="sd">    and its estimate from a linear combination of the neighboring grid-points:</span>

<span class="sd">    .. math::</span>

<span class="sd">        \\eta_{i} = f_{i}^{\\left(1\\right)} -</span>
<span class="sd">                    \\left[ \\alpha f\\left(x_{i}\\right) +</span>
<span class="sd">                            \\beta f\\left(x_{i} + h_{d}\\right) +</span>
<span class="sd">                            \\gamma f\\left(x_{i}-h_{s}\\right)</span>
<span class="sd">                    \\right]</span>

<span class="sd">    By substituting :math:`f(x_{i} + h_{d})` and :math:`f(x_{i} - h_{s})`</span>
<span class="sd">    with their Taylor series expansion, this translates into solving</span>
<span class="sd">    the following the linear system:</span>

<span class="sd">    .. math::</span>

<span class="sd">        \\left\\{</span>
<span class="sd">            \\begin{array}{r}</span>
<span class="sd">                \\alpha+\\beta+\\gamma=0 \\\\</span>
<span class="sd">                \\beta h_{d}-\\gamma h_{s}=1 \\\\</span>
<span class="sd">                \\beta h_{d}^{2}+\\gamma h_{s}^{2}=0</span>
<span class="sd">            \\end{array}</span>
<span class="sd">        \\right.</span>

<span class="sd">    The resulting approximation of :math:`f_{i}^{(1)}` is the following:</span>

<span class="sd">    .. math::</span>

<span class="sd">        \\hat f_{i}^{(1)} =</span>
<span class="sd">            \\frac{</span>
<span class="sd">                h_{s}^{2}f\\left(x_{i} + h_{d}\\right)</span>
<span class="sd">                + \\left(h_{d}^{2} - h_{s}^{2}\\right)f\\left(x_{i}\\right)</span>
<span class="sd">                - h_{d}^{2}f\\left(x_{i}-h_{s}\\right)}</span>
<span class="sd">                { h_{s}h_{d}\\left(h_{d} + h_{s}\\right)}</span>
<span class="sd">            + \\mathcal{O}\\left(\\frac{h_{d}h_{s}^{2}</span>
<span class="sd">                                + h_{s}h_{d}^{2}}{h_{d}</span>
<span class="sd">                                + h_{s}}\\right)</span>

<span class="sd">    It is worth noting that if :math:`h_{s}=h_{d}`</span>
<span class="sd">    (i.e., data are evenly spaced)</span>
<span class="sd">    we find the standard second order approximation:</span>

<span class="sd">    .. math::</span>

<span class="sd">        \\hat f_{i}^{(1)}=</span>
<span class="sd">            \\frac{f\\left(x_{i+1}\\right) - f\\left(x_{i-1}\\right)}{2h}</span>
<span class="sd">            + \\mathcal{O}\\left(h^{2}\\right)</span>

<span class="sd">    With a similar procedure the forward/backward approximations used for</span>
<span class="sd">    boundaries can be derived.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1]  Quarteroni A., Sacco R., Saleri F. (2007) Numerical Mathematics</span>
<span class="sd">            (Texts in Applied Mathematics). New York: Springer.</span>
<span class="sd">    .. [2]  Durran D. R. (1999) Numerical Methods for Wave Equations</span>
<span class="sd">            in Geophysical Fluid Dynamics. New York: Springer.</span>
<span class="sd">    .. [3]  Fornberg B. (1988) Generation of Finite Difference Formulas on</span>
<span class="sd">            Arbitrarily Spaced Grids,</span>
<span class="sd">            Mathematics of Computation 51, no. 184 : 699-706.</span>
<span class="sd">            `PDF &lt;http://www.ams.org/journals/mcom/1988-51-184/</span>
<span class="sd">            S0025-5718-1988-0935077-0/S0025-5718-1988-0935077-0.pdf&gt;`_.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">ndim</span>  <span class="c1"># number of dimensions</span>

    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="n">_nx</span><span class="o">.</span><span class="n">normalize_axis_tuple</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>

    <span class="n">len_axes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">varargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># no spacing argument - use 1 in all axes</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">]</span> <span class="o">*</span> <span class="n">len_axes</span>
    <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">varargs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># single scalar for all axes</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="n">varargs</span> <span class="o">*</span> <span class="n">len_axes</span>
    <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="n">len_axes</span><span class="p">:</span>
        <span class="c1"># scalar or 1d array for each axis</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">varargs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">distances</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dx</span><span class="p">):</span>
            <span class="n">distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">distances</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">elif</span> <span class="n">distances</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;distances must be either scalars or 1d&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span> <span class="o">!=</span> <span class="n">f</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">]]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;when 1d, distances must match &quot;</span>
                                 <span class="s2">&quot;the length of the corresponding dimension&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">distances</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
                <span class="c1"># Convert numpy integer types to float64 to avoid modular</span>
                <span class="c1"># arithmetic in np.diff(distances).</span>
                <span class="n">distances</span> <span class="o">=</span> <span class="n">distances</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="n">diffx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span>
            <span class="c1"># if distances are constant reduce to the scalar case</span>
            <span class="c1"># since it brings a consistent speedup</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">diffx</span> <span class="o">==</span> <span class="n">diffx</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="n">diffx</span> <span class="o">=</span> <span class="n">diffx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">dx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">diffx</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;invalid number of arguments&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">edge_order</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;edge_order&#39; greater than 2 not supported&quot;</span><span class="p">)</span>

    <span class="c1"># use central differences on interior and one-sided differences on the</span>
    <span class="c1"># endpoints. This preserves second order-accuracy over the full domain.</span>

    <span class="n">outvals</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># create slice objects --- initially all are [:, :, ..., :]</span>
    <span class="n">slice1</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span><span class="o">*</span><span class="n">N</span>
    <span class="n">slice2</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span><span class="o">*</span><span class="n">N</span>
    <span class="n">slice3</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span><span class="o">*</span><span class="n">N</span>
    <span class="n">slice4</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span><span class="o">*</span><span class="n">N</span>

    <span class="n">otype</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">dtype</span>
    <span class="k">if</span> <span class="n">otype</span><span class="o">.</span><span class="n">type</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">:</span>
        <span class="c1"># the timedelta dtype with the same unit information</span>
        <span class="n">otype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">otype</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;datetime&#39;</span><span class="p">,</span> <span class="s1">&#39;timedelta&#39;</span><span class="p">))</span>
        <span class="c1"># view as timedelta to allow addition</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">otype</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">otype</span><span class="o">.</span><span class="n">type</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">timedelta64</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">otype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inexact</span><span class="p">):</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># All other types convert to floating point.</span>
        <span class="c1"># First check if f is a numpy integer type; if so, convert f to float64</span>
        <span class="c1"># to avoid modular arithmetic when computing the changes in f.</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">otype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">otype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span>

    <span class="k">for</span> <span class="n">axis</span><span class="p">,</span> <span class="n">ax_dx</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="n">dx</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">edge_order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Shape of array too small to calculate a numerical gradient, &quot;</span>
                <span class="s2">&quot;at least (edge_order + 1) elements are required.&quot;</span><span class="p">)</span>
        <span class="c1"># result allocation</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">otype</span><span class="p">)</span>

        <span class="c1"># spacing for the current axis</span>
        <span class="n">uniform_spacing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">ax_dx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>

        <span class="c1"># Numerical differentiation: 2nd order interior</span>
        <span class="n">slice1</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">slice2</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">slice3</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">slice4</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">uniform_spacing</span><span class="p">:</span>
            <span class="n">out</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slice1</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slice4</span><span class="p">)]</span> <span class="o">-</span> <span class="n">f</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slice2</span><span class="p">)])</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.</span> <span class="o">*</span> <span class="n">ax_dx</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dx1</span> <span class="o">=</span> <span class="n">ax_dx</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">dx2</span> <span class="o">=</span> <span class="n">ax_dx</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">a</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">dx2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">dx1</span> <span class="o">*</span> <span class="p">(</span><span class="n">dx1</span> <span class="o">+</span> <span class="n">dx2</span><span class="p">))</span>
            <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">dx2</span> <span class="o">-</span> <span class="n">dx1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">dx1</span> <span class="o">*</span> <span class="n">dx2</span><span class="p">)</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">dx1</span> <span class="o">/</span> <span class="p">(</span><span class="n">dx2</span> <span class="o">*</span> <span class="p">(</span><span class="n">dx1</span> <span class="o">+</span> <span class="n">dx2</span><span class="p">))</span>
            <span class="c1"># fix the shape for broadcasting</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">a</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">shape</span>
            <span class="c1"># 1D equivalent -- out[1:-1] = a * f[:-2] + b * f[1:-1] + c * f[2:]</span>
            <span class="n">out</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slice1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">f</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slice2</span><span class="p">)]</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">f</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slice3</span><span class="p">)]</span> <span class="o">+</span> <span class="n">c</span> <span class="o">*</span> <span class="n">f</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slice4</span><span class="p">)]</span>

        <span class="c1"># Numerical differentiation: 1st order edges</span>
        <span class="k">if</span> <span class="n">edge_order</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">slice1</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">slice2</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">slice3</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">dx_0</span> <span class="o">=</span> <span class="n">ax_dx</span> <span class="k">if</span> <span class="n">uniform_spacing</span> <span class="k">else</span> <span class="n">ax_dx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># 1D equivalent -- out[0] = (f[1] - f[0]) / (x[1] - x[0])</span>
            <span class="n">out</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slice1</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slice2</span><span class="p">)]</span> <span class="o">-</span> <span class="n">f</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slice3</span><span class="p">)])</span> <span class="o">/</span> <span class="n">dx_0</span>

            <span class="n">slice1</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">slice2</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">slice3</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>
            <span class="n">dx_n</span> <span class="o">=</span> <span class="n">ax_dx</span> <span class="k">if</span> <span class="n">uniform_spacing</span> <span class="k">else</span> <span class="n">ax_dx</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># 1D equivalent -- out[-1] = (f[-1] - f[-2]) / (x[-1] - x[-2])</span>
            <span class="n">out</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slice1</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slice2</span><span class="p">)]</span> <span class="o">-</span> <span class="n">f</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slice3</span><span class="p">)])</span> <span class="o">/</span> <span class="n">dx_n</span>

        <span class="c1"># Numerical differentiation: 2nd order edges</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">slice1</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">slice2</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">slice3</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">slice4</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="k">if</span> <span class="n">uniform_spacing</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.5</span> <span class="o">/</span> <span class="n">ax_dx</span>
                <span class="n">b</span> <span class="o">=</span> <span class="mf">2.</span> <span class="o">/</span> <span class="n">ax_dx</span>
                <span class="n">c</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">/</span> <span class="n">ax_dx</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dx1</span> <span class="o">=</span> <span class="n">ax_dx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">dx2</span> <span class="o">=</span> <span class="n">ax_dx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">a</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="mf">2.</span> <span class="o">*</span> <span class="n">dx1</span> <span class="o">+</span> <span class="n">dx2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">dx1</span> <span class="o">*</span> <span class="p">(</span><span class="n">dx1</span> <span class="o">+</span> <span class="n">dx2</span><span class="p">))</span>
                <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">dx1</span> <span class="o">+</span> <span class="n">dx2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">dx1</span> <span class="o">*</span> <span class="n">dx2</span><span class="p">)</span>
                <span class="n">c</span> <span class="o">=</span> <span class="o">-</span> <span class="n">dx1</span> <span class="o">/</span> <span class="p">(</span><span class="n">dx2</span> <span class="o">*</span> <span class="p">(</span><span class="n">dx1</span> <span class="o">+</span> <span class="n">dx2</span><span class="p">))</span>
            <span class="c1"># 1D equivalent -- out[0] = a * f[0] + b * f[1] + c * f[2]</span>
            <span class="n">out</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slice1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">f</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slice2</span><span class="p">)]</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">f</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slice3</span><span class="p">)]</span> <span class="o">+</span> <span class="n">c</span> <span class="o">*</span> <span class="n">f</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slice4</span><span class="p">)]</span>

            <span class="n">slice1</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">slice2</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">3</span>
            <span class="n">slice3</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>
            <span class="n">slice4</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">if</span> <span class="n">uniform_spacing</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">/</span> <span class="n">ax_dx</span>
                <span class="n">b</span> <span class="o">=</span> <span class="o">-</span><span class="mf">2.</span> <span class="o">/</span> <span class="n">ax_dx</span>
                <span class="n">c</span> <span class="o">=</span> <span class="mf">1.5</span> <span class="o">/</span> <span class="n">ax_dx</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dx1</span> <span class="o">=</span> <span class="n">ax_dx</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">dx2</span> <span class="o">=</span> <span class="n">ax_dx</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">dx2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">dx1</span> <span class="o">*</span> <span class="p">(</span><span class="n">dx1</span> <span class="o">+</span> <span class="n">dx2</span><span class="p">))</span>
                <span class="n">b</span> <span class="o">=</span> <span class="o">-</span> <span class="p">(</span><span class="n">dx2</span> <span class="o">+</span> <span class="n">dx1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">dx1</span> <span class="o">*</span> <span class="n">dx2</span><span class="p">)</span>
                <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.</span> <span class="o">*</span> <span class="n">dx2</span> <span class="o">+</span> <span class="n">dx1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">dx2</span> <span class="o">*</span> <span class="p">(</span><span class="n">dx1</span> <span class="o">+</span> <span class="n">dx2</span><span class="p">))</span>
            <span class="c1"># 1D equivalent -- out[-1] = a * f[-3] + b * f[-2] + c * f[-1]</span>
            <span class="n">out</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slice1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">f</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slice2</span><span class="p">)]</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">f</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slice3</span><span class="p">)]</span> <span class="o">+</span> <span class="n">c</span> <span class="o">*</span> <span class="n">f</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slice4</span><span class="p">)]</span>

        <span class="n">outvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

        <span class="c1"># reset the slice object in this dimension to &quot;:&quot;</span>
        <span class="n">slice1</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">slice2</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">slice3</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">slice4</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">len_axes</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">outvals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">_using_numpy2_behavior</span><span class="p">():</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">outvals</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">outvals</span>


<span class="k">def</span> <span class="nf">_diff_dispatcher</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">prepend</span><span class="p">,</span> <span class="n">append</span><span class="p">)</span>


<span class="nd">@array_function_dispatch</span><span class="p">(</span><span class="n">_diff_dispatcher</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">diff</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the n-th discrete difference along the given axis.</span>

<span class="sd">    The first difference is given by ``out[i] = a[i+1] - a[i]`` along</span>
<span class="sd">    the given axis, higher differences are calculated by using `diff`</span>
<span class="sd">    recursively.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input array</span>
<span class="sd">    n : int, optional</span>
<span class="sd">        The number of times values are differenced. If zero, the input</span>
<span class="sd">        is returned as-is.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        The axis along which the difference is taken, default is the</span>
<span class="sd">        last axis.</span>
<span class="sd">    prepend, append : array_like, optional</span>
<span class="sd">        Values to prepend or append to `a` along axis prior to</span>
<span class="sd">        performing the difference.  Scalar values are expanded to</span>
<span class="sd">        arrays with length 1 in the direction of axis and the shape</span>
<span class="sd">        of the input array in along all other axes.  Otherwise the</span>
<span class="sd">        dimension and shape must match `a` except along axis.</span>

<span class="sd">        .. versionadded:: 1.16.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    diff : ndarray</span>
<span class="sd">        The n-th differences. The shape of the output is the same as `a`</span>
<span class="sd">        except along `axis` where the dimension is smaller by `n`. The</span>
<span class="sd">        type of the output is the same as the type of the difference</span>
<span class="sd">        between any two elements of `a`. This is the same as the type of</span>
<span class="sd">        `a` in most cases. A notable exception is `datetime64`, which</span>
<span class="sd">        results in a `timedelta64` output array.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    gradient, ediff1d, cumsum</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Type is preserved for boolean arrays, so the result will contain</span>
<span class="sd">    `False` when consecutive elements are the same and `True` when they</span>
<span class="sd">    differ.</span>

<span class="sd">    For unsigned integer arrays, the results will also be unsigned. This</span>
<span class="sd">    should not be surprising, as the result is consistent with</span>
<span class="sd">    calculating the difference directly:</span>

<span class="sd">    &gt;&gt;&gt; u8_arr = np.array([1, 0], dtype=np.uint8)</span>
<span class="sd">    &gt;&gt;&gt; np.diff(u8_arr)</span>
<span class="sd">    array([255], dtype=uint8)</span>
<span class="sd">    &gt;&gt;&gt; u8_arr[1,...] - u8_arr[0,...]</span>
<span class="sd">    255</span>

<span class="sd">    If this is not desirable, then the array should be cast to a larger</span>
<span class="sd">    integer type first:</span>

<span class="sd">    &gt;&gt;&gt; i16_arr = u8_arr.astype(np.int16)</span>
<span class="sd">    &gt;&gt;&gt; np.diff(i16_arr)</span>
<span class="sd">    array([-1], dtype=int16)</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = np.array([1, 2, 4, 7, 0])</span>
<span class="sd">    &gt;&gt;&gt; np.diff(x)</span>
<span class="sd">    array([ 1,  2,  3, -7])</span>
<span class="sd">    &gt;&gt;&gt; np.diff(x, n=2)</span>
<span class="sd">    array([  1,   1, -10])</span>

<span class="sd">    &gt;&gt;&gt; x = np.array([[1, 3, 6, 10], [0, 5, 6, 8]])</span>
<span class="sd">    &gt;&gt;&gt; np.diff(x)</span>
<span class="sd">    array([[2, 3, 4],</span>
<span class="sd">           [5, 1, 2]])</span>
<span class="sd">    &gt;&gt;&gt; np.diff(x, axis=0)</span>
<span class="sd">    array([[-1,  2,  0, -2]])</span>

<span class="sd">    &gt;&gt;&gt; x = np.arange(&#39;1066-10-13&#39;, &#39;1066-10-16&#39;, dtype=np.datetime64)</span>
<span class="sd">    &gt;&gt;&gt; np.diff(x)</span>
<span class="sd">    array([1, 1], dtype=&#39;timedelta64[D]&#39;)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">a</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;order must be non-negative but got &quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>

    <span class="n">a</span> <span class="o">=</span> <span class="n">asanyarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">nd</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span>
    <span class="k">if</span> <span class="n">nd</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;diff requires input that is at least one dimensional&quot;</span><span class="p">)</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="n">normalize_axis_index</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">nd</span><span class="p">)</span>

    <span class="n">combined</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">prepend</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">:</span>
        <span class="n">prepend</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">prepend</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">prepend</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">prepend</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">prepend</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">shape</span><span class="p">))</span>
        <span class="n">combined</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prepend</span><span class="p">)</span>

    <span class="n">combined</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">append</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">:</span>
        <span class="n">append</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">append</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">append</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">append</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">append</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">shape</span><span class="p">))</span>
        <span class="n">combined</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">append</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">combined</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">combined</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

    <span class="n">slice1</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">nd</span>
    <span class="n">slice2</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">nd</span>
    <span class="n">slice1</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">slice2</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">slice1</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">slice1</span><span class="p">)</span>
    <span class="n">slice2</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">slice2</span><span class="p">)</span>

    <span class="n">op</span> <span class="o">=</span> <span class="n">not_equal</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span> <span class="k">else</span> <span class="n">subtract</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">slice1</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="n">slice2</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">a</span>


<span class="k">def</span> <span class="nf">_interp_dispatcher</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xp</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">period</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xp</span><span class="p">,</span> <span class="n">fp</span><span class="p">)</span>


<span class="nd">@array_function_dispatch</span><span class="p">(</span><span class="n">_interp_dispatcher</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">interp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xp</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">period</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    One-dimensional linear interpolation for monotonically increasing sample points.</span>

<span class="sd">    Returns the one-dimensional piecewise linear interpolant to a function</span>
<span class="sd">    with given discrete data points (`xp`, `fp`), evaluated at `x`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array_like</span>
<span class="sd">        The x-coordinates at which to evaluate the interpolated values.</span>

<span class="sd">    xp : 1-D sequence of floats</span>
<span class="sd">        The x-coordinates of the data points, must be increasing if argument</span>
<span class="sd">        `period` is not specified. Otherwise, `xp` is internally sorted after</span>
<span class="sd">        normalizing the periodic boundaries with ``xp = xp % period``.</span>

<span class="sd">    fp : 1-D sequence of float or complex</span>
<span class="sd">        The y-coordinates of the data points, same length as `xp`.</span>

<span class="sd">    left : optional float or complex corresponding to fp</span>
<span class="sd">        Value to return for `x &lt; xp[0]`, default is `fp[0]`.</span>

<span class="sd">    right : optional float or complex corresponding to fp</span>
<span class="sd">        Value to return for `x &gt; xp[-1]`, default is `fp[-1]`.</span>

<span class="sd">    period : None or float, optional</span>
<span class="sd">        A period for the x-coordinates. This parameter allows the proper</span>
<span class="sd">        interpolation of angular x-coordinates. Parameters `left` and `right`</span>
<span class="sd">        are ignored if `period` is specified.</span>

<span class="sd">        .. versionadded:: 1.10.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : float or complex (corresponding to fp) or ndarray</span>
<span class="sd">        The interpolated values, same shape as `x`.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If `xp` and `fp` have different length</span>
<span class="sd">        If `xp` or `fp` are not 1-D sequences</span>
<span class="sd">        If `period == 0`</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    scipy.interpolate</span>

<span class="sd">    Warnings</span>
<span class="sd">    --------</span>
<span class="sd">    The x-coordinate sequence is expected to be increasing, but this is not</span>
<span class="sd">    explicitly enforced.  However, if the sequence `xp` is non-increasing,</span>
<span class="sd">    interpolation results are meaningless.</span>

<span class="sd">    Note that, since NaN is unsortable, `xp` also cannot contain NaNs.</span>

<span class="sd">    A simple check for `xp` being strictly increasing is::</span>

<span class="sd">        np.all(np.diff(xp) &gt; 0)</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; xp = [1, 2, 3]</span>
<span class="sd">    &gt;&gt;&gt; fp = [3, 2, 0]</span>
<span class="sd">    &gt;&gt;&gt; np.interp(2.5, xp, fp)</span>
<span class="sd">    1.0</span>
<span class="sd">    &gt;&gt;&gt; np.interp([0, 1, 1.5, 2.72, 3.14], xp, fp)</span>
<span class="sd">    array([3.  , 3.  , 2.5 , 0.56, 0.  ])</span>
<span class="sd">    &gt;&gt;&gt; UNDEF = -99.0</span>
<span class="sd">    &gt;&gt;&gt; np.interp(3.14, xp, fp, right=UNDEF)</span>
<span class="sd">    -99.0</span>

<span class="sd">    Plot an interpolant to the sine function:</span>

<span class="sd">    &gt;&gt;&gt; x = np.linspace(0, 2*np.pi, 10)</span>
<span class="sd">    &gt;&gt;&gt; y = np.sin(x)</span>
<span class="sd">    &gt;&gt;&gt; xvals = np.linspace(0, 2*np.pi, 50)</span>
<span class="sd">    &gt;&gt;&gt; yinterp = np.interp(xvals, x, y)</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(x, y, &#39;o&#39;)</span>
<span class="sd">    [&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(xvals, yinterp, &#39;-x&#39;)</span>
<span class="sd">    [&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    Interpolation with periodic x-coordinates:</span>

<span class="sd">    &gt;&gt;&gt; x = [-180, -170, -185, 185, -10, -5, 0, 365]</span>
<span class="sd">    &gt;&gt;&gt; xp = [190, -190, 350, -350]</span>
<span class="sd">    &gt;&gt;&gt; fp = [5, 10, 3, 4]</span>
<span class="sd">    &gt;&gt;&gt; np.interp(x, xp, fp, period=360)</span>
<span class="sd">    array([7.5 , 5.  , 8.75, 6.25, 3.  , 3.25, 3.5 , 3.75])</span>

<span class="sd">    Complex interpolation:</span>

<span class="sd">    &gt;&gt;&gt; x = [1.5, 4.0]</span>
<span class="sd">    &gt;&gt;&gt; xp = [2,3,5]</span>
<span class="sd">    &gt;&gt;&gt; fp = [1.0j, 0, 2+3j]</span>
<span class="sd">    &gt;&gt;&gt; np.interp(x, xp, fp)</span>
<span class="sd">    array([0.+1.j , 1.+1.5j])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">fp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">iscomplexobj</span><span class="p">(</span><span class="n">fp</span><span class="p">):</span>
        <span class="n">interp_func</span> <span class="o">=</span> <span class="n">compiled_interp_complex</span>
        <span class="n">input_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">complex128</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">interp_func</span> <span class="o">=</span> <span class="n">compiled_interp</span>
        <span class="n">input_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span>

    <span class="k">if</span> <span class="n">period</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">period</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;period must be a non-zero value&quot;</span><span class="p">)</span>
        <span class="n">period</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">period</span><span class="p">)</span>
        <span class="n">left</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">right</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">xp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">xp</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">fp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">input_dtype</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">xp</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">fp</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Data points must be 1-D sequences&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">xp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">fp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;fp and xp are not of the same length&quot;</span><span class="p">)</span>
        <span class="c1"># normalizing periodic boundaries</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">%</span> <span class="n">period</span>
        <span class="n">xp</span> <span class="o">=</span> <span class="n">xp</span> <span class="o">%</span> <span class="n">period</span>
        <span class="n">asort_xp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">xp</span><span class="p">)</span>
        <span class="n">xp</span> <span class="o">=</span> <span class="n">xp</span><span class="p">[</span><span class="n">asort_xp</span><span class="p">]</span>
        <span class="n">fp</span> <span class="o">=</span> <span class="n">fp</span><span class="p">[</span><span class="n">asort_xp</span><span class="p">]</span>
        <span class="n">xp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">xp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:]</span><span class="o">-</span><span class="n">period</span><span class="p">,</span> <span class="n">xp</span><span class="p">,</span> <span class="n">xp</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">period</span><span class="p">))</span>
        <span class="n">fp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">fp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:],</span> <span class="n">fp</span><span class="p">,</span> <span class="n">fp</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]))</span>

    <span class="k">return</span> <span class="n">interp_func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xp</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_angle_dispatcher</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">deg</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">z</span><span class="p">,)</span>


<span class="nd">@array_function_dispatch</span><span class="p">(</span><span class="n">_angle_dispatcher</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">angle</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">deg</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the angle of the complex argument.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    z : array_like</span>
<span class="sd">        A complex number or sequence of complex numbers.</span>
<span class="sd">    deg : bool, optional</span>
<span class="sd">        Return angle in degrees if True, radians if False (default).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    angle : ndarray or scalar</span>
<span class="sd">        The counterclockwise angle from the positive real axis on the complex</span>
<span class="sd">        plane in the range ``(-pi, pi]``, with dtype as numpy.float64.</span>

<span class="sd">        .. versionchanged:: 1.16.0</span>
<span class="sd">            This function works on subclasses of ndarray like `ma.array`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    arctan2</span>
<span class="sd">    absolute</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Although the angle of the complex number 0 is undefined, ``numpy.angle(0)``</span>
<span class="sd">    returns the value 0.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.angle([1.0, 1.0j, 1+1j])               # in radians</span>
<span class="sd">    array([ 0.        ,  1.57079633,  0.78539816]) # may vary</span>
<span class="sd">    &gt;&gt;&gt; np.angle(1+1j, deg=True)                  # in degrees</span>
<span class="sd">    45.0</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">asanyarray</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">_nx</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">):</span>
        <span class="n">zimag</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">imag</span>
        <span class="n">zreal</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">real</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">zimag</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">zreal</span> <span class="o">=</span> <span class="n">z</span>

    <span class="n">a</span> <span class="o">=</span> <span class="n">arctan2</span><span class="p">(</span><span class="n">zimag</span><span class="p">,</span> <span class="n">zreal</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">deg</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">*=</span> <span class="mi">180</span><span class="o">/</span><span class="n">pi</span>
    <span class="k">return</span> <span class="n">a</span>


<span class="k">def</span> <span class="nf">_unwrap_dispatcher</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">discont</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">period</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">p</span><span class="p">,)</span>


<span class="nd">@array_function_dispatch</span><span class="p">(</span><span class="n">_unwrap_dispatcher</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">unwrap</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">discont</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">period</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Unwrap by taking the complement of large deltas with respect to the period.</span>

<span class="sd">    This unwraps a signal `p` by changing elements which have an absolute</span>
<span class="sd">    difference from their predecessor of more than ``max(discont, period/2)``</span>
<span class="sd">    to their `period`-complementary values.</span>

<span class="sd">    For the default case where `period` is :math:`2\pi` and `discont` is</span>
<span class="sd">    :math:`\pi`, this unwraps a radian phase `p` such that adjacent differences</span>
<span class="sd">    are never greater than :math:`\pi` by adding :math:`2k\pi` for some</span>
<span class="sd">    integer :math:`k`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    p : array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    discont : float, optional</span>
<span class="sd">        Maximum discontinuity between values, default is ``period/2``.</span>
<span class="sd">        Values below ``period/2`` are treated as if they were ``period/2``.</span>
<span class="sd">        To have an effect different from the default, `discont` should be</span>
<span class="sd">        larger than ``period/2``.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Axis along which unwrap will operate, default is the last axis.</span>
<span class="sd">    period : float, optional</span>
<span class="sd">        Size of the range over which the input wraps. By default, it is</span>
<span class="sd">        ``2 pi``.</span>

<span class="sd">        .. versionadded:: 1.21.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : ndarray</span>
<span class="sd">        Output array.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    rad2deg, deg2rad</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    If the discontinuity in `p` is smaller than ``period/2``,</span>
<span class="sd">    but larger than `discont`, no unwrapping is done because taking</span>
<span class="sd">    the complement would only make the discontinuity larger.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; phase = np.linspace(0, np.pi, num=5)</span>
<span class="sd">    &gt;&gt;&gt; phase[3:] += np.pi</span>
<span class="sd">    &gt;&gt;&gt; phase</span>
<span class="sd">    array([ 0.        ,  0.78539816,  1.57079633,  5.49778714,  6.28318531]) # may vary</span>
<span class="sd">    &gt;&gt;&gt; np.unwrap(phase)</span>
<span class="sd">    array([ 0.        ,  0.78539816,  1.57079633, -0.78539816,  0.        ]) # may vary</span>
<span class="sd">    &gt;&gt;&gt; np.unwrap([0, 1, 2, -1, 0], period=4)</span>
<span class="sd">    array([0, 1, 2, 3, 4])</span>
<span class="sd">    &gt;&gt;&gt; np.unwrap([ 1, 2, 3, 4, 5, 6, 1, 2, 3], period=6)</span>
<span class="sd">    array([1, 2, 3, 4, 5, 6, 7, 8, 9])</span>
<span class="sd">    &gt;&gt;&gt; np.unwrap([2, 3, 4, 5, 2, 3, 4, 5], period=4)</span>
<span class="sd">    array([2, 3, 4, 5, 6, 7, 8, 9])</span>
<span class="sd">    &gt;&gt;&gt; phase_deg = np.mod(np.linspace(0 ,720, 19), 360) - 180</span>
<span class="sd">    &gt;&gt;&gt; np.unwrap(phase_deg, period=360)</span>
<span class="sd">    array([-180., -140., -100.,  -60.,  -20.,   20.,   60.,  100.,  140.,</span>
<span class="sd">            180.,  220.,  260.,  300.,  340.,  380.,  420.,  460.,  500.,</span>
<span class="sd">            540.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="n">nd</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">dd</span> <span class="o">=</span> <span class="n">diff</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">discont</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">discont</span> <span class="o">=</span> <span class="n">period</span><span class="o">/</span><span class="mi">2</span>
    <span class="n">slice1</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span><span class="o">*</span><span class="n">nd</span>     <span class="c1"># full slices</span>
    <span class="n">slice1</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">slice1</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">slice1</span><span class="p">)</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="n">dd</span><span class="p">,</span> <span class="n">period</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">_nx</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">_nx</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
        <span class="n">interval_high</span><span class="p">,</span> <span class="n">rem</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">period</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">boundary_ambiguous</span> <span class="o">=</span> <span class="n">rem</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">interval_high</span> <span class="o">=</span> <span class="n">period</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">boundary_ambiguous</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">interval_low</span> <span class="o">=</span> <span class="o">-</span><span class="n">interval_high</span>
    <span class="n">ddmod</span> <span class="o">=</span> <span class="n">mod</span><span class="p">(</span><span class="n">dd</span> <span class="o">-</span> <span class="n">interval_low</span><span class="p">,</span> <span class="n">period</span><span class="p">)</span> <span class="o">+</span> <span class="n">interval_low</span>
    <span class="k">if</span> <span class="n">boundary_ambiguous</span><span class="p">:</span>
        <span class="c1"># for `mask = (abs(dd) == period/2)`, the above line made</span>
        <span class="c1"># `ddmod[mask] == -period/2`. correct these such that</span>
        <span class="c1"># `ddmod[mask] == sign(dd[mask])*period/2`.</span>
        <span class="n">_nx</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">ddmod</span><span class="p">,</span> <span class="n">interval_high</span><span class="p">,</span>
                   <span class="n">where</span><span class="o">=</span><span class="p">(</span><span class="n">ddmod</span> <span class="o">==</span> <span class="n">interval_low</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">dd</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span>
    <span class="n">ph_correct</span> <span class="o">=</span> <span class="n">ddmod</span> <span class="o">-</span> <span class="n">dd</span>
    <span class="n">_nx</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">ph_correct</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="nb">abs</span><span class="p">(</span><span class="n">dd</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">discont</span><span class="p">)</span>
    <span class="n">up</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">up</span><span class="p">[</span><span class="n">slice1</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">slice1</span><span class="p">]</span> <span class="o">+</span> <span class="n">ph_correct</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">up</span>


<span class="k">def</span> <span class="nf">_sort_complex</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">a</span><span class="p">,)</span>


<span class="nd">@array_function_dispatch</span><span class="p">(</span><span class="n">_sort_complex</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">sort_complex</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sort a complex array using the real part first, then the imaginary part.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input array</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : complex ndarray</span>
<span class="sd">        Always returns a sorted complex array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.sort_complex([5, 3, 6, 2, 1])</span>
<span class="sd">    array([1.+0.j, 2.+0.j, 3.+0.j, 5.+0.j, 6.+0.j])</span>

<span class="sd">    &gt;&gt;&gt; np.sort_complex([1 + 2j, 2 - 1j, 3 - 2j, 3 - 3j, 3 + 5j])</span>
<span class="sd">    array([1.+2.j,  2.-1.j,  3.-3.j,  3.-2.j,  3.+5.j])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">b</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">_nx</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">char</span> <span class="ow">in</span> <span class="s1">&#39;bhBH&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">b</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">b</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">char</span> <span class="o">==</span> <span class="s1">&#39;g&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">b</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;G&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">b</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;D&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">b</span>


<span class="k">def</span> <span class="nf">_trim_zeros</span><span class="p">(</span><span class="n">filt</span><span class="p">,</span> <span class="n">trim</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">filt</span><span class="p">,)</span>


<span class="nd">@array_function_dispatch</span><span class="p">(</span><span class="n">_trim_zeros</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">trim_zeros</span><span class="p">(</span><span class="n">filt</span><span class="p">,</span> <span class="n">trim</span><span class="o">=</span><span class="s1">&#39;fb&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Trim the leading and/or trailing zeros from a 1-D array or sequence.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    filt : 1-D array or sequence</span>
<span class="sd">        Input array.</span>
<span class="sd">    trim : str, optional</span>
<span class="sd">        A string with &#39;f&#39; representing trim from front and &#39;b&#39; to trim from</span>
<span class="sd">        back. Default is &#39;fb&#39;, trim zeros from both front and back of the</span>
<span class="sd">        array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    trimmed : 1-D array or sequence</span>
<span class="sd">        The result of trimming the input. The input data type is preserved.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = np.array((0, 0, 0, 1, 2, 3, 0, 2, 1, 0))</span>
<span class="sd">    &gt;&gt;&gt; np.trim_zeros(a)</span>
<span class="sd">    array([1, 2, 3, 0, 2, 1])</span>

<span class="sd">    &gt;&gt;&gt; np.trim_zeros(a, &#39;b&#39;)</span>
<span class="sd">    array([0, 0, 0, ..., 0, 2, 1])</span>

<span class="sd">    The input data type is preserved, list/tuple in means list/tuple out.</span>

<span class="sd">    &gt;&gt;&gt; np.trim_zeros([0, 1, 2, 0])</span>
<span class="sd">    [1, 2]</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">first</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">trim</span> <span class="o">=</span> <span class="n">trim</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
    <span class="k">if</span> <span class="s1">&#39;F&#39;</span> <span class="ow">in</span> <span class="n">trim</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">filt</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="mf">0.</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">first</span> <span class="o">=</span> <span class="n">first</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">last</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">filt</span><span class="p">)</span>
    <span class="k">if</span> <span class="s1">&#39;B&#39;</span> <span class="ow">in</span> <span class="n">trim</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">filt</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="mf">0.</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">last</span> <span class="o">=</span> <span class="n">last</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">filt</span><span class="p">[</span><span class="n">first</span><span class="p">:</span><span class="n">last</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_extract_dispatcher</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">arr</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">arr</span><span class="p">)</span>


<span class="nd">@array_function_dispatch</span><span class="p">(</span><span class="n">_extract_dispatcher</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">extract</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">arr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the elements of an array that satisfy some condition.</span>

<span class="sd">    This is equivalent to ``np.compress(ravel(condition), ravel(arr))``.  If</span>
<span class="sd">    `condition` is boolean ``np.extract`` is equivalent to ``arr[condition]``.</span>

<span class="sd">    Note that `place` does the exact opposite of `extract`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    condition : array_like</span>
<span class="sd">        An array whose nonzero or True entries indicate the elements of `arr`</span>
<span class="sd">        to extract.</span>
<span class="sd">    arr : array_like</span>
<span class="sd">        Input array of the same size as `condition`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    extract : ndarray</span>
<span class="sd">        Rank 1 array of values from `arr` where `condition` is True.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    take, put, copyto, compress, place</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; arr = np.arange(12).reshape((3, 4))</span>
<span class="sd">    &gt;&gt;&gt; arr</span>
<span class="sd">    array([[ 0,  1,  2,  3],</span>
<span class="sd">           [ 4,  5,  6,  7],</span>
<span class="sd">           [ 8,  9, 10, 11]])</span>
<span class="sd">    &gt;&gt;&gt; condition = np.mod(arr, 3)==0</span>
<span class="sd">    &gt;&gt;&gt; condition</span>
<span class="sd">    array([[ True, False, False,  True],</span>
<span class="sd">           [False, False,  True, False],</span>
<span class="sd">           [False,  True, False, False]])</span>
<span class="sd">    &gt;&gt;&gt; np.extract(condition, arr)</span>
<span class="sd">    array([0, 3, 6, 9])</span>


<span class="sd">    If `condition` is boolean:</span>

<span class="sd">    &gt;&gt;&gt; arr[condition]</span>
<span class="sd">    array([0, 3, 6, 9])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_nx</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">ravel</span><span class="p">(</span><span class="n">arr</span><span class="p">),</span> <span class="n">nonzero</span><span class="p">(</span><span class="n">ravel</span><span class="p">(</span><span class="n">condition</span><span class="p">))[</span><span class="mi">0</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">_place_dispatcher</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">vals</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">vals</span><span class="p">)</span>


<span class="nd">@array_function_dispatch</span><span class="p">(</span><span class="n">_place_dispatcher</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">place</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">vals</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Change elements of an array based on conditional and input values.</span>

<span class="sd">    Similar to ``np.copyto(arr, vals, where=mask)``, the difference is that</span>
<span class="sd">    `place` uses the first N elements of `vals`, where N is the number of</span>
<span class="sd">    True values in `mask`, while `copyto` uses the elements where `mask`</span>
<span class="sd">    is True.</span>

<span class="sd">    Note that `extract` does the exact opposite of `place`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr : ndarray</span>
<span class="sd">        Array to put data into.</span>
<span class="sd">    mask : array_like</span>
<span class="sd">        Boolean mask array. Must have the same size as `a`.</span>
<span class="sd">    vals : 1-D sequence</span>
<span class="sd">        Values to put into `a`. Only the first N elements are used, where</span>
<span class="sd">        N is the number of True values in `mask`. If `vals` is smaller</span>
<span class="sd">        than N, it will be repeated, and if elements of `a` are to be masked,</span>
<span class="sd">        this sequence must be non-empty.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    copyto, put, take, extract</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; arr = np.arange(6).reshape(2, 3)</span>
<span class="sd">    &gt;&gt;&gt; np.place(arr, arr&gt;2, [44, 55])</span>
<span class="sd">    &gt;&gt;&gt; arr</span>
<span class="sd">    array([[ 0,  1,  2],</span>
<span class="sd">           [44, 55, 44]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_place</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">vals</span><span class="p">)</span>


<div class="viewcode-block" id="disp">
<a class="viewcode-back" href="../../../autoapi/arkouda/numpy/index.html#arkouda.numpy.disp">[docs]</a>
<span class="k">def</span> <span class="nf">disp</span><span class="p">(</span><span class="n">mesg</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">linefeed</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Display a message on a device.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mesg : str</span>
<span class="sd">        Message to display.</span>
<span class="sd">    device : object</span>
<span class="sd">        Device to write message. If None, defaults to ``sys.stdout`` which is</span>
<span class="sd">        very similar to ``print``. `device` needs to have ``write()`` and</span>
<span class="sd">        ``flush()`` methods.</span>
<span class="sd">    linefeed : bool, optional</span>
<span class="sd">        Option whether to print a line feed or not. Defaults to True.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    AttributeError</span>
<span class="sd">        If `device` does not have a ``write()`` or ``flush()`` method.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Besides ``sys.stdout``, a file-like object can also be used as it has</span>
<span class="sd">    both required methods:</span>

<span class="sd">    &gt;&gt;&gt; from io import StringIO</span>
<span class="sd">    &gt;&gt;&gt; buf = StringIO()</span>
<span class="sd">    &gt;&gt;&gt; np.disp(u&#39;&quot;Display&quot; in a file&#39;, device=buf)</span>
<span class="sd">    &gt;&gt;&gt; buf.getvalue()</span>
<span class="sd">    &#39;&quot;Display&quot; in a file\\n&#39;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">device</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">device</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span>
    <span class="k">if</span> <span class="n">linefeed</span><span class="p">:</span>
        <span class="n">device</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">mesg</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">device</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">mesg</span><span class="p">)</span>
    <span class="n">device</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
    <span class="k">return</span></div>



<span class="c1"># See https://docs.scipy.org/doc/numpy/reference/c-api.generalized-ufuncs.html</span>
<span class="n">_DIMENSION_NAME</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;\w+&#39;</span>
<span class="n">_CORE_DIMENSION_LIST</span> <span class="o">=</span> <span class="s1">&#39;(?:</span><span class="si">{0:}</span><span class="s1">(?:,</span><span class="si">{0:}</span><span class="s1">)*)?&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">_DIMENSION_NAME</span><span class="p">)</span>
<span class="n">_ARGUMENT</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;\(</span><span class="si">{}</span><span class="s1">\)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">_CORE_DIMENSION_LIST</span><span class="p">)</span>
<span class="n">_ARGUMENT_LIST</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{0:}</span><span class="s1">(?:,</span><span class="si">{0:}</span><span class="s1">)*&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">_ARGUMENT</span><span class="p">)</span>
<span class="n">_SIGNATURE</span> <span class="o">=</span> <span class="s1">&#39;^</span><span class="si">{0:}</span><span class="s1">-&gt;</span><span class="si">{0:}</span><span class="s1">$&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">_ARGUMENT_LIST</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_parse_gufunc_signature</span><span class="p">(</span><span class="n">signature</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parse string signatures for a generalized universal function.</span>

<span class="sd">    Arguments</span>
<span class="sd">    ---------</span>
<span class="sd">    signature : string</span>
<span class="sd">        Generalized universal function signature, e.g., ``(m,n),(n,p)-&gt;(m,p)``</span>
<span class="sd">        for ``np.matmul``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Tuple of input and output core dimensions parsed from the signature, each</span>
<span class="sd">    of the form List[Tuple[str, ...]].</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">signature</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\s+&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">signature</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">_SIGNATURE</span><span class="p">,</span> <span class="n">signature</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;not a valid gufunc signature: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">signature</span><span class="p">))</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">([</span><span class="nb">tuple</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">_DIMENSION_NAME</span><span class="p">,</span> <span class="n">arg</span><span class="p">))</span>
                  <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">_ARGUMENT</span><span class="p">,</span> <span class="n">arg_list</span><span class="p">)]</span>
                 <span class="k">for</span> <span class="n">arg_list</span> <span class="ow">in</span> <span class="n">signature</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;-&gt;&#39;</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_update_dim_sizes</span><span class="p">(</span><span class="n">dim_sizes</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">core_dims</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Incrementally check and update core dimension sizes for a single argument.</span>

<span class="sd">    Arguments</span>
<span class="sd">    ---------</span>
<span class="sd">    dim_sizes : Dict[str, int]</span>
<span class="sd">        Sizes of existing core dimensions. Will be updated in-place.</span>
<span class="sd">    arg : ndarray</span>
<span class="sd">        Argument to examine.</span>
<span class="sd">    core_dims : Tuple[str, ...]</span>
<span class="sd">        Core dimensions for this argument.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">core_dims</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="n">num_core_dims</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">core_dims</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">arg</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="n">num_core_dims</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;</span><span class="si">%d</span><span class="s1">-dimensional argument does not have enough &#39;</span>
            <span class="s1">&#39;dimensions for all core dimensions </span><span class="si">%r</span><span class="s1">&#39;</span>
            <span class="o">%</span> <span class="p">(</span><span class="n">arg</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="n">core_dims</span><span class="p">))</span>

    <span class="n">core_shape</span> <span class="o">=</span> <span class="n">arg</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="n">num_core_dims</span><span class="p">:]</span>
    <span class="k">for</span> <span class="n">dim</span><span class="p">,</span> <span class="n">size</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">core_dims</span><span class="p">,</span> <span class="n">core_shape</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">dim_sizes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">size</span> <span class="o">!=</span> <span class="n">dim_sizes</span><span class="p">[</span><span class="n">dim</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;inconsistent size for core dimension </span><span class="si">%r</span><span class="s1">: </span><span class="si">%r</span><span class="s1"> vs </span><span class="si">%r</span><span class="s1">&#39;</span>
                    <span class="o">%</span> <span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">dim_sizes</span><span class="p">[</span><span class="n">dim</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dim_sizes</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">size</span>


<span class="k">def</span> <span class="nf">_parse_input_dimensions</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">input_core_dims</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parse broadcast and core dimensions for vectorize with a signature.</span>

<span class="sd">    Arguments</span>
<span class="sd">    ---------</span>
<span class="sd">    args : Tuple[ndarray, ...]</span>
<span class="sd">        Tuple of input arguments to examine.</span>
<span class="sd">    input_core_dims : List[Tuple[str, ...]]</span>
<span class="sd">        List of core dimensions corresponding to each input.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    broadcast_shape : Tuple[int, ...]</span>
<span class="sd">        Common shape to broadcast all non-core dimensions to.</span>
<span class="sd">    dim_sizes : Dict[str, int]</span>
<span class="sd">        Common sizes for named core dimensions.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">broadcast_args</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">dim_sizes</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">arg</span><span class="p">,</span> <span class="n">core_dims</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">input_core_dims</span><span class="p">):</span>
        <span class="n">_update_dim_sizes</span><span class="p">(</span><span class="n">dim_sizes</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">core_dims</span><span class="p">)</span>
        <span class="n">ndim</span> <span class="o">=</span> <span class="n">arg</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">core_dims</span><span class="p">)</span>
        <span class="n">dummy_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">stride_tricks</span><span class="o">.</span><span class="n">as_strided</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">arg</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">ndim</span><span class="p">])</span>
        <span class="n">broadcast_args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dummy_array</span><span class="p">)</span>
    <span class="n">broadcast_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">stride_tricks</span><span class="o">.</span><span class="n">_broadcast_shape</span><span class="p">(</span><span class="o">*</span><span class="n">broadcast_args</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">broadcast_shape</span><span class="p">,</span> <span class="n">dim_sizes</span>


<span class="k">def</span> <span class="nf">_calculate_shapes</span><span class="p">(</span><span class="n">broadcast_shape</span><span class="p">,</span> <span class="n">dim_sizes</span><span class="p">,</span> <span class="n">list_of_core_dims</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Helper for calculating broadcast shapes with core dimensions.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">broadcast_shape</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">dim_sizes</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">core_dims</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">core_dims</span> <span class="ow">in</span> <span class="n">list_of_core_dims</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_create_arrays</span><span class="p">(</span><span class="n">broadcast_shape</span><span class="p">,</span> <span class="n">dim_sizes</span><span class="p">,</span> <span class="n">list_of_core_dims</span><span class="p">,</span> <span class="n">dtypes</span><span class="p">,</span>
                   <span class="n">results</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Helper for creating output arrays in vectorize.&quot;&quot;&quot;</span>
    <span class="n">shapes</span> <span class="o">=</span> <span class="n">_calculate_shapes</span><span class="p">(</span><span class="n">broadcast_shape</span><span class="p">,</span> <span class="n">dim_sizes</span><span class="p">,</span> <span class="n">list_of_core_dims</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dtypes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dtypes</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">shapes</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">results</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">arrays</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
                       <span class="k">for</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">shapes</span><span class="p">,</span> <span class="n">dtypes</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">arrays</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
                       <span class="k">for</span> <span class="n">result</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span>
                       <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">shapes</span><span class="p">,</span> <span class="n">dtypes</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">arrays</span>


<span class="nd">@set_module</span><span class="p">(</span><span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">vectorize</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    vectorize(pyfunc=np._NoValue, otypes=None, doc=None, excluded=None,</span>
<span class="sd">    cache=False, signature=None)</span>

<span class="sd">    Returns an object that acts like pyfunc, but takes arrays as input.</span>

<span class="sd">    Define a vectorized function which takes a nested sequence of objects or</span>
<span class="sd">    numpy arrays as inputs and returns a single numpy array or a tuple of numpy</span>
<span class="sd">    arrays. The vectorized function evaluates `pyfunc` over successive tuples</span>
<span class="sd">    of the input arrays like the python map function, except it uses the</span>
<span class="sd">    broadcasting rules of numpy.</span>

<span class="sd">    The data type of the output of `vectorized` is determined by calling</span>
<span class="sd">    the function with the first element of the input.  This can be avoided</span>
<span class="sd">    by specifying the `otypes` argument.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pyfunc : callable, optional</span>
<span class="sd">        A python function or method.</span>
<span class="sd">        Can be omitted to produce a decorator with keyword arguments.</span>
<span class="sd">    otypes : str or list of dtypes, optional</span>
<span class="sd">        The output data type. It must be specified as either a string of</span>
<span class="sd">        typecode characters or a list of data type specifiers. There should</span>
<span class="sd">        be one data type specifier for each output.</span>
<span class="sd">    doc : str, optional</span>
<span class="sd">        The docstring for the function. If None, the docstring will be the</span>
<span class="sd">        ``pyfunc.__doc__``.</span>
<span class="sd">    excluded : set, optional</span>
<span class="sd">        Set of strings or integers representing the positional or keyword</span>
<span class="sd">        arguments for which the function will not be vectorized.  These will be</span>
<span class="sd">        passed directly to `pyfunc` unmodified.</span>

<span class="sd">        .. versionadded:: 1.7.0</span>

<span class="sd">    cache : bool, optional</span>
<span class="sd">        If `True`, then cache the first function call that determines the number</span>
<span class="sd">        of outputs if `otypes` is not provided.</span>

<span class="sd">        .. versionadded:: 1.7.0</span>

<span class="sd">    signature : string, optional</span>
<span class="sd">        Generalized universal function signature, e.g., ``(m,n),(n)-&gt;(m)`` for</span>
<span class="sd">        vectorized matrix-vector multiplication. If provided, ``pyfunc`` will</span>
<span class="sd">        be called with (and expected to return) arrays with shapes given by the</span>
<span class="sd">        size of corresponding core dimensions. By default, ``pyfunc`` is</span>
<span class="sd">        assumed to take scalars as input and output.</span>

<span class="sd">        .. versionadded:: 1.12.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : callable</span>
<span class="sd">        A vectorized function if ``pyfunc`` was provided,</span>
<span class="sd">        a decorator otherwise.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    frompyfunc : Takes an arbitrary Python function and returns a ufunc</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The `vectorize` function is provided primarily for convenience, not for</span>
<span class="sd">    performance. The implementation is essentially a for loop.</span>

<span class="sd">    If `otypes` is not specified, then a call to the function with the</span>
<span class="sd">    first argument will be used to determine the number of outputs.  The</span>
<span class="sd">    results of this call will be cached if `cache` is `True` to prevent</span>
<span class="sd">    calling the function twice.  However, to implement the cache, the</span>
<span class="sd">    original function must be wrapped which will slow down subsequent</span>
<span class="sd">    calls, so only do this if your function is expensive.</span>

<span class="sd">    The new keyword argument interface and `excluded` argument support</span>
<span class="sd">    further degrades performance.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] :doc:`/reference/c-api/generalized-ufuncs`</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; def myfunc(a, b):</span>
<span class="sd">    ...     &quot;Return a-b if a&gt;b, otherwise return a+b&quot;</span>
<span class="sd">    ...     if a &gt; b:</span>
<span class="sd">    ...         return a - b</span>
<span class="sd">    ...     else:</span>
<span class="sd">    ...         return a + b</span>

<span class="sd">    &gt;&gt;&gt; vfunc = np.vectorize(myfunc)</span>
<span class="sd">    &gt;&gt;&gt; vfunc([1, 2, 3, 4], 2)</span>
<span class="sd">    array([3, 4, 1, 2])</span>

<span class="sd">    The docstring is taken from the input function to `vectorize` unless it</span>
<span class="sd">    is specified:</span>

<span class="sd">    &gt;&gt;&gt; vfunc.__doc__</span>
<span class="sd">    &#39;Return a-b if a&gt;b, otherwise return a+b&#39;</span>
<span class="sd">    &gt;&gt;&gt; vfunc = np.vectorize(myfunc, doc=&#39;Vectorized `myfunc`&#39;)</span>
<span class="sd">    &gt;&gt;&gt; vfunc.__doc__</span>
<span class="sd">    &#39;Vectorized `myfunc`&#39;</span>

<span class="sd">    The output type is determined by evaluating the first element of the input,</span>
<span class="sd">    unless it is specified:</span>

<span class="sd">    &gt;&gt;&gt; out = vfunc([1, 2, 3, 4], 2)</span>
<span class="sd">    &gt;&gt;&gt; type(out[0])</span>
<span class="sd">    &lt;class &#39;numpy.int64&#39;&gt;</span>
<span class="sd">    &gt;&gt;&gt; vfunc = np.vectorize(myfunc, otypes=[float])</span>
<span class="sd">    &gt;&gt;&gt; out = vfunc([1, 2, 3, 4], 2)</span>
<span class="sd">    &gt;&gt;&gt; type(out[0])</span>
<span class="sd">    &lt;class &#39;numpy.float64&#39;&gt;</span>

<span class="sd">    The `excluded` argument can be used to prevent vectorizing over certain</span>
<span class="sd">    arguments.  This can be useful for array-like arguments of a fixed length</span>
<span class="sd">    such as the coefficients for a polynomial as in `polyval`:</span>

<span class="sd">    &gt;&gt;&gt; def mypolyval(p, x):</span>
<span class="sd">    ...     _p = list(p)</span>
<span class="sd">    ...     res = _p.pop(0)</span>
<span class="sd">    ...     while _p:</span>
<span class="sd">    ...         res = res*x + _p.pop(0)</span>
<span class="sd">    ...     return res</span>
<span class="sd">    &gt;&gt;&gt; vpolyval = np.vectorize(mypolyval, excluded=[&#39;p&#39;])</span>
<span class="sd">    &gt;&gt;&gt; vpolyval(p=[1, 2, 3], x=[0, 1])</span>
<span class="sd">    array([3, 6])</span>

<span class="sd">    Positional arguments may also be excluded by specifying their position:</span>

<span class="sd">    &gt;&gt;&gt; vpolyval.excluded.add(0)</span>
<span class="sd">    &gt;&gt;&gt; vpolyval([1, 2, 3], x=[0, 1])</span>
<span class="sd">    array([3, 6])</span>

<span class="sd">    The `signature` argument allows for vectorizing functions that act on</span>
<span class="sd">    non-scalar arrays of fixed length. For example, you can use it for a</span>
<span class="sd">    vectorized calculation of Pearson correlation coefficient and its p-value:</span>

<span class="sd">    &gt;&gt;&gt; import scipy.stats</span>
<span class="sd">    &gt;&gt;&gt; pearsonr = np.vectorize(scipy.stats.pearsonr,</span>
<span class="sd">    ...                 signature=&#39;(n),(n)-&gt;(),()&#39;)</span>
<span class="sd">    &gt;&gt;&gt; pearsonr([[0, 1, 2, 3]], [[1, 2, 3, 4], [4, 3, 2, 1]])</span>
<span class="sd">    (array([ 1., -1.]), array([ 0.,  0.]))</span>

<span class="sd">    Or for a vectorized convolution:</span>

<span class="sd">    &gt;&gt;&gt; convolve = np.vectorize(np.convolve, signature=&#39;(n),(m)-&gt;(k)&#39;)</span>
<span class="sd">    &gt;&gt;&gt; convolve(np.eye(4), [1, 2, 1])</span>
<span class="sd">    array([[1., 2., 1., 0., 0., 0.],</span>
<span class="sd">           [0., 1., 2., 1., 0., 0.],</span>
<span class="sd">           [0., 0., 1., 2., 1., 0.],</span>
<span class="sd">           [0., 0., 0., 1., 2., 1.]])</span>

<span class="sd">    Decorator syntax is supported.  The decorator can be called as</span>
<span class="sd">    a function to provide keyword arguments.</span>
<span class="sd">    &gt;&gt;&gt;@np.vectorize</span>
<span class="sd">    ...def identity(x):</span>
<span class="sd">    ...    return x</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt;identity([0, 1, 2])</span>
<span class="sd">    array([0, 1, 2])</span>
<span class="sd">    &gt;&gt;&gt;@np.vectorize(otypes=[float])</span>
<span class="sd">    ...def as_float(x):</span>
<span class="sd">    ...    return x</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt;as_float([0, 1, 2])</span>
<span class="sd">    array([0., 1., 2.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pyfunc</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">,</span> <span class="n">otypes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">excluded</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">signature</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">pyfunc</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">callable</span><span class="p">(</span><span class="n">pyfunc</span><span class="p">)):</span>
            <span class="c1">#Splitting the error message to keep</span>
            <span class="c1">#the length below 79 characters.</span>
            <span class="n">part1</span> <span class="o">=</span> <span class="s2">&quot;When used as a decorator, &quot;</span>
            <span class="n">part2</span> <span class="o">=</span> <span class="s2">&quot;only accepts keyword arguments.&quot;</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">part1</span> <span class="o">+</span> <span class="n">part2</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pyfunc</span> <span class="o">=</span> <span class="n">pyfunc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cache</span> <span class="o">=</span> <span class="n">cache</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">signature</span> <span class="o">=</span> <span class="n">signature</span>
        <span class="k">if</span> <span class="n">pyfunc</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">pyfunc</span><span class="p">,</span> <span class="s1">&#39;__name__&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">pyfunc</span><span class="o">.</span><span class="vm">__name__</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_ufunc</span> <span class="o">=</span> <span class="p">{}</span>    <span class="c1"># Caching to improve default performance</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_doc</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">doc</span>
        <span class="k">if</span> <span class="n">doc</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">pyfunc</span><span class="p">,</span> <span class="s1">&#39;__doc__&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">pyfunc</span><span class="o">.</span><span class="vm">__doc__</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_doc</span> <span class="o">=</span> <span class="n">doc</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">otypes</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">otypes</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">char</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">typecodes</span><span class="p">[</span><span class="s1">&#39;All&#39;</span><span class="p">]:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid otype specified: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">char</span><span class="p">,))</span>
        <span class="k">elif</span> <span class="n">iterable</span><span class="p">(</span><span class="n">otypes</span><span class="p">):</span>
            <span class="n">otypes</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">_nx</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">char</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">otypes</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">otypes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid otype specification&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">otypes</span> <span class="o">=</span> <span class="n">otypes</span>

        <span class="c1"># Excluded variable support</span>
        <span class="k">if</span> <span class="n">excluded</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">excluded</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">excluded</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">excluded</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">signature</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_in_and_out_core_dims</span> <span class="o">=</span> <span class="n">_parse_gufunc_signature</span><span class="p">(</span><span class="n">signature</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_in_and_out_core_dims</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_init_stage_2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pyfunc</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">pyfunc</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pyfunc</span> <span class="o">=</span> <span class="n">pyfunc</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_doc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">pyfunc</span><span class="o">.</span><span class="vm">__doc__</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_doc</span>

    <span class="k">def</span> <span class="nf">_call_as_normal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return arrays with the results of `pyfunc` broadcast (vectorized) over</span>
<span class="sd">        `args` and `kwargs` not in `excluded`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">excluded</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">excluded</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">kwargs</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">excluded</span><span class="p">:</span>
            <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pyfunc</span>
            <span class="n">vargs</span> <span class="o">=</span> <span class="n">args</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># The wrapper accepts only positional arguments: we use `names` and</span>
            <span class="c1"># `inds` to mutate `the_args` and `kwargs` to pass to the original</span>
            <span class="c1"># function.</span>
            <span class="n">nargs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

            <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">_n</span> <span class="k">for</span> <span class="n">_n</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">if</span> <span class="n">_n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">excluded</span><span class="p">]</span>
            <span class="n">inds</span> <span class="o">=</span> <span class="p">[</span><span class="n">_i</span> <span class="k">for</span> <span class="n">_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nargs</span><span class="p">)</span> <span class="k">if</span> <span class="n">_i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">excluded</span><span class="p">]</span>
            <span class="n">the_args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="o">*</span><span class="n">vargs</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">_n</span><span class="p">,</span> <span class="n">_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">inds</span><span class="p">):</span>
                    <span class="n">the_args</span><span class="p">[</span><span class="n">_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">vargs</span><span class="p">[</span><span class="n">_n</span><span class="p">]</span>
                <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">vargs</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">inds</span><span class="p">):]))</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pyfunc</span><span class="p">(</span><span class="o">*</span><span class="n">the_args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="n">vargs</span> <span class="o">=</span> <span class="p">[</span><span class="n">args</span><span class="p">[</span><span class="n">_i</span><span class="p">]</span> <span class="k">for</span> <span class="n">_i</span> <span class="ow">in</span> <span class="n">inds</span><span class="p">]</span>
            <span class="n">vargs</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">kwargs</span><span class="p">[</span><span class="n">_n</span><span class="p">]</span> <span class="k">for</span> <span class="n">_n</span> <span class="ow">in</span> <span class="n">names</span><span class="p">])</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vectorize_call</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="n">vargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pyfunc</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_init_stage_2</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_call_as_normal</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_ufunc_and_otypes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return (ufunc, otypes).&quot;&quot;&quot;</span>
        <span class="c1"># frompyfunc will fail if args is empty</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;args can not be empty&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">otypes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">otypes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">otypes</span>

            <span class="c1"># self._ufunc is a dictionary whose keys are the number of</span>
            <span class="c1"># arguments (i.e. len(args)) and whose values are ufuncs created</span>
            <span class="c1"># by frompyfunc. len(args) can be different for different calls if</span>
            <span class="c1"># self.pyfunc has parameters with default values.  We only use the</span>
            <span class="c1"># cache when func is self.pyfunc, which occurs when the call uses</span>
            <span class="c1"># only positional arguments and no arguments are excluded.</span>

            <span class="n">nin</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
            <span class="n">nout</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">otypes</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">pyfunc</span> <span class="ow">or</span> <span class="n">nin</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ufunc</span><span class="p">:</span>
                <span class="n">ufunc</span> <span class="o">=</span> <span class="n">frompyfunc</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">nin</span><span class="p">,</span> <span class="n">nout</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ufunc</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># We&#39;ll get it from self._ufunc</span>
            <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">pyfunc</span><span class="p">:</span>
                <span class="n">ufunc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ufunc</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">nin</span><span class="p">,</span> <span class="n">ufunc</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Get number of outputs and output types by calling the function on</span>
            <span class="c1"># the first entries of args.  We also cache the result to prevent</span>
            <span class="c1"># the subsequent call when the ufunc is evaluated.</span>
            <span class="c1"># Assumes that ufunc first evaluates the 0th elements in the input</span>
            <span class="c1"># arrays (the input values are not checked to ensure this)</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">asarray</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">builtins</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">arg</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;cannot call `vectorize` on size 0 inputs &#39;</span>
                                 <span class="s1">&#39;unless `otypes` is set&#39;</span><span class="p">)</span>

            <span class="n">inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">arg</span><span class="o">.</span><span class="n">flat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
            <span class="n">outputs</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">inputs</span><span class="p">)</span>

            <span class="c1"># Performance note: profiling indicates that -- for simple</span>
            <span class="c1"># functions at least -- this wrapping can almost double the</span>
            <span class="c1"># execution time.</span>
            <span class="c1"># Hence we make it optional.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">:</span>
                <span class="n">_cache</span> <span class="o">=</span> <span class="p">[</span><span class="n">outputs</span><span class="p">]</span>

                <span class="k">def</span> <span class="nf">_func</span><span class="p">(</span><span class="o">*</span><span class="n">vargs</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">_cache</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">_cache</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">vargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_func</span> <span class="o">=</span> <span class="n">func</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="n">nout</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nout</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">outputs</span> <span class="o">=</span> <span class="p">(</span><span class="n">outputs</span><span class="p">,)</span>

            <span class="n">otypes</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">asarray</span><span class="p">(</span><span class="n">outputs</span><span class="p">[</span><span class="n">_k</span><span class="p">])</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">char</span>
                              <span class="k">for</span> <span class="n">_k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nout</span><span class="p">)])</span>

            <span class="c1"># Performance note: profiling indicates that creating the ufunc is</span>
            <span class="c1"># not a significant cost compared with wrapping so it seems not</span>
            <span class="c1"># worth trying to cache this.</span>
            <span class="n">ufunc</span> <span class="o">=</span> <span class="n">frompyfunc</span><span class="p">(</span><span class="n">_func</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">),</span> <span class="n">nout</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ufunc</span><span class="p">,</span> <span class="n">otypes</span>

    <span class="k">def</span> <span class="nf">_vectorize_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Vectorized call to `func` over positional `args`.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">signature</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vectorize_call_with_signature</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">args</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">func</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ufunc</span><span class="p">,</span> <span class="n">otypes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_ufunc_and_otypes</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="n">args</span><span class="p">)</span>

            <span class="c1"># Convert args to object arrays first</span>
            <span class="n">inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>

            <span class="n">outputs</span> <span class="o">=</span> <span class="n">ufunc</span><span class="p">(</span><span class="o">*</span><span class="n">inputs</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">ufunc</span><span class="o">.</span><span class="n">nout</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">asanyarray</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">otypes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">t</span><span class="p">)</span>
                             <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="n">otypes</span><span class="p">)])</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span> <span class="nf">_vectorize_call_with_signature</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Vectorized call over positional arguments with a signature.&quot;&quot;&quot;</span>
        <span class="n">input_core_dims</span><span class="p">,</span> <span class="n">output_core_dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_in_and_out_core_dims</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_core_dims</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;wrong number of positional arguments: &#39;</span>
                            <span class="s1">&#39;expected </span><span class="si">%r</span><span class="s1">, got </span><span class="si">%r</span><span class="s1">&#39;</span>
                            <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">input_core_dims</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)))</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">)</span>

        <span class="n">broadcast_shape</span><span class="p">,</span> <span class="n">dim_sizes</span> <span class="o">=</span> <span class="n">_parse_input_dimensions</span><span class="p">(</span>
            <span class="n">args</span><span class="p">,</span> <span class="n">input_core_dims</span><span class="p">)</span>
        <span class="n">input_shapes</span> <span class="o">=</span> <span class="n">_calculate_shapes</span><span class="p">(</span><span class="n">broadcast_shape</span><span class="p">,</span> <span class="n">dim_sizes</span><span class="p">,</span>
                                         <span class="n">input_core_dims</span><span class="p">)</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">arg</span><span class="p">,</span> <span class="n">shape</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">input_shapes</span><span class="p">)]</span>

        <span class="n">outputs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">otypes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">otypes</span>
        <span class="n">nout</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">output_core_dims</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndindex</span><span class="p">(</span><span class="o">*</span><span class="n">broadcast_shape</span><span class="p">):</span>
            <span class="n">results</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">arg</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">))</span>

            <span class="n">n_results</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">results</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="k">else</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="n">nout</span> <span class="o">!=</span> <span class="n">n_results</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;wrong number of outputs from pyfunc: expected </span><span class="si">%r</span><span class="s1">, got </span><span class="si">%r</span><span class="s1">&#39;</span>
                    <span class="o">%</span> <span class="p">(</span><span class="n">nout</span><span class="p">,</span> <span class="n">n_results</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">nout</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">results</span> <span class="o">=</span> <span class="p">(</span><span class="n">results</span><span class="p">,)</span>

            <span class="k">if</span> <span class="n">outputs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">result</span><span class="p">,</span> <span class="n">core_dims</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">output_core_dims</span><span class="p">):</span>
                    <span class="n">_update_dim_sizes</span><span class="p">(</span><span class="n">dim_sizes</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">core_dims</span><span class="p">)</span>

                <span class="n">outputs</span> <span class="o">=</span> <span class="n">_create_arrays</span><span class="p">(</span><span class="n">broadcast_shape</span><span class="p">,</span> <span class="n">dim_sizes</span><span class="p">,</span>
                                         <span class="n">output_core_dims</span><span class="p">,</span> <span class="n">otypes</span><span class="p">,</span> <span class="n">results</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">output</span><span class="p">,</span> <span class="n">result</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="n">results</span><span class="p">):</span>
                <span class="n">output</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>

        <span class="k">if</span> <span class="n">outputs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># did not call the function even once</span>
            <span class="k">if</span> <span class="n">otypes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;cannot call `vectorize` on size 0 inputs &#39;</span>
                                 <span class="s1">&#39;unless `otypes` is set&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">builtins</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">dim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dim_sizes</span>
                            <span class="k">for</span> <span class="n">dims</span> <span class="ow">in</span> <span class="n">output_core_dims</span>
                            <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;cannot call `vectorize` with a signature &#39;</span>
                                 <span class="s1">&#39;including new output dimensions on size 0 &#39;</span>
                                 <span class="s1">&#39;inputs&#39;</span><span class="p">)</span>
            <span class="n">outputs</span> <span class="o">=</span> <span class="n">_create_arrays</span><span class="p">(</span><span class="n">broadcast_shape</span><span class="p">,</span> <span class="n">dim_sizes</span><span class="p">,</span>
                                     <span class="n">output_core_dims</span><span class="p">,</span> <span class="n">otypes</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">nout</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">outputs</span>


<span class="k">def</span> <span class="nf">_cov_dispatcher</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rowvar</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">fweights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">aweights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">fweights</span><span class="p">,</span> <span class="n">aweights</span><span class="p">)</span>


<span class="nd">@array_function_dispatch</span><span class="p">(</span><span class="n">_cov_dispatcher</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">cov</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rowvar</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fweights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">aweights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Estimate a covariance matrix, given data and weights.</span>

<span class="sd">    Covariance indicates the level to which two variables vary together.</span>
<span class="sd">    If we examine N-dimensional samples, :math:`X = [x_1, x_2, ... x_N]^T`,</span>
<span class="sd">    then the covariance matrix element :math:`C_{ij}` is the covariance of</span>
<span class="sd">    :math:`x_i` and :math:`x_j`. The element :math:`C_{ii}` is the variance</span>
<span class="sd">    of :math:`x_i`.</span>

<span class="sd">    See the notes for an outline of the algorithm.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    m : array_like</span>
<span class="sd">        A 1-D or 2-D array containing multiple variables and observations.</span>
<span class="sd">        Each row of `m` represents a variable, and each column a single</span>
<span class="sd">        observation of all those variables. Also see `rowvar` below.</span>
<span class="sd">    y : array_like, optional</span>
<span class="sd">        An additional set of variables and observations. `y` has the same form</span>
<span class="sd">        as that of `m`.</span>
<span class="sd">    rowvar : bool, optional</span>
<span class="sd">        If `rowvar` is True (default), then each row represents a</span>
<span class="sd">        variable, with observations in the columns. Otherwise, the relationship</span>
<span class="sd">        is transposed: each column represents a variable, while the rows</span>
<span class="sd">        contain observations.</span>
<span class="sd">    bias : bool, optional</span>
<span class="sd">        Default normalization (False) is by ``(N - 1)``, where ``N`` is the</span>
<span class="sd">        number of observations given (unbiased estimate). If `bias` is True,</span>
<span class="sd">        then normalization is by ``N``. These values can be overridden by using</span>
<span class="sd">        the keyword ``ddof`` in numpy versions &gt;= 1.5.</span>
<span class="sd">    ddof : int, optional</span>
<span class="sd">        If not ``None`` the default value implied by `bias` is overridden.</span>
<span class="sd">        Note that ``ddof=1`` will return the unbiased estimate, even if both</span>
<span class="sd">        `fweights` and `aweights` are specified, and ``ddof=0`` will return</span>
<span class="sd">        the simple average. See the notes for the details. The default value</span>
<span class="sd">        is ``None``.</span>

<span class="sd">        .. versionadded:: 1.5</span>
<span class="sd">    fweights : array_like, int, optional</span>
<span class="sd">        1-D array of integer frequency weights; the number of times each</span>
<span class="sd">        observation vector should be repeated.</span>

<span class="sd">        .. versionadded:: 1.10</span>
<span class="sd">    aweights : array_like, optional</span>
<span class="sd">        1-D array of observation vector weights. These relative weights are</span>
<span class="sd">        typically large for observations considered &quot;important&quot; and smaller for</span>
<span class="sd">        observations considered less &quot;important&quot;. If ``ddof=0`` the array of</span>
<span class="sd">        weights can be used to assign probabilities to observation vectors.</span>

<span class="sd">        .. versionadded:: 1.10</span>
<span class="sd">    dtype : data-type, optional</span>
<span class="sd">        Data-type of the result. By default, the return data-type will have</span>
<span class="sd">        at least `numpy.float64` precision.</span>

<span class="sd">        .. versionadded:: 1.20</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : ndarray</span>
<span class="sd">        The covariance matrix of the variables.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    corrcoef : Normalized covariance matrix</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Assume that the observations are in the columns of the observation</span>
<span class="sd">    array `m` and let ``f = fweights`` and ``a = aweights`` for brevity. The</span>
<span class="sd">    steps to compute the weighted covariance are as follows::</span>

<span class="sd">        &gt;&gt;&gt; m = np.arange(10, dtype=np.float64)</span>
<span class="sd">        &gt;&gt;&gt; f = np.arange(10) * 2</span>
<span class="sd">        &gt;&gt;&gt; a = np.arange(10) ** 2.</span>
<span class="sd">        &gt;&gt;&gt; ddof = 1</span>
<span class="sd">        &gt;&gt;&gt; w = f * a</span>
<span class="sd">        &gt;&gt;&gt; v1 = np.sum(w)</span>
<span class="sd">        &gt;&gt;&gt; v2 = np.sum(w * a)</span>
<span class="sd">        &gt;&gt;&gt; m -= np.sum(m * w, axis=None, keepdims=True) / v1</span>
<span class="sd">        &gt;&gt;&gt; cov = np.dot(m * w, m.T) * v1 / (v1**2 - ddof * v2)</span>

<span class="sd">    Note that when ``a == 1``, the normalization factor</span>
<span class="sd">    ``v1 / (v1**2 - ddof * v2)`` goes over to ``1 / (np.sum(f) - ddof)``</span>
<span class="sd">    as it should.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Consider two variables, :math:`x_0` and :math:`x_1`, which</span>
<span class="sd">    correlate perfectly, but in opposite directions:</span>

<span class="sd">    &gt;&gt;&gt; x = np.array([[0, 2], [1, 1], [2, 0]]).T</span>
<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    array([[0, 1, 2],</span>
<span class="sd">           [2, 1, 0]])</span>

<span class="sd">    Note how :math:`x_0` increases while :math:`x_1` decreases. The covariance</span>
<span class="sd">    matrix shows this clearly:</span>

<span class="sd">    &gt;&gt;&gt; np.cov(x)</span>
<span class="sd">    array([[ 1., -1.],</span>
<span class="sd">           [-1.,  1.]])</span>

<span class="sd">    Note that element :math:`C_{0,1}`, which shows the correlation between</span>
<span class="sd">    :math:`x_0` and :math:`x_1`, is negative.</span>

<span class="sd">    Further, note how `x` and `y` are combined:</span>

<span class="sd">    &gt;&gt;&gt; x = [-2.1, -1,  4.3]</span>
<span class="sd">    &gt;&gt;&gt; y = [3,  1.1,  0.12]</span>
<span class="sd">    &gt;&gt;&gt; X = np.stack((x, y), axis=0)</span>
<span class="sd">    &gt;&gt;&gt; np.cov(X)</span>
<span class="sd">    array([[11.71      , -4.286     ], # may vary</span>
<span class="sd">           [-4.286     ,  2.144133]])</span>
<span class="sd">    &gt;&gt;&gt; np.cov(x, y)</span>
<span class="sd">    array([[11.71      , -4.286     ], # may vary</span>
<span class="sd">           [-4.286     ,  2.144133]])</span>
<span class="sd">    &gt;&gt;&gt; np.cov(x)</span>
<span class="sd">    array(11.71)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check inputs</span>
    <span class="k">if</span> <span class="n">ddof</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">ddof</span> <span class="o">!=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ddof</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;ddof must be integer&quot;</span><span class="p">)</span>

    <span class="c1"># Handles complex arrays too</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;m has more than 2 dimensions&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;y has more than 2 dimensions&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

    <span class="n">X</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">rowvar</span> <span class="ow">and</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span>
    <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">rowvar</span> <span class="ow">and</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">T</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">ddof</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">bias</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">ddof</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ddof</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Get the product of frequencies and weights</span>
    <span class="n">w</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">fweights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fweights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">fweights</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">fweights</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">fweights</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;fweights must be integer&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fweights</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;cannot handle multidimensional fweights&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fweights</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;incompatible numbers of samples and fweights&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">fweights</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;fweights cannot be negative&quot;</span><span class="p">)</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">fweights</span>
    <span class="k">if</span> <span class="n">aweights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">aweights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">aweights</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">aweights</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;cannot handle multidimensional aweights&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">aweights</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;incompatible numbers of samples and aweights&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">aweights</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;aweights cannot be negative&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">aweights</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">*=</span> <span class="n">aweights</span>

    <span class="n">avg</span><span class="p">,</span> <span class="n">w_sum</span> <span class="o">=</span> <span class="n">average</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">w</span><span class="p">,</span> <span class="n">returned</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">w_sum</span> <span class="o">=</span> <span class="n">w_sum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Determine the normalization</span>
    <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fact</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ddof</span>
    <span class="k">elif</span> <span class="n">ddof</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">fact</span> <span class="o">=</span> <span class="n">w_sum</span>
    <span class="k">elif</span> <span class="n">aweights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fact</span> <span class="o">=</span> <span class="n">w_sum</span> <span class="o">-</span> <span class="n">ddof</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fact</span> <span class="o">=</span> <span class="n">w_sum</span> <span class="o">-</span> <span class="n">ddof</span><span class="o">*</span><span class="nb">sum</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">aweights</span><span class="p">)</span><span class="o">/</span><span class="n">w_sum</span>

    <span class="k">if</span> <span class="n">fact</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Degrees of freedom &lt;= 0 for slice&quot;</span><span class="p">,</span>
                      <span class="ne">RuntimeWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">fact</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="n">X</span> <span class="o">-=</span> <span class="n">avg</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">X_T</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">X_T</span> <span class="o">=</span> <span class="p">(</span><span class="n">X</span><span class="o">*</span><span class="n">w</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">X_T</span><span class="o">.</span><span class="n">conj</span><span class="p">())</span>
    <span class="n">c</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">true_divide</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">fact</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">c</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">_corrcoef_dispatcher</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rowvar</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
                         <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>


<span class="nd">@array_function_dispatch</span><span class="p">(</span><span class="n">_corrcoef_dispatcher</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">corrcoef</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rowvar</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
             <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return Pearson product-moment correlation coefficients.</span>

<span class="sd">    Please refer to the documentation for `cov` for more detail.  The</span>
<span class="sd">    relationship between the correlation coefficient matrix, `R`, and the</span>
<span class="sd">    covariance matrix, `C`, is</span>

<span class="sd">    .. math:: R_{ij} = \\frac{ C_{ij} } { \\sqrt{ C_{ii} C_{jj} } }</span>

<span class="sd">    The values of `R` are between -1 and 1, inclusive.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array_like</span>
<span class="sd">        A 1-D or 2-D array containing multiple variables and observations.</span>
<span class="sd">        Each row of `x` represents a variable, and each column a single</span>
<span class="sd">        observation of all those variables. Also see `rowvar` below.</span>
<span class="sd">    y : array_like, optional</span>
<span class="sd">        An additional set of variables and observations. `y` has the same</span>
<span class="sd">        shape as `x`.</span>
<span class="sd">    rowvar : bool, optional</span>
<span class="sd">        If `rowvar` is True (default), then each row represents a</span>
<span class="sd">        variable, with observations in the columns. Otherwise, the relationship</span>
<span class="sd">        is transposed: each column represents a variable, while the rows</span>
<span class="sd">        contain observations.</span>
<span class="sd">    bias : _NoValue, optional</span>
<span class="sd">        Has no effect, do not use.</span>

<span class="sd">        .. deprecated:: 1.10.0</span>
<span class="sd">    ddof : _NoValue, optional</span>
<span class="sd">        Has no effect, do not use.</span>

<span class="sd">        .. deprecated:: 1.10.0</span>
<span class="sd">    dtype : data-type, optional</span>
<span class="sd">        Data-type of the result. By default, the return data-type will have</span>
<span class="sd">        at least `numpy.float64` precision.</span>

<span class="sd">        .. versionadded:: 1.20</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    R : ndarray</span>
<span class="sd">        The correlation coefficient matrix of the variables.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    cov : Covariance matrix</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Due to floating point rounding the resulting array may not be Hermitian,</span>
<span class="sd">    the diagonal elements may not be 1, and the elements may not satisfy the</span>
<span class="sd">    inequality abs(a) &lt;= 1. The real and imaginary parts are clipped to the</span>
<span class="sd">    interval [-1,  1] in an attempt to improve on that situation but is not</span>
<span class="sd">    much help in the complex case.</span>

<span class="sd">    This function accepts but discards arguments `bias` and `ddof`.  This is</span>
<span class="sd">    for backwards compatibility with previous versions of this function.  These</span>
<span class="sd">    arguments had no effect on the return values of the function and can be</span>
<span class="sd">    safely ignored in this and previous versions of numpy.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    In this example we generate two random arrays, ``xarr`` and ``yarr``, and</span>
<span class="sd">    compute the row-wise and column-wise Pearson correlation coefficients,</span>
<span class="sd">    ``R``. Since ``rowvar`` is  true by  default, we first find the row-wise</span>
<span class="sd">    Pearson correlation coefficients between the variables of ``xarr``.</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; rng = np.random.default_rng(seed=42)</span>
<span class="sd">    &gt;&gt;&gt; xarr = rng.random((3, 3))</span>
<span class="sd">    &gt;&gt;&gt; xarr</span>
<span class="sd">    array([[0.77395605, 0.43887844, 0.85859792],</span>
<span class="sd">           [0.69736803, 0.09417735, 0.97562235],</span>
<span class="sd">           [0.7611397 , 0.78606431, 0.12811363]])</span>
<span class="sd">    &gt;&gt;&gt; R1 = np.corrcoef(xarr)</span>
<span class="sd">    &gt;&gt;&gt; R1</span>
<span class="sd">    array([[ 1.        ,  0.99256089, -0.68080986],</span>
<span class="sd">           [ 0.99256089,  1.        , -0.76492172],</span>
<span class="sd">           [-0.68080986, -0.76492172,  1.        ]])</span>

<span class="sd">    If we add another set of variables and observations ``yarr``, we can</span>
<span class="sd">    compute the row-wise Pearson correlation coefficients between the</span>
<span class="sd">    variables in ``xarr`` and ``yarr``.</span>

<span class="sd">    &gt;&gt;&gt; yarr = rng.random((3, 3))</span>
<span class="sd">    &gt;&gt;&gt; yarr</span>
<span class="sd">    array([[0.45038594, 0.37079802, 0.92676499],</span>
<span class="sd">           [0.64386512, 0.82276161, 0.4434142 ],</span>
<span class="sd">           [0.22723872, 0.55458479, 0.06381726]])</span>
<span class="sd">    &gt;&gt;&gt; R2 = np.corrcoef(xarr, yarr)</span>
<span class="sd">    &gt;&gt;&gt; R2</span>
<span class="sd">    array([[ 1.        ,  0.99256089, -0.68080986,  0.75008178, -0.934284  ,</span>
<span class="sd">            -0.99004057],</span>
<span class="sd">           [ 0.99256089,  1.        , -0.76492172,  0.82502011, -0.97074098,</span>
<span class="sd">            -0.99981569],</span>
<span class="sd">           [-0.68080986, -0.76492172,  1.        , -0.99507202,  0.89721355,</span>
<span class="sd">             0.77714685],</span>
<span class="sd">           [ 0.75008178,  0.82502011, -0.99507202,  1.        , -0.93657855,</span>
<span class="sd">            -0.83571711],</span>
<span class="sd">           [-0.934284  , -0.97074098,  0.89721355, -0.93657855,  1.        ,</span>
<span class="sd">             0.97517215],</span>
<span class="sd">           [-0.99004057, -0.99981569,  0.77714685, -0.83571711,  0.97517215,</span>
<span class="sd">             1.        ]])</span>

<span class="sd">    Finally if we use the option ``rowvar=False``, the columns are now</span>
<span class="sd">    being treated as the variables and we will find the column-wise Pearson</span>
<span class="sd">    correlation coefficients between variables in ``xarr`` and ``yarr``.</span>

<span class="sd">    &gt;&gt;&gt; R3 = np.corrcoef(xarr, yarr, rowvar=False)</span>
<span class="sd">    &gt;&gt;&gt; R3</span>
<span class="sd">    array([[ 1.        ,  0.77598074, -0.47458546, -0.75078643, -0.9665554 ,</span>
<span class="sd">             0.22423734],</span>
<span class="sd">           [ 0.77598074,  1.        , -0.92346708, -0.99923895, -0.58826587,</span>
<span class="sd">            -0.44069024],</span>
<span class="sd">           [-0.47458546, -0.92346708,  1.        ,  0.93773029,  0.23297648,</span>
<span class="sd">             0.75137473],</span>
<span class="sd">           [-0.75078643, -0.99923895,  0.93773029,  1.        ,  0.55627469,</span>
<span class="sd">             0.47536961],</span>
<span class="sd">           [-0.9665554 , -0.58826587,  0.23297648,  0.55627469,  1.        ,</span>
<span class="sd">            -0.46666491],</span>
<span class="sd">           [ 0.22423734, -0.44069024,  0.75137473,  0.47536961, -0.46666491,</span>
<span class="sd">             1.        ]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">bias</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span> <span class="ow">or</span> <span class="n">ddof</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">:</span>
        <span class="c1"># 2015-03-15, 1.10</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;bias and ddof have no effect and are deprecated&#39;</span><span class="p">,</span>
                      <span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">cov</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">rowvar</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">diag</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="c1"># scalar covariance</span>
        <span class="c1"># nan if incorrect value (nan, inf, 0), 1 otherwise</span>
        <span class="k">return</span> <span class="n">c</span> <span class="o">/</span> <span class="n">c</span>
    <span class="n">stddev</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">real</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">/=</span> <span class="n">stddev</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>
    <span class="n">c</span> <span class="o">/=</span> <span class="n">stddev</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>

    <span class="c1"># Clip real and imaginary parts to [-1, 1].  This does not guarantee</span>
    <span class="c1"># abs(a[i,j]) &lt;= 1 for complex arrays, but is the best we can do without</span>
    <span class="c1"># excessive work.</span>
    <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">c</span><span class="o">.</span><span class="n">real</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">iscomplexobj</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
        <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">c</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">c</span>


<span class="nd">@set_module</span><span class="p">(</span><span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">blackman</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the Blackman window.</span>

<span class="sd">    The Blackman window is a taper formed by using the first three</span>
<span class="sd">    terms of a summation of cosines. It was designed to have close to the</span>
<span class="sd">    minimal leakage possible.  It is close to optimal, only slightly worse</span>
<span class="sd">    than a Kaiser window.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    M : int</span>
<span class="sd">        Number of points in the output window. If zero or less, an empty</span>
<span class="sd">        array is returned.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : ndarray</span>
<span class="sd">        The window, with the maximum value normalized to one (the value one</span>
<span class="sd">        appears only if the number of samples is odd).</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    bartlett, hamming, hanning, kaiser</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The Blackman window is defined as</span>

<span class="sd">    .. math::  w(n) = 0.42 - 0.5 \\cos(2\\pi n/M) + 0.08 \\cos(4\\pi n/M)</span>

<span class="sd">    Most references to the Blackman window come from the signal processing</span>
<span class="sd">    literature, where it is used as one of many windowing functions for</span>
<span class="sd">    smoothing values.  It is also known as an apodization (which means</span>
<span class="sd">    &quot;removing the foot&quot;, i.e. smoothing discontinuities at the beginning</span>
<span class="sd">    and end of the sampled signal) or tapering function. It is known as a</span>
<span class="sd">    &quot;near optimal&quot; tapering function, almost as good (by some measures)</span>
<span class="sd">    as the kaiser window.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    Blackman, R.B. and Tukey, J.W., (1958) The measurement of power spectra,</span>
<span class="sd">    Dover Publications, New York.</span>

<span class="sd">    Oppenheim, A.V., and R.W. Schafer. Discrete-Time Signal Processing.</span>
<span class="sd">    Upper Saddle River, NJ: Prentice-Hall, 1999, pp. 468-471.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; np.blackman(12)</span>
<span class="sd">    array([-1.38777878e-17,   3.26064346e-02,   1.59903635e-01, # may vary</span>
<span class="sd">            4.14397981e-01,   7.36045180e-01,   9.67046769e-01,</span>
<span class="sd">            9.67046769e-01,   7.36045180e-01,   4.14397981e-01,</span>
<span class="sd">            1.59903635e-01,   3.26064346e-02,  -1.38777878e-17])</span>

<span class="sd">    Plot the window and the frequency response:</span>

<span class="sd">    &gt;&gt;&gt; from numpy.fft import fft, fftshift</span>
<span class="sd">    &gt;&gt;&gt; window = np.blackman(51)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(window)</span>
<span class="sd">    [&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&quot;Blackman window&quot;)</span>
<span class="sd">    Text(0.5, 1.0, &#39;Blackman window&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&quot;Amplitude&quot;)</span>
<span class="sd">    Text(0, 0.5, &#39;Amplitude&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&quot;Sample&quot;)</span>
<span class="sd">    Text(0.5, 0, &#39;Sample&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &gt;&gt;&gt; plt.figure()</span>
<span class="sd">    &lt;Figure size 640x480 with 0 Axes&gt;</span>
<span class="sd">    &gt;&gt;&gt; A = fft(window, 2048) / 25.5</span>
<span class="sd">    &gt;&gt;&gt; mag = np.abs(fftshift(A))</span>
<span class="sd">    &gt;&gt;&gt; freq = np.linspace(-0.5, 0.5, len(A))</span>
<span class="sd">    &gt;&gt;&gt; with np.errstate(divide=&#39;ignore&#39;, invalid=&#39;ignore&#39;):</span>
<span class="sd">    ...     response = 20 * np.log10(mag)</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; response = np.clip(response, -100, 100)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(freq, response)</span>
<span class="sd">    [&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&quot;Frequency response of Blackman window&quot;)</span>
<span class="sd">    Text(0.5, 1.0, &#39;Frequency response of Blackman window&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&quot;Magnitude [dB]&quot;)</span>
<span class="sd">    Text(0, 0.5, &#39;Magnitude [dB]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&quot;Normalized frequency [cycles per sample]&quot;)</span>
<span class="sd">    Text(0.5, 0, &#39;Normalized frequency [cycles per sample]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; _ = plt.axis(&#39;tight&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Ensures at least float64 via 0.0.  M should be an integer, but conversion</span>
    <span class="c1"># to double is safe for a range.</span>
    <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">M</span><span class="p">])</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">M</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">M</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">M</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="mf">0.42</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">pi</span><span class="o">*</span><span class="n">n</span><span class="o">/</span><span class="p">(</span><span class="n">M</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="mf">0.08</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">n</span><span class="o">/</span><span class="p">(</span><span class="n">M</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>


<span class="nd">@set_module</span><span class="p">(</span><span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">bartlett</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the Bartlett window.</span>

<span class="sd">    The Bartlett window is very similar to a triangular window, except</span>
<span class="sd">    that the end points are at zero.  It is often used in signal</span>
<span class="sd">    processing for tapering a signal, without generating too much</span>
<span class="sd">    ripple in the frequency domain.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    M : int</span>
<span class="sd">        Number of points in the output window. If zero or less, an</span>
<span class="sd">        empty array is returned.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : array</span>
<span class="sd">        The triangular window, with the maximum value normalized to one</span>
<span class="sd">        (the value one appears only if the number of samples is odd), with</span>
<span class="sd">        the first and last samples equal to zero.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    blackman, hamming, hanning, kaiser</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The Bartlett window is defined as</span>

<span class="sd">    .. math:: w(n) = \\frac{2}{M-1} \\left(</span>
<span class="sd">              \\frac{M-1}{2} - \\left|n - \\frac{M-1}{2}\\right|</span>
<span class="sd">              \\right)</span>

<span class="sd">    Most references to the Bartlett window come from the signal processing</span>
<span class="sd">    literature, where it is used as one of many windowing functions for</span>
<span class="sd">    smoothing values.  Note that convolution with this window produces linear</span>
<span class="sd">    interpolation.  It is also known as an apodization (which means &quot;removing</span>
<span class="sd">    the foot&quot;, i.e. smoothing discontinuities at the beginning and end of the</span>
<span class="sd">    sampled signal) or tapering function. The Fourier transform of the</span>
<span class="sd">    Bartlett window is the product of two sinc functions. Note the excellent</span>
<span class="sd">    discussion in Kanasewich [2]_.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] M.S. Bartlett, &quot;Periodogram Analysis and Continuous Spectra&quot;,</span>
<span class="sd">           Biometrika 37, 1-16, 1950.</span>
<span class="sd">    .. [2] E.R. Kanasewich, &quot;Time Sequence Analysis in Geophysics&quot;,</span>
<span class="sd">           The University of Alberta Press, 1975, pp. 109-110.</span>
<span class="sd">    .. [3] A.V. Oppenheim and R.W. Schafer, &quot;Discrete-Time Signal</span>
<span class="sd">           Processing&quot;, Prentice-Hall, 1999, pp. 468-471.</span>
<span class="sd">    .. [4] Wikipedia, &quot;Window function&quot;,</span>
<span class="sd">           https://en.wikipedia.org/wiki/Window_function</span>
<span class="sd">    .. [5] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,</span>
<span class="sd">           &quot;Numerical Recipes&quot;, Cambridge University Press, 1986, page 429.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; np.bartlett(12)</span>
<span class="sd">    array([ 0.        ,  0.18181818,  0.36363636,  0.54545455,  0.72727273, # may vary</span>
<span class="sd">            0.90909091,  0.90909091,  0.72727273,  0.54545455,  0.36363636,</span>
<span class="sd">            0.18181818,  0.        ])</span>

<span class="sd">    Plot the window and its frequency response (requires SciPy and matplotlib):</span>

<span class="sd">    &gt;&gt;&gt; from numpy.fft import fft, fftshift</span>
<span class="sd">    &gt;&gt;&gt; window = np.bartlett(51)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(window)</span>
<span class="sd">    [&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&quot;Bartlett window&quot;)</span>
<span class="sd">    Text(0.5, 1.0, &#39;Bartlett window&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&quot;Amplitude&quot;)</span>
<span class="sd">    Text(0, 0.5, &#39;Amplitude&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&quot;Sample&quot;)</span>
<span class="sd">    Text(0.5, 0, &#39;Sample&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &gt;&gt;&gt; plt.figure()</span>
<span class="sd">    &lt;Figure size 640x480 with 0 Axes&gt;</span>
<span class="sd">    &gt;&gt;&gt; A = fft(window, 2048) / 25.5</span>
<span class="sd">    &gt;&gt;&gt; mag = np.abs(fftshift(A))</span>
<span class="sd">    &gt;&gt;&gt; freq = np.linspace(-0.5, 0.5, len(A))</span>
<span class="sd">    &gt;&gt;&gt; with np.errstate(divide=&#39;ignore&#39;, invalid=&#39;ignore&#39;):</span>
<span class="sd">    ...     response = 20 * np.log10(mag)</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; response = np.clip(response, -100, 100)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(freq, response)</span>
<span class="sd">    [&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&quot;Frequency response of Bartlett window&quot;)</span>
<span class="sd">    Text(0.5, 1.0, &#39;Frequency response of Bartlett window&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&quot;Magnitude [dB]&quot;)</span>
<span class="sd">    Text(0, 0.5, &#39;Magnitude [dB]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&quot;Normalized frequency [cycles per sample]&quot;)</span>
<span class="sd">    Text(0.5, 0, &#39;Normalized frequency [cycles per sample]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; _ = plt.axis(&#39;tight&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Ensures at least float64 via 0.0.  M should be an integer, but conversion</span>
    <span class="c1"># to double is safe for a range.</span>
    <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">M</span><span class="p">])</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">M</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">M</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">M</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">where</span><span class="p">(</span><span class="n">less_equal</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">n</span><span class="o">/</span><span class="p">(</span><span class="n">M</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">n</span><span class="o">/</span><span class="p">(</span><span class="n">M</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>


<span class="nd">@set_module</span><span class="p">(</span><span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">hanning</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the Hanning window.</span>

<span class="sd">    The Hanning window is a taper formed by using a weighted cosine.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    M : int</span>
<span class="sd">        Number of points in the output window. If zero or less, an</span>
<span class="sd">        empty array is returned.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : ndarray, shape(M,)</span>
<span class="sd">        The window, with the maximum value normalized to one (the value</span>
<span class="sd">        one appears only if `M` is odd).</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    bartlett, blackman, hamming, kaiser</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The Hanning window is defined as</span>

<span class="sd">    .. math::  w(n) = 0.5 - 0.5\\cos\\left(\\frac{2\\pi{n}}{M-1}\\right)</span>
<span class="sd">               \\qquad 0 \\leq n \\leq M-1</span>

<span class="sd">    The Hanning was named for Julius von Hann, an Austrian meteorologist.</span>
<span class="sd">    It is also known as the Cosine Bell. Some authors prefer that it be</span>
<span class="sd">    called a Hann window, to help avoid confusion with the very similar</span>
<span class="sd">    Hamming window.</span>

<span class="sd">    Most references to the Hanning window come from the signal processing</span>
<span class="sd">    literature, where it is used as one of many windowing functions for</span>
<span class="sd">    smoothing values.  It is also known as an apodization (which means</span>
<span class="sd">    &quot;removing the foot&quot;, i.e. smoothing discontinuities at the beginning</span>
<span class="sd">    and end of the sampled signal) or tapering function.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Blackman, R.B. and Tukey, J.W., (1958) The measurement of power</span>
<span class="sd">           spectra, Dover Publications, New York.</span>
<span class="sd">    .. [2] E.R. Kanasewich, &quot;Time Sequence Analysis in Geophysics&quot;,</span>
<span class="sd">           The University of Alberta Press, 1975, pp. 106-108.</span>
<span class="sd">    .. [3] Wikipedia, &quot;Window function&quot;,</span>
<span class="sd">           https://en.wikipedia.org/wiki/Window_function</span>
<span class="sd">    .. [4] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,</span>
<span class="sd">           &quot;Numerical Recipes&quot;, Cambridge University Press, 1986, page 425.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.hanning(12)</span>
<span class="sd">    array([0.        , 0.07937323, 0.29229249, 0.57115742, 0.82743037,</span>
<span class="sd">           0.97974649, 0.97974649, 0.82743037, 0.57115742, 0.29229249,</span>
<span class="sd">           0.07937323, 0.        ])</span>

<span class="sd">    Plot the window and its frequency response:</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; from numpy.fft import fft, fftshift</span>
<span class="sd">    &gt;&gt;&gt; window = np.hanning(51)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(window)</span>
<span class="sd">    [&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&quot;Hann window&quot;)</span>
<span class="sd">    Text(0.5, 1.0, &#39;Hann window&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&quot;Amplitude&quot;)</span>
<span class="sd">    Text(0, 0.5, &#39;Amplitude&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&quot;Sample&quot;)</span>
<span class="sd">    Text(0.5, 0, &#39;Sample&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &gt;&gt;&gt; plt.figure()</span>
<span class="sd">    &lt;Figure size 640x480 with 0 Axes&gt;</span>
<span class="sd">    &gt;&gt;&gt; A = fft(window, 2048) / 25.5</span>
<span class="sd">    &gt;&gt;&gt; mag = np.abs(fftshift(A))</span>
<span class="sd">    &gt;&gt;&gt; freq = np.linspace(-0.5, 0.5, len(A))</span>
<span class="sd">    &gt;&gt;&gt; with np.errstate(divide=&#39;ignore&#39;, invalid=&#39;ignore&#39;):</span>
<span class="sd">    ...     response = 20 * np.log10(mag)</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; response = np.clip(response, -100, 100)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(freq, response)</span>
<span class="sd">    [&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&quot;Frequency response of the Hann window&quot;)</span>
<span class="sd">    Text(0.5, 1.0, &#39;Frequency response of the Hann window&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&quot;Magnitude [dB]&quot;)</span>
<span class="sd">    Text(0, 0.5, &#39;Magnitude [dB]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&quot;Normalized frequency [cycles per sample]&quot;)</span>
<span class="sd">    Text(0.5, 0, &#39;Normalized frequency [cycles per sample]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.axis(&#39;tight&#39;)</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Ensures at least float64 via 0.0.  M should be an integer, but conversion</span>
    <span class="c1"># to double is safe for a range.</span>
    <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">M</span><span class="p">])</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">M</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">M</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">M</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">pi</span><span class="o">*</span><span class="n">n</span><span class="o">/</span><span class="p">(</span><span class="n">M</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>


<span class="nd">@set_module</span><span class="p">(</span><span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">hamming</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the Hamming window.</span>

<span class="sd">    The Hamming window is a taper formed by using a weighted cosine.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    M : int</span>
<span class="sd">        Number of points in the output window. If zero or less, an</span>
<span class="sd">        empty array is returned.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : ndarray</span>
<span class="sd">        The window, with the maximum value normalized to one (the value</span>
<span class="sd">        one appears only if the number of samples is odd).</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    bartlett, blackman, hanning, kaiser</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The Hamming window is defined as</span>

<span class="sd">    .. math::  w(n) = 0.54 - 0.46\\cos\\left(\\frac{2\\pi{n}}{M-1}\\right)</span>
<span class="sd">               \\qquad 0 \\leq n \\leq M-1</span>

<span class="sd">    The Hamming was named for R. W. Hamming, an associate of J. W. Tukey</span>
<span class="sd">    and is described in Blackman and Tukey. It was recommended for</span>
<span class="sd">    smoothing the truncated autocovariance function in the time domain.</span>
<span class="sd">    Most references to the Hamming window come from the signal processing</span>
<span class="sd">    literature, where it is used as one of many windowing functions for</span>
<span class="sd">    smoothing values.  It is also known as an apodization (which means</span>
<span class="sd">    &quot;removing the foot&quot;, i.e. smoothing discontinuities at the beginning</span>
<span class="sd">    and end of the sampled signal) or tapering function.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Blackman, R.B. and Tukey, J.W., (1958) The measurement of power</span>
<span class="sd">           spectra, Dover Publications, New York.</span>
<span class="sd">    .. [2] E.R. Kanasewich, &quot;Time Sequence Analysis in Geophysics&quot;, The</span>
<span class="sd">           University of Alberta Press, 1975, pp. 109-110.</span>
<span class="sd">    .. [3] Wikipedia, &quot;Window function&quot;,</span>
<span class="sd">           https://en.wikipedia.org/wiki/Window_function</span>
<span class="sd">    .. [4] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,</span>
<span class="sd">           &quot;Numerical Recipes&quot;, Cambridge University Press, 1986, page 425.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.hamming(12)</span>
<span class="sd">    array([ 0.08      ,  0.15302337,  0.34890909,  0.60546483,  0.84123594, # may vary</span>
<span class="sd">            0.98136677,  0.98136677,  0.84123594,  0.60546483,  0.34890909,</span>
<span class="sd">            0.15302337,  0.08      ])</span>

<span class="sd">    Plot the window and the frequency response:</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; from numpy.fft import fft, fftshift</span>
<span class="sd">    &gt;&gt;&gt; window = np.hamming(51)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(window)</span>
<span class="sd">    [&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&quot;Hamming window&quot;)</span>
<span class="sd">    Text(0.5, 1.0, &#39;Hamming window&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&quot;Amplitude&quot;)</span>
<span class="sd">    Text(0, 0.5, &#39;Amplitude&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&quot;Sample&quot;)</span>
<span class="sd">    Text(0.5, 0, &#39;Sample&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &gt;&gt;&gt; plt.figure()</span>
<span class="sd">    &lt;Figure size 640x480 with 0 Axes&gt;</span>
<span class="sd">    &gt;&gt;&gt; A = fft(window, 2048) / 25.5</span>
<span class="sd">    &gt;&gt;&gt; mag = np.abs(fftshift(A))</span>
<span class="sd">    &gt;&gt;&gt; freq = np.linspace(-0.5, 0.5, len(A))</span>
<span class="sd">    &gt;&gt;&gt; response = 20 * np.log10(mag)</span>
<span class="sd">    &gt;&gt;&gt; response = np.clip(response, -100, 100)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(freq, response)</span>
<span class="sd">    [&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&quot;Frequency response of Hamming window&quot;)</span>
<span class="sd">    Text(0.5, 1.0, &#39;Frequency response of Hamming window&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&quot;Magnitude [dB]&quot;)</span>
<span class="sd">    Text(0, 0.5, &#39;Magnitude [dB]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&quot;Normalized frequency [cycles per sample]&quot;)</span>
<span class="sd">    Text(0.5, 0, &#39;Normalized frequency [cycles per sample]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.axis(&#39;tight&#39;)</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Ensures at least float64 via 0.0.  M should be an integer, but conversion</span>
    <span class="c1"># to double is safe for a range.</span>
    <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">M</span><span class="p">])</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">M</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">M</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">M</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="mf">0.54</span> <span class="o">+</span> <span class="mf">0.46</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">pi</span><span class="o">*</span><span class="n">n</span><span class="o">/</span><span class="p">(</span><span class="n">M</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>


<span class="c1">## Code from cephes for i0</span>

<span class="n">_i0A</span> <span class="o">=</span> <span class="p">[</span>
    <span class="o">-</span><span class="mf">4.41534164647933937950E-18</span><span class="p">,</span>
    <span class="mf">3.33079451882223809783E-17</span><span class="p">,</span>
    <span class="o">-</span><span class="mf">2.43127984654795469359E-16</span><span class="p">,</span>
    <span class="mf">1.71539128555513303061E-15</span><span class="p">,</span>
    <span class="o">-</span><span class="mf">1.16853328779934516808E-14</span><span class="p">,</span>
    <span class="mf">7.67618549860493561688E-14</span><span class="p">,</span>
    <span class="o">-</span><span class="mf">4.85644678311192946090E-13</span><span class="p">,</span>
    <span class="mf">2.95505266312963983461E-12</span><span class="p">,</span>
    <span class="o">-</span><span class="mf">1.72682629144155570723E-11</span><span class="p">,</span>
    <span class="mf">9.67580903537323691224E-11</span><span class="p">,</span>
    <span class="o">-</span><span class="mf">5.18979560163526290666E-10</span><span class="p">,</span>
    <span class="mf">2.65982372468238665035E-9</span><span class="p">,</span>
    <span class="o">-</span><span class="mf">1.30002500998624804212E-8</span><span class="p">,</span>
    <span class="mf">6.04699502254191894932E-8</span><span class="p">,</span>
    <span class="o">-</span><span class="mf">2.67079385394061173391E-7</span><span class="p">,</span>
    <span class="mf">1.11738753912010371815E-6</span><span class="p">,</span>
    <span class="o">-</span><span class="mf">4.41673835845875056359E-6</span><span class="p">,</span>
    <span class="mf">1.64484480707288970893E-5</span><span class="p">,</span>
    <span class="o">-</span><span class="mf">5.75419501008210370398E-5</span><span class="p">,</span>
    <span class="mf">1.88502885095841655729E-4</span><span class="p">,</span>
    <span class="o">-</span><span class="mf">5.76375574538582365885E-4</span><span class="p">,</span>
    <span class="mf">1.63947561694133579842E-3</span><span class="p">,</span>
    <span class="o">-</span><span class="mf">4.32430999505057594430E-3</span><span class="p">,</span>
    <span class="mf">1.05464603945949983183E-2</span><span class="p">,</span>
    <span class="o">-</span><span class="mf">2.37374148058994688156E-2</span><span class="p">,</span>
    <span class="mf">4.93052842396707084878E-2</span><span class="p">,</span>
    <span class="o">-</span><span class="mf">9.49010970480476444210E-2</span><span class="p">,</span>
    <span class="mf">1.71620901522208775349E-1</span><span class="p">,</span>
    <span class="o">-</span><span class="mf">3.04682672343198398683E-1</span><span class="p">,</span>
    <span class="mf">6.76795274409476084995E-1</span>
    <span class="p">]</span>

<span class="n">_i0B</span> <span class="o">=</span> <span class="p">[</span>
    <span class="o">-</span><span class="mf">7.23318048787475395456E-18</span><span class="p">,</span>
    <span class="o">-</span><span class="mf">4.83050448594418207126E-18</span><span class="p">,</span>
    <span class="mf">4.46562142029675999901E-17</span><span class="p">,</span>
    <span class="mf">3.46122286769746109310E-17</span><span class="p">,</span>
    <span class="o">-</span><span class="mf">2.82762398051658348494E-16</span><span class="p">,</span>
    <span class="o">-</span><span class="mf">3.42548561967721913462E-16</span><span class="p">,</span>
    <span class="mf">1.77256013305652638360E-15</span><span class="p">,</span>
    <span class="mf">3.81168066935262242075E-15</span><span class="p">,</span>
    <span class="o">-</span><span class="mf">9.55484669882830764870E-15</span><span class="p">,</span>
    <span class="o">-</span><span class="mf">4.15056934728722208663E-14</span><span class="p">,</span>
    <span class="mf">1.54008621752140982691E-14</span><span class="p">,</span>
    <span class="mf">3.85277838274214270114E-13</span><span class="p">,</span>
    <span class="mf">7.18012445138366623367E-13</span><span class="p">,</span>
    <span class="o">-</span><span class="mf">1.79417853150680611778E-12</span><span class="p">,</span>
    <span class="o">-</span><span class="mf">1.32158118404477131188E-11</span><span class="p">,</span>
    <span class="o">-</span><span class="mf">3.14991652796324136454E-11</span><span class="p">,</span>
    <span class="mf">1.18891471078464383424E-11</span><span class="p">,</span>
    <span class="mf">4.94060238822496958910E-10</span><span class="p">,</span>
    <span class="mf">3.39623202570838634515E-9</span><span class="p">,</span>
    <span class="mf">2.26666899049817806459E-8</span><span class="p">,</span>
    <span class="mf">2.04891858946906374183E-7</span><span class="p">,</span>
    <span class="mf">2.89137052083475648297E-6</span><span class="p">,</span>
    <span class="mf">6.88975834691682398426E-5</span><span class="p">,</span>
    <span class="mf">3.36911647825569408990E-3</span><span class="p">,</span>
    <span class="mf">8.04490411014108831608E-1</span>
    <span class="p">]</span>


<span class="k">def</span> <span class="nf">_chbevl</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">vals</span><span class="p">):</span>
    <span class="n">b0</span> <span class="o">=</span> <span class="n">vals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">b1</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">vals</span><span class="p">)):</span>
        <span class="n">b2</span> <span class="o">=</span> <span class="n">b1</span>
        <span class="n">b1</span> <span class="o">=</span> <span class="n">b0</span>
        <span class="n">b0</span> <span class="o">=</span> <span class="n">x</span><span class="o">*</span><span class="n">b1</span> <span class="o">-</span> <span class="n">b2</span> <span class="o">+</span> <span class="n">vals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="k">return</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">b0</span> <span class="o">-</span> <span class="n">b2</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_i0_1</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">_chbevl</span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="mf">2.0</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="n">_i0A</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_i0_2</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">_chbevl</span><span class="p">(</span><span class="mf">32.0</span><span class="o">/</span><span class="n">x</span> <span class="o">-</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">_i0B</span><span class="p">)</span> <span class="o">/</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_i0_dispatcher</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,)</span>


<span class="nd">@array_function_dispatch</span><span class="p">(</span><span class="n">_i0_dispatcher</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">i0</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Modified Bessel function of the first kind, order 0.</span>

<span class="sd">    Usually denoted :math:`I_0`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array_like of float</span>
<span class="sd">        Argument of the Bessel function.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : ndarray, shape = x.shape, dtype = float</span>
<span class="sd">        The modified Bessel function evaluated at each of the elements of `x`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    scipy.special.i0, scipy.special.iv, scipy.special.ive</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The scipy implementation is recommended over this function: it is a</span>
<span class="sd">    proper ufunc written in C, and more than an order of magnitude faster.</span>

<span class="sd">    We use the algorithm published by Clenshaw [1]_ and referenced by</span>
<span class="sd">    Abramowitz and Stegun [2]_, for which the function domain is</span>
<span class="sd">    partitioned into the two intervals [0,8] and (8,inf), and Chebyshev</span>
<span class="sd">    polynomial expansions are employed in each interval. Relative error on</span>
<span class="sd">    the domain [0,30] using IEEE arithmetic is documented [3]_ as having a</span>
<span class="sd">    peak of 5.8e-16 with an rms of 1.4e-16 (n = 30000).</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] C. W. Clenshaw, &quot;Chebyshev series for mathematical functions&quot;, in</span>
<span class="sd">           *National Physical Laboratory Mathematical Tables*, vol. 5, London:</span>
<span class="sd">           Her Majesty&#39;s Stationery Office, 1962.</span>
<span class="sd">    .. [2] M. Abramowitz and I. A. Stegun, *Handbook of Mathematical</span>
<span class="sd">           Functions*, 10th printing, New York: Dover, 1964, pp. 379.</span>
<span class="sd">           https://personal.math.ubc.ca/~cbm/aands/page_379.htm</span>
<span class="sd">    .. [3] https://metacpan.org/pod/distribution/Math-Cephes/lib/Math/Cephes.pod#i0:-Modified-Bessel-function-of-order-zero</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.i0(0.)</span>
<span class="sd">    array(1.0)</span>
<span class="sd">    &gt;&gt;&gt; np.i0([0, 1, 2, 3])</span>
<span class="sd">    array([1.        , 1.26606588, 2.2795853 , 4.88079259])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;i0 not supported for complex values&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">!=</span> <span class="s1">&#39;f&#39;</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">piecewise</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="mf">8.0</span><span class="p">],</span> <span class="p">[</span><span class="n">_i0_1</span><span class="p">,</span> <span class="n">_i0_2</span><span class="p">])</span>

<span class="c1">## End of cephes code for i0</span>


<span class="nd">@set_module</span><span class="p">(</span><span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">kaiser</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">beta</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the Kaiser window.</span>

<span class="sd">    The Kaiser window is a taper formed by using a Bessel function.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    M : int</span>
<span class="sd">        Number of points in the output window. If zero or less, an</span>
<span class="sd">        empty array is returned.</span>
<span class="sd">    beta : float</span>
<span class="sd">        Shape parameter for window.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : array</span>
<span class="sd">        The window, with the maximum value normalized to one (the value</span>
<span class="sd">        one appears only if the number of samples is odd).</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    bartlett, blackman, hamming, hanning</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The Kaiser window is defined as</span>

<span class="sd">    .. math::  w(n) = I_0\\left( \\beta \\sqrt{1-\\frac{4n^2}{(M-1)^2}}</span>
<span class="sd">               \\right)/I_0(\\beta)</span>

<span class="sd">    with</span>

<span class="sd">    .. math:: \\quad -\\frac{M-1}{2} \\leq n \\leq \\frac{M-1}{2},</span>

<span class="sd">    where :math:`I_0` is the modified zeroth-order Bessel function.</span>

<span class="sd">    The Kaiser was named for Jim Kaiser, who discovered a simple</span>
<span class="sd">    approximation to the DPSS window based on Bessel functions.  The Kaiser</span>
<span class="sd">    window is a very good approximation to the Digital Prolate Spheroidal</span>
<span class="sd">    Sequence, or Slepian window, which is the transform which maximizes the</span>
<span class="sd">    energy in the main lobe of the window relative to total energy.</span>

<span class="sd">    The Kaiser can approximate many other windows by varying the beta</span>
<span class="sd">    parameter.</span>

<span class="sd">    ====  =======================</span>
<span class="sd">    beta  Window shape</span>
<span class="sd">    ====  =======================</span>
<span class="sd">    0     Rectangular</span>
<span class="sd">    5     Similar to a Hamming</span>
<span class="sd">    6     Similar to a Hanning</span>
<span class="sd">    8.6   Similar to a Blackman</span>
<span class="sd">    ====  =======================</span>

<span class="sd">    A beta value of 14 is probably a good starting point. Note that as beta</span>
<span class="sd">    gets large, the window narrows, and so the number of samples needs to be</span>
<span class="sd">    large enough to sample the increasingly narrow spike, otherwise NaNs will</span>
<span class="sd">    get returned.</span>

<span class="sd">    Most references to the Kaiser window come from the signal processing</span>
<span class="sd">    literature, where it is used as one of many windowing functions for</span>
<span class="sd">    smoothing values.  It is also known as an apodization (which means</span>
<span class="sd">    &quot;removing the foot&quot;, i.e. smoothing discontinuities at the beginning</span>
<span class="sd">    and end of the sampled signal) or tapering function.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] J. F. Kaiser, &quot;Digital Filters&quot; - Ch 7 in &quot;Systems analysis by</span>
<span class="sd">           digital computer&quot;, Editors: F.F. Kuo and J.F. Kaiser, p 218-285.</span>
<span class="sd">           John Wiley and Sons, New York, (1966).</span>
<span class="sd">    .. [2] E.R. Kanasewich, &quot;Time Sequence Analysis in Geophysics&quot;, The</span>
<span class="sd">           University of Alberta Press, 1975, pp. 177-178.</span>
<span class="sd">    .. [3] Wikipedia, &quot;Window function&quot;,</span>
<span class="sd">           https://en.wikipedia.org/wiki/Window_function</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; np.kaiser(12, 14)</span>
<span class="sd">     array([7.72686684e-06, 3.46009194e-03, 4.65200189e-02, # may vary</span>
<span class="sd">            2.29737120e-01, 5.99885316e-01, 9.45674898e-01,</span>
<span class="sd">            9.45674898e-01, 5.99885316e-01, 2.29737120e-01,</span>
<span class="sd">            4.65200189e-02, 3.46009194e-03, 7.72686684e-06])</span>


<span class="sd">    Plot the window and the frequency response:</span>

<span class="sd">    &gt;&gt;&gt; from numpy.fft import fft, fftshift</span>
<span class="sd">    &gt;&gt;&gt; window = np.kaiser(51, 14)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(window)</span>
<span class="sd">    [&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&quot;Kaiser window&quot;)</span>
<span class="sd">    Text(0.5, 1.0, &#39;Kaiser window&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&quot;Amplitude&quot;)</span>
<span class="sd">    Text(0, 0.5, &#39;Amplitude&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&quot;Sample&quot;)</span>
<span class="sd">    Text(0.5, 0, &#39;Sample&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &gt;&gt;&gt; plt.figure()</span>
<span class="sd">    &lt;Figure size 640x480 with 0 Axes&gt;</span>
<span class="sd">    &gt;&gt;&gt; A = fft(window, 2048) / 25.5</span>
<span class="sd">    &gt;&gt;&gt; mag = np.abs(fftshift(A))</span>
<span class="sd">    &gt;&gt;&gt; freq = np.linspace(-0.5, 0.5, len(A))</span>
<span class="sd">    &gt;&gt;&gt; response = 20 * np.log10(mag)</span>
<span class="sd">    &gt;&gt;&gt; response = np.clip(response, -100, 100)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(freq, response)</span>
<span class="sd">    [&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&quot;Frequency response of Kaiser window&quot;)</span>
<span class="sd">    Text(0.5, 1.0, &#39;Frequency response of Kaiser window&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&quot;Magnitude [dB]&quot;)</span>
<span class="sd">    Text(0, 0.5, &#39;Magnitude [dB]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&quot;Normalized frequency [cycles per sample]&quot;)</span>
<span class="sd">    Text(0.5, 0, &#39;Normalized frequency [cycles per sample]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.axis(&#39;tight&#39;)</span>
<span class="sd">    (-0.5, 0.5, -100.0, ...) # may vary</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Ensures at least float64 via 0.0.  M should be an integer, but conversion</span>
    <span class="c1"># to double is safe for a range.  (Simplified result_type with 0.0</span>
    <span class="c1"># strongly typed.  result-type is not/less order sensitive, but that mainly</span>
    <span class="c1"># matters for integers anyway.)</span>
    <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">beta</span><span class="p">])</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">beta</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">M</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="p">(</span><span class="n">M</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span>
    <span class="k">return</span> <span class="n">i0</span><span class="p">(</span><span class="n">beta</span> <span class="o">*</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="p">((</span><span class="n">n</span><span class="o">-</span><span class="n">alpha</span><span class="p">)</span><span class="o">/</span><span class="n">alpha</span><span class="p">)</span><span class="o">**</span><span class="mf">2.0</span><span class="p">))</span><span class="o">/</span><span class="n">i0</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_sinc_dispatcher</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,)</span>


<span class="nd">@array_function_dispatch</span><span class="p">(</span><span class="n">_sinc_dispatcher</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">sinc</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the normalized sinc function.</span>

<span class="sd">    The sinc function is equal to :math:`\sin(\pi x)/(\pi x)` for any argument</span>
<span class="sd">    :math:`x\ne 0`. ``sinc(0)`` takes the limit value 1, making ``sinc`` not</span>
<span class="sd">    only everywhere continuous but also infinitely differentiable.</span>

<span class="sd">    .. note::</span>

<span class="sd">        Note the normalization factor of ``pi`` used in the definition.</span>
<span class="sd">        This is the most commonly used definition in signal processing.</span>
<span class="sd">        Use ``sinc(x / np.pi)`` to obtain the unnormalized sinc function</span>
<span class="sd">        :math:`\sin(x)/x` that is more common in mathematics.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : ndarray</span>
<span class="sd">        Array (possibly multi-dimensional) of values for which to calculate</span>
<span class="sd">        ``sinc(x)``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : ndarray</span>
<span class="sd">        ``sinc(x)``, which has the same shape as the input.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The name sinc is short for &quot;sine cardinal&quot; or &quot;sinus cardinalis&quot;.</span>

<span class="sd">    The sinc function is used in various signal processing applications,</span>
<span class="sd">    including in anti-aliasing, in the construction of a Lanczos resampling</span>
<span class="sd">    filter, and in interpolation.</span>

<span class="sd">    For bandlimited interpolation of discrete-time signals, the ideal</span>
<span class="sd">    interpolation kernel is proportional to the sinc function.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Weisstein, Eric W. &quot;Sinc Function.&quot; From MathWorld--A Wolfram Web</span>
<span class="sd">           Resource. http://mathworld.wolfram.com/SincFunction.html</span>
<span class="sd">    .. [2] Wikipedia, &quot;Sinc function&quot;,</span>
<span class="sd">           https://en.wikipedia.org/wiki/Sinc_function</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; x = np.linspace(-4, 4, 41)</span>
<span class="sd">    &gt;&gt;&gt; np.sinc(x)</span>
<span class="sd">     array([-3.89804309e-17,  -4.92362781e-02,  -8.40918587e-02, # may vary</span>
<span class="sd">            -8.90384387e-02,  -5.84680802e-02,   3.89804309e-17,</span>
<span class="sd">            6.68206631e-02,   1.16434881e-01,   1.26137788e-01,</span>
<span class="sd">            8.50444803e-02,  -3.89804309e-17,  -1.03943254e-01,</span>
<span class="sd">            -1.89206682e-01,  -2.16236208e-01,  -1.55914881e-01,</span>
<span class="sd">            3.89804309e-17,   2.33872321e-01,   5.04551152e-01,</span>
<span class="sd">            7.56826729e-01,   9.35489284e-01,   1.00000000e+00,</span>
<span class="sd">            9.35489284e-01,   7.56826729e-01,   5.04551152e-01,</span>
<span class="sd">            2.33872321e-01,   3.89804309e-17,  -1.55914881e-01,</span>
<span class="sd">           -2.16236208e-01,  -1.89206682e-01,  -1.03943254e-01,</span>
<span class="sd">           -3.89804309e-17,   8.50444803e-02,   1.26137788e-01,</span>
<span class="sd">            1.16434881e-01,   6.68206631e-02,   3.89804309e-17,</span>
<span class="sd">            -5.84680802e-02,  -8.90384387e-02,  -8.40918587e-02,</span>
<span class="sd">            -4.92362781e-02,  -3.89804309e-17])</span>

<span class="sd">    &gt;&gt;&gt; plt.plot(x, np.sinc(x))</span>
<span class="sd">    [&lt;matplotlib.lines.Line2D object at 0x...&gt;]</span>
<span class="sd">    &gt;&gt;&gt; plt.title(&quot;Sinc Function&quot;)</span>
<span class="sd">    Text(0.5, 1.0, &#39;Sinc Function&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&quot;Amplitude&quot;)</span>
<span class="sd">    Text(0, 0.5, &#39;Amplitude&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&quot;X&quot;)</span>
<span class="sd">    Text(0.5, 0, &#39;X&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">where</span><span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">1.0e-20</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">sin</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">/</span><span class="n">y</span>


<span class="k">def</span> <span class="nf">_msort_dispatcher</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">a</span><span class="p">,)</span>


<span class="nd">@array_function_dispatch</span><span class="p">(</span><span class="n">_msort_dispatcher</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">msort</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a copy of an array sorted along the first axis.</span>

<span class="sd">    .. deprecated:: 1.24</span>

<span class="sd">       msort is deprecated, use ``np.sort(a, axis=0)`` instead.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Array to be sorted.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sorted_array : ndarray</span>
<span class="sd">        Array of the same type and shape as `a`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    sort</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    ``np.msort(a)`` is equivalent to  ``np.sort(a, axis=0)``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([[1, 4], [3, 1]])</span>
<span class="sd">    &gt;&gt;&gt; np.msort(a)  # sort along the first axis</span>
<span class="sd">    array([[1, 1],</span>
<span class="sd">           [3, 4]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># 2022-10-20 1.24</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
        <span class="s2">&quot;msort is deprecated, use np.sort(a, axis=0) instead&quot;</span><span class="p">,</span>
        <span class="ne">DeprecationWarning</span><span class="p">,</span>
        <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">b</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">b</span>


<span class="k">def</span> <span class="nf">_ureduce</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Internal Function.</span>
<span class="sd">    Call `func` with `a` as first argument swapping the axes to use extended</span>
<span class="sd">    axis on functions that don&#39;t support it natively.</span>

<span class="sd">    Returns result and a.shape with axis dims set to 1.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input array or object that can be converted to an array.</span>
<span class="sd">    func : callable</span>
<span class="sd">        Reduction function capable of receiving a single axis argument.</span>
<span class="sd">        It is called with `a` as first argument followed by `kwargs`.</span>
<span class="sd">    kwargs : keyword arguments</span>
<span class="sd">        additional keyword arguments to pass to `func`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    result : tuple</span>
<span class="sd">        Result of func(a, **kwargs) and a.shape with axis dims set to 1</span>
<span class="sd">        which can be used to reshape the result to the same shape a ufunc with</span>
<span class="sd">        keepdims=True would produce.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;axis&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;out&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">keepdims</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">:</span>
        <span class="n">keepdims</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="n">nd</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">_nx</span><span class="o">.</span><span class="n">normalize_axis_tuple</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">nd</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">keepdims</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">index_out</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                    <span class="mi">0</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">axis</span> <span class="k">else</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nd</span><span class="p">))</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;out&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">out</span><span class="p">[(</span><span class="bp">Ellipsis</span><span class="p">,</span> <span class="p">)</span> <span class="o">+</span> <span class="n">index_out</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;axis&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">axis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">keep</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">nd</span><span class="p">))</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
            <span class="n">nkeep</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">keep</span><span class="p">)</span>
            <span class="c1"># swap axis that should not be reduced to front</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">keep</span><span class="p">)):</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
            <span class="c1"># merge reduced axis</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">nkeep</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,))</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;axis&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">keepdims</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">index_out</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">)</span> <span class="o">*</span> <span class="n">nd</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;out&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">out</span><span class="p">[(</span><span class="bp">Ellipsis</span><span class="p">,</span> <span class="p">)</span> <span class="o">+</span> <span class="n">index_out</span><span class="p">]</span>

    <span class="n">r</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">if</span> <span class="n">keepdims</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">index_r</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">)</span> <span class="o">*</span> <span class="n">nd</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">index_r</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">axis</span> <span class="k">else</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nd</span><span class="p">))</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">r</span><span class="p">[(</span><span class="bp">Ellipsis</span><span class="p">,</span> <span class="p">)</span> <span class="o">+</span> <span class="n">index_r</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">r</span>


<span class="k">def</span> <span class="nf">_median_dispatcher</span><span class="p">(</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>


<span class="nd">@array_function_dispatch</span><span class="p">(</span><span class="n">_median_dispatcher</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">median</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the median along the specified axis.</span>

<span class="sd">    Returns the median of the array elements.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input array or object that can be converted to an array.</span>
<span class="sd">    axis : {int, sequence of int, None}, optional</span>
<span class="sd">        Axis or axes along which the medians are computed. The default</span>
<span class="sd">        is to compute the median along a flattened version of the array.</span>
<span class="sd">        A sequence of axes is supported since version 1.9.0.</span>
<span class="sd">    out : ndarray, optional</span>
<span class="sd">        Alternative output array in which to place the result. It must</span>
<span class="sd">        have the same shape and buffer length as the expected output,</span>
<span class="sd">        but the type (of the output) will be cast if necessary.</span>
<span class="sd">    overwrite_input : bool, optional</span>
<span class="sd">       If True, then allow use of memory of input array `a` for</span>
<span class="sd">       calculations. The input array will be modified by the call to</span>
<span class="sd">       `median`. This will save memory when you do not need to preserve</span>
<span class="sd">       the contents of the input array. Treat the input as undefined,</span>
<span class="sd">       but it will probably be fully or partially sorted. Default is</span>
<span class="sd">       False. If `overwrite_input` is ``True`` and `a` is not already an</span>
<span class="sd">       `ndarray`, an error will be raised.</span>
<span class="sd">    keepdims : bool, optional</span>
<span class="sd">        If this is set to True, the axes which are reduced are left</span>
<span class="sd">        in the result as dimensions with size one. With this option,</span>
<span class="sd">        the result will broadcast correctly against the original `arr`.</span>

<span class="sd">        .. versionadded:: 1.9.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    median : ndarray</span>
<span class="sd">        A new array holding the result. If the input contains integers</span>
<span class="sd">        or floats smaller than ``float64``, then the output data-type is</span>
<span class="sd">        ``np.float64``.  Otherwise, the data-type of the output is the</span>
<span class="sd">        same as that of the input. If `out` is specified, that array is</span>
<span class="sd">        returned instead.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    mean, percentile</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Given a vector ``V`` of length ``N``, the median of ``V`` is the</span>
<span class="sd">    middle value of a sorted copy of ``V``, ``V_sorted`` - i</span>
<span class="sd">    e., ``V_sorted[(N-1)/2]``, when ``N`` is odd, and the average of the</span>
<span class="sd">    two middle values of ``V_sorted`` when ``N`` is even.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([[10, 7, 4], [3, 2, 1]])</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[10,  7,  4],</span>
<span class="sd">           [ 3,  2,  1]])</span>
<span class="sd">    &gt;&gt;&gt; np.median(a)</span>
<span class="sd">    3.5</span>
<span class="sd">    &gt;&gt;&gt; np.median(a, axis=0)</span>
<span class="sd">    array([6.5, 4.5, 2.5])</span>
<span class="sd">    &gt;&gt;&gt; np.median(a, axis=1)</span>
<span class="sd">    array([7.,  2.])</span>
<span class="sd">    &gt;&gt;&gt; m = np.median(a, axis=0)</span>
<span class="sd">    &gt;&gt;&gt; out = np.zeros_like(m)</span>
<span class="sd">    &gt;&gt;&gt; np.median(a, axis=0, out=m)</span>
<span class="sd">    array([6.5,  4.5,  2.5])</span>
<span class="sd">    &gt;&gt;&gt; m</span>
<span class="sd">    array([6.5,  4.5,  2.5])</span>
<span class="sd">    &gt;&gt;&gt; b = a.copy()</span>
<span class="sd">    &gt;&gt;&gt; np.median(b, axis=1, overwrite_input=True)</span>
<span class="sd">    array([7.,  2.])</span>
<span class="sd">    &gt;&gt;&gt; assert not np.all(a==b)</span>
<span class="sd">    &gt;&gt;&gt; b = a.copy()</span>
<span class="sd">    &gt;&gt;&gt; np.median(b, axis=None, overwrite_input=True)</span>
<span class="sd">    3.5</span>
<span class="sd">    &gt;&gt;&gt; assert not np.all(a==b)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_ureduce</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="n">_median</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
                    <span class="n">overwrite_input</span><span class="o">=</span><span class="n">overwrite_input</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_median</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="c1"># can&#39;t be reasonably be implemented in terms of percentile as we have to</span>
    <span class="c1"># call mean to not break astropy</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="c1"># Set the partition indexes</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sz</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">size</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sz</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">sz</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">szh</span> <span class="o">=</span> <span class="n">sz</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">kth</span> <span class="o">=</span> <span class="p">[</span><span class="n">szh</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">szh</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">kth</span> <span class="o">=</span> <span class="p">[(</span><span class="n">sz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span>

    <span class="c1"># We have to check for NaNs (as of writing &#39;M&#39; doesn&#39;t actually work).</span>
    <span class="n">supports_nans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inexact</span><span class="p">)</span> <span class="ow">or</span> <span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="s1">&#39;Mm&#39;</span>
    <span class="k">if</span> <span class="n">supports_nans</span><span class="p">:</span>
        <span class="n">kth</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">overwrite_input</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">part</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="n">part</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="n">kth</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">a</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="n">kth</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
            <span class="n">part</span> <span class="o">=</span> <span class="n">a</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">part</span> <span class="o">=</span> <span class="n">partition</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">kth</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">part</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">():</span>
        <span class="c1"># make 0-D arrays work</span>
        <span class="k">return</span> <span class="n">part</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">indexer</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">part</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">part</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="n">part</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># index with slice to allow mean (below) to work</span>
        <span class="n">indexer</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">indexer</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">index</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">indexer</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">indexer</span><span class="p">)</span>

    <span class="c1"># Use mean in both odd and even case to coerce data type,</span>
    <span class="c1"># using out array if needed.</span>
    <span class="n">rout</span> <span class="o">=</span> <span class="n">mean</span><span class="p">(</span><span class="n">part</span><span class="p">[</span><span class="n">indexer</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">supports_nans</span> <span class="ow">and</span> <span class="n">sz</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># If nans are possible, warn and replace by nans like mean would.</span>
        <span class="n">rout</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">_median_nancheck</span><span class="p">(</span><span class="n">part</span><span class="p">,</span> <span class="n">rout</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">rout</span>


<span class="k">def</span> <span class="nf">_percentile_dispatcher</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                           <span class="n">method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>


<span class="nd">@array_function_dispatch</span><span class="p">(</span><span class="n">_percentile_dispatcher</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">percentile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span>
               <span class="n">q</span><span class="p">,</span>
               <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">overwrite_input</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
               <span class="n">method</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span>
               <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
               <span class="o">*</span><span class="p">,</span>
               <span class="n">interpolation</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the q-th percentile of the data along the specified axis.</span>

<span class="sd">    Returns the q-th percentile(s) of the array elements.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like of real numbers</span>
<span class="sd">        Input array or object that can be converted to an array.</span>
<span class="sd">    q : array_like of float</span>
<span class="sd">        Percentage or sequence of percentages for the percentiles to compute.</span>
<span class="sd">        Values must be between 0 and 100 inclusive.</span>
<span class="sd">    axis : {int, tuple of int, None}, optional</span>
<span class="sd">        Axis or axes along which the percentiles are computed. The</span>
<span class="sd">        default is to compute the percentile(s) along a flattened</span>
<span class="sd">        version of the array.</span>

<span class="sd">        .. versionchanged:: 1.9.0</span>
<span class="sd">            A tuple of axes is supported</span>
<span class="sd">    out : ndarray, optional</span>
<span class="sd">        Alternative output array in which to place the result. It must</span>
<span class="sd">        have the same shape and buffer length as the expected output,</span>
<span class="sd">        but the type (of the output) will be cast if necessary.</span>
<span class="sd">    overwrite_input : bool, optional</span>
<span class="sd">        If True, then allow the input array `a` to be modified by intermediate</span>
<span class="sd">        calculations, to save memory. In this case, the contents of the input</span>
<span class="sd">        `a` after this function completes is undefined.</span>
<span class="sd">    method : str, optional</span>
<span class="sd">        This parameter specifies the method to use for estimating the</span>
<span class="sd">        percentile.  There are many different methods, some unique to NumPy.</span>
<span class="sd">        See the notes for explanation.  The options sorted by their R type</span>
<span class="sd">        as summarized in the H&amp;F paper [1]_ are:</span>

<span class="sd">        1. &#39;inverted_cdf&#39;</span>
<span class="sd">        2. &#39;averaged_inverted_cdf&#39;</span>
<span class="sd">        3. &#39;closest_observation&#39;</span>
<span class="sd">        4. &#39;interpolated_inverted_cdf&#39;</span>
<span class="sd">        5. &#39;hazen&#39;</span>
<span class="sd">        6. &#39;weibull&#39;</span>
<span class="sd">        7. &#39;linear&#39;  (default)</span>
<span class="sd">        8. &#39;median_unbiased&#39;</span>
<span class="sd">        9. &#39;normal_unbiased&#39;</span>

<span class="sd">        The first three methods are discontinuous.  NumPy further defines the</span>
<span class="sd">        following discontinuous variations of the default &#39;linear&#39; (7.) option:</span>

<span class="sd">        * &#39;lower&#39;</span>
<span class="sd">        * &#39;higher&#39;,</span>
<span class="sd">        * &#39;midpoint&#39;</span>
<span class="sd">        * &#39;nearest&#39;</span>

<span class="sd">        .. versionchanged:: 1.22.0</span>
<span class="sd">            This argument was previously called &quot;interpolation&quot; and only</span>
<span class="sd">            offered the &quot;linear&quot; default and last four options.</span>

<span class="sd">    keepdims : bool, optional</span>
<span class="sd">        If this is set to True, the axes which are reduced are left in</span>
<span class="sd">        the result as dimensions with size one. With this option, the</span>
<span class="sd">        result will broadcast correctly against the original array `a`.</span>

<span class="sd">        .. versionadded:: 1.9.0</span>

<span class="sd">    interpolation : str, optional</span>
<span class="sd">        Deprecated name for the method keyword argument.</span>

<span class="sd">        .. deprecated:: 1.22.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    percentile : scalar or ndarray</span>
<span class="sd">        If `q` is a single percentile and `axis=None`, then the result</span>
<span class="sd">        is a scalar. If multiple percentiles are given, first axis of</span>
<span class="sd">        the result corresponds to the percentiles. The other axes are</span>
<span class="sd">        the axes that remain after the reduction of `a`. If the input</span>
<span class="sd">        contains integers or floats smaller than ``float64``, the output</span>
<span class="sd">        data-type is ``float64``. Otherwise, the output data-type is the</span>
<span class="sd">        same as that of the input. If `out` is specified, that array is</span>
<span class="sd">        returned instead.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    mean</span>
<span class="sd">    median : equivalent to ``percentile(..., 50)``</span>
<span class="sd">    nanpercentile</span>
<span class="sd">    quantile : equivalent to percentile, except q in the range [0, 1].</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Given a vector ``V`` of length ``n``, the q-th percentile of ``V`` is</span>
<span class="sd">    the value ``q/100`` of the way from the minimum to the maximum in a</span>
<span class="sd">    sorted copy of ``V``. The values and distances of the two nearest</span>
<span class="sd">    neighbors as well as the `method` parameter will determine the</span>
<span class="sd">    percentile if the normalized ranking does not match the location of</span>
<span class="sd">    ``q`` exactly. This function is the same as the median if ``q=50``, the</span>
<span class="sd">    same as the minimum if ``q=0`` and the same as the maximum if</span>
<span class="sd">    ``q=100``.</span>

<span class="sd">    The optional `method` parameter specifies the method to use when the</span>
<span class="sd">    desired percentile lies between two indexes ``i`` and ``j = i + 1``.</span>
<span class="sd">    In that case, we first determine ``i + g``, a virtual index that lies</span>
<span class="sd">    between ``i`` and ``j``, where  ``i`` is the floor and ``g`` is the</span>
<span class="sd">    fractional part of the index. The final result is, then, an interpolation</span>
<span class="sd">    of ``a[i]`` and ``a[j]`` based on ``g``. During the computation of ``g``,</span>
<span class="sd">    ``i`` and ``j`` are modified using correction constants ``alpha`` and</span>
<span class="sd">    ``beta`` whose choices depend on the ``method`` used. Finally, note that</span>
<span class="sd">    since Python uses 0-based indexing, the code subtracts another 1 from the</span>
<span class="sd">    index internally.</span>

<span class="sd">    The following formula determines the virtual index ``i + g``, the location</span>
<span class="sd">    of the percentile in the sorted sample:</span>

<span class="sd">    .. math::</span>
<span class="sd">        i + g = (q / 100) * ( n - alpha - beta + 1 ) + alpha</span>

<span class="sd">    The different methods then work as follows</span>

<span class="sd">    inverted_cdf:</span>
<span class="sd">        method 1 of H&amp;F [1]_.</span>
<span class="sd">        This method gives discontinuous results:</span>

<span class="sd">        * if g &gt; 0 ; then take j</span>
<span class="sd">        * if g = 0 ; then take i</span>

<span class="sd">    averaged_inverted_cdf:</span>
<span class="sd">        method 2 of H&amp;F [1]_.</span>
<span class="sd">        This method give discontinuous results:</span>

<span class="sd">        * if g &gt; 0 ; then take j</span>
<span class="sd">        * if g = 0 ; then average between bounds</span>

<span class="sd">    closest_observation:</span>
<span class="sd">        method 3 of H&amp;F [1]_.</span>
<span class="sd">        This method give discontinuous results:</span>

<span class="sd">        * if g &gt; 0 ; then take j</span>
<span class="sd">        * if g = 0 and index is odd ; then take j</span>
<span class="sd">        * if g = 0 and index is even ; then take i</span>

<span class="sd">    interpolated_inverted_cdf:</span>
<span class="sd">        method 4 of H&amp;F [1]_.</span>
<span class="sd">        This method give continuous results using:</span>

<span class="sd">        * alpha = 0</span>
<span class="sd">        * beta = 1</span>

<span class="sd">    hazen:</span>
<span class="sd">        method 5 of H&amp;F [1]_.</span>
<span class="sd">        This method give continuous results using:</span>

<span class="sd">        * alpha = 1/2</span>
<span class="sd">        * beta = 1/2</span>

<span class="sd">    weibull:</span>
<span class="sd">        method 6 of H&amp;F [1]_.</span>
<span class="sd">        This method give continuous results using:</span>

<span class="sd">        * alpha = 0</span>
<span class="sd">        * beta = 0</span>

<span class="sd">    linear:</span>
<span class="sd">        method 7 of H&amp;F [1]_.</span>
<span class="sd">        This method give continuous results using:</span>

<span class="sd">        * alpha = 1</span>
<span class="sd">        * beta = 1</span>

<span class="sd">    median_unbiased:</span>
<span class="sd">        method 8 of H&amp;F [1]_.</span>
<span class="sd">        This method is probably the best method if the sample</span>
<span class="sd">        distribution function is unknown (see reference).</span>
<span class="sd">        This method give continuous results using:</span>

<span class="sd">        * alpha = 1/3</span>
<span class="sd">        * beta = 1/3</span>

<span class="sd">    normal_unbiased:</span>
<span class="sd">        method 9 of H&amp;F [1]_.</span>
<span class="sd">        This method is probably the best method if the sample</span>
<span class="sd">        distribution function is known to be normal.</span>
<span class="sd">        This method give continuous results using:</span>

<span class="sd">        * alpha = 3/8</span>
<span class="sd">        * beta = 3/8</span>

<span class="sd">    lower:</span>
<span class="sd">        NumPy method kept for backwards compatibility.</span>
<span class="sd">        Takes ``i`` as the interpolation point.</span>

<span class="sd">    higher:</span>
<span class="sd">        NumPy method kept for backwards compatibility.</span>
<span class="sd">        Takes ``j`` as the interpolation point.</span>

<span class="sd">    nearest:</span>
<span class="sd">        NumPy method kept for backwards compatibility.</span>
<span class="sd">        Takes ``i`` or ``j``, whichever is nearest.</span>

<span class="sd">    midpoint:</span>
<span class="sd">        NumPy method kept for backwards compatibility.</span>
<span class="sd">        Uses ``(i + j) / 2``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([[10, 7, 4], [3, 2, 1]])</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[10,  7,  4],</span>
<span class="sd">           [ 3,  2,  1]])</span>
<span class="sd">    &gt;&gt;&gt; np.percentile(a, 50)</span>
<span class="sd">    3.5</span>
<span class="sd">    &gt;&gt;&gt; np.percentile(a, 50, axis=0)</span>
<span class="sd">    array([6.5, 4.5, 2.5])</span>
<span class="sd">    &gt;&gt;&gt; np.percentile(a, 50, axis=1)</span>
<span class="sd">    array([7.,  2.])</span>
<span class="sd">    &gt;&gt;&gt; np.percentile(a, 50, axis=1, keepdims=True)</span>
<span class="sd">    array([[7.],</span>
<span class="sd">           [2.]])</span>

<span class="sd">    &gt;&gt;&gt; m = np.percentile(a, 50, axis=0)</span>
<span class="sd">    &gt;&gt;&gt; out = np.zeros_like(m)</span>
<span class="sd">    &gt;&gt;&gt; np.percentile(a, 50, axis=0, out=out)</span>
<span class="sd">    array([6.5, 4.5, 2.5])</span>
<span class="sd">    &gt;&gt;&gt; m</span>
<span class="sd">    array([6.5, 4.5, 2.5])</span>

<span class="sd">    &gt;&gt;&gt; b = a.copy()</span>
<span class="sd">    &gt;&gt;&gt; np.percentile(b, 50, axis=1, overwrite_input=True)</span>
<span class="sd">    array([7.,  2.])</span>
<span class="sd">    &gt;&gt;&gt; assert not np.all(a == b)</span>

<span class="sd">    The different methods can be visualized graphically:</span>

<span class="sd">    .. plot::</span>

<span class="sd">        import matplotlib.pyplot as plt</span>

<span class="sd">        a = np.arange(4)</span>
<span class="sd">        p = np.linspace(0, 100, 6001)</span>
<span class="sd">        ax = plt.gca()</span>
<span class="sd">        lines = [</span>
<span class="sd">            (&#39;linear&#39;, &#39;-&#39;, &#39;C0&#39;),</span>
<span class="sd">            (&#39;inverted_cdf&#39;, &#39;:&#39;, &#39;C1&#39;),</span>
<span class="sd">            # Almost the same as `inverted_cdf`:</span>
<span class="sd">            (&#39;averaged_inverted_cdf&#39;, &#39;-.&#39;, &#39;C1&#39;),</span>
<span class="sd">            (&#39;closest_observation&#39;, &#39;:&#39;, &#39;C2&#39;),</span>
<span class="sd">            (&#39;interpolated_inverted_cdf&#39;, &#39;--&#39;, &#39;C1&#39;),</span>
<span class="sd">            (&#39;hazen&#39;, &#39;--&#39;, &#39;C3&#39;),</span>
<span class="sd">            (&#39;weibull&#39;, &#39;-.&#39;, &#39;C4&#39;),</span>
<span class="sd">            (&#39;median_unbiased&#39;, &#39;--&#39;, &#39;C5&#39;),</span>
<span class="sd">            (&#39;normal_unbiased&#39;, &#39;-.&#39;, &#39;C6&#39;),</span>
<span class="sd">            ]</span>
<span class="sd">        for method, style, color in lines:</span>
<span class="sd">            ax.plot(</span>
<span class="sd">                p, np.percentile(a, p, method=method),</span>
<span class="sd">                label=method, linestyle=style, color=color)</span>
<span class="sd">        ax.set(</span>
<span class="sd">            title=&#39;Percentiles for different methods and data: &#39; + str(a),</span>
<span class="sd">            xlabel=&#39;Percentile&#39;,</span>
<span class="sd">            ylabel=&#39;Estimated percentile value&#39;,</span>
<span class="sd">            yticks=a)</span>
<span class="sd">        ax.legend(bbox_to_anchor=(1.03, 1))</span>
<span class="sd">        plt.tight_layout()</span>
<span class="sd">        plt.show()</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] R. J. Hyndman and Y. Fan,</span>
<span class="sd">       &quot;Sample quantiles in statistical packages,&quot;</span>
<span class="sd">       The American Statistician, 50(4), pp. 361-365, 1996</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">interpolation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">method</span> <span class="o">=</span> <span class="n">_check_interpolation_as_method</span><span class="p">(</span>
            <span class="n">method</span><span class="p">,</span> <span class="n">interpolation</span><span class="p">,</span> <span class="s2">&quot;percentile&quot;</span><span class="p">)</span>

    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;c&quot;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;a must be an array of real numbers&quot;</span><span class="p">)</span>

    <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">true_divide</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">asanyarray</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>  <span class="c1"># undo any decay that the ufunc performed (see gh-13105)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">_quantile_is_valid</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Percentiles must be in the range [0, 100]&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_quantile_unchecked</span><span class="p">(</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">keepdims</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_quantile_dispatcher</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="n">method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>


<span class="nd">@array_function_dispatch</span><span class="p">(</span><span class="n">_quantile_dispatcher</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">quantile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span>
             <span class="n">q</span><span class="p">,</span>
             <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">overwrite_input</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
             <span class="n">method</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span>
             <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
             <span class="o">*</span><span class="p">,</span>
             <span class="n">interpolation</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the q-th quantile of the data along the specified axis.</span>

<span class="sd">    .. versionadded:: 1.15.0</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like of real numbers</span>
<span class="sd">        Input array or object that can be converted to an array.</span>
<span class="sd">    q : array_like of float</span>
<span class="sd">        Probability or sequence of probabilities for the quantiles to compute.</span>
<span class="sd">        Values must be between 0 and 1 inclusive.</span>
<span class="sd">    axis : {int, tuple of int, None}, optional</span>
<span class="sd">        Axis or axes along which the quantiles are computed. The default is</span>
<span class="sd">        to compute the quantile(s) along a flattened version of the array.</span>
<span class="sd">    out : ndarray, optional</span>
<span class="sd">        Alternative output array in which to place the result. It must have</span>
<span class="sd">        the same shape and buffer length as the expected output, but the</span>
<span class="sd">        type (of the output) will be cast if necessary.</span>
<span class="sd">    overwrite_input : bool, optional</span>
<span class="sd">        If True, then allow the input array `a` to be modified by</span>
<span class="sd">        intermediate calculations, to save memory. In this case, the</span>
<span class="sd">        contents of the input `a` after this function completes is</span>
<span class="sd">        undefined.</span>
<span class="sd">    method : str, optional</span>
<span class="sd">        This parameter specifies the method to use for estimating the</span>
<span class="sd">        quantile.  There are many different methods, some unique to NumPy.</span>
<span class="sd">        See the notes for explanation.  The options sorted by their R type</span>
<span class="sd">        as summarized in the H&amp;F paper [1]_ are:</span>

<span class="sd">        1. &#39;inverted_cdf&#39;</span>
<span class="sd">        2. &#39;averaged_inverted_cdf&#39;</span>
<span class="sd">        3. &#39;closest_observation&#39;</span>
<span class="sd">        4. &#39;interpolated_inverted_cdf&#39;</span>
<span class="sd">        5. &#39;hazen&#39;</span>
<span class="sd">        6. &#39;weibull&#39;</span>
<span class="sd">        7. &#39;linear&#39;  (default)</span>
<span class="sd">        8. &#39;median_unbiased&#39;</span>
<span class="sd">        9. &#39;normal_unbiased&#39;</span>

<span class="sd">        The first three methods are discontinuous.  NumPy further defines the</span>
<span class="sd">        following discontinuous variations of the default &#39;linear&#39; (7.) option:</span>

<span class="sd">        * &#39;lower&#39;</span>
<span class="sd">        * &#39;higher&#39;,</span>
<span class="sd">        * &#39;midpoint&#39;</span>
<span class="sd">        * &#39;nearest&#39;</span>

<span class="sd">        .. versionchanged:: 1.22.0</span>
<span class="sd">            This argument was previously called &quot;interpolation&quot; and only</span>
<span class="sd">            offered the &quot;linear&quot; default and last four options.</span>

<span class="sd">    keepdims : bool, optional</span>
<span class="sd">        If this is set to True, the axes which are reduced are left in</span>
<span class="sd">        the result as dimensions with size one. With this option, the</span>
<span class="sd">        result will broadcast correctly against the original array `a`.</span>

<span class="sd">    interpolation : str, optional</span>
<span class="sd">        Deprecated name for the method keyword argument.</span>

<span class="sd">        .. deprecated:: 1.22.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    quantile : scalar or ndarray</span>
<span class="sd">        If `q` is a single probability and `axis=None`, then the result</span>
<span class="sd">        is a scalar. If multiple probabilies levels are given, first axis of</span>
<span class="sd">        the result corresponds to the quantiles. The other axes are</span>
<span class="sd">        the axes that remain after the reduction of `a`. If the input</span>
<span class="sd">        contains integers or floats smaller than ``float64``, the output</span>
<span class="sd">        data-type is ``float64``. Otherwise, the output data-type is the</span>
<span class="sd">        same as that of the input. If `out` is specified, that array is</span>
<span class="sd">        returned instead.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    mean</span>
<span class="sd">    percentile : equivalent to quantile, but with q in the range [0, 100].</span>
<span class="sd">    median : equivalent to ``quantile(..., 0.5)``</span>
<span class="sd">    nanquantile</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Given a vector ``V`` of length ``n``, the q-th quantile of ``V`` is</span>
<span class="sd">    the value ``q`` of the way from the minimum to the maximum in a</span>
<span class="sd">    sorted copy of ``V``. The values and distances of the two nearest</span>
<span class="sd">    neighbors as well as the `method` parameter will determine the</span>
<span class="sd">    quantile if the normalized ranking does not match the location of</span>
<span class="sd">    ``q`` exactly. This function is the same as the median if ``q=0.5``, the</span>
<span class="sd">    same as the minimum if ``q=0.0`` and the same as the maximum if</span>
<span class="sd">    ``q=1.0``.</span>

<span class="sd">    The optional `method` parameter specifies the method to use when the</span>
<span class="sd">    desired quantile lies between two indexes ``i`` and ``j = i + 1``.</span>
<span class="sd">    In that case, we first determine ``i + g``, a virtual index that lies</span>
<span class="sd">    between ``i`` and ``j``, where  ``i`` is the floor and ``g`` is the</span>
<span class="sd">    fractional part of the index. The final result is, then, an interpolation</span>
<span class="sd">    of ``a[i]`` and ``a[j]`` based on ``g``. During the computation of ``g``,</span>
<span class="sd">    ``i`` and ``j`` are modified using correction constants ``alpha`` and</span>
<span class="sd">    ``beta`` whose choices depend on the ``method`` used. Finally, note that</span>
<span class="sd">    since Python uses 0-based indexing, the code subtracts another 1 from the</span>
<span class="sd">    index internally.</span>

<span class="sd">    The following formula determines the virtual index ``i + g``, the location</span>
<span class="sd">    of the quantile in the sorted sample:</span>

<span class="sd">    .. math::</span>
<span class="sd">        i + g = q * ( n - alpha - beta + 1 ) + alpha</span>

<span class="sd">    The different methods then work as follows</span>

<span class="sd">    inverted_cdf:</span>
<span class="sd">        method 1 of H&amp;F [1]_.</span>
<span class="sd">        This method gives discontinuous results:</span>

<span class="sd">        * if g &gt; 0 ; then take j</span>
<span class="sd">        * if g = 0 ; then take i</span>

<span class="sd">    averaged_inverted_cdf:</span>
<span class="sd">        method 2 of H&amp;F [1]_.</span>
<span class="sd">        This method gives discontinuous results:</span>

<span class="sd">        * if g &gt; 0 ; then take j</span>
<span class="sd">        * if g = 0 ; then average between bounds</span>

<span class="sd">    closest_observation:</span>
<span class="sd">        method 3 of H&amp;F [1]_.</span>
<span class="sd">        This method gives discontinuous results:</span>

<span class="sd">        * if g &gt; 0 ; then take j</span>
<span class="sd">        * if g = 0 and index is odd ; then take j</span>
<span class="sd">        * if g = 0 and index is even ; then take i</span>

<span class="sd">    interpolated_inverted_cdf:</span>
<span class="sd">        method 4 of H&amp;F [1]_.</span>
<span class="sd">        This method gives continuous results using:</span>

<span class="sd">        * alpha = 0</span>
<span class="sd">        * beta = 1</span>

<span class="sd">    hazen:</span>
<span class="sd">        method 5 of H&amp;F [1]_.</span>
<span class="sd">        This method gives continuous results using:</span>

<span class="sd">        * alpha = 1/2</span>
<span class="sd">        * beta = 1/2</span>

<span class="sd">    weibull:</span>
<span class="sd">        method 6 of H&amp;F [1]_.</span>
<span class="sd">        This method gives continuous results using:</span>

<span class="sd">        * alpha = 0</span>
<span class="sd">        * beta = 0</span>

<span class="sd">    linear:</span>
<span class="sd">        method 7 of H&amp;F [1]_.</span>
<span class="sd">        This method gives continuous results using:</span>

<span class="sd">        * alpha = 1</span>
<span class="sd">        * beta = 1</span>

<span class="sd">    median_unbiased:</span>
<span class="sd">        method 8 of H&amp;F [1]_.</span>
<span class="sd">        This method is probably the best method if the sample</span>
<span class="sd">        distribution function is unknown (see reference).</span>
<span class="sd">        This method gives continuous results using:</span>

<span class="sd">        * alpha = 1/3</span>
<span class="sd">        * beta = 1/3</span>

<span class="sd">    normal_unbiased:</span>
<span class="sd">        method 9 of H&amp;F [1]_.</span>
<span class="sd">        This method is probably the best method if the sample</span>
<span class="sd">        distribution function is known to be normal.</span>
<span class="sd">        This method gives continuous results using:</span>

<span class="sd">        * alpha = 3/8</span>
<span class="sd">        * beta = 3/8</span>

<span class="sd">    lower:</span>
<span class="sd">        NumPy method kept for backwards compatibility.</span>
<span class="sd">        Takes ``i`` as the interpolation point.</span>

<span class="sd">    higher:</span>
<span class="sd">        NumPy method kept for backwards compatibility.</span>
<span class="sd">        Takes ``j`` as the interpolation point.</span>

<span class="sd">    nearest:</span>
<span class="sd">        NumPy method kept for backwards compatibility.</span>
<span class="sd">        Takes ``i`` or ``j``, whichever is nearest.</span>

<span class="sd">    midpoint:</span>
<span class="sd">        NumPy method kept for backwards compatibility.</span>
<span class="sd">        Uses ``(i + j) / 2``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([[10, 7, 4], [3, 2, 1]])</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[10,  7,  4],</span>
<span class="sd">           [ 3,  2,  1]])</span>
<span class="sd">    &gt;&gt;&gt; np.quantile(a, 0.5)</span>
<span class="sd">    3.5</span>
<span class="sd">    &gt;&gt;&gt; np.quantile(a, 0.5, axis=0)</span>
<span class="sd">    array([6.5, 4.5, 2.5])</span>
<span class="sd">    &gt;&gt;&gt; np.quantile(a, 0.5, axis=1)</span>
<span class="sd">    array([7.,  2.])</span>
<span class="sd">    &gt;&gt;&gt; np.quantile(a, 0.5, axis=1, keepdims=True)</span>
<span class="sd">    array([[7.],</span>
<span class="sd">           [2.]])</span>
<span class="sd">    &gt;&gt;&gt; m = np.quantile(a, 0.5, axis=0)</span>
<span class="sd">    &gt;&gt;&gt; out = np.zeros_like(m)</span>
<span class="sd">    &gt;&gt;&gt; np.quantile(a, 0.5, axis=0, out=out)</span>
<span class="sd">    array([6.5, 4.5, 2.5])</span>
<span class="sd">    &gt;&gt;&gt; m</span>
<span class="sd">    array([6.5, 4.5, 2.5])</span>
<span class="sd">    &gt;&gt;&gt; b = a.copy()</span>
<span class="sd">    &gt;&gt;&gt; np.quantile(b, 0.5, axis=1, overwrite_input=True)</span>
<span class="sd">    array([7.,  2.])</span>
<span class="sd">    &gt;&gt;&gt; assert not np.all(a == b)</span>

<span class="sd">    See also `numpy.percentile` for a visualization of most methods.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] R. J. Hyndman and Y. Fan,</span>
<span class="sd">       &quot;Sample quantiles in statistical packages,&quot;</span>
<span class="sd">       The American Statistician, 50(4), pp. 361-365, 1996</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">interpolation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">method</span> <span class="o">=</span> <span class="n">_check_interpolation_as_method</span><span class="p">(</span>
            <span class="n">method</span><span class="p">,</span> <span class="n">interpolation</span><span class="p">,</span> <span class="s2">&quot;quantile&quot;</span><span class="p">)</span>

    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;c&quot;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;a must be an array of real numbers&quot;</span><span class="p">)</span>

    <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">_quantile_is_valid</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Quantiles must be in the range [0, 1]&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_quantile_unchecked</span><span class="p">(</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">keepdims</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_quantile_unchecked</span><span class="p">(</span><span class="n">a</span><span class="p">,</span>
                        <span class="n">q</span><span class="p">,</span>
                        <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">overwrite_input</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">method</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span>
                        <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Assumes that q is in [0, 1], and is an ndarray&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_ureduce</span><span class="p">(</span><span class="n">a</span><span class="p">,</span>
                    <span class="n">func</span><span class="o">=</span><span class="n">_quantile_ureduce_func</span><span class="p">,</span>
                    <span class="n">q</span><span class="o">=</span><span class="n">q</span><span class="p">,</span>
                    <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span>
                    <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
                    <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
                    <span class="n">overwrite_input</span><span class="o">=</span><span class="n">overwrite_input</span><span class="p">,</span>
                    <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_quantile_is_valid</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
    <span class="c1"># avoid expensive reductions, relevant for arrays with &lt; O(1000) elements</span>
    <span class="k">if</span> <span class="n">q</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">q</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mf">0.0</span> <span class="o">&lt;=</span> <span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mf">1.0</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">q</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">q</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)):</span>
            <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span>


<span class="k">def</span> <span class="nf">_check_interpolation_as_method</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">interpolation</span><span class="p">,</span> <span class="n">fname</span><span class="p">):</span>
    <span class="c1"># Deprecated NumPy 1.22, 2021-11-08</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;the `interpolation=` argument to </span><span class="si">{</span><span class="n">fname</span><span class="si">}</span><span class="s2"> was renamed to &quot;</span>
        <span class="s2">&quot;`method=`, which has additional options.</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="s2">&quot;Users of the modes &#39;nearest&#39;, &#39;lower&#39;, &#39;higher&#39;, or &quot;</span>
        <span class="s2">&quot;&#39;midpoint&#39; are encouraged to review the method they used. &quot;</span>
        <span class="s2">&quot;(Deprecated NumPy 1.22)&quot;</span><span class="p">,</span>
        <span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">!=</span> <span class="s2">&quot;linear&quot;</span><span class="p">:</span>
        <span class="c1"># sanity check, we assume this basically never happens</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;You shall not pass both `method` and `interpolation`!</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;(`interpolation` is Deprecated in favor of `method`)&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">interpolation</span>


<span class="k">def</span> <span class="nf">_compute_virtual_index</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">quantiles</span><span class="p">,</span> <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">beta</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the floating point indexes of an array for the linear</span>
<span class="sd">    interpolation of quantiles.</span>
<span class="sd">    n : array_like</span>
<span class="sd">        The sample sizes.</span>
<span class="sd">    quantiles : array_like</span>
<span class="sd">        The quantiles values.</span>
<span class="sd">    alpha : float</span>
<span class="sd">        A constant used to correct the index computed.</span>
<span class="sd">    beta : float</span>
<span class="sd">        A constant used to correct the index computed.</span>

<span class="sd">    alpha and beta values depend on the chosen method</span>
<span class="sd">    (see quantile documentation)</span>

<span class="sd">    Reference:</span>
<span class="sd">    Hyndman&amp;Fan paper &quot;Sample Quantiles in Statistical Packages&quot;,</span>
<span class="sd">    DOI: 10.1080/00031305.1996.10473566</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="n">quantiles</span> <span class="o">+</span> <span class="p">(</span>
            <span class="n">alpha</span> <span class="o">+</span> <span class="n">quantiles</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">alpha</span> <span class="o">-</span> <span class="n">beta</span><span class="p">)</span>
    <span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>


<span class="k">def</span> <span class="nf">_get_gamma</span><span class="p">(</span><span class="n">virtual_indexes</span><span class="p">,</span> <span class="n">previous_indexes</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute gamma (a.k.a &#39;m&#39; or &#39;weight&#39;) for the linear interpolation</span>
<span class="sd">    of quantiles.</span>

<span class="sd">    virtual_indexes : array_like</span>
<span class="sd">        The indexes where the percentile is supposed to be found in the sorted</span>
<span class="sd">        sample.</span>
<span class="sd">    previous_indexes : array_like</span>
<span class="sd">        The floor values of virtual_indexes.</span>
<span class="sd">    interpolation : dict</span>
<span class="sd">        The interpolation method chosen, which may have a specific rule</span>
<span class="sd">        modifying gamma.</span>

<span class="sd">    gamma is usually the fractional part of virtual_indexes but can be modified</span>
<span class="sd">    by the interpolation method.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">gamma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">virtual_indexes</span> <span class="o">-</span> <span class="n">previous_indexes</span><span class="p">)</span>
    <span class="n">gamma</span> <span class="o">=</span> <span class="n">method</span><span class="p">[</span><span class="s2">&quot;fix_gamma&quot;</span><span class="p">](</span><span class="n">gamma</span><span class="p">,</span> <span class="n">virtual_indexes</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_lerp</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the linear interpolation weighted by gamma on each point of</span>
<span class="sd">    two same shape array.</span>

<span class="sd">    a : array_like</span>
<span class="sd">        Left bound.</span>
<span class="sd">    b : array_like</span>
<span class="sd">        Right bound.</span>
<span class="sd">    t : array_like</span>
<span class="sd">        The interpolation weight.</span>
<span class="sd">    out : array_like</span>
<span class="sd">        Output array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">diff_b_a</span> <span class="o">=</span> <span class="n">subtract</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
    <span class="c1"># asanyarray is a stop-gap until gh-13105</span>
    <span class="n">lerp_interpolation</span> <span class="o">=</span> <span class="n">asanyarray</span><span class="p">(</span><span class="n">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">diff_b_a</span> <span class="o">*</span> <span class="n">t</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">))</span>
    <span class="n">subtract</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">diff_b_a</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">t</span><span class="p">),</span> <span class="n">out</span><span class="o">=</span><span class="n">lerp_interpolation</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="n">t</span> <span class="o">&gt;=</span> <span class="mf">0.5</span><span class="p">,</span>
             <span class="n">casting</span><span class="o">=</span><span class="s1">&#39;unsafe&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="n">lerp_interpolation</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">lerp_interpolation</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">lerp_interpolation</span> <span class="o">=</span> <span class="n">lerp_interpolation</span><span class="p">[()]</span>  <span class="c1"># unpack 0d arrays</span>
    <span class="k">return</span> <span class="n">lerp_interpolation</span>


<span class="k">def</span> <span class="nf">_get_gamma_mask</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">default_value</span><span class="p">,</span> <span class="n">conditioned_value</span><span class="p">,</span> <span class="n">where</span><span class="p">):</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">default_value</span><span class="p">)</span>
    <span class="n">np</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">conditioned_value</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span> <span class="n">casting</span><span class="o">=</span><span class="s2">&quot;unsafe&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out</span>


<span class="k">def</span> <span class="nf">_discret_interpolation_to_boundaries</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">gamma_condition_fun</span><span class="p">):</span>
    <span class="n">previous</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
    <span class="nb">next</span> <span class="o">=</span> <span class="n">previous</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">gamma</span> <span class="o">=</span> <span class="n">index</span> <span class="o">-</span> <span class="n">previous</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">_get_gamma_mask</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">index</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                          <span class="n">default_value</span><span class="o">=</span><span class="nb">next</span><span class="p">,</span>
                          <span class="n">conditioned_value</span><span class="o">=</span><span class="n">previous</span><span class="p">,</span>
                          <span class="n">where</span><span class="o">=</span><span class="n">gamma_condition_fun</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
                          <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
    <span class="c1"># Some methods can lead to out-of-bound integers, clip them:</span>
    <span class="n">res</span><span class="p">[</span><span class="n">res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">res</span>


<span class="k">def</span> <span class="nf">_closest_observation</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">quantiles</span><span class="p">):</span>
    <span class="n">gamma_fun</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="p">(</span><span class="n">gamma</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_discret_interpolation_to_boundaries</span><span class="p">((</span><span class="n">n</span> <span class="o">*</span> <span class="n">quantiles</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">,</span>
                                                <span class="n">gamma_fun</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_inverted_cdf</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">quantiles</span><span class="p">):</span>
    <span class="n">gamma_fun</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="p">(</span><span class="n">gamma</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_discret_interpolation_to_boundaries</span><span class="p">((</span><span class="n">n</span> <span class="o">*</span> <span class="n">quantiles</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                                                <span class="n">gamma_fun</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_quantile_ureduce_func</span><span class="p">(</span>
        <span class="n">a</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span>
        <span class="n">q</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">overwrite_input</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">q</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="c1"># The code below works fine for nd, but it might not have useful</span>
        <span class="c1"># semantics. For now, keep the supported dimensions the same as it was</span>
        <span class="c1"># before.</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;q must be a scalar or 1d&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">overwrite_input</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">a</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">_quantile</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span>
                       <span class="n">quantiles</span><span class="o">=</span><span class="n">q</span><span class="p">,</span>
                       <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
                       <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                       <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">_get_indexes</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">virtual_indexes</span><span class="p">,</span> <span class="n">valid_values_count</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the valid indexes of arr neighbouring virtual_indexes.</span>
<span class="sd">    Note</span>
<span class="sd">    This is a companion function to linear interpolation of</span>
<span class="sd">    Quantiles</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    (previous_indexes, next_indexes): Tuple</span>
<span class="sd">        A Tuple of virtual_indexes neighbouring indexes</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">previous_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">virtual_indexes</span><span class="p">))</span>
    <span class="n">next_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">previous_indexes</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">indexes_above_bounds</span> <span class="o">=</span> <span class="n">virtual_indexes</span> <span class="o">&gt;=</span> <span class="n">valid_values_count</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="c1"># When indexes is above max index, take the max value of the array</span>
    <span class="k">if</span> <span class="n">indexes_above_bounds</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="n">previous_indexes</span><span class="p">[</span><span class="n">indexes_above_bounds</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">next_indexes</span><span class="p">[</span><span class="n">indexes_above_bounds</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="c1"># When indexes is below min index, take the min value of the array</span>
    <span class="n">indexes_below_bounds</span> <span class="o">=</span> <span class="n">virtual_indexes</span> <span class="o">&lt;</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">indexes_below_bounds</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="n">previous_indexes</span><span class="p">[</span><span class="n">indexes_below_bounds</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">next_indexes</span><span class="p">[</span><span class="n">indexes_below_bounds</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inexact</span><span class="p">):</span>
        <span class="c1"># After the sort, slices having NaNs will have for last element a NaN</span>
        <span class="n">virtual_indexes_nans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">virtual_indexes</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">virtual_indexes_nans</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">previous_indexes</span><span class="p">[</span><span class="n">virtual_indexes_nans</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">next_indexes</span><span class="p">[</span><span class="n">virtual_indexes_nans</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">previous_indexes</span> <span class="o">=</span> <span class="n">previous_indexes</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
    <span class="n">next_indexes</span> <span class="o">=</span> <span class="n">next_indexes</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">previous_indexes</span><span class="p">,</span> <span class="n">next_indexes</span>


<span class="k">def</span> <span class="nf">_quantile</span><span class="p">(</span>
        <span class="n">arr</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span>
        <span class="n">quantiles</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Private function that doesn&#39;t support extended axis or keepdims.</span>
<span class="sd">    These methods are extended to this function using _ureduce</span>
<span class="sd">    See nanpercentile for parameter usage</span>
<span class="sd">    It computes the quantiles of the array for the given axis.</span>
<span class="sd">    A linear interpolation is performed based on the `interpolation`.</span>

<span class="sd">    By default, the method is &quot;linear&quot; where alpha == beta == 1 which</span>
<span class="sd">    performs the 7th method of Hyndman&amp;Fan.</span>
<span class="sd">    With &quot;median_unbiased&quot; we get alpha == beta == 1/3</span>
<span class="sd">    thus the 8th method of Hyndman&amp;Fan.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># --- Setup</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="n">values_count</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
    <span class="c1"># The dimensions of `q` are prepended to the output shape, so we need the</span>
    <span class="c1"># axis being sampled from `arr` to be last.</span>

    <span class="k">if</span> <span class="n">axis</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># But moveaxis is slow, so only call it if necessary.</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1"># --- Computation of indexes</span>
    <span class="c1"># Index where to find the value in the sorted array.</span>
    <span class="c1"># Virtual because it is a floating point value, not an valid index.</span>
    <span class="c1"># The nearest neighbours are used for interpolation</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">method</span> <span class="o">=</span> <span class="n">_QuantileMethods</span><span class="p">[</span><span class="n">method</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">method</span><span class="si">!r}</span><span class="s2"> is not a valid method. Use one of: &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">_QuantileMethods</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="kc">None</span>
    <span class="n">virtual_indexes</span> <span class="o">=</span> <span class="n">method</span><span class="p">[</span><span class="s2">&quot;get_virtual_index&quot;</span><span class="p">](</span><span class="n">values_count</span><span class="p">,</span> <span class="n">quantiles</span><span class="p">)</span>
    <span class="n">virtual_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">virtual_indexes</span><span class="p">)</span>

    <span class="n">supports_nans</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inexact</span><span class="p">)</span> <span class="ow">or</span> <span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="s1">&#39;Mm&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">virtual_indexes</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
        <span class="c1"># No interpolation needed, take the points along axis</span>
        <span class="k">if</span> <span class="n">supports_nans</span><span class="p">:</span>
            <span class="c1"># may contain nan, which would sort to the end</span>
            <span class="n">arr</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="n">concatenate</span><span class="p">((</span><span class="n">virtual_indexes</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">slices_having_nans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">...</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># cannot contain nan</span>
            <span class="n">arr</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="n">virtual_indexes</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">slices_having_nans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">take</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">virtual_indexes</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">previous_indexes</span><span class="p">,</span> <span class="n">next_indexes</span> <span class="o">=</span> <span class="n">_get_indexes</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span>
                                                      <span class="n">virtual_indexes</span><span class="p">,</span>
                                                      <span class="n">values_count</span><span class="p">)</span>
        <span class="c1"># --- Sorting</span>
        <span class="n">arr</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                                      <span class="n">previous_indexes</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                                      <span class="n">next_indexes</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                                      <span class="p">))),</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">supports_nans</span><span class="p">:</span>
            <span class="n">slices_having_nans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">...</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">slices_having_nans</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># --- Get values from indexes</span>
        <span class="n">previous</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">previous_indexes</span><span class="p">]</span>
        <span class="nb">next</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">next_indexes</span><span class="p">]</span>
        <span class="c1"># --- Linear interpolation</span>
        <span class="n">gamma</span> <span class="o">=</span> <span class="n">_get_gamma</span><span class="p">(</span><span class="n">virtual_indexes</span><span class="p">,</span> <span class="n">previous_indexes</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>
        <span class="n">result_shape</span> <span class="o">=</span> <span class="n">virtual_indexes</span><span class="o">.</span><span class="n">shape</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">gamma</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">result_shape</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">_lerp</span><span class="p">(</span><span class="n">previous</span><span class="p">,</span>
                       <span class="nb">next</span><span class="p">,</span>
                       <span class="n">gamma</span><span class="p">,</span>
                       <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">slices_having_nans</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># can&#39;t write to a scalar, but indexing will be correct</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">arr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">where</span><span class="o">=</span><span class="n">slices_having_nans</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">_trapz_dispatcher</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>


<span class="nd">@array_function_dispatch</span><span class="p">(</span><span class="n">_trapz_dispatcher</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">trapz</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dx</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Integrate along the given axis using the composite trapezoidal rule.</span>

<span class="sd">    If `x` is provided, the integration happens in sequence along its</span>
<span class="sd">    elements - they are not sorted.</span>

<span class="sd">    Integrate `y` (`x`) along each 1d slice on the given axis, compute</span>
<span class="sd">    :math:`\int y(x) dx`.</span>
<span class="sd">    When `x` is specified, this integrates along the parametric curve,</span>
<span class="sd">    computing :math:`\int_t y(t) dt =</span>
<span class="sd">    \int_t y(t) \left.\frac{dx}{dt}\right|_{x=x(t)} dt`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : array_like</span>
<span class="sd">        Input array to integrate.</span>
<span class="sd">    x : array_like, optional</span>
<span class="sd">        The sample points corresponding to the `y` values. If `x` is None,</span>
<span class="sd">        the sample points are assumed to be evenly spaced `dx` apart. The</span>
<span class="sd">        default is None.</span>
<span class="sd">    dx : scalar, optional</span>
<span class="sd">        The spacing between sample points when `x` is None. The default is 1.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        The axis along which to integrate.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    trapz : float or ndarray</span>
<span class="sd">        Definite integral of `y` = n-dimensional array as approximated along</span>
<span class="sd">        a single axis by the trapezoidal rule. If `y` is a 1-dimensional array,</span>
<span class="sd">        then the result is a float. If `n` is greater than 1, then the result</span>
<span class="sd">        is an `n`-1 dimensional array.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    sum, cumsum</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Image [2]_ illustrates trapezoidal rule -- y-axis locations of points</span>
<span class="sd">    will be taken from `y` array, by default x-axis distances between</span>
<span class="sd">    points will be 1.0, alternatively they can be provided with `x` array</span>
<span class="sd">    or with `dx` scalar.  Return value will be equal to combined area under</span>
<span class="sd">    the red lines.</span>


<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Wikipedia page: https://en.wikipedia.org/wiki/Trapezoidal_rule</span>

<span class="sd">    .. [2] Illustration image:</span>
<span class="sd">           https://en.wikipedia.org/wiki/File:Composite_trapezoidal_rule_illustration.png</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Use the trapezoidal rule on evenly spaced points:</span>

<span class="sd">    &gt;&gt;&gt; np.trapz([1, 2, 3])</span>
<span class="sd">    4.0</span>

<span class="sd">    The spacing between sample points can be selected by either the</span>
<span class="sd">    ``x`` or ``dx`` arguments:</span>

<span class="sd">    &gt;&gt;&gt; np.trapz([1, 2, 3], x=[4, 6, 8])</span>
<span class="sd">    8.0</span>
<span class="sd">    &gt;&gt;&gt; np.trapz([1, 2, 3], dx=2)</span>
<span class="sd">    8.0</span>

<span class="sd">    Using a decreasing ``x`` corresponds to integrating in reverse:</span>

<span class="sd">    &gt;&gt;&gt; np.trapz([1, 2, 3], x=[8, 6, 4])</span>
<span class="sd">    -8.0</span>

<span class="sd">    More generally ``x`` is used to integrate along a parametric curve. We can</span>
<span class="sd">    estimate the integral :math:`\int_0^1 x^2 = 1/3` using:</span>

<span class="sd">    &gt;&gt;&gt; x = np.linspace(0, 1, num=50)</span>
<span class="sd">    &gt;&gt;&gt; y = x**2</span>
<span class="sd">    &gt;&gt;&gt; np.trapz(y, x)</span>
<span class="sd">    0.33340274885464394</span>

<span class="sd">    Or estimate the area of a circle, noting we repeat the sample which closes</span>
<span class="sd">    the curve:</span>

<span class="sd">    &gt;&gt;&gt; theta = np.linspace(0, 2 * np.pi, num=1000, endpoint=True)</span>
<span class="sd">    &gt;&gt;&gt; np.trapz(np.cos(theta), x=np.sin(theta))</span>
<span class="sd">    3.141571941375841</span>

<span class="sd">    ``np.trapz`` can be applied along a specified axis to do multiple</span>
<span class="sd">    computations in one call:</span>

<span class="sd">    &gt;&gt;&gt; a = np.arange(6).reshape(2, 3)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[0, 1, 2],</span>
<span class="sd">           [3, 4, 5]])</span>
<span class="sd">    &gt;&gt;&gt; np.trapz(a, axis=0)</span>
<span class="sd">    array([1.5, 2.5, 3.5])</span>
<span class="sd">    &gt;&gt;&gt; np.trapz(a, axis=1)</span>
<span class="sd">    array([2.,  8.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">asanyarray</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">dx</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">asanyarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="c1"># reshape to correct shape</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">y</span><span class="o">.</span><span class="n">ndim</span>
            <span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="n">nd</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">slice1</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span><span class="o">*</span><span class="n">nd</span>
    <span class="n">slice2</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span><span class="o">*</span><span class="n">nd</span>
    <span class="n">slice1</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">slice2</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="n">d</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slice1</span><span class="p">)]</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slice2</span><span class="p">)])</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="c1"># Operations didn&#39;t work, cast to ndarray</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">add</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">d</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slice1</span><span class="p">)]</span><span class="o">+</span><span class="n">y</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slice2</span><span class="p">)])</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ret</span>


<span class="c1"># __array_function__ has no __code__ or other attributes normal Python funcs we</span>
<span class="c1"># wrap everything into a C callable. SciPy however, tries to &quot;clone&quot; `trapz`</span>
<span class="c1"># into a new Python function which requires `__code__` and a few other</span>
<span class="c1"># attributes. So we create a dummy clone and copy over its attributes allowing</span>
<span class="c1"># SciPy &lt;= 1.10 to work: https://github.com/scipy/scipy/issues/17811</span>
<span class="k">assert</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">trapz</span><span class="p">,</span> <span class="s2">&quot;__code__&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_fake_trapz</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dx</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">trapz</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">dx</span><span class="o">=</span><span class="n">dx</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>


<span class="n">trapz</span><span class="o">.</span><span class="vm">__code__</span> <span class="o">=</span> <span class="n">_fake_trapz</span><span class="o">.</span><span class="vm">__code__</span>
<span class="n">trapz</span><span class="o">.</span><span class="vm">__globals__</span> <span class="o">=</span> <span class="n">_fake_trapz</span><span class="o">.</span><span class="vm">__globals__</span>
<span class="n">trapz</span><span class="o">.</span><span class="vm">__defaults__</span> <span class="o">=</span> <span class="n">_fake_trapz</span><span class="o">.</span><span class="vm">__defaults__</span>
<span class="n">trapz</span><span class="o">.</span><span class="vm">__closure__</span> <span class="o">=</span> <span class="n">_fake_trapz</span><span class="o">.</span><span class="vm">__closure__</span>
<span class="n">trapz</span><span class="o">.</span><span class="vm">__kwdefaults__</span> <span class="o">=</span> <span class="n">_fake_trapz</span><span class="o">.</span><span class="vm">__kwdefaults__</span>


<span class="k">def</span> <span class="nf">_meshgrid_dispatcher</span><span class="p">(</span><span class="o">*</span><span class="n">xi</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">xi</span>


<span class="c1"># Based on scitools meshgrid</span>
<span class="nd">@array_function_dispatch</span><span class="p">(</span><span class="n">_meshgrid_dispatcher</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="n">xi</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;xy&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a list of coordinate matrices from coordinate vectors.</span>

<span class="sd">    Make N-D coordinate arrays for vectorized evaluations of</span>
<span class="sd">    N-D scalar/vector fields over N-D grids, given</span>
<span class="sd">    one-dimensional coordinate arrays x1, x2,..., xn.</span>

<span class="sd">    .. versionchanged:: 1.9</span>
<span class="sd">       1-D and 0-D cases are allowed.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1, x2,..., xn : array_like</span>
<span class="sd">        1-D arrays representing the coordinates of a grid.</span>
<span class="sd">    indexing : {&#39;xy&#39;, &#39;ij&#39;}, optional</span>
<span class="sd">        Cartesian (&#39;xy&#39;, default) or matrix (&#39;ij&#39;) indexing of output.</span>
<span class="sd">        See Notes for more details.</span>

<span class="sd">        .. versionadded:: 1.7.0</span>
<span class="sd">    sparse : bool, optional</span>
<span class="sd">        If True the shape of the returned coordinate array for dimension *i*</span>
<span class="sd">        is reduced from ``(N1, ..., Ni, ... Nn)`` to</span>
<span class="sd">        ``(1, ..., 1, Ni, 1, ..., 1)``.  These sparse coordinate grids are</span>
<span class="sd">        intended to be use with :ref:`basics.broadcasting`.  When all</span>
<span class="sd">        coordinates are used in an expression, broadcasting still leads to a</span>
<span class="sd">        fully-dimensonal result array.</span>

<span class="sd">        Default is False.</span>

<span class="sd">        .. versionadded:: 1.7.0</span>
<span class="sd">    copy : bool, optional</span>
<span class="sd">        If False, a view into the original arrays are returned in order to</span>
<span class="sd">        conserve memory.  Default is True.  Please note that</span>
<span class="sd">        ``sparse=False, copy=False`` will likely return non-contiguous</span>
<span class="sd">        arrays.  Furthermore, more than one element of a broadcast array</span>
<span class="sd">        may refer to a single memory location.  If you need to write to the</span>
<span class="sd">        arrays, make copies first.</span>

<span class="sd">        .. versionadded:: 1.7.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    X1, X2,..., XN : list of ndarrays</span>
<span class="sd">        For vectors `x1`, `x2`,..., `xn` with lengths ``Ni=len(xi)``,</span>
<span class="sd">        returns ``(N1, N2, N3,..., Nn)`` shaped arrays if indexing=&#39;ij&#39;</span>
<span class="sd">        or ``(N2, N1, N3,..., Nn)`` shaped arrays if indexing=&#39;xy&#39;</span>
<span class="sd">        with the elements of `xi` repeated to fill the matrix along</span>
<span class="sd">        the first dimension for `x1`, the second for `x2` and so on.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function supports both indexing conventions through the indexing</span>
<span class="sd">    keyword argument.  Giving the string &#39;ij&#39; returns a meshgrid with</span>
<span class="sd">    matrix indexing, while &#39;xy&#39; returns a meshgrid with Cartesian indexing.</span>
<span class="sd">    In the 2-D case with inputs of length M and N, the outputs are of shape</span>
<span class="sd">    (N, M) for &#39;xy&#39; indexing and (M, N) for &#39;ij&#39; indexing.  In the 3-D case</span>
<span class="sd">    with inputs of length M, N and P, outputs are of shape (N, M, P) for</span>
<span class="sd">    &#39;xy&#39; indexing and (M, N, P) for &#39;ij&#39; indexing.  The difference is</span>
<span class="sd">    illustrated by the following code snippet::</span>

<span class="sd">        xv, yv = np.meshgrid(x, y, indexing=&#39;ij&#39;)</span>
<span class="sd">        for i in range(nx):</span>
<span class="sd">            for j in range(ny):</span>
<span class="sd">                # treat xv[i,j], yv[i,j]</span>

<span class="sd">        xv, yv = np.meshgrid(x, y, indexing=&#39;xy&#39;)</span>
<span class="sd">        for i in range(nx):</span>
<span class="sd">            for j in range(ny):</span>
<span class="sd">                # treat xv[j,i], yv[j,i]</span>

<span class="sd">    In the 1-D and 0-D case, the indexing and sparse keywords have no effect.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    mgrid : Construct a multi-dimensional &quot;meshgrid&quot; using indexing notation.</span>
<span class="sd">    ogrid : Construct an open multi-dimensional &quot;meshgrid&quot; using indexing</span>
<span class="sd">            notation.</span>
<span class="sd">    how-to-index</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; nx, ny = (3, 2)</span>
<span class="sd">    &gt;&gt;&gt; x = np.linspace(0, 1, nx)</span>
<span class="sd">    &gt;&gt;&gt; y = np.linspace(0, 1, ny)</span>
<span class="sd">    &gt;&gt;&gt; xv, yv = np.meshgrid(x, y)</span>
<span class="sd">    &gt;&gt;&gt; xv</span>
<span class="sd">    array([[0. , 0.5, 1. ],</span>
<span class="sd">           [0. , 0.5, 1. ]])</span>
<span class="sd">    &gt;&gt;&gt; yv</span>
<span class="sd">    array([[0.,  0.,  0.],</span>
<span class="sd">           [1.,  1.,  1.]])</span>

<span class="sd">    The result of `meshgrid` is a coordinate grid:</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(xv, yv, marker=&#39;o&#39;, color=&#39;k&#39;, linestyle=&#39;none&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    You can create sparse output arrays to save memory and computation time.</span>

<span class="sd">    &gt;&gt;&gt; xv, yv = np.meshgrid(x, y, sparse=True)</span>
<span class="sd">    &gt;&gt;&gt; xv</span>
<span class="sd">    array([[0. ,  0.5,  1. ]])</span>
<span class="sd">    &gt;&gt;&gt; yv</span>
<span class="sd">    array([[0.],</span>
<span class="sd">           [1.]])</span>

<span class="sd">    `meshgrid` is very useful to evaluate functions on a grid. If the</span>
<span class="sd">    function depends on all coordinates, both dense and sparse outputs can be</span>
<span class="sd">    used.</span>

<span class="sd">    &gt;&gt;&gt; x = np.linspace(-5, 5, 101)</span>
<span class="sd">    &gt;&gt;&gt; y = np.linspace(-5, 5, 101)</span>
<span class="sd">    &gt;&gt;&gt; # full coordinate arrays</span>
<span class="sd">    &gt;&gt;&gt; xx, yy = np.meshgrid(x, y)</span>
<span class="sd">    &gt;&gt;&gt; zz = np.sqrt(xx**2 + yy**2)</span>
<span class="sd">    &gt;&gt;&gt; xx.shape, yy.shape, zz.shape</span>
<span class="sd">    ((101, 101), (101, 101), (101, 101))</span>
<span class="sd">    &gt;&gt;&gt; # sparse coordinate arrays</span>
<span class="sd">    &gt;&gt;&gt; xs, ys = np.meshgrid(x, y, sparse=True)</span>
<span class="sd">    &gt;&gt;&gt; zs = np.sqrt(xs**2 + ys**2)</span>
<span class="sd">    &gt;&gt;&gt; xs.shape, ys.shape, zs.shape</span>
<span class="sd">    ((1, 101), (101, 1), (101, 101))</span>
<span class="sd">    &gt;&gt;&gt; np.array_equal(zz, zs)</span>
<span class="sd">    True</span>

<span class="sd">    &gt;&gt;&gt; h = plt.contourf(x, y, zs)</span>
<span class="sd">    &gt;&gt;&gt; plt.axis(&#39;scaled&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.colorbar()</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">indexing</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;xy&#39;</span><span class="p">,</span> <span class="s1">&#39;ij&#39;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Valid values for `indexing` are &#39;xy&#39; and &#39;ij&#39;.&quot;</span><span class="p">)</span>

    <span class="n">s0</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">*</span> <span class="n">ndim</span>
    <span class="n">output</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">s0</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,)</span> <span class="o">+</span> <span class="n">s0</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:])</span>
              <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">xi</span><span class="p">)]</span>

    <span class="k">if</span> <span class="n">indexing</span> <span class="o">==</span> <span class="s1">&#39;xy&#39;</span> <span class="ow">and</span> <span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># switch first and second axis</span>
        <span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">s0</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
        <span class="n">output</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">s0</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">sparse</span><span class="p">:</span>
        <span class="c1"># Return the full N-D matrix (not only the 1-D vector)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_arrays</span><span class="p">(</span><span class="o">*</span><span class="n">output</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
        <span class="n">output</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">output</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">output</span>


<span class="k">def</span> <span class="nf">_delete_dispatcher</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>


<span class="nd">@array_function_dispatch</span><span class="p">(</span><span class="n">_delete_dispatcher</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">delete</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a new array with sub-arrays along an axis deleted. For a one</span>
<span class="sd">    dimensional array, this returns those entries not returned by</span>
<span class="sd">    `arr[obj]`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr : array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    obj : slice, int or array of ints</span>
<span class="sd">        Indicate indices of sub-arrays to remove along the specified axis.</span>

<span class="sd">        .. versionchanged:: 1.19.0</span>
<span class="sd">            Boolean indices are now treated as a mask of elements to remove,</span>
<span class="sd">            rather than being cast to the integers 0 and 1.</span>

<span class="sd">    axis : int, optional</span>
<span class="sd">        The axis along which to delete the subarray defined by `obj`.</span>
<span class="sd">        If `axis` is None, `obj` is applied to the flattened array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : ndarray</span>
<span class="sd">        A copy of `arr` with the elements specified by `obj` removed. Note</span>
<span class="sd">        that `delete` does not occur in-place. If `axis` is None, `out` is</span>
<span class="sd">        a flattened array.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    insert : Insert elements into an array.</span>
<span class="sd">    append : Append elements at the end of an array.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Often it is preferable to use a boolean mask. For example:</span>

<span class="sd">    &gt;&gt;&gt; arr = np.arange(12) + 1</span>
<span class="sd">    &gt;&gt;&gt; mask = np.ones(len(arr), dtype=bool)</span>
<span class="sd">    &gt;&gt;&gt; mask[[0,2,4]] = False</span>
<span class="sd">    &gt;&gt;&gt; result = arr[mask,...]</span>

<span class="sd">    Is equivalent to ``np.delete(arr, [0,2,4], axis=0)``, but allows further</span>
<span class="sd">    use of `mask`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; arr = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])</span>
<span class="sd">    &gt;&gt;&gt; arr</span>
<span class="sd">    array([[ 1,  2,  3,  4],</span>
<span class="sd">           [ 5,  6,  7,  8],</span>
<span class="sd">           [ 9, 10, 11, 12]])</span>
<span class="sd">    &gt;&gt;&gt; np.delete(arr, 1, 0)</span>
<span class="sd">    array([[ 1,  2,  3,  4],</span>
<span class="sd">           [ 9, 10, 11, 12]])</span>

<span class="sd">    &gt;&gt;&gt; np.delete(arr, np.s_[::2], 1)</span>
<span class="sd">    array([[ 2,  4],</span>
<span class="sd">           [ 6,  8],</span>
<span class="sd">           [10, 12]])</span>
<span class="sd">    &gt;&gt;&gt; np.delete(arr, [1,3,5], None)</span>
<span class="sd">    array([ 1,  3,  5,  7,  8,  9, 10, 11, 12])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">wrap</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">ndarray</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">wrap</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">__array_wrap__</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>

    <span class="n">arr</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="n">ndim</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">arrorder</span> <span class="o">=</span> <span class="s1">&#39;F&#39;</span> <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">fnc</span> <span class="k">else</span> <span class="s1">&#39;C&#39;</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="c1"># needed for np.matrix, which is still not 1d after being ravelled</span>
        <span class="n">ndim</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">normalize_axis_index</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">ndim</span><span class="p">)</span>

    <span class="n">slobj</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span><span class="o">*</span><span class="n">ndim</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
    <span class="n">newshape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
        <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
        <span class="n">xr</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
        <span class="n">numtodel</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xr</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">numtodel</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">wrap</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">wrap</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="n">arrorder</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">arr</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="n">arrorder</span><span class="p">)</span>

        <span class="c1"># Invert if step is negative:</span>
        <span class="k">if</span> <span class="n">step</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">step</span> <span class="o">=</span> <span class="o">-</span><span class="n">step</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">xr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="n">xr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="n">newshape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">-=</span> <span class="n">numtodel</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">empty</span><span class="p">(</span><span class="n">newshape</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">arrorder</span><span class="p">)</span>
        <span class="c1"># copy initial chunk</span>
        <span class="k">if</span> <span class="n">start</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">slobj</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span>
            <span class="n">new</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slobj</span><span class="p">)]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slobj</span><span class="p">)]</span>
        <span class="c1"># copy end chunk</span>
        <span class="k">if</span> <span class="n">stop</span> <span class="o">==</span> <span class="n">N</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">slobj</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">stop</span><span class="o">-</span><span class="n">numtodel</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">slobj2</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span><span class="o">*</span><span class="n">ndim</span>
            <span class="n">slobj2</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">stop</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">new</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slobj</span><span class="p">)]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slobj2</span><span class="p">)]</span>
        <span class="c1"># copy middle pieces</span>
        <span class="k">if</span> <span class="n">step</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># use array indexing.</span>
            <span class="n">keep</span> <span class="o">=</span> <span class="n">ones</span><span class="p">(</span><span class="n">stop</span><span class="o">-</span><span class="n">start</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="n">keep</span><span class="p">[:</span><span class="n">stop</span><span class="o">-</span><span class="n">start</span><span class="p">:</span><span class="n">step</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">slobj</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="o">-</span><span class="n">numtodel</span><span class="p">)</span>
            <span class="n">slobj2</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span><span class="o">*</span><span class="n">ndim</span>
            <span class="n">slobj2</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">)</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slobj2</span><span class="p">)]</span>
            <span class="n">slobj2</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">keep</span>
            <span class="n">new</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slobj</span><span class="p">)]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slobj2</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">wrap</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">wrap</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">new</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">integer</span><span class="p">))</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="n">single_value</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">single_value</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">_obj</span> <span class="o">=</span> <span class="n">obj</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="c1"># `size == 0` to allow empty lists similar to indexing, but (as there)</span>
        <span class="c1"># is really too generic:</span>
        <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_obj</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">intp</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">obj</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">obj</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="s2">&quot;ui&quot;</span><span class="p">:</span>
            <span class="c1"># For a size 1 integer array we can use the single-value path</span>
            <span class="c1"># (most dtypes, except boolean, should just fail later).</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
            <span class="n">single_value</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">if</span> <span class="n">single_value</span><span class="p">:</span>
        <span class="c1"># optimization for a single value</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">obj</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">N</span> <span class="ow">or</span> <span class="n">obj</span> <span class="o">&gt;=</span> <span class="n">N</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                <span class="s2">&quot;index </span><span class="si">%i</span><span class="s2"> is out of bounds for axis </span><span class="si">%i</span><span class="s2"> with &quot;</span>
                <span class="s2">&quot;size </span><span class="si">%i</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">N</span><span class="p">))</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">obj</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">obj</span> <span class="o">+=</span> <span class="n">N</span>
        <span class="n">newshape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">empty</span><span class="p">(</span><span class="n">newshape</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">arrorder</span><span class="p">)</span>
        <span class="n">slobj</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>
        <span class="n">new</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slobj</span><span class="p">)]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slobj</span><span class="p">)]</span>
        <span class="n">slobj</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">slobj2</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span><span class="o">*</span><span class="n">ndim</span>
        <span class="n">slobj2</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">obj</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">new</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slobj</span><span class="p">)]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slobj2</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">bool</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">N</span><span class="p">,):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;boolean array argument obj to delete &#39;</span>
                                 <span class="s1">&#39;must be one dimensional and match the axis &#39;</span>
                                 <span class="s1">&#39;length of </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">N</span><span class="p">))</span>

            <span class="c1"># optimization, the other branch is slower</span>
            <span class="n">keep</span> <span class="o">=</span> <span class="o">~</span><span class="n">obj</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">keep</span> <span class="o">=</span> <span class="n">ones</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="n">keep</span><span class="p">[</span><span class="n">obj</span><span class="p">,]</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">slobj</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">keep</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slobj</span><span class="p">)]</span>

    <span class="k">if</span> <span class="n">wrap</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">wrap</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">new</span>


<span class="k">def</span> <span class="nf">_insert_dispatcher</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>


<span class="nd">@array_function_dispatch</span><span class="p">(</span><span class="n">_insert_dispatcher</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Insert values along the given axis before the given indices.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr : array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    obj : int, slice or sequence of ints</span>
<span class="sd">        Object that defines the index or indices before which `values` is</span>
<span class="sd">        inserted.</span>

<span class="sd">        .. versionadded:: 1.8.0</span>

<span class="sd">        Support for multiple insertions when `obj` is a single scalar or a</span>
<span class="sd">        sequence with one element (similar to calling insert multiple</span>
<span class="sd">        times).</span>
<span class="sd">    values : array_like</span>
<span class="sd">        Values to insert into `arr`. If the type of `values` is different</span>
<span class="sd">        from that of `arr`, `values` is converted to the type of `arr`.</span>
<span class="sd">        `values` should be shaped so that ``arr[...,obj,...] = values``</span>
<span class="sd">        is legal.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Axis along which to insert `values`.  If `axis` is None then `arr`</span>
<span class="sd">        is flattened first.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : ndarray</span>
<span class="sd">        A copy of `arr` with `values` inserted.  Note that `insert`</span>
<span class="sd">        does not occur in-place: a new array is returned. If</span>
<span class="sd">        `axis` is None, `out` is a flattened array.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    append : Append elements at the end of an array.</span>
<span class="sd">    concatenate : Join a sequence of arrays along an existing axis.</span>
<span class="sd">    delete : Delete elements from an array.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Note that for higher dimensional inserts ``obj=0`` behaves very different</span>
<span class="sd">    from ``obj=[0]`` just like ``arr[:,0,:] = values`` is different from</span>
<span class="sd">    ``arr[:,[0],:] = values``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([[1, 1], [2, 2], [3, 3]])</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[1, 1],</span>
<span class="sd">           [2, 2],</span>
<span class="sd">           [3, 3]])</span>
<span class="sd">    &gt;&gt;&gt; np.insert(a, 1, 5)</span>
<span class="sd">    array([1, 5, 1, ..., 2, 3, 3])</span>
<span class="sd">    &gt;&gt;&gt; np.insert(a, 1, 5, axis=1)</span>
<span class="sd">    array([[1, 5, 1],</span>
<span class="sd">           [2, 5, 2],</span>
<span class="sd">           [3, 5, 3]])</span>

<span class="sd">    Difference between sequence and scalars:</span>

<span class="sd">    &gt;&gt;&gt; np.insert(a, [1], [[1],[2],[3]], axis=1)</span>
<span class="sd">    array([[1, 1, 1],</span>
<span class="sd">           [2, 2, 2],</span>
<span class="sd">           [3, 3, 3]])</span>
<span class="sd">    &gt;&gt;&gt; np.array_equal(np.insert(a, 1, [1, 2, 3], axis=1),</span>
<span class="sd">    ...                np.insert(a, [1], [[1],[2],[3]], axis=1))</span>
<span class="sd">    True</span>

<span class="sd">    &gt;&gt;&gt; b = a.flatten()</span>
<span class="sd">    &gt;&gt;&gt; b</span>
<span class="sd">    array([1, 1, 2, 2, 3, 3])</span>
<span class="sd">    &gt;&gt;&gt; np.insert(b, [2, 2], [5, 6])</span>
<span class="sd">    array([1, 1, 5, ..., 2, 3, 3])</span>

<span class="sd">    &gt;&gt;&gt; np.insert(b, slice(2, 4), [5, 6])</span>
<span class="sd">    array([1, 1, 5, ..., 2, 3, 3])</span>

<span class="sd">    &gt;&gt;&gt; np.insert(b, [2, 2], [7.13, False]) # type casting</span>
<span class="sd">    array([1, 1, 7, ..., 2, 3, 3])</span>

<span class="sd">    &gt;&gt;&gt; x = np.arange(8).reshape(2, 4)</span>
<span class="sd">    &gt;&gt;&gt; idx = (1, 3)</span>
<span class="sd">    &gt;&gt;&gt; np.insert(x, idx, 999, axis=1)</span>
<span class="sd">    array([[  0, 999,   1,   2, 999,   3],</span>
<span class="sd">           [  4, 999,   5,   6, 999,   7]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">wrap</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">ndarray</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">wrap</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">__array_wrap__</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>

    <span class="n">arr</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="n">ndim</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">arrorder</span> <span class="o">=</span> <span class="s1">&#39;F&#39;</span> <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">fnc</span> <span class="k">else</span> <span class="s1">&#39;C&#39;</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="c1"># needed for np.matrix, which is still not 1d after being ravelled</span>
        <span class="n">ndim</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">normalize_axis_index</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">ndim</span><span class="p">)</span>
    <span class="n">slobj</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span><span class="o">*</span><span class="n">ndim</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
    <span class="n">newshape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
        <span class="c1"># turn it into a range object</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="o">*</span><span class="n">obj</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="n">N</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">intp</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># need to copy obj, because indices will be changed in-place</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">indices</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">bool</span><span class="p">:</span>
            <span class="c1"># See also delete</span>
            <span class="c1"># 2012-10-11, NumPy 1.8</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;in the future insert will treat boolean arrays and &quot;</span>
                <span class="s2">&quot;array-likes as a boolean index instead of casting it to &quot;</span>
                <span class="s2">&quot;integer&quot;</span><span class="p">,</span> <span class="ne">FutureWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">indices</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">intp</span><span class="p">)</span>
            <span class="c1"># Code after warning period:</span>
            <span class="c1">#if obj.ndim != 1:</span>
            <span class="c1">#    raise ValueError(&#39;boolean array argument obj to insert &#39;</span>
            <span class="c1">#                     &#39;must be one dimensional&#39;)</span>
            <span class="c1">#indices = np.flatnonzero(obj)</span>
        <span class="k">elif</span> <span class="n">indices</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;index array argument obj to insert must be one dimensional &quot;</span>
                <span class="s2">&quot;or scalar&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">indices</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">indices</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">N</span> <span class="ow">or</span> <span class="n">index</span> <span class="o">&gt;</span> <span class="n">N</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;index </span><span class="si">{</span><span class="n">obj</span><span class="si">}</span><span class="s2"> is out of bounds for axis </span><span class="si">{</span><span class="n">axis</span><span class="si">}</span><span class="s2"> &quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;with size </span><span class="si">{</span><span class="n">N</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">index</span> <span class="o">+=</span> <span class="n">N</span>

        <span class="c1"># There are some object array corner cases here, but we cannot avoid</span>
        <span class="c1"># that:</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="n">arr</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">indices</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># broadcasting is very different here, since a[:,0,:] = ... behaves</span>
            <span class="c1"># very different from a[:,[0],:] = ...! This changes values so that</span>
            <span class="c1"># it works likes the second case. (here a[:,0:1,:])</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="n">numnew</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
        <span class="n">newshape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">+=</span> <span class="n">numnew</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">empty</span><span class="p">(</span><span class="n">newshape</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">arrorder</span><span class="p">)</span>
        <span class="n">slobj</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
        <span class="n">new</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slobj</span><span class="p">)]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slobj</span><span class="p">)]</span>
        <span class="n">slobj</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">index</span><span class="o">+</span><span class="n">numnew</span><span class="p">)</span>
        <span class="n">new</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slobj</span><span class="p">)]</span> <span class="o">=</span> <span class="n">values</span>
        <span class="n">slobj</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">index</span><span class="o">+</span><span class="n">numnew</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">slobj2</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">ndim</span>
        <span class="n">slobj2</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">new</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slobj</span><span class="p">)]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slobj2</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">wrap</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">wrap</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new</span>
    <span class="k">elif</span> <span class="n">indices</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="c1"># Can safely cast the empty list to intp</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">indices</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">intp</span><span class="p">)</span>

    <span class="n">indices</span><span class="p">[</span><span class="n">indices</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">N</span>

    <span class="n">numnew</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
    <span class="n">order</span> <span class="o">=</span> <span class="n">indices</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="s1">&#39;mergesort&#39;</span><span class="p">)</span>   <span class="c1"># stable sort</span>
    <span class="n">indices</span><span class="p">[</span><span class="n">order</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">numnew</span><span class="p">)</span>

    <span class="n">newshape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">+=</span> <span class="n">numnew</span>
    <span class="n">old_mask</span> <span class="o">=</span> <span class="n">ones</span><span class="p">(</span><span class="n">newshape</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="n">old_mask</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="n">new</span> <span class="o">=</span> <span class="n">empty</span><span class="p">(</span><span class="n">newshape</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">arrorder</span><span class="p">)</span>
    <span class="n">slobj2</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span><span class="o">*</span><span class="n">ndim</span>
    <span class="n">slobj</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">indices</span>
    <span class="n">slobj2</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">old_mask</span>
    <span class="n">new</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slobj</span><span class="p">)]</span> <span class="o">=</span> <span class="n">values</span>
    <span class="n">new</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slobj2</span><span class="p">)]</span> <span class="o">=</span> <span class="n">arr</span>

    <span class="k">if</span> <span class="n">wrap</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">wrap</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">new</span>


<span class="k">def</span> <span class="nf">_append_dispatcher</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>


<span class="nd">@array_function_dispatch</span><span class="p">(</span><span class="n">_append_dispatcher</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Append values to the end of an array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr : array_like</span>
<span class="sd">        Values are appended to a copy of this array.</span>
<span class="sd">    values : array_like</span>
<span class="sd">        These values are appended to a copy of `arr`.  It must be of the</span>
<span class="sd">        correct shape (the same shape as `arr`, excluding `axis`).  If</span>
<span class="sd">        `axis` is not specified, `values` can be any shape and will be</span>
<span class="sd">        flattened before use.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        The axis along which `values` are appended.  If `axis` is not</span>
<span class="sd">        given, both `arr` and `values` are flattened before use.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    append : ndarray</span>
<span class="sd">        A copy of `arr` with `values` appended to `axis`.  Note that</span>
<span class="sd">        `append` does not occur in-place: a new array is allocated and</span>
<span class="sd">        filled.  If `axis` is None, `out` is a flattened array.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    insert : Insert elements into an array.</span>
<span class="sd">    delete : Delete elements from an array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.append([1, 2, 3], [[4, 5, 6], [7, 8, 9]])</span>
<span class="sd">    array([1, 2, 3, ..., 7, 8, 9])</span>

<span class="sd">    When `axis` is specified, `values` must have the correct shape.</span>

<span class="sd">    &gt;&gt;&gt; np.append([[1, 2, 3], [4, 5, 6]], [[7, 8, 9]], axis=0)</span>
<span class="sd">    array([[1, 2, 3],</span>
<span class="sd">           [4, 5, 6],</span>
<span class="sd">           [7, 8, 9]])</span>
<span class="sd">    &gt;&gt;&gt; np.append([[1, 2, 3], [4, 5, 6]], [7, 8, 9], axis=0)</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">    ValueError: all the input arrays must have same number of dimensions, but</span>
<span class="sd">    the array at index 0 has 2 dimension(s) and the array at index 1 has 1</span>
<span class="sd">    dimension(s)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">asanyarray</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">ravel</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="mi">1</span>
    <span class="k">return</span> <span class="n">concatenate</span><span class="p">((</span><span class="n">arr</span><span class="p">,</span> <span class="n">values</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_digitize_dispatcher</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">bins</span><span class="p">)</span>


<span class="nd">@array_function_dispatch</span><span class="p">(</span><span class="n">_digitize_dispatcher</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">digitize</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the indices of the bins to which each value in input array belongs.</span>

<span class="sd">    =========  =============  ============================</span>
<span class="sd">    `right`    order of bins  returned index `i` satisfies</span>
<span class="sd">    =========  =============  ============================</span>
<span class="sd">    ``False``  increasing     ``bins[i-1] &lt;= x &lt; bins[i]``</span>
<span class="sd">    ``True``   increasing     ``bins[i-1] &lt; x &lt;= bins[i]``</span>
<span class="sd">    ``False``  decreasing     ``bins[i-1] &gt; x &gt;= bins[i]``</span>
<span class="sd">    ``True``   decreasing     ``bins[i-1] &gt;= x &gt; bins[i]``</span>
<span class="sd">    =========  =============  ============================</span>

<span class="sd">    If values in `x` are beyond the bounds of `bins`, 0 or ``len(bins)`` is</span>
<span class="sd">    returned as appropriate.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array_like</span>
<span class="sd">        Input array to be binned. Prior to NumPy 1.10.0, this array had to</span>
<span class="sd">        be 1-dimensional, but can now have any shape.</span>
<span class="sd">    bins : array_like</span>
<span class="sd">        Array of bins. It has to be 1-dimensional and monotonic.</span>
<span class="sd">    right : bool, optional</span>
<span class="sd">        Indicating whether the intervals include the right or the left bin</span>
<span class="sd">        edge. Default behavior is (right==False) indicating that the interval</span>
<span class="sd">        does not include the right edge. The left bin end is open in this</span>
<span class="sd">        case, i.e., bins[i-1] &lt;= x &lt; bins[i] is the default behavior for</span>
<span class="sd">        monotonically increasing bins.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    indices : ndarray of ints</span>
<span class="sd">        Output array of indices, of same shape as `x`.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If `bins` is not monotonic.</span>
<span class="sd">    TypeError</span>
<span class="sd">        If the type of the input is complex.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    bincount, histogram, unique, searchsorted</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    If values in `x` are such that they fall outside the bin range,</span>
<span class="sd">    attempting to index `bins` with the indices that `digitize` returns</span>
<span class="sd">    will result in an IndexError.</span>

<span class="sd">    .. versionadded:: 1.10.0</span>

<span class="sd">    `np.digitize` is  implemented in terms of `np.searchsorted`. This means</span>
<span class="sd">    that a binary search is used to bin the values, which scales much better</span>
<span class="sd">    for larger number of bins than the previous linear search. It also removes</span>
<span class="sd">    the requirement for the input array to be 1-dimensional.</span>

<span class="sd">    For monotonically _increasing_ `bins`, the following are equivalent::</span>

<span class="sd">        np.digitize(x, bins, right=True)</span>
<span class="sd">        np.searchsorted(bins, x, side=&#39;left&#39;)</span>

<span class="sd">    Note that as the order of the arguments are reversed, the side must be too.</span>
<span class="sd">    The `searchsorted` call is marginally faster, as it does not do any</span>
<span class="sd">    monotonicity checks. Perhaps more importantly, it supports all dtypes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = np.array([0.2, 6.4, 3.0, 1.6])</span>
<span class="sd">    &gt;&gt;&gt; bins = np.array([0.0, 1.0, 2.5, 4.0, 10.0])</span>
<span class="sd">    &gt;&gt;&gt; inds = np.digitize(x, bins)</span>
<span class="sd">    &gt;&gt;&gt; inds</span>
<span class="sd">    array([1, 4, 3, 2])</span>
<span class="sd">    &gt;&gt;&gt; for n in range(x.size):</span>
<span class="sd">    ...   print(bins[inds[n]-1], &quot;&lt;=&quot;, x[n], &quot;&lt;&quot;, bins[inds[n]])</span>
<span class="sd">    ...</span>
<span class="sd">    0.0 &lt;= 0.2 &lt; 1.0</span>
<span class="sd">    4.0 &lt;= 6.4 &lt; 10.0</span>
<span class="sd">    2.5 &lt;= 3.0 &lt; 4.0</span>
<span class="sd">    1.0 &lt;= 1.6 &lt; 2.5</span>

<span class="sd">    &gt;&gt;&gt; x = np.array([1.2, 10.0, 12.4, 15.5, 20.])</span>
<span class="sd">    &gt;&gt;&gt; bins = np.array([0, 5, 10, 15, 20])</span>
<span class="sd">    &gt;&gt;&gt; np.digitize(x,bins,right=True)</span>
<span class="sd">    array([1, 2, 3, 4, 4])</span>
<span class="sd">    &gt;&gt;&gt; np.digitize(x,bins,right=False)</span>
<span class="sd">    array([1, 3, 3, 4, 5])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">_nx</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">bins</span> <span class="o">=</span> <span class="n">_nx</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span>

    <span class="c1"># here for compatibility, searchsorted below is happy to take this</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">_nx</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;x may not be complex&quot;</span><span class="p">)</span>

    <span class="n">mono</span> <span class="o">=</span> <span class="n">_monotonicity</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mono</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;bins must be monotonically increasing or decreasing&quot;</span><span class="p">)</span>

    <span class="c1"># this is backwards because the arguments below are swapped</span>
    <span class="n">side</span> <span class="o">=</span> <span class="s1">&#39;left&#39;</span> <span class="k">if</span> <span class="n">right</span> <span class="k">else</span> <span class="s1">&#39;right&#39;</span>
    <span class="k">if</span> <span class="n">mono</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="c1"># reverse the bins, and invert the results</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span> <span class="o">-</span> <span class="n">_nx</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">bins</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="n">side</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_nx</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="n">side</span><span class="p">)</span>
</pre></div>
        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2020, Michael Merrill and William Reus
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer no-toc">
      
      
      
    </aside>
  </div>
</div><script src="../../../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/scripts/furo.js?v=5fa4622c"></script>
    <script src="../../../_static/design-tabs.js?v=f930bc37"></script>
    </body>
</html>