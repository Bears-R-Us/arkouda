.. default-domain:: chpl

.. module:: Message

Message
=======
**Usage**

.. code-block:: chapel

   use Message;


or

.. code-block:: chapel

   import Message;

.. enum:: enum MsgType { NORMAL, WARNING, ERROR }

   .. enumconstant:: enum constant NORMAL

   .. enumconstant:: enum constant WARNING

   .. enumconstant:: enum constant ERROR

.. enum:: enum MsgFormat { STRING, BINARY }

   .. enumconstant:: enum constant STRING

   .. enumconstant:: enum constant BINARY

.. record:: MsgTuple

   
   * Encapsulates the message string and message type.
   

   .. attribute:: var msg: string

   .. attribute:: var msgType: MsgType

   .. attribute:: var msgFormat: MsgFormat

   .. attribute:: var user: string

   .. attribute:: var payload: bytes

.. record:: RequestMsg

   
   * Encapsulates state corresponding to a client request sent to the Arkouda server.
   

   .. attribute:: var user: string

   .. attribute:: var token: string

   .. attribute:: var cmd: string

   .. attribute:: var format: string

   .. attribute:: var args: string

   .. attribute:: var size: int

.. method:: proc MsgTuple.init()

.. method:: proc MsgTuple.init(msg: string, msgType: MsgType)

.. method:: proc MsgTuple.init(msg: string, msgType: MsgType, msgFormat: MsgFormat, user = "", in payload = b"")

.. method:: proc type MsgTuple.success(msg: string = ""): MsgTuple

.. method:: proc type MsgTuple.warning(msg: string): MsgTuple

.. method:: proc type MsgTuple.error(msg: string): MsgTuple

.. method:: proc type MsgTuple.newSymbol(name: string, sym: borrowed AbstractSymEntry): MsgTuple throws

   
   Create a MsgTuple indicating to the client that a new symbol was created
   

.. method:: proc type MsgTuple.fromResponses(responses: [] MsgTuple): MsgTuple throws

   
   Create a MsgTuple from a group of responses (useful for returning multiple
   symbols from one command, see: 'unstack' in 'ManipulationMsg')
   
   If any of the responses are errors, return the first error message.
   Otherwise, return a success message, where each of the 'msg' fields
   are composed into a JSON list.
   

.. method:: proc type MsgTuple.fromScalar(scalar: ?t): MsgTuple throws

.. method:: proc type MsgTuple.payload(in data: bytes): MsgTuple

.. method:: proc ref MsgTuple.serialize(user: string) throws

.. record:: ParameterObj

   
   * Encapsulate parameter for a request sent to the Arkouda server
   * Note - Only used when args is in JSON format. 
   * Note - during the transition from space delimited string to JSON formated string, this object is not part of RequestMsg,
   *   but will be once all messages are transitioned to JSON arguments.
   

   .. attribute:: var key: string

   .. attribute:: var val: string

   .. attribute:: var dtype: string

   .. method:: proc init()

   .. method:: proc init(key: string, val: string, dtype: string)

   .. method:: proc ref setKey(value: string)

   .. method:: proc ref setVal(value: string)

   .. method:: proc getDType()

      
      * Return the Dtype value as NumpyDtype
      * Returns Dtype
      

   .. method:: proc getValue()

      
      * Return the raw string value
      * Returns string
      

   .. method:: proc tryGetScalar(type t): (t, bool)

   .. method:: proc toScalar(type t): t throws

      
      Get a value of the given type from a JSON scalar
      
      :arg t: type: the scalar type to parse
      
      Throws an ErrorWithContext if the value cannot be parsed as the given
          type
      

   .. method:: proc toScalarTuple(type t, param size: int): size*t throws

      
      Get a tuple of the given type from a JSON array of scalar values
      
      :arg size: int: the number of elements in the tuple (must match
          the number of elements in the JSON array)
      :arg t: type: the scalar type to parse
      
      Throws an ErrorWithContext if the value is not a JSON array, the
          tuple is the wrong size, or if the elements of the array cannot
          be parsed as the given type
      

   .. method:: proc toScalarList(type t): list(t) throws

      
      Get a list of the given type from a JSON array of scalar values
      
      :arg t: type: the scalar type to parse
      
      Throws an ErrorWithContext if the value is not a JSON array or if the
          elements of the array cannot be parsed as the given type
      

   .. method:: proc toScalarArray(type t, size: int): [] t throws

      
      Get an array of the given type from a JSON array of scalar values
      
      :arg t: type: the scalar type to parse
      :arg size: int: the number of elements in the array (must match the
          number of elements in the JSON array)
      
      Throws an ErrorWithContext if the value is not a JSON array, the
          array is the wrong size, or if the elements of the array cannot
          be parsed as the given type
      

   .. method:: proc getScalarValue(type t): t throws

   .. method:: proc getIntValue(): int throws

   .. method:: proc getPositiveIntValue(max: int): int throws

      
      Return the value as a positive int
      If the value is negative, return 'value + max + 1', otherwise return the value
      This is useful for implementing Python's negative indexing rules
      

   .. method:: proc getUIntValue(): uint throws

   .. method:: proc getUInt8Value(): uint(8) throws

   .. method:: proc getRealValue(): real throws

   .. method:: proc getBoolValue(): bool throws

   .. method:: proc getBigIntValue(): bigint throws

   .. method:: proc getList(size: int) throws

   .. method:: proc getTuple(param size: int): size*int throws

.. class:: MessageArgs : writeSerializable

   
   Container class for the message arguments formatted as json
   :param_list:  array of ParameterObj
   :size: int - number of parameters contained in list
   

   .. attribute:: var param_list: list(ParameterObj)

   .. attribute:: var size: int

   .. attribute:: var payload: bytes

   .. method:: proc init()

   .. method:: proc init(param_list: list(ParameterObj))

   .. method:: proc init(param_list: list(ParameterObj, parSafe = true), in payload: bytes)

   .. method:: proc addPayload(in p: bytes)

      
      Attach a binary payload to the message arguments
      

   .. method:: proc this(key: string): ParameterObj throws

      
      Get the value of the argument with the given key
      

   .. itermethod:: iter these(): ParameterObj

   .. method:: override proc serialize(writer: fileWriter(?), ref serializer: ?st) throws

   .. method:: proc get(key: string): ParameterObj throws

      
      * Identify the parameter with the provided key and return it
      * Returns ParameterObj with the provided key
      * Throws KeyNotFound error if the provide key does not exist.
      

   .. method:: proc getValueOf(key: string): string throws

   .. method:: proc contains(key: string): bool

      
      Return true if there is an argument with the given name, false otherwise
      

.. function:: proc parseParameter(payload: string) throws

   
   Parse and individual parameter components into a ParameterObj
   

.. function:: proc parseMessageArgs(json_str: string, size: int, in payload = b"") throws

   
   Parse arguments formatted as json string into objects
   

.. function:: proc deserialize(ref msg: RequestMsg, request: string) throws

   
   * Deserializes a JSON-formatted string to a RequestMsg object, where the
   * JSON format is as follows (size is only set for json args. Otherwise, -1):
   *
   * {"user": "user", "token": "token", "cmd": "cmd", "format": "STRING", "args": "arg1 arg2", "size": "-1"}
   *
   

.. function:: proc serialize(msg: string, msgType: MsgType, msgFormat: MsgFormat, user: string): string throws

   
   * Generates a ReplyMsg object and serializes it into a JSON-formatted reply message
   

