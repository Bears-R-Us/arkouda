.. default-domain:: chpl

.. module:: AryUtil

AryUtil
=======
**Usage**

.. code-block:: chapel

   use AryUtil;


or

.. code-block:: chapel

   import AryUtil;

.. data:: param bitsPerDigit = RSLSD_bitsPerDigit

.. data:: const auLogger = new Logger(logLevel, logChannel)

.. data:: var printThresh = 30

   
   Threshold for the amount of data that will be printed.
   Arrays larger than printThresh will print less data.
   

.. function:: proc formatAry(A: [?d]): string throws

   
   Prints the passed array.
   
   :arg name: name of the array
   :arg A: array to be printed
   

.. function:: proc printAry(name: string, A)

.. function:: proc printOwnership(x)

   1.18 version print out localSubdomains
   
   :arg x: array
   :type x: []
   

.. function:: proc isSorted(A: [?D] ?t): bool where D.rank == 1

   
   Determines if the passed array is sorted.
   
   :arg A: array to check
   
   

.. function:: proc isSortedOver(const ref A: [?D] ?t, const ref slice, axisIdx: int)

   
   Determines if the passed array is sorted along a given axis,
   within a slice domain.
   
   :arg A: array to check
   :arg slice: a slice domain (only the indices in this domain are checked)
   :arg axisIdx: the axis to check
   

.. function:: proc validateNegativeAxes(axis: int, param nd: int): (bool, int)

   
   Modifies an array of (potentially negative) axis arguments to be
   positive and within the range of the number of dimensions, while
   confirming that the axes are valid.
   
   A negative axis 'a' is converted to 'nd + a', where 'nd' is the
   number of dimensions in the array.
   
   :arg axes: array of axis arguments
   :arg nd: number of dimensions in the array
   
   :returns: a tuple of a boolean indicating whether the axes are valid,
             and the array of modified axes
   

.. function:: proc validateNegativeAxes(axes: [?d] int, param nd: int): (bool, [d] int)

.. function:: proc validateNegativeAxes(axes: list(int), param nd: int): (bool, list(int))

.. function:: proc domOnAxis(D: domain(?), idx: D.rank*int, axes: int ...?NA): domain(?) where NA <= D.rank

   
   Get a domain that selects out the idx'th set of indices along the specified axes
   
   :arg D: the domain to slice
   :arg idx: the index to select along the specified axes (must have the same rank as D)
   :arg axes: the axes to slice along (must be a subset of the axes of D)
   
   For example, if D represents a stack of 1000 10x10 matrices (ex: {1..10, 1..10, 1..1000})
   Then, domOnAxis(D, (1, 1, 25), 0, 1) will return D sliced with {1..10, 1..10, 25..25}
   (i.e., the 25th matrix)
   

.. function:: proc domOnAxis(D: domain(?), idx: D.rank*int, axes: [?aD] int): domain(?) throws

.. function:: proc domOnAxis(D: domain(?), idx: D.rank*int, const ref axes: list(int)): domain(?) throws

.. function:: proc domOffAxis(D: domain(?), axes: int ...?NA): domain(?) where NA <= D.rank

   
   Get a domain over the set of indices orthogonal to the specified axes
   
   :arg D: the domain to slice
   :arg axes: the axes to slice along (must be a subset of the axes of D)
   
   For example, if D represents a stack of 1000 10x10 matrices (ex: {1..10, 1..10, 1..1000})
   Then, domOffAxis(D, 0, 1) will return D sliced with {0..0, 0..0, 1..1000}
   (i.e., a set of indices for the 1000 matrices)
   

.. function:: proc domOffAxis(D: domain(?), axes: [?aD] int): domain(?) throws

.. function:: proc domOffAxis(D: domain(?), const ref axes: list(int)): domain(?) throws

.. iterfunction:: iter axisSlices(D: domain(?), const ref axes: list(int)): (domain(?), D.rank*int) throws

   
   Iterate over all the slices of a domain along the specified axes
   

.. iterfunction:: iter axisSlices(param tag: iterKind, D: domain(?), const ref axes: list(int)): (domain(?), D.rank*int) throws where tag == iterKind.standalone

.. iterfunction:: iter axisSlices(D: domain(?), axes: int ...?N): (domain(?), D.rank*int) throws where N <= D.rank

.. iterfunction:: iter axisSlices(param tag: iterKind, D: domain(?), axes: int ...?N): (domain(?), D.rank*int) throws where tag == iterKind.standalone && N <= D.rank

.. function:: proc subDomChunk(dom: domain(?), chunkIdx: int, nChunks: int): domain(?)

   
   Create a domain over a chunk of the input domain
   
   Chunks are created by splitting the 0th dimension of the input domain
   into 'nChunks' roughly equal-sized chunks, and then taking the
   'chunkIdx'-th chunk
   
   (if 'nChunks' is greater than the size of the first dimension, the
   first 'nChunks-1' chunks will be empty, and the last chunk will contain
   the entire set of indices)
   

.. function:: proc reducedShape(shape: ?N*int, axes: [] int): N*int

   
   Modify an array shape by making the specified axes degenerate.
   
   :arg shape: array shape as a tuple of sizes
   :arg axes: array of axis arguments
   
   :returns: a tuple of sizes where the specified axes have a size of 1
   

.. function:: proc reducedShape(shape: ?N*int, axis: int): N*int

.. function:: proc reducedShape(shape: ?N*int, axes: list(int)): N*int

.. function:: proc aStats(a: [?D] int): (int, int, real, real, real)

   
   Returns stats on a given array in form (int,int,real,real,real).
   
   :arg a: array to produce statistics on
   :type a: [] int
   
   :returns: a_min, a_max, a_mean, a_variation, a_stdDeviation
   

.. function:: proc fillUniform(A: [?D] int, a_min: int, a_max: int, seed: int = 241)

.. function:: proc concatArrays(a: [?aD] ?t, b: [?bD] t, ordered = true) throws

   
   Concatenate 2 arrays and return the result.
   

.. iterfunction:: iter offset(ind) where isRange(ind) || isDomain(ind)

   
   Iterate over indices (range/domain) ``ind`` but in an offset manner based
   on the locale id. Can be used to avoid doing communication in lockstep.
   

.. function:: proc contiguousIndices(A: []) param

   
   Determines if the passed array array maps contiguous indices to
   contiguous memory.
   
   :arg A: array to check
   

.. function:: proc validateArraysSameLength(n: int, names: [] string, types: [] string, st: borrowed SymTab) throws

   
   * Takes a variable number of array names from a command message and
   * validates them, checking that they all exist and are the same length
   * and returning metadata about them.
   *
   * :arg n: number of arrays
   * :arg fields: the fields derived from the command message
   * :arg st: symbol table
   *
   * :returns: (length, hasStr, names, objtypes)
   

.. function:: proc getBitWidth(a: [?aD] int): (int, bool)

.. function:: proc getBitWidth(a: [?aD] uint): (int, bool)

.. function:: proc getBitWidth(a: [?aD] real): (int, bool)

.. function:: proc getBitWidth(a: [?aD] bool): (int, bool)

.. function:: proc getBitWidth(a: [?aD] (uint, uint)): (int, bool)

.. function:: proc getBitWidth(a: [?aD] ?t): (int, bool) where isHomogeneousTuple(t) && t == t.size * uint(bitsPerDigit)

.. function:: proc getDigit(key: int, rshift: int, last: bool, negs: bool): int

.. function:: proc getDigit(key: uint, rshift: int, last: bool, negs: bool): int

.. function:: proc getDigit(in key: real, rshift: int, last: bool, negs: bool): int

.. function:: proc getDigit(key: 2*(uint), rshift: int, last: bool, negs: bool): int

.. function:: proc getDigit(key: _tuple, rshift: int, last: bool, negs: bool): int where isHomogeneousTuple(key) && key.type == key.size * uint(bitsPerDigit)

.. function:: proc getNumDigitsNumericArrays(names, st: borrowed SymTab) throws

.. function:: proc mergeNumericArrays(param numDigits, size, totalDigits, bitWidths, negs, names, st) throws

.. record:: lowLevelLocalizingSlice

   
   A localized "slice" of an array. This is meant to be a low-level
   alternative to array slice assignment with better performance (fewer
   allocations, especially when the region is local). When the region being
   sliced is local, a borrowed pointer is stored and `isOwned` is set to
   false. When the region is remote or non-contiguous, memory is copied to
   a local buffer and `isOwned` is true.
   

   .. attribute:: type t

   .. attribute:: var ptr: c_ptr(t) = nil

      Pointer to localized memory 

   .. attribute:: var isOwned: bool = false

      Do we own the memory? 

   .. method:: proc init(ref A: [] ?t, region: range())

   .. method:: proc deinit()

.. function:: proc removeDegenRanks(A: [?D] ?t, param N: int) throws where N <= D.rank

   
   Create a rank 'N' array by removing the degenerate ranks from
   'A' and copying it's contents into the new array
   
   'N' must be equal to 'A's rank minus the number of degenerate ranks;
   halts if this condition isn't met.
   
   See also: 'ManipulationMsg.squeezeMsg'
   

.. function:: proc broadcastShape(sa: ?Na*int, sb: ?Nb*int, param N: int): N*int throws

   
   Algorithm to determine shape of broadcasted PD array given two array shapes
   
   see: https://data-apis.org/array-api/latest/API_specification/broadcasting.html#algorithm
   

.. function:: proc broadcastShape(sa: ?N1*int, sb: ?N2*int): N1*int throws where N1 >= N2

.. function:: proc broadcastShape(sa: ?N1*int, sb: ?N2*int): N2*int throws where N1 < N2

.. function:: proc removeAxis(shape: ?N*int, axis: int): (N-1)*int

.. function:: proc appendAxis(shape: ?N*int, axis: int, param value: int): (N+1)*int throws

.. function:: proc appendAxis(shape: int, axis: int, param value: int): 2*(int) throws

.. function:: proc unflatten(const ref a: [?d] ?t, shape: ?N*int): [] t throws where t != bigint

   
   unflatten a 1D array into a multi-dimensional array of the given shape
   

.. function:: proc unflatten(const ref a: [?d] ?t, shape: ?N*int): [] t throws where t == bigint

.. function:: proc flatten(const ref a: [?d] ?t): [] t throws where t != bigint

   
   flatten a multi-dimensional array into a 1D array
   

.. function:: proc flatten(const ref a: [?d] ?t): [] t throws where t == bigint

.. record:: orderer

   .. attribute:: param rank: int

   .. attribute:: const accumRankSizes: [0..<rank] int

   .. method:: proc init(shape: ?N*int)

   .. method:: proc indexToOrder(idx: rank*?t): t where t == int || t == uint(64)

   .. method:: proc indexToOrder(idx: ?t): t where t == int || t == uint(64)

