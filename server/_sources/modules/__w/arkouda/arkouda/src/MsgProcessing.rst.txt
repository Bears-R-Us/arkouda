.. default-domain:: chpl

.. module:: MsgProcessing

MsgProcessing
=============
**Usage**

.. code-block:: chapel

   use MsgProcessing;


or

.. code-block:: chapel

   import MsgProcessing;

.. data:: const mpLogger = new Logger(logLevel, logChannel)

.. function:: proc create(cmd: string, msgArgs: borrowed MessageArgs, st: borrowed SymTab, type array_dtype, param array_nd: int): MsgTuple throws

    
   Parse, execute, and respond to a create message 
   
   :arg : payload
   :type string: containing (dtype,size)
   
   :arg st: SymTab to act on
   :type st: borrowed SymTab 
   
   :returns: (MsgTuple) response message
   

.. function:: proc createScalarArray(cmd: string, msgArgs: borrowed MessageArgs, st: borrowed SymTab, type array_dtype): MsgTuple throws

.. function:: proc deleteMsg(cmd: string, msgArgs: borrowed MessageArgs, st: borrowed SymTab): MsgTuple throws

    
   Parse, execute, and respond to a delete message 
   
   :arg reqMsg: request containing (cmd,name)
   :type reqMsg: string 
   
   :arg st: SymTab to act on
   :type st: borrowed SymTab 
   
   :returns: MsgTuple
   

.. function:: proc clearMsg(cmd: string, msgArgs: borrowed MessageArgs, st: borrowed SymTab): MsgTuple throws

    
   Clear all unregistered symbols and associated data from sym table
   
   :arg reqMsg: request containing (cmd)
   :type reqMsg: string 
   
   :arg st: SymTab to act on
   :type st: borrowed SymTab 
   
   :returns: MsgTuple
    

.. function:: proc infoMsg(cmd: string, msgArgs: borrowed MessageArgs, st: borrowed SymTab): MsgTuple throws

    
   Takes the name of data referenced in a msg and searches for the name in the provided sym table.
   Returns a string of info for the sym entry that is mapped to the provided name.
   
   :arg reqMsg: request containing (cmd,name)
   :type reqMsg: string 
   
   :arg st: SymTab to act on
   :type st: borrowed SymTab 
   
   :returns: MsgTuple
    

.. function:: proc getconfigMsg(cmd: string, msgArgs: borrowed MessageArgs, st: borrowed SymTab): MsgTuple throws

    
   query server configuration...
   
   :arg reqMsg: request containing (cmd)
   :type reqMsg: string 
   
   :arg st: SymTab to act on
   :type st: borrowed SymTab 
   
   :returns: MsgTuple
    

.. function:: proc getmemusedMsg(cmd: string, msgArgs: borrowed MessageArgs, st: borrowed SymTab): MsgTuple throws

    
   query server total memory allocated or symbol table data memory
   
   :arg reqMsg: request containing (cmd)
   :type reqMsg: string
   
   :arg st: SymTab to act on
   :type st: borrowed SymTab
   
   :returns: MsgTuple
   

.. function:: proc getmemavailMsg(cmd: string, msgArgs: borrowed MessageArgs, st: borrowed SymTab): MsgTuple throws

   
   query server total memory availble
   
   :arg reqMsg: request containing (cmd)
   :type reqMsg: string
   
   :arg st: SymTab to act on
   :type st: borrowed SymTab
   
   :returns: MsgTuple
   

.. function:: proc getCommandMapMsg(cmd: string, msgArgs: borrowed MessageArgs, st: borrowed SymTab) throws

   *
   * Generate the mapping of server command to function as JSON
   * encoded string.
   *
   * The args are IGNORED. They are only here to match the CommandMap
   * standard function signature, similar to other procs.
   *
   * :arg cmd: Ignored
   * :type cmd: string 
   *
   * :arg payload: Ignored
   * :type payload: string
   *
   * :arg st: Ignored
   * :type st: borrowed SymTab 
   *
   * :returns: MsgTuple containing JSON formatted string of cmd -> function mapping
   

.. function:: proc strMsg(cmd: string, msgArgs: borrowed MessageArgs, st: borrowed SymTab): MsgTuple throws

    
   Response to __str__ method in python str convert array data to string 
   
   :arg reqMsg: request containing (cmd,name)
   :type reqMsg: string 
   
   :arg st: SymTab to act on
   :type st: borrowed SymTab 
   
   :returns: (string,MsgType)
   

.. function:: proc reprMsg(cmd: string, msgArgs: borrowed MessageArgs, st: borrowed SymTab): MsgTuple throws

   Response to __repr__ method in python.
   Repr convert array data to string 
   
   :arg reqMsg: request containing (cmd,name)
   :type reqMsg: string 
   
   :arg st: SymTab to act on
   :type st: borrowed SymTab 
   
   :returns: MsgTuple
   

.. function:: proc setMsg(cmd: string, msgArgs: borrowed MessageArgs, st: borrowed SymTab, type array_dtype, param array_nd: int): MsgTuple throws

    
   Sets all elements in array to a value (broadcast) 
   
   :arg reqMsg: request containing (cmd,name,dtype,value)
   :type reqMsg: string 
   
   :arg st: SymTab to act on
   :type st: borrowed SymTab 
   
   :returns: MsgTuple
   :throws: `UndefinedSymbolError(name)`
   

.. function:: proc chunkInfoAsString(array: [?d] ?t): string throws where t == bool || t == int(64) || t == uint(64) || t == uint(8) || t == real

   
   Get a list of lists indicating how an array is "chunked" across locales.
   
   For example, a 100x40 2D array on 4 locales could return: [[0, 50], [0, 20]]
   indicating that the chunks start at indices 0 and 50 in the first dimension,
   and 0 and 20 in the second dimension.
   

.. function:: proc chunkInfoAsString(array: [?d] ?t): string throws where t != bool && t != int(64) && t != uint(64) && t != uint(8) && t != real

.. function:: proc chunkInfoAsArray(array: [?d] ?t): [] int throws where t == bool || t == int(64) || t == uint(64) || t == uint(8) || t == real

.. function:: proc chunkInfoAsArray(array: [?d] ?t): [d] int throws where t != bool && t != int(64) && t != uint(64) && t != uint(8) && t != real

