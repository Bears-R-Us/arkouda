.. default-domain:: chpl

.. module:: SparseMatrix

SparseMatrix
============
**Usage**

.. code-block:: chapel

   use SparseMatrix;


or

.. code-block:: chapel

   import SparseMatrix;

**Submodules**

.. toctree::
   :maxdepth: 1
   :glob:

   SparseMatrix/*

.. function:: proc fillSparseMatrix(ref spsMat, const A: [?D] ?eltType, param l: Layout) throws

.. function:: proc getGrid(const ref spsMat) where spsMat.chpl_isNonDistributedArray()

.. function:: proc getGrid(const ref spsMat) where !spsMat.chpl_isNonDistributedArray()

.. function:: proc getLSD(const ref spsMat) where spsMat.chpl_isNonDistributedArray()

.. function:: proc getLSD(const ref spsMat) where !spsMat.chpl_isNonDistributedArray()

.. function:: proc getLSA(const ref spsMat, rowBlockIdx: int, colBlockIdx: int) const ref where spsMat.chpl_isNonDistributedArray()

.. function:: proc getLSA(const ref spsMat, rowBlockIdx: int, colBlockIdx: int) const ref where !spsMat.chpl_isNonDistributedArray()

.. function:: proc sparseMatToPdarray(const ref spsMat, ref rows, ref cols, ref vals, param layout: Layout) where layout == Layout.CSR

   
   Fill the rows, cols, and vals arrays with the non-zero indices and values
   from the sparse matrix in row-major order.
   

.. function:: proc sparseMatToPdarray(const ref spsMat, ref rows, ref cols, ref vals, param layout: Layout) where layout == Layout.CSC

.. function:: proc rowMajorExScan(in nnzPerColBlock: [?d] int, grid: [] locale, const ref pdom)

.. function:: proc colMajorExScan(in nnzPerRowBlock: [?d] int, grid: [] locale, const ref pdom)

.. function:: proc sparseMatMatMult(A, B)

.. function:: proc sparseMatMatMult(A, B, ref spsData)

.. function:: proc sparseMatMatMult(A, B) where !A.chpl_isNonDistributedArray() && !B.chpl_isNonDistributedArray()

.. function:: proc denseMatMatMult(A, B)

.. function:: proc randSparseMatrix(shape: 2*(int), density, param layout, type eltType)

.. function:: proc sparseMatFromArrays(rows, cols, vals, shape: 2*(int), param layout, type eltType) throws

